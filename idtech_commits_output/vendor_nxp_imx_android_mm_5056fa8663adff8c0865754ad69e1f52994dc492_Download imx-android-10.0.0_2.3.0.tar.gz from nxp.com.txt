5056fa8 jenkins 2020-07-17

Download imx-android-10.0.0_2.3.0.tar.gz from nxp.com

Change-Id: Ia5ca7d1c1996abbd392ffa23c636a4e43d63bdec

diff --git a/codec2/audio_dec/Android.bp b/codec2/audio_dec/Android.bp
index 00ea6ef..3635fac 100644
--- a/codec2/audio_dec/Android.bp
+++ b/codec2/audio_dec/Android.bp
@@ -1,3 +1,25 @@
+imx_c2_audio_dec_defaults {
+    name: "imx_c2_audio_dec_default",
+}
+
+
+bootstrap_go_package {
+    name: "soong-audio_dec",
+    pkgPath: "android/soong/vendor/nxp/imx_android_mm/codec2/audio_dec",
+    deps: [
+        "blueprint",
+        "blueprint-pathtools",
+        "soong",
+        "soong-android",
+        "soong-cc",
+        "soong-genrule",
+    ],
+    srcs: [
+        "audio_dec.go",
+    ],
+    pluginFor: ["soong_build"],
+}
+
 subdirs = [
     "common",
     "aac_dec",
diff --git a/codec2/audio_dec/aac_dec/AacDecodeUtil.cpp b/codec2/audio_dec/aac_dec/AacDecodeUtil.cpp
index 3c34bad..b81822f 100755
--- a/codec2/audio_dec/aac_dec/AacDecodeUtil.cpp
+++ b/codec2/audio_dec/aac_dec/AacDecodeUtil.cpp
@@ -19,6 +19,9 @@
 
 #include "AacDecodeUtil.h"
 
+#undef bool
+#define bool bool
+
 namespace android {
 
 #define AACD_FRAME_SIZE  1024
@@ -149,7 +152,7 @@ public:
                 })})
                 .withSetter(Setter<decltype(*mAacFormat)>::StrictValueWithNoDeps)
                 .build());
-/*
+
         addParameter(
                 DefineParam(mProfileLevel, C2_PARAMKEY_PROFILE_LEVEL)
                 .withDefault(new C2StreamProfileLevelInfo::input(0u,
@@ -158,18 +161,21 @@ public:
                     C2F(mProfileLevel, profile).oneOf({
                             C2Config::PROFILE_AAC_LC,
                             C2Config::PROFILE_AAC_HE,
-                            C2Config::PROFILE_AAC_HE_PS,
-                            C2Config::PROFILE_AAC_LD,
-                            C2Config::PROFILE_AAC_ELD,
-                            C2Config::PROFILE_AAC_ER_SCALABLE,
-                            C2Config::PROFILE_AAC_XHE}),
+                            C2Config::PROFILE_AAC_HE_PS}),
                     C2F(mProfileLevel, level).oneOf({
                             C2Config::LEVEL_UNUSED
                     })
                 })
                 .withSetter(ProfileLevelSetter)
                 .build());
-*/
+
+        addParameter(
+                DefineParam(mLowLatency, C2_PARAMKEY_VENDOR_LOW_LATENCY)
+                .withDefault(new C2StreamVendorLowLatency::input(0u, 1))
+                .withFields({C2F(mLowLatency, value).inRange(0, 1)})
+                .withSetter(Setter<decltype(*mLowLatency)>::NonStrictValueWithNoDeps)
+                .build());
+
     }
 
     static C2R ProfileLevelSetter(bool mayBlock, C2P<C2StreamProfileLevelInfo::input> &me) {
@@ -186,6 +192,7 @@ public:
     void setChannelCount(uint32_t value) { mChannelCount->value = value; };
     void setBitrate(uint32_t value) { mBitrate->value = value; };
     void setAacFormat(C2Config::aac_packaging_t fmt) { mAacFormat->value = fmt; };
+    bool isLowLatency() { return (mLowLatency->value == 1);};
 
 private:
     std::shared_ptr<C2StreamSampleRateInfo::output> mSampleRate;
@@ -194,6 +201,7 @@ private:
     std::shared_ptr<C2StreamMaxBufferSizeInfo::input> mInputMaxBufSize;
     std::shared_ptr<C2StreamAacFormatInfo::input> mAacFormat;
     std::shared_ptr<C2StreamProfileLevelInfo::input> mProfileLevel;
+    std::shared_ptr<C2StreamVendorLowLatency::input> mLowLatency;
 };
 
 AacDecodeUtil::AacDecodeUtil(std::string & codecName, const std::shared_ptr<IntfImpl> &intfImpl)
@@ -234,7 +242,9 @@ c2_status_t AacDecodeUtil::getLibName(const char ** lib, const char ** optionalL
 uint32_t AacDecodeUtil::getFrameHdrBufLen()
 {
     LOGV("entry");
-    return AAC_PUSH_MODE_LEN;
+
+    return mIntf->isLowLatency() ? 1 : AAC_PUSH_MODE_LEN;
+
 }
 
 uint32_t AacDecodeUtil::getOutBufferLen()
@@ -253,6 +263,13 @@ c2_status_t AacDecodeUtil::checkFrameHeader(unsigned char * pBuffer, size_t leng
 
     if(bFrameChecked){
         return C2_OK;
+    } else if (mIntf->isLowLatency()) {
+        if (mIntf->getAacFormat() == C2AacStreamFormatRaw) {
+            mFrameInput = true;
+        }
+        bFrameChecked = true;
+        LOGV("low latency mode, mFrameInput %d", mFrameInput);
+        return C2_OK;
     }
 
     do{
@@ -319,7 +336,7 @@ c2_status_t AacDecodeUtil::parseFrame(uint8_t * pBuffer, int len, UniaDecFrameIn
 
 }
 
-c2_status_t AacDecodeUtil::getDecoderProp(AUDIOFORMAT *formatType, bool *isHwBased)
+c2_status_t AacDecodeUtil::getDecoderProp(AUDIOFORMAT *formatType, int *isHwBased)
 {
     LOGV("entry");
     if (formatType)
diff --git a/codec2/audio_dec/aac_dec/Android.bp b/codec2/audio_dec/aac_dec/Android.bp
index 07f168a..e39fc4e 100644
--- a/codec2/audio_dec/aac_dec/Android.bp
+++ b/codec2/audio_dec/aac_dec/Android.bp
@@ -40,6 +40,7 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
     //compile_multilib: "32",
 }
diff --git a/codec2/audio_dec/ac3_dec/Android.bp b/codec2/audio_dec/ac3_dec/Android.bp
index 4921038..4b75e59 100644
--- a/codec2/audio_dec/ac3_dec/Android.bp
+++ b/codec2/audio_dec/ac3_dec/Android.bp
@@ -40,6 +40,7 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
     //compile_multilib: "32",
 }
diff --git a/codec2/audio_dec/audio_dec.go b/codec2/audio_dec/audio_dec.go
new file mode 100644
index 0000000..51f93bc
--- /dev/null
+++ b/codec2/audio_dec/audio_dec.go
@@ -0,0 +1,47 @@
+// Copyright 2019 NXP
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package audio_dec
+
+import (
+        "android/soong/android"
+        "android/soong/cc"
+        "github.com/google/blueprint/proptools"
+)
+
+func init() {
+    android.RegisterModuleType("imx_c2_audio_dec_defaults", audio_decDefaultsFactory)
+}
+
+func audio_decDefaultsFactory() (android.Module) {
+    module := cc.DefaultsFactory()
+    android.AddLoadHook(module, audio_decDefaults)
+    return module
+}
+
+func audio_decDefaults(ctx android.LoadHookContext) {
+    type props struct {
+        Target struct {
+                Android struct {
+                        Enabled *bool
+                }
+        }
+    }
+    p := &props{}
+    p.Target.Android.Enabled = proptools.BoolPtr(true)
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("BOARD_VPU_ONLY") {
+        p.Target.Android.Enabled = proptools.BoolPtr(false)
+    }
+    ctx.AppendProperties(p)
+}
diff --git a/codec2/audio_dec/common/Android.bp b/codec2/audio_dec/common/Android.bp
index 8f6cd78..355afbf 100644
--- a/codec2/audio_dec/common/Android.bp
+++ b/codec2/audio_dec/common/Android.bp
@@ -42,5 +42,6 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
 }
diff --git a/codec2/audio_dec/common/IMXAudioDecComponent.cpp b/codec2/audio_dec/common/IMXAudioDecComponent.cpp
index c9f58cb..f37d444 100755
--- a/codec2/audio_dec/common/IMXAudioDecComponent.cpp
+++ b/codec2/audio_dec/common/IMXAudioDecComponent.cpp
@@ -68,6 +68,7 @@ c2_status_t IMXAudioDecComponent::onInit()
     nConvertBufferSize = 200000;
     bCheckFrameHeader = false;
     mTimestampDelta = 0;
+    mDecodeEachInput = 0;
     if(bConvertEnable){
         pConvertBuffer = (uint8_t *)malloc(nConvertBufferSize);
     }
@@ -122,6 +123,7 @@ c2_status_t IMXAudioDecComponent::onFlush_sm()
     bDecoderEOS = false;
     bFirstOutput = true;
     bCheckFrameHeader = false;
+    mDecodeEachInput = 0;
     mTimestampDelta = 0;
     AudioRingBuffer.BufferReset();
     TS_Manager.Reset();
@@ -172,10 +174,9 @@ void IMXAudioDecComponent::processWork(const std::unique_ptr<C2Work> &work)
     }else{
         threshold = nRequiredSize = AudioRingBuffer.AudioDataLen()+DEFAULT_REQUIRED_SIZE;
     }
-#ifdef DECODE_EACH_INPUT
-    // force decode input data in every work
-    threshold = 1;
-#endif
+
+    if (mDecodeEachInput)
+        threshold = 1;
 
     LOGV("playMode %s, nRequiredSize %d, nPushModeInputLen %d, result threshold %d",
         (ePlayMode == DEC_FILE_MODE)?"file":"stream", nRequiredSize, nPushModeInputLen, threshold);
diff --git a/codec2/audio_dec/common/IMXAudioDecComponent.h b/codec2/audio_dec/common/IMXAudioDecComponent.h
index 6a099be..a3e9b18 100755
--- a/codec2/audio_dec/common/IMXAudioDecComponent.h
+++ b/codec2/audio_dec/common/IMXAudioDecComponent.h
@@ -94,6 +94,7 @@ protected:
     AudioTSManager TS_Manager;
     bool bReceivedEOS;
     int64_t mTimestampDelta;
+    uint32_t mDecodeEachInput;
 
 private:
 
diff --git a/codec2/audio_dec/common/UniaDecoder.cpp b/codec2/audio_dec/common/UniaDecoder.cpp
index 8b3368d..a65f1f7 100755
--- a/codec2/audio_dec/common/UniaDecoder.cpp
+++ b/codec2/audio_dec/common/UniaDecoder.cpp
@@ -113,6 +113,12 @@ UniaDecoder::UniaDecoder(const std::shared_ptr<C2ComponentInterface> &intf, Audi
     profileErrorCount = 0;
 
     accumulatedOutputLen = 0;
+    mWrapper = nullptr;
+    mWrapperHandle = nullptr;
+    mLibHandle = nullptr;
+    codecConfig.buf = nullptr;
+
+    mDecodeEachInput = 0;
 }
 
 UniaDecoder::~UniaDecoder()
@@ -217,6 +223,14 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::doDecode(const std::unique_ptr<C2Work> &wo
 {
     LOGV("entry");
     AUDIO_DECODE_RETURN_TYPE ret;
+
+    // MA-17241 aac dsp decoder needs calling DecodeFrame() again to output valid data sometimes
+    int32_t retry=0;
+    const int32_t maxRetryCount = 1;
+
+    int32_t loopCount = 0;
+    const int32_t maxLoopCount = 500;
+
     do{
         uint32_t nTmpOutBufferLen = 0;
         uint8_t * pTmpOutBuffer = nullptr;
@@ -227,18 +241,24 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::doDecode(const std::unique_ptr<C2Work> &wo
             outputSizes.push_back(nTmpOutBufferLen);
             LOGV("push %d to outputSizes", nTmpOutBufferLen);
         }
-        /*
         if(ret == AUDIO_DECODE_NEEDMORE
-            && (AudioRingBuffer.AudioDataLen() < nPushModeInputLen)
-            && !bReceivedEOS
-            )
-            return AUDIO_DECODE_SUCCESS;
-        */
+            && AudioRingBuffer.AudioDataLen() > 0
+            && retry++ < maxRetryCount)
+            continue;
+
         if(ret == AUDIO_DECODE_FATAL_ERROR || ret == AUDIO_DECODE_EOS)
             break;
 
         if(AudioRingBuffer.AudioDataLen() < nPushModeInputLen && !bReceivedEOS)
             break;
+
+        // to avoid dead loop while core decoder returns InputOffset=0 ,
+        // no chance to decrease ringbuffer data length to break from while loop
+        // AAC_LC_44kHz_128kbps_1_SSR.aac, cts bug_25928803.mp4
+        if(loopCount++ > maxLoopCount){
+            LOGE("core decoder fails to return valid InputOffset after %d retries", maxLoopCount);
+            return AUDIO_DECODE_FATAL_ERROR;
+        }
     }while(true);
 
     return ret;
@@ -256,11 +276,16 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::_doDecodeInternal(
     uint32_t InputLen = 0;;
     uint32_t InputOffset = 0;
     uint8_t * pInputBuffer = nullptr;
+    AUDIOFORMAT format = FORMAT_UNKNOW;
+    bool hwBased = false, swBased = true;
     *ppOutputBuffer = nullptr;
     *pOutputSize = 0;
     UniaDecFrameInfo FrameInfo;
     memset(&FrameInfo, 0, sizeof(UniaDecFrameInfo));
 
+    mUtil->getDecoderProp(&format, &hwBased);
+    swBased = !hwBased;
+
     AudioRingBuffer.BufferGet(&pInputBuffer, nPushModeInputLen, &InputLen);
     LOGV("nPushModeInputLen %d,InputLen %d,isFrameInput %d",
               nPushModeInputLen, InputLen, mUtil->isFrameInput());
@@ -313,7 +338,7 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::_doDecodeInternal(
     if(pInputBuffer && InputLen > 0){
         decoderRet = mWrapper->DecodeFrame(mWrapperHandle,pInputBuffer,InputLen,
             &InputOffset,&pOutputBuffer,&nActualOutLen);
-        if(!mUtil->isFrameInput()){
+        if(!(mUtil->isFrameInput() && swBased)){
             if(decoderRet == ACODEC_ERR_UNKNOWN && InputOffset == 0)
                 InputOffset = InputLen; // skip this block of data, avoid dead loop in doDecode
             LOGV("ringbuffer consumed InputOffset %d", InputOffset);
@@ -344,8 +369,15 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::_doDecodeInternal(
 
         mWrapper->GetParameter(mWrapperHandle,UNIA_CONSUMED_LENGTH,(UniACodecParameter*)&consumeLen);
 
-        TS_Manager.Consumed(consumeLen);
-        LOGV("AudioTime.TS_Increase TS_PerFrame=%lld",(long long)TS_PerFrame);
+        if(!mUtil->isFrameInput() || (mUtil->isFrameInput() && swBased)){
+            LOGV("TSM Consumed consumeLen %d",consumeLen);
+            TS_Manager.Consumed(consumeLen);
+        }
+        else{
+            LOGV("TSM Consumed inputOffset %d",InputOffset);
+            TS_Manager.Consumed(InputOffset);
+        }
+
         TS_Manager.TS_SetIncrease(TS_PerFrame);
 
         // finetune ts with total output len to match with vts
@@ -358,7 +390,7 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::_doDecodeInternal(
             TS_Manager.TS_SetIncrease(1);
 
         consumeFrameCount += consumeLen;
-        if(mUtil->isFrameInput()){
+        if(mUtil->isFrameInput() && swBased){
             //more than one frames could be in a frame buffer, so consume one frame's length.
             LOGV("ringbuffer consumed consumeLen %d", consumeLen);
             AudioRingBuffer.BufferConsumed(consumeLen);
@@ -389,7 +421,7 @@ AUDIO_DECODE_RETURN_TYPE UniaDecoder::_doDecodeInternal(
     }else if((decoderRet == ACODEC_ERROR_STREAM || decoderRet == ACODEC_ERR_UNKNOWN) && pInputBuffer){
         mWrapper->GetParameter(mWrapperHandle,UNIA_CONSUMED_LENGTH,(UniACodecParameter*)&consumeLen);
         mWrapper->ResetDecoder(mWrapperHandle);
-        if(mUtil->isFrameInput()){
+        if(mUtil->isFrameInput() && swBased){
             LOGV("ringbuffer consumed InputOffset %d", InputOffset);
             AudioRingBuffer.BufferConsumed(InputOffset);
             LOGV("ringbuffer left %d", AudioRingBuffer.AudioDataLen());
@@ -457,10 +489,6 @@ c2_status_t UniaDecoder::checkFrameHeader()
     AudioRingBuffer.BufferGet(&pBuffer, pushModeLen, &nActualLen);
     LOGV("Get stream length: %d, pushModeLen %zu
", nActualLen, pushModeLen);
 
-#ifdef DECODE_EACH_INPUT
-    pushModeLen = 1;
-#endif
-
     if (nActualLen < pushModeLen && ePlayMode == DEC_FILE_MODE){
         LOGW("no enough data to check frame header");
         return C2_OK;
@@ -471,6 +499,8 @@ c2_status_t UniaDecoder::checkFrameHeader()
         AudioRingBuffer.BufferConsumed(nOffset);
         TS_Manager.Consumed(nOffset);
     }
+
+    mDecodeEachInput = mUtil->isFrameInput();
     LOGI("isFrameInput %d", mUtil->isFrameInput());
 
     return ret;
diff --git a/codec2/audio_dec/eac3_dec/Android.bp b/codec2/audio_dec/eac3_dec/Android.bp
index 4a33f76..5269b72 100644
--- a/codec2/audio_dec/eac3_dec/Android.bp
+++ b/codec2/audio_dec/eac3_dec/Android.bp
@@ -40,5 +40,6 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
 }
diff --git a/codec2/audio_dec/mp3_dec/Android.bp b/codec2/audio_dec/mp3_dec/Android.bp
index bb05404..8e084f7 100644
--- a/codec2/audio_dec/mp3_dec/Android.bp
+++ b/codec2/audio_dec/mp3_dec/Android.bp
@@ -40,6 +40,7 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
     //compile_multilib: "32",
 }
diff --git a/codec2/audio_dec/mp3_dec/Mp3DecodeUtil.cpp b/codec2/audio_dec/mp3_dec/Mp3DecodeUtil.cpp
index cb85895..6fb1cda 100755
--- a/codec2/audio_dec/mp3_dec/Mp3DecodeUtil.cpp
+++ b/codec2/audio_dec/mp3_dec/Mp3DecodeUtil.cpp
@@ -22,7 +22,7 @@
 namespace android {
 
 #define MP3D_FRAME_SIZE  1152
-#define MP3_PUSH_MODE_LEN   (2048*4)
+#define MP3_PUSH_MODE_LEN   (2048*3)
 #define MP3_DECODER_DELAY 529 //samples
 
 #define DSP_WRAPPER_LIB_NAME "lib_dsp_wrap_arm12_android.so"
@@ -172,8 +172,10 @@ c2_status_t Mp3DecodeUtil::checkFrameHeader(unsigned char * pBuffer, size_t leng
         //    LOGD("buffer=%02x%02x%02x%02x",pBuffer[nOffset],pBuffer[nOffset+1],pBuffer[nOffset+2],pBuffer[nOffset+1]);
         *pOffset = nOffset;
 
-        if(bFound)
+        if(bFound) {
+            bFrameChecked = true;
             return C2_OK;
+        }
     }while(0);
 
     return C2_NOT_FOUND;
diff --git a/codec2/audio_dec/realaudio_dec/Android.bp b/codec2/audio_dec/realaudio_dec/Android.bp
index e78f4fa..d6e1515 100644
--- a/codec2/audio_dec/realaudio_dec/Android.bp
+++ b/codec2/audio_dec/realaudio_dec/Android.bp
@@ -41,5 +41,6 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
 }
diff --git a/codec2/audio_dec/wma_dec/Android.bp b/codec2/audio_dec/wma_dec/Android.bp
index ecec4f2..34ca4c6 100644
--- a/codec2/audio_dec/wma_dec/Android.bp
+++ b/codec2/audio_dec/wma_dec/Android.bp
@@ -40,6 +40,7 @@ cc_library_shared {
 
     defaults: [
         "imx_defaults",
+        "imx_c2_audio_dec_default",
     ],
     //compile_multilib: "32",
 }
diff --git a/codec2/audio_dec/wma_dec/WmaDecodeUtil.cpp b/codec2/audio_dec/wma_dec/WmaDecodeUtil.cpp
index 2ba21d2..04827bd 100755
--- a/codec2/audio_dec/wma_dec/WmaDecodeUtil.cpp
+++ b/codec2/audio_dec/wma_dec/WmaDecodeUtil.cpp
@@ -22,6 +22,7 @@
 namespace android {
 
 #define WMA_OUTPUT_PORT_SIZE 200000
+#define DSP_WRAPPER_LIB_NAME "lib_dsp_wrap_arm12_android.so"
 
 #define WMA_MAX_CHANNELS 8
 /* pcm channel mask for wma*/
@@ -202,6 +203,10 @@ WmaDecodeUtil::WmaDecodeUtil(std::string & codecName, const std::shared_ptr<Intf
         wrapperLibName = "lib_wma10d_wrap_arm12_elinux_android.so";
         optionalWrapperLibName = nullptr;
     }
+    else if(codecName.find("c2.imx.wma.decoder.hw", 0) != std::string::npos){
+        wrapperLibName = DSP_WRAPPER_LIB_NAME;
+        optionalWrapperLibName = nullptr;
+    }
     else{
         // error
         LOGE("invalid codecName %s", codecName.c_str());
@@ -234,6 +239,8 @@ c2_status_t WmaDecodeUtil::getDecoderProp(AUDIOFORMAT *formatType, bool *isHwBas
     LOGV("entry");
     if (formatType)
         *formatType = WMA;
+    if (isHwBased)
+        *isHwBased = !strcmp(wrapperLibName, DSP_WRAPPER_LIB_NAME);
     return C2_OK;
 }
 
diff --git a/codec2/base/IMXC2ComponentBase.cpp b/codec2/base/IMXC2ComponentBase.cpp
index 71c780f..303e254 100755
--- a/codec2/base/IMXC2ComponentBase.cpp
+++ b/codec2/base/IMXC2ComponentBase.cpp
@@ -477,6 +477,7 @@ c2_status_t IMXC2ComponentBase::finishWithException(bool eos, bool force) {
             ALOGI("no pending work when get eos");
             std::unique_ptr<C2Work> work(new C2Work);
             work->input.flags = C2FrameData::FLAG_END_OF_STREAM;
+            work->input.ordinal.frameIndex = nCurFrameIndex;
             work->input.buffers.clear();
 
             work->worklets.emplace_back(new C2Worklet);
diff --git a/codec2/include/C2Config_imx.h b/codec2/include/C2Config_imx.h
index df196de..f571580 100755
--- a/codec2/include/C2Config_imx.h
+++ b/codec2/include/C2Config_imx.h
@@ -27,6 +27,7 @@ constexpr imx_aac_packaging_t C2AacStreamFormatAdif = AAC_PACKAGING_ADIF;
 #define kParamIndexBitsPerFrame (C2_PARAM_INDEX_VENDOR_START + 2)
 #define kParamIndexVendorHalPixelFormat (C2_PARAM_INDEX_VENDOR_START + 3)
 #define kParamIndexBitsPerSample (C2_PARAM_INDEX_VENDOR_START + 4)
+#define kParamIndexVendorLowLatency (C2_PARAM_INDEX_VENDOR_START + 5)
 
 typedef C2StreamParam<C2Info, C2Uint32Value, kParamIndexVendorSubFormat> C2StreamVendorSubFormat;
 constexpr char C2_PARAMKEY_VENDOR_SUB_FORMAT[] = "vendor.sub-format";
@@ -43,5 +44,8 @@ constexpr char C2_PARAMKEY_BITS_PER_FRAME[] = "vendor.bits-per-frame";
 typedef C2StreamParam<C2Info, C2Uint32Value, kParamIndexBitsPerSample> C2StreamBitsPerSample;
 constexpr char C2_PARAMKEY_BITS_PER_SAMPLE[] = "vendor.bits-per-sample";
 
+typedef C2StreamParam<C2Info, C2Uint32Value, kParamIndexVendorLowLatency> C2StreamVendorLowLatency;
+constexpr char C2_PARAMKEY_VENDOR_LOW_LATENCY[] = "vendor.low-latency";
+
 #endif
 
diff --git a/codec2/process/common/ProcessBase.h b/codec2/process/common/ProcessBase.h
index 4228b80..a2f9b8b 100644
--- a/codec2/process/common/ProcessBase.h
+++ b/codec2/process/common/ProcessBase.h
@@ -39,8 +39,10 @@ typedef struct {
     uint32_t format;
     uint32_t stride;
     uint32_t bufferSize;
+    uint32_t flag;
     bool interlaced;
 } PROCESSBASE_FORMAT;
+#define PROCESSBASE_FORMAT_FLAG_NV12    (1)
 
 typedef struct {
     int32_t mBlockId = -1;
diff --git a/codec2/process/g2d_post/G2dPostProcess.cpp b/codec2/process/g2d_post/G2dPostProcess.cpp
old mode 100755
new mode 100644
index b75bb06..cb8245f
--- a/codec2/process/g2d_post/G2dPostProcess.cpp
+++ b/codec2/process/g2d_post/G2dPostProcess.cpp
@@ -15,7 +15,7 @@
 
 #include "G2dPostProcess.h"
 #include "graphics_ext.h"
-
+#include <sys/mman.h>
 
 #define G2D_POST_PROCESS_API_TRACE
 #ifdef G2D_POST_PROCESS_API_TRACE
@@ -33,6 +33,15 @@
 
 #define G2DPP_ERR_LOG ALOGE
 
+//#define G2D_LOG_TS
+
+#define G2D_POST_LOG_LEVELFILE "/data/g2d_post_level"
+#define G2D_POST_INPUT_FILE "/data/g2d_post_in.yuv"
+#define G2D_POST_OUTPUT_FILE "/data/g2d_post_out.yuv"
+
+#define DUMP_G2D_POST_FLAG_INPUT     0x1
+#define DUMP_G2D_POST_FLAG_OUTPUT    0x2
+
 namespace android {
 
 G2dPostProcess::G2dPostProcess() {
@@ -166,14 +175,34 @@ status_t G2dPostProcess::onProcess() {
     sSrcSurface.base.width = sInFormat.width;
     sSrcSurface.base.height = sInFormat.height;
     sSrcSurface.base.stride = sInFormat.stride;
+
+    sDstSurface.base.left = 0;
+    sDstSurface.base.top = 0;
+    sDstSurface.base.right = sOutFormat.width;
+    sDstSurface.base.bottom = sOutFormat.height;
+
+    sDstSurface.base.stride = sOutFormat.stride;
+    sDstSurface.base.width = sOutFormat.width;
+    sDstSurface.base.height = sOutFormat.height;
     #endif
 
     sSrcSurface.base.planes[0] = (int)inPhys;
-    sSrcSurface.base.planes[1] = (int)inPhys + sSrcSurface.base.width * sSrcSurface.base.height;
-    ALOGV("G2dProcess::Process src w=%d,h=%d,right=%d,bottom=%d
",sSrcSurface.base.width,sSrcSurface.base.height,sSrcSurface.base.right, sSrcSurface.base.bottom);
-
+    sSrcSurface.base.planes[1] = (int)inPhys + sSrcSurface.base.stride * sSrcSurface.base.height;
+    ALOGV("src plane[0]=0x%x,plane[1]=0x%x, stride=%d,src w=%d",
+        sSrcSurface.base.planes[0],sSrcSurface.base.planes[1],sSrcSurface.base.stride,sSrcSurface.base.width);
 
     sDstSurface.base.planes[0] = (int)outPhys;
+    if(sDstSurface.base.format == G2D_NV12){
+        sDstSurface.base.planes[1] = (int)outPhys + sDstSurface.base.stride * sDstSurface.base.height;
+    }
+
+    ALOGV("dst plane[0]=0x%x,plane[1]=0x%x, stride=%d,src w=%d",
+        sDstSurface.base.planes[0],sDstSurface.base.planes[1],sDstSurface.base.stride,sDstSurface.base.width);
+
+    #ifdef G2D_LOG_TS
+    struct timeval tv, tv1;
+    gettimeofday (&tv, nullptr);
+    #endif
 
     if (sG2dModule.mG2dBlitEx(pPPHandle->g2dHandle, &sSrcSurface, &sDstSurface) != 0) {
         G2DPP_ERR_LOG("g2d_blitEx failed
");
@@ -185,6 +214,14 @@ status_t G2dPostProcess::onProcess() {
         return BAD_VALUE;
     }
 
+    #ifdef G2D_LOG_TS
+    gettimeofday (&tv1, nullptr);
+    ALOGV("G2dProcess::Process cost: %d
", (tv1.tv_sec-tv.tv_sec)*1000+(tv1.tv_usec-tv.tv_usec)/1000);
+    #endif
+
+    dumpOutBuffer(outId,sOutFormat.bufferSize);
+    ALOGV("G2dProcess::Process mG2dFinish");
+
     mInputQueue.pop();
     ProcessFrameClear(&sInMemInfo, inIndex);
 
@@ -258,7 +295,7 @@ status_t G2dPostProcess::onInit() {
     }
 
     setPostProcessParameters();
-
+    ParseG2dLogLevel();
     createFetchThread();
 
     return OK;
@@ -300,11 +337,20 @@ status_t G2dPostProcess::onDestroy() {
 }
 
 void G2dPostProcess::setPostProcessParameters() {
+
     sOutFormat.width = sInFormat.width;
     sOutFormat.height = sInFormat.height;
-    sOutFormat.stride = sInFormat.stride;
-    sOutFormat.format = HAL_PIXEL_FORMAT_YCbCr_422_I;
-    sOutFormat.bufferSize = sOutFormat.width * sOutFormat.height * 2;
+    sOutFormat.stride = sInFormat.width;
+
+    if(sInFormat.format == HAL_PIXEL_FORMAT_P010 || (sInFormat.flag & PROCESSBASE_FORMAT_FLAG_NV12)){
+        sOutFormat.format = HAL_PIXEL_FORMAT_YCbCr_420_SP;
+        sOutFormat.bufferSize = sOutFormat.width * sOutFormat.height * 3/2;
+        ALOGV("sOutFormat.format HAL_PIXEL_FORMAT_YCbCr_420_SP");
+    }else{
+        sOutFormat.format = HAL_PIXEL_FORMAT_YCbCr_422_I;
+        sOutFormat.bufferSize = sOutFormat.width * sOutFormat.height * 2;
+        ALOGV("sOutFormat.format HAL_PIXEL_FORMAT_YCbCr_422_I");
+    }
 
     sSrcSurface.base.format = G2D_NV12;
 
@@ -317,14 +363,26 @@ void G2dPostProcess::setPostProcessParameters() {
     sSrcSurface.base.height = sInFormat.height;
     sSrcSurface.base.stride = sInFormat.stride;
     sSrcSurface.tiling = G2D_AMPHION_TILED;
+
     if (sInFormat.interlaced) {
         sSrcSurface.tiling = (enum g2d_tiling)(sSrcSurface.tiling | G2D_AMPHION_INTERLACED);
         G2DPP_LOG("it is interlaced source");
     }
-    ALOGV("setPostProcessParameters src w=%d,h=%d
",sSrcSurface.base.width,sSrcSurface.base.height);
+
+    if(sInFormat.format == HAL_PIXEL_FORMAT_P010){
+        sSrcSurface.tiling = G2D_AMPHION_TILED_10BIT;
+        ALOGV("10 bit video");
+    }
+
+    ALOGV("sSrcSurface w=%d,h=%d,right=%d,bottom=%d,stride=%d", 
+        sSrcSurface.base.width, sSrcSurface.base.height, sSrcSurface.base.right, sSrcSurface.base.bottom, sSrcSurface.base.stride);
 
     sDstSurface.tiling = G2D_LINEAR;
-    sDstSurface.base.format = G2D_YUYV;
+
+    if(sOutFormat.format == HAL_PIXEL_FORMAT_YCbCr_420_SP){
+        sDstSurface.base.format = G2D_NV12;
+    }else
+        sDstSurface.base.format = G2D_YUYV;
 
     sDstSurface.base.left = 0;
     sDstSurface.base.top = 0;
@@ -334,6 +392,9 @@ void G2dPostProcess::setPostProcessParameters() {
     sDstSurface.base.stride = sOutFormat.stride;
     sDstSurface.base.width = sOutFormat.width;
     sDstSurface.base.height = sOutFormat.height;
+
+    ALOGV("sDstSurface w=%d,h=%d,right=%d,bottom=%d,stride=%d", 
+        sDstSurface.base.width, sDstSurface.base.height, sDstSurface.base.right, sDstSurface.base.bottom, sDstSurface.base.stride);
 }
 
 status_t G2dPostProcess::DoSetConfig(ProcessConfig index, void* pConfig) {
@@ -343,6 +404,65 @@ status_t G2dPostProcess::DoSetConfig(ProcessConfig index, void* pConfig) {
 status_t G2dPostProcess::DoGetConfig(ProcessConfig index, void* pConfig) {
     return BAD_VALUE; // not support any index yet
 }
+void G2dPostProcess::ParseG2dLogLevel()
+{
+    int level=0;
+    FILE* fpVpuLog;
+    nDebugFlag = 0;
+    
+    fpVpuLog=fopen(G2D_POST_LOG_LEVELFILE, "r");
+    if (NULL==fpVpuLog){
+        return;
+    }
+
+    char symbol;
+    int readLen = 0;
+
+    readLen = fread(&symbol,1,1,fpVpuLog);
+    if(feof(fpVpuLog) != 0){
+        ;
+    }
+    else{
+        level=atoi(&symbol);
+        if((level<0) || (level>255)){
+            level=0;
+        }
+    }
+    fclose(fpVpuLog);
+
+    nDebugFlag=level;
+
+    if(nDebugFlag != 0)
+        ALOGV("ParseVpuLogLevel nDebugFlag=%x",nDebugFlag);
+    return;
+}
+void G2dPostProcess::dumpOutBuffer(int id, uint32_t size)
+{
+    FILE * pfile = NULL;
+    void* buf = NULL;
+
+    if(!(nDebugFlag & DUMP_G2D_POST_FLAG_OUTPUT))
+        return;
+
+    ProcessBlockInfo* pInfo = getProcessBlockById(id);
+
+    if(pInfo->mFd <= 0){
+        ALOGV("dumpOutBuffer invalid fd");
+        return;
+    }
+
+    pfile = fopen(G2D_POST_OUTPUT_FILE,"ab");
+
+    if(pfile){
+        buf = mmap(0, size, PROT_READ, MAP_SHARED, pInfo->mFd, 0);
+        fwrite(buf,1,size,pfile);
+        ALOGV("dumpOutBuffer write %d",size);
+        munmap(buf, size);
+        fclose(pfile);
+    }else
+        ALOGV("dumpOutBuffer failed to open %s",G2D_POST_OUTPUT_FILE);
+    return;
+}
 
 ProcessBase * CreatePostProcessInstance() {
     return static_cast<ProcessBase *>(new G2dPostProcess());
diff --git a/codec2/process/g2d_post/G2dPostProcess.h b/codec2/process/g2d_post/G2dPostProcess.h
index 249a746..f7084af 100644
--- a/codec2/process/g2d_post/G2dPostProcess.h
+++ b/codec2/process/g2d_post/G2dPostProcess.h
@@ -59,26 +59,18 @@ private:
 
     bool bFetchStarted;
     bool bFetchStopped;
-/*
-    bool bProcessStarted;
-    bool bProcessStopped;
-*/
-    //Mutex mLock;
+    uint32_t nDebugFlag;
+
     pthread_t mFetchThread;
-    //pthread_t mProcessThread;
 
     status_t createFetchThread();
     status_t destroyFetchThread();
     static void *FetchThreadWrapper(void *);
     status_t HandleFetchThread();
-/*
-    status_t createProcessThread();
-    status_t destroyProcessThread();
-    static void *ProcessThreadWrapper(void *);
-    status_t HandleProcessThread();
-    status_t DoProcess();*/
 
     void setPostProcessParameters();
+    void ParseG2dLogLevel();
+    void dumpOutBuffer(int fd, uint32_t size);
 };
 
 } // namespcae android
diff --git a/codec2/process/isi_pre/IsiPreProcess.cpp b/codec2/process/isi_pre/IsiPreProcess.cpp
index 2dd1330..d4f7224 100644
--- a/codec2/process/isi_pre/IsiPreProcess.cpp
+++ b/codec2/process/isi_pre/IsiPreProcess.cpp
@@ -366,9 +366,7 @@ status_t IsiPreProcess::destroyPollThread()
         bPollStarted = false;
         ALOGV("destroyPollThread bPollStarted FALSE");
         usleep(1000);
-        mLock.lock();
         pthread_join(mPollThread, NULL);
-        mLock.unlock();
     }
     return OK;
 }
diff --git a/codec2/store/ImxC2Store.cpp b/codec2/store/ImxC2Store.cpp
index 7785ad5..bb4b085 100755
--- a/codec2/store/ImxC2Store.cpp
+++ b/codec2/store/ImxC2Store.cpp
@@ -10,6 +10,8 @@
 #define LOG_TAG "ImxC2Store"
 #include <log/log.h>
 
+#include <stdio.h>
+#include <unistd.h>
 #include <cutils/properties.h>
 #include <C2ComponentFactory.h>
 #include <C2Config.h>
@@ -22,6 +24,8 @@
 
 namespace android {
 
+#define IMX_EXTRACTOR_PATH "/system/lib64/extractors/libimxextractor.so"
+
 typedef ::C2ComponentFactory* (*IMXCreateCodec2FactoryFunc)(C2String name);
 typedef void (*IMXDestroyCodec2FactoryFunc)(::C2ComponentFactory*);
 
@@ -251,9 +255,32 @@ c2_status_t ImxC2Store::ComponentBox::init()
             if (traits->domain == C2Component::DOMAIN_VIDEO)
                 traits->rank = (useImxVideo ? 0x1 : 0x400);
             else if (traits->domain == C2Component::DOMAIN_AUDIO)
-                traits->rank = (useImxAudio ? 0x1 : 0x400);
+                traits->rank = (useImxAudio ? 0x2 : 0x400);
             else
                 traits->rank = 0x200;
+
+            // set imx aac decoder's rank to the lowest, as these is only one aac decoder
+            // for audio/mp4a-latm, imx aac decoder still is the default aac decoder, but
+            // in CTS-on-GSI, google aac decoder has higher rank and it will be the default
+            // aac decoder, then all aac CTS can pass.
+            if (traits->name.find("c2.imx.aac.decoder") != std::string::npos) {
+                traits->rank = 0x400;
+            }
+
+            // for CTS-on-GSI, as there is no imx extractors, set imx audio decoder the lowest priority.
+            if (traits->domain == C2Component::DOMAIN_AUDIO) {
+                if (access(IMX_EXTRACTOR_PATH, 0) != 0) {
+                    traits->rank = 0x400;
+                }
+            }
+
+            if (traits->domain == C2Component::DOMAIN_AUDIO
+                && traits->name.find("decoder.hw") != std::string::npos) {
+                    if(traits->rank > 1)
+                        traits->rank -= 1;
+                    else
+                        ALOGE("Can't set audio dsp decoder to high priority!");
+            }
         }
         mTraits = traits;
     }
@@ -344,7 +371,7 @@ ImxC2Store::ImxC2Store()
     REG_ENTRY * pReg;
     for (i = 0; i < num; i++) {
         pReg = localRegParser.QueryRegComp(i);
-        if (pReg && pReg->disable != true) {
+        if (pReg) {
             ALOGV("emplace component %s lib %s", pReg->compName, pReg->libName);
             emplace(pReg->compName, pReg->libName);
         }
diff --git a/codec2/store/RegistryParser.cpp b/codec2/store/RegistryParser.cpp
index dc8d8a1..64ac3d2 100755
--- a/codec2/store/RegistryParser.cpp
+++ b/codec2/store/RegistryParser.cpp
@@ -13,7 +13,6 @@
 #include <string.h>
 #include "RegistryParser.h"
 
-
 RegistryParser::RegistryParser()
 {
     registerdCompNum = 0;
@@ -56,31 +55,6 @@ REG_ERRORTYPE RegistryParser::ParseRegList(char *file_name) {
         DoParseRegList(includeFiles[i]);
     }
 
-    int hwMp3Index = -1, hwAacIndex = -1;
-    int swMp3Index = -1, swAacIndex = -1;
-
-    for (i=0; i< registerdCompNum; i++) {
-        if (strstr(RegList[i].compName, "mp3.decoder.hw"))
-            hwMp3Index = i;
-        else if (strstr(RegList[i].compName, "mp3.decoder.sw"))
-            swMp3Index = i;
-        else if (strstr(RegList[i].compName, "aac.decoder.hw"))
-            hwAacIndex = i;
-        else if (strstr(RegList[i].compName, "aac.decoder.sw"))
-            swAacIndex = i;
-    }
-
-    ALOGV("hwMp3Index %d swMp3Index %d", hwMp3Index, swMp3Index);
-    ALOGV("hwAacIndex %d swAacIndex %d", hwAacIndex, swAacIndex);
-
-    if (hwMp3Index > 0 && swMp3Index > 0) {
-        RegList[swMp3Index].disable = true;
-    }
-
-    if (hwAacIndex > 0 && swAacIndex > 0) {
-        RegList[swAacIndex].disable = true;
-    }
-
     return REG_SUCCESS;
 }
 
@@ -156,7 +130,6 @@ REG_ERRORTYPE RegistryParser::DoParseRegList(char *file_name)
 			{
 			    if (EntryFounded && getCompName && getLibName) {
                     ALOGV("register comp index %d %s %s ", registerdCompNum, pRegEntry->compName, pRegEntry->libName);
-                    pRegEntry->disable = false;
                     registerdCompNum++;
                 }
                 EntryFounded = false;
diff --git a/codec2/store/RegistryParser.h b/codec2/store/RegistryParser.h
old mode 100755
new mode 100644
index b7bb96c..e4c2444
--- a/codec2/store/RegistryParser.h
+++ b/codec2/store/RegistryParser.h
@@ -34,7 +34,6 @@ typedef enum {
 typedef struct _REG_ENTRY {
     char compName[ITEM_NAME_LEN];
     char libName[ITEM_NAME_LEN];
-    bool disable;
 }REG_ENTRY;
 
 class RegistryParser {
diff --git a/codec2/store/registry/c2_component_register_8mp b/codec2/store/registry/c2_component_register_8mp
index 899c579..4ce700e 100644
--- a/codec2/store/registry/c2_component_register_8mp
+++ b/codec2/store/registry/c2_component_register_8mp
@@ -12,6 +12,7 @@ include_file=/vendor/etc/c2_component_register_ms;
 include_file=/vendor/etc/c2_component_register_ra;
 include_file=/vendor/etc/c2_component_register_dsp;
 include_file=/vendor/etc/c2_component_register_dsp_aacp;
+include_file=/vendor/etc/c2_component_register_dsp_wma;
 $
 
 @
diff --git a/codec2/store/registry/c2_component_register_8q b/codec2/store/registry/c2_component_register_8q
index 91cbc34..8dc23c2 100644
--- a/codec2/store/registry/c2_component_register_8q
+++ b/codec2/store/registry/c2_component_register_8q
@@ -14,6 +14,7 @@ include_file=/vendor/etc/c2_component_register_rv;
 include_file=/vendor/etc/c2_component_register_wmv9;
 include_file=/vendor/etc/c2_component_register_dsp;
 include_file=/vendor/etc/c2_component_register_dsp_aacp;
+include_file=/vendor/etc/c2_component_register_dsp_wma;
 $
 
 @
diff --git a/codec2/v4l2_dev/V4l2Dev.cpp b/codec2/v4l2_dev/V4l2Dev.cpp
index c15084d..981a9c0 100644
--- a/codec2/v4l2_dev/V4l2Dev.cpp
+++ b/codec2/v4l2_dev/V4l2Dev.cpp
@@ -23,6 +23,7 @@
 #include <media/stagefright/MediaErrors.h>
 #include "graphics_ext.h"
 #include "Imx_ext.h"
+#include "C2Config.h"
 
 namespace android {
 
@@ -103,8 +104,7 @@ status_t V4l2Dev::SearchName(V4l2DEV_TYPE type)
     }
 
     int32_t index = 0;
-    //isi node is /dev/video4 on board with due camera
-    const int32_t index_map[MAX_VIDEO_SEARCH_NODE]={4,3,2,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,0,1};
+    //isi node is /dev/video2 on board with due camera
     int32_t fd = -1;
     char name[MAX_DEV_NAME_LEN];
     bool bGet = false;
@@ -112,7 +112,7 @@ status_t V4l2Dev::SearchName(V4l2DEV_TYPE type)
 
     while(index < MAX_VIDEO_SEARCH_NODE){
 
-        sprintf((char*)name, "/dev/video%d", index_map[index]);
+        sprintf((char*)name, "/dev/video%d", index);
 
         fd = open ((char*)name, O_RDWR);
         if(fd < 0){
@@ -136,7 +136,7 @@ status_t V4l2Dev::SearchName(V4l2DEV_TYPE type)
             }
         }
         if(type == V4L2_DEV_ISI){
-            if(NULL == strstr((char*)cap.driver, "mxc-isi")){
+            if(NULL == strstr((char*)cap.driver, "mxc-isi-m2m")){
                 close(fd);
                 index ++;
                 continue;
@@ -321,7 +321,7 @@ static const COLOR_FORMAT_TABLE color_format_table[]={
     { HAL_PIXEL_FORMAT_NV12_TILED, V4L2_PIX_FMT_NV12 },
     { HAL_PIXEL_FORMAT_YCbCr_420_SP, V4L2_PIX_FMT_NV12 },
     { HAL_PIXEL_FORMAT_YCbCr_420_888, V4L2_PIX_FMT_NV12 },
-    //{ 2, v4l2_fourcc('N', 'T', '1', '2')}
+    { HAL_PIXEL_FORMAT_P010, v4l2_fourcc('N', 'T', '1', '2')}
 };
 status_t V4l2Dev::GetStreamTypeByMime(const char * mime, uint32_t * format_type)
 {
@@ -394,8 +394,8 @@ uint32_t V4l2Dev::Poll()
     int r;
     struct pollfd pfd[2];
     struct timespec ts;
-    ts.tv_sec = 1;//default timeout 1 seconds
-    ts.tv_nsec = 0;
+    ts.tv_sec = 0;//default timeout 1 seconds
+    ts.tv_nsec = 400000000;
 
     pfd[0].fd = nFd;
     pfd[0].events = POLLERR | POLLNVAL | POLLHUP;
@@ -625,13 +625,85 @@ status_t V4l2Dev::SetEncoderParam(V4l2EncInputParam *param)
 status_t V4l2Dev::SetH264EncoderProfileAndLevel(uint32_t profile, uint32_t level)
 {
     int ret = 0;
-    int32_t v4l2_profile = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN;
-    int32_t v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_1;
+    int v4l2_profile = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE;
+    int v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_1;
 
+    switch(profile){
+        case PROFILE_AVC_BASELINE:
+        case PROFILE_AVC_CONSTRAINED_BASELINE:
+            v4l2_profile = V4L2_MPEG_VIDEO_H264_PROFILE_BASELINE;
+            break;
+        case PROFILE_AVC_MAIN:
+            v4l2_profile = V4L2_MPEG_VIDEO_H264_PROFILE_MAIN;
+            break;
+        case PROFILE_AVC_HIGH:
+            v4l2_profile = V4L2_MPEG_VIDEO_H264_PROFILE_HIGH;
+            break;
+        default:
+            break;
+    }
+
+    switch (level) {
+        case 10:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_1_0;
+            break;
+        case 9:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_1B;
+            break;
+        case 11:
+            //adjust according to cts's code
+            //v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_1_1;
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_1_0;
+            break;
+        case 12:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_1_2;
+            break;
+        case 13:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_1_3;
+            break;
+        case 20:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_2_0;
+            break;
+        case 21:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_2_1;
+            break;
+        case 22:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_2_2;
+            break;
+        case 30:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_3_0;
+            break;
+        case 31:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_3_1;
+            break;
+        case 32:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_3_2;
+            break;
+        case 40:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_0;
+            break;
+        case 41:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_1;
+            break;
+        case 42:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_4_2;
+            break;
+        case 50:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_5_0;
+            break;
+        case 51:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_5_1;
+            break;
+        case 52:
+            v4l2_level = V4L2_MPEG_VIDEO_H264_LEVEL_5_1;
+            break;
+        default:
+            break;
+    }
 
     ret |= SetCtrl(V4L2_CID_MPEG_VIDEO_H264_PROFILE, v4l2_profile);
     ret |= SetCtrl(V4L2_CID_MPEG_VIDEO_H264_LEVEL, v4l2_level);
-    ALOGV("set profile=%d,level=%d,ret=%d",v4l2_profile,v4l2_level,ret);
+    ALOGV("set profile=%d,level=%d,v4l2_profile=%d,v4l2_level=%d,ret=%d",profile,level,v4l2_profile,v4l2_level,ret);
     return OK;
 }
 
diff --git a/codec2/video_dec/common/IMXC2VideoDecoder.cpp b/codec2/video_dec/common/IMXC2VideoDecoder.cpp
old mode 100755
new mode 100644
index d25579b..4b9fd02
--- a/codec2/video_dec/common/IMXC2VideoDecoder.cpp
+++ b/codec2/video_dec/common/IMXC2VideoDecoder.cpp
@@ -33,6 +33,7 @@ namespace android {
 #define IMX_VIDEO_DEC_API_TRACE
 #endif
 
+
 class IMXC2VideoDecoder::IntfImpl : public IMXInterface<void>::BaseParams {
 public:
     explicit IntfImpl(const std::shared_ptr<C2ReflectorHelper> &helper, C2String componentName)
@@ -101,7 +102,7 @@ public:
                 .withDefault(new C2StreamMaxPictureSizeTuning::output(0u, 320, 240))
                 .withFields({
                     C2F(mSize, width).inRange(2, 4096, 2),
-                    C2F(mSize, height).inRange(2, 2160, 2),
+                    C2F(mSize, height).inRange(2, 2560, 2),
                 })
                 .withSetter(MaxPictureSizeSetter, mSize)
                 .build());
@@ -419,6 +420,8 @@ public:
         (void)mayBlock;
         // assume compression ratio of 2
         me.set().value = (((maxSize.v.width + 15) / 16) * ((maxSize.v.height + 15) / 16) * 192);
+        // HACK: allow 20% overhead
+        me.set().value += me.set().value / 5;
         return C2R::Ok();
     }
 
@@ -876,10 +879,6 @@ void IMXC2VideoDecoder::handleOutputPicture(GraphicBlockInfo* info, uint64_t tim
     C2PortActualDelayTuning::output outputDelay(0);
     C2StreamPictureSizeInfo::output size(0u, mWidth, mHeight);
     C2StreamPixelFormatInfo::output fmt(0u, HAL_PIXEL_FORMAT_YCBCR_420_888);
-    if(bPPEnabled){
-        fmt.value = HAL_PIXEL_FORMAT_YCBCR_422_I;//0x14;
-        ALOGV("handleOutputPicture bPPEnabled");
-    }
 
     {
         IntfImpl::Lock lock = mIntf->lock();
@@ -938,7 +937,10 @@ void IMXC2VideoDecoder::handleOutputPicture(GraphicBlockInfo* info, uint64_t tim
         }
 
         ALOGV("configUpdate outputDelay.value=%d", outputDelay.value);
-
+        if(bPPEnabled){
+            fmt.value = mIntf->getVenderHalFormat();
+            ALOGV("handleOutputPicture bPPEnabled");
+        }
     }
 
     auto fillWork = [buffer, timestamp, configUpdate, size, outputDelay, fmt]
@@ -990,7 +992,7 @@ void IMXC2VideoDecoder::handleOutputPicture(GraphicBlockInfo* info, uint64_t tim
 // update intf configure
 void IMXC2VideoDecoder::notifyVideoInfo(VideoFormat *pFormat) {
     status_t err = OK;
-
+    uint32_t ppOutFmt = 0;
     bPPEnabled = mDecoder->checkIfPostProcessNeeded();
 
     if (bPPEnabled) {
@@ -999,8 +1001,16 @@ void IMXC2VideoDecoder::notifyVideoInfo(VideoFormat *pFormat) {
         PROCESSBASE_FORMAT inFmt, outFmt;
         inFmt.width = pFormat->width;
         inFmt.height = pFormat->height;
-        inFmt.stride = pFormat->width;
+        inFmt.stride = pFormat->stride;
         inFmt.interlaced = pFormat->interlaced;
+        inFmt.flag = 0;
+        inFmt.format = (uint32_t)pFormat->pixelFormat;
+        ALOGV("vendor hal format=%d",mIntf->getVenderHalFormat());
+        //nuplayer will set vendor hal format. if not, enable nv12 format
+        if(0 == mIntf->getVenderHalFormat()){
+            inFmt.flag = PROCESSBASE_FORMAT_FLAG_NV12;
+            ALOGI("enable NV12 format");
+        }
 
         // receive the first format change event, post process is created and configured.
         // later post process just need to call videoFormatChanged to handle this event.
@@ -1011,7 +1021,7 @@ void IMXC2VideoDecoder::notifyVideoInfo(VideoFormat *pFormat) {
                 return;
             }
 
-            ALOGV("config process input format: %d x %d, stride %d", pFormat->width, pFormat->height, pFormat->width);
+            ALOGV("config process input format: %d x %d, stride %d, fmt=%d", pFormat->width, pFormat->height, pFormat->width, pFormat->pixelFormat);
 
             err = mPostProcess->setConfig(PROCESS_CONFIG_INPUT_FORMAT, &inFmt);
             if (err) {
@@ -1030,8 +1040,10 @@ void IMXC2VideoDecoder::notifyVideoInfo(VideoFormat *pFormat) {
                 bSignalledError = true;
                 return;
             }
+            ppOutFmt = outFmt.format;
         } else {
             ALOGV("notifyVideoInfo call mPostProcess->videoFormatChanged");
+            ppOutFmt = mIntf->getVenderHalFormat();
             // need reconfigure post processor to handle resolution change.
             mPostProcess->videoFormatChanged(&inFmt);
             mPostProcess->start();
@@ -1059,10 +1071,12 @@ void IMXC2VideoDecoder::notifyVideoInfo(VideoFormat *pFormat) {
     (void)mIntf->config({&crop}, C2_MAY_BLOCK, &failures);
 
     //update C2StreamVendorHalPixelFormat when enable post process for malone decoder
-    if(0 == mIntf->getVenderHalFormat() && bPPEnabled){
+    if(bPPEnabled){
         C2StreamVendorHalPixelFormat::output fmt(0u, HAL_PIXEL_FORMAT_YCBCR_422_I);//FORMAT_YUYV 0x14
+        if(ppOutFmt != 0)
+            fmt.value = ppOutFmt;
         (void)mIntf->config({&fmt}, C2_MAY_BLOCK, &failures);
-        ALOGV("config C2StreamVendorHalPixelFormat HAL_PIXEL_FORMAT_YCBCR_422_I");
+        ALOGV("config C2StreamVendorHalPixelFormat fmt=0x%x",fmt.value);
     }
 
     DecColorAspects colorAspects;
@@ -1184,10 +1198,7 @@ status_t IMXC2VideoDecoder::notifyProcessInputUsed(int inputId) {
     if(mDecoder == NULL)
         return OK;
 
-    if(bPPEnabled && mPostProcess != NULL)
-        return mDecoder->queueOutput(inputId);
-    else
-        mDecoder->returnOutputBufferToDecoder(inputId);
+    mDecoder->returnOutputBufferToDecoder(inputId);
     return OK;
 }
 
diff --git a/codec2/video_dec/common/VideoDecoderBase.cpp b/codec2/video_dec/common/VideoDecoderBase.cpp
index e270ca6..5157c46 100755
--- a/codec2/video_dec/common/VideoDecoderBase.cpp
+++ b/codec2/video_dec/common/VideoDecoderBase.cpp
@@ -545,7 +545,7 @@ status_t VideoDecoderBase::onOutputFormatChanged() {
     VDB_API_TRACE("%s, line %d", __FUNCTION__, __LINE__);
 
     ALOGI("New format(pixelfmt=0x%x, min buffers=%u, request buffers %d, w*h=%d x %d, crop=(%d %d %d %d), interlaced %d)",
-          static_cast<uint32_t>(mOutputFormat.pixelFormat), mOutputFormat.minBufferNum, mOutputFormat.bufferNum,
+          mOutputFormat.pixelFormat, mOutputFormat.minBufferNum, mOutputFormat.bufferNum,
           mOutputFormat.width, mOutputFormat.height,
           mOutputFormat.rect.left, mOutputFormat.rect.top,
           mOutputFormat.rect.right, mOutputFormat.rect.bottom, mOutputFormat.interlaced);
diff --git a/codec2/video_dec/common/VideoDecoderBase.h b/codec2/video_dec/common/VideoDecoderBase.h
old mode 100755
new mode 100644
index 9c525b2..42c4201
--- a/codec2/video_dec/common/VideoDecoderBase.h
+++ b/codec2/video_dec/common/VideoDecoderBase.h
@@ -90,6 +90,7 @@ struct VideoFormat {
     uint32_t minBufferNum = 0;
     uint32_t width;
     uint32_t height;
+    uint32_t stride;
     uint32_t bufferNum;
     uint32_t bufferSize;
     VideoRect rect;
diff --git a/codec2/video_dec/v4l2_dec/V4l2Dec.cpp b/codec2/video_dec/v4l2_dec/V4l2Dec.cpp
old mode 100755
new mode 100644
index a54c44e..f4afa4b
--- a/codec2/video_dec/v4l2_dec/V4l2Dec.cpp
+++ b/codec2/video_dec/v4l2_dec/V4l2Dec.cpp
@@ -19,6 +19,14 @@
 
 namespace android {
 
+#define VPU_DECODER_LOG_LEVELFILE "/data/vpu_dec_level"
+#define DUMP_DEC_INPUT_FILE "/data/temp_dec_in.bit"
+#define DUMP_DEC_OUTPUT_FILE "/data/temp_dec_out.yuv"
+
+#define DUMP_DEC_FLAG_INPUT     0x1
+#define DUMP_DEC_FLAG_OUTPUT    0x2
+
+
 #define IMX_V4L2_BUF_FLAG_CODECCONFIG      0x00200000
 #define IMX_V4L2_BUF_FLAG_TIMESTAMP_INVALID    0x00400000
 
@@ -93,6 +101,8 @@ status_t V4l2Dec::onInit(){
     mState = UNINITIALIZED;
     mInCnt = 0;
     mOutCnt = 0;
+
+    ParseVpuLogLevel();
     return OK;
 }
 status_t V4l2Dec::onStart()
@@ -686,7 +696,7 @@ status_t V4l2Dec::destroyPollThread()
             cnt ++;
         } while (!bPollStopped && cnt < 20);
         ALOGV("%s bPollStopped bPollStopped=%d,cnt=%d", __FUNCTION__,bPollStopped,cnt);
-        Mutex::Autolock autoLock(mLock);
+
         pDev->SetPollInterrupt();
         ALOGV("%s call pthread_join", __FUNCTION__);
         pthread_join(mPollThread, NULL);
@@ -724,7 +734,7 @@ status_t V4l2Dec::destroyFetchThread()
             cnt ++;
         } while (!bFetchStopped && cnt < 20);
         ALOGV("%s bFetchStopped=%d,cnt=%d", __FUNCTION__,bFetchStopped,cnt);
-        Mutex::Autolock autoLock(mLock);
+
         pthread_join(mFetchThread, NULL);
     }
     ALOGV("%s END", __FUNCTION__);
@@ -801,6 +811,7 @@ QueueOneBuffer:
     if(mInMemType == V4L2_MEMORY_MMAP){
         memcpy((void*)(uintptr_t)(mInputBufferMap[index].plane.vaddr + buf_length), input->pInBuffer, input->size);
         buf_length += input->size;
+        dumpInputBuffer((void*)(uintptr_t)mInputBufferMap[index].plane.vaddr, buf_length);
     }
 
     if(mInputBufferMap[index].at_device){
@@ -826,8 +837,10 @@ QueueOneBuffer:
 
     stV4lBuf.index = index;
     stV4lBuf.type = V4L2_BUF_TYPE_VIDEO_OUTPUT_MPLANE;
-    stV4lBuf.timestamp.tv_sec = ts / 1000000;
-    stV4lBuf.timestamp.tv_usec = ts % 1000000;
+    if((int64_t)ts > 0){
+        stV4lBuf.timestamp.tv_sec = ts / 1000000;
+        stV4lBuf.timestamp.tv_usec = ts % 1000000;
+    }
     stV4lBuf.memory = mInMemType;
     stV4lBuf.m.planes = &plane;
     stV4lBuf.length = kInputBufferPlaneNum;
@@ -864,6 +877,7 @@ status_t V4l2Dec::dequeueInputBuffer()
     int result = 0;
     int input_id = -1;
 
+
     if(!bInputStreamOn || mState != RUNNING )
         return OK;
 
@@ -928,7 +942,7 @@ status_t V4l2Dec::queueOutput(GraphicBlockInfo* pInfo)
     paddr[1] = pInfo->mPhysAddr;
 
     offset[0] = 0;
-    offset[1] = mOutputFormat.width * mOutputFormat.height;
+    offset[1] = mOutputPlaneSize[0];//mOutputFormat.stride * mOutputFormat.height;
 
     fd[0] = pInfo->mDMABufFd;
     fd[1] = pInfo->mDMABufFd;
@@ -970,7 +984,7 @@ status_t V4l2Dec::queueOutput(GraphicBlockInfo* pInfo)
     }
 
     if(mOutputBufferMap[index].at_device){
-        ALOGE("queueOutput index=%d, at_device,pInfo->mBlockId=%d",index,pInfo->mBlockId);
+        ALOGE("queueOutput at_device,index=%d, pInfo->mBlockId=%d",index,pInfo->mBlockId);
     }
 
     struct v4l2_buffer stV4lBuf;
@@ -1126,6 +1140,7 @@ status_t V4l2Dec::dequeueOutputBuffer()
     mVpuOwnedOutputBufferNum--;
     mOutCnt ++;
     mOutputBufferMap[stV4lBuf.index].at_device = false;
+    dumpOutputBuffer((void*)(uintptr_t)mOutputBufferMap[stV4lBuf.index].planes[0].vaddr,mOutputFormat.bufferSize);
     NotifyPictureReady(mOutputBufferMap[stV4lBuf.index].picture_id, ts);
     return OK;
 }
@@ -1134,6 +1149,7 @@ status_t V4l2Dec::onDequeueEvent()
     int result = 0;
     struct v4l2_event event;
     memset(&event, 0, sizeof(struct v4l2_event));
+
     result = ioctl(mFd, VIDIOC_DQEVENT, &event);
     if(result == 0){
         ALOGV("onDequeueEvent type=%d",event.type);
@@ -1141,7 +1157,8 @@ status_t V4l2Dec::onDequeueEvent()
             case V4L2_EVENT_SOURCE_CHANGE:
                 if(event.u.src_change.changes & V4L2_EVENT_SRC_CH_RESOLUTION){
                     //TODO: send event
-                    handleFormatChanged();
+                    if(STOPPING != mState)
+                        handleFormatChanged();
                 }
                 break;
             case V4L2_EVENT_EOS:
@@ -1342,6 +1359,7 @@ status_t V4l2Dec::handleFormatChanged() {
 
     status_t ret = OK;
     int pre_state;
+    Mutex::Autolock autoThreadLock(mThreadLock);
     ALOGV("outputFormatChanged BEGIN");
     {
         Mutex::Autolock autoLock(mLock);
@@ -1363,9 +1381,21 @@ status_t V4l2Dec::handleFormatChanged() {
             return ret;
 
         mOutputFormat.pixelFormat = static_cast<int>(pixel_format);
+        if(mOutputFormat.pixelFormat == HAL_PIXEL_FORMAT_P010){
+            bNeedPostProcess = true;
+            mOutFormat = format.fmt.pix_mp.pixelformat;
+            ALOGV("10bit video stride=%d",format.fmt.pix_mp.plane_fmt[0].bytesperline);
+        }
 
         mOutputFormat.width = Align(format.fmt.pix_mp.width, FRAME_ALIGN);
         mOutputFormat.height = Align(format.fmt.pix_mp.height, FRAME_ALIGN);
+        mOutputFormat.stride = mOutputFormat.width;
+
+        //for 10bit video, stride is larger than width, should use stride to allocate buffer
+        if(mOutputFormat.width < format.fmt.pix_mp.plane_fmt[0].bytesperline){
+            mOutputFormat.stride = format.fmt.pix_mp.plane_fmt[0].bytesperline;
+        }
+
         mOutputFormat.interlaced = ((format.fmt.pix_mp.field == V4L2_FIELD_INTERLACED) ? true: false);
         mOutputFormat.bufferSize = format.fmt.pix_mp.plane_fmt[0].sizeimage + format.fmt.pix_mp.plane_fmt[1].sizeimage;
 
@@ -1411,6 +1441,9 @@ status_t V4l2Dec::handleFormatChanged() {
         mOutputFormat.rect.left = crop.c.left;
     }
 
+    ALOGV("outputFormatChanged w=%d,h=%d,buf cnt=%d, buffer size[0]=%d,size[1]=%d",
+        mOutputFormat.width, mOutputFormat.height, mOutputFormat.minBufferNum, mOutputPlaneSize[0], mOutputPlaneSize[1]);
+
     if(pre_state == STOPPING || pre_state == FLUSHING){
         ALOGI("do not handle resolution while flushing or stopping");
         return OK;
@@ -1430,8 +1463,7 @@ status_t V4l2Dec::handleFormatChanged() {
 
     outputFormatChanged();
 
-    ALOGV("outputFormatChanged w=%d,h=%d,buf cnt=%d, buffer size[0]=%d,size[1]=%d",
-        mOutputFormat.width, mOutputFormat.height, mOutputFormat.minBufferNum, mOutputPlaneSize[0], mOutputPlaneSize[1]);
+    ALOGV("outputFormatChanged end");
     return OK;
 }
 
@@ -1492,7 +1524,8 @@ status_t V4l2Dec::onFlush()
     {
         Mutex::Autolock autoLock(mLock);
         pre_state = mState;
-        mState = FLUSHING;
+        if(mState != STOPPING)
+            mState = FLUSHING;
     }
     status_t ret = UNKNOWN_ERROR;
 
@@ -1519,6 +1552,7 @@ status_t V4l2Dec::onStop()
 
     ALOGV("%s", __FUNCTION__);
     status_t ret = UNKNOWN_ERROR;
+    Mutex::Autolock autoThreadLock(mThreadLock);
     {
     Mutex::Autolock autoLock(mLock);
     mState = STOPPING;
@@ -1584,7 +1618,82 @@ status_t V4l2Dec::onDestroy()
 bool V4l2Dec::checkIfPostProcessNeeded() {
     return bNeedPostProcess;
 }
+void V4l2Dec::ParseVpuLogLevel()
+{
+    int level=0;
+    FILE* fpVpuLog;
+    nDebugFlag = 0;
+    
+    fpVpuLog=fopen(VPU_DECODER_LOG_LEVELFILE, "r");
+    if (NULL==fpVpuLog){
+        return;
+    }
+
+    char symbol;
+    int readLen = 0;
+
+    readLen = fread(&symbol,1,1,fpVpuLog);
+    if(feof(fpVpuLog) != 0){
+        ;
+    }
+    else{
+        level=atoi(&symbol);
+        if((level<0) || (level>255)){
+            level=0;
+        }
+    }
+    fclose(fpVpuLog);
+
+    nDebugFlag=level;
+
+    if(nDebugFlag != 0)
+        ALOGV("ParseVpuLogLevel nDebugFlag=%x",nDebugFlag);
+    return;
+}
+void V4l2Dec::dumpInputBuffer(void* inBuf, uint32_t size)
+{
+    FILE * pfile = NULL;
+
+    if(!(nDebugFlag & DUMP_DEC_FLAG_INPUT))
+        return;
+
+    if(!inBuf){
+        ALOGV("dumpInputBuffer invalid fd");
+        return;
+    }
+
+    pfile = fopen(DUMP_DEC_INPUT_FILE,"ab");
 
+    if(pfile){
+        fwrite(inBuf,1,size,pfile);
+        ALOGV("dumpInputBuffer write %d",size);
+        fclose(pfile);
+    }else
+        ALOGV("dumpInputBuffer failed to open %s",DUMP_DEC_INPUT_FILE);
+    return;
+}
+void V4l2Dec::dumpOutputBuffer(void* inBuf, uint32_t size)
+{
+    FILE * pfile = NULL;
+
+    if(!(nDebugFlag & DUMP_DEC_FLAG_OUTPUT))
+        return;
+
+    if(!inBuf){
+        ALOGV("dumpOutputBuffer invalid fd");
+        return;
+    }
+
+    pfile = fopen(DUMP_DEC_OUTPUT_FILE,"ab");
+
+    if(pfile){
+        fwrite(inBuf,1,size,pfile);
+        ALOGV("dumpOutputBuffer write %d",size);
+        fclose(pfile);
+    }else
+        ALOGV("dumpOutputBuffer failed to open %s",DUMP_DEC_OUTPUT_FILE);
+    return;
+}
 VideoDecoderBase * CreateVideoDecoderInstance(const char* mime) {
     return static_cast<VideoDecoderBase *>(new V4l2Dec(mime));
 }
diff --git a/codec2/video_dec/v4l2_dec/V4l2Dec.h b/codec2/video_dec/v4l2_dec/V4l2Dec.h
old mode 100755
new mode 100644
index eed0e37..a87931e
--- a/codec2/video_dec/v4l2_dec/V4l2Dec.h
+++ b/codec2/video_dec/v4l2_dec/V4l2Dec.h
@@ -108,6 +108,7 @@ private:
     std::vector<OutputRecord> mOutputBufferMap;
 
     Mutex mLock;
+    Mutex mThreadLock;
 
     bool bPollStarted;
     bool bPollStopped;
@@ -132,7 +133,7 @@ private:
 
     uint32_t mInCnt;
     uint32_t mOutCnt;
-
+    uint32_t nDebugFlag;
 
     status_t prepareInputParams();
     status_t SetInputFormats();
@@ -164,6 +165,9 @@ private:
     status_t HandleFetchThread();
 
     status_t handleFormatChanged();
+    void ParseVpuLogLevel();
+    void dumpInputBuffer(void* inBuf, uint32_t size);
+    void dumpOutputBuffer(void* buf, uint32_t size);
 };
 
 
diff --git a/codec2/video_dec/vpuwrapper_dec/Android.bp b/codec2/video_dec/vpuwrapper_dec/Android.bp
index eeb2088..957114a 100644
--- a/codec2/video_dec/vpuwrapper_dec/Android.bp
+++ b/codec2/video_dec/vpuwrapper_dec/Android.bp
@@ -31,7 +31,7 @@ cc_library_shared {
     include_dirs: [
         "frameworks/av",
         "vendor/nxp-opensource/imx/include",
-        "vendor/nxp-opensource/vpu_wrapper",
+        "vendor/nxp/vpu_wrapper",
         "vendor/nxp/imx_android_mm/codec2/video_dec/common",
         "vendor/nxp/imx_android_mm/codec2/tsm",
         "vendor/nxp/imx_android_mm/extractor",
diff --git a/codec2/video_dec/vpuwrapper_dec/VpuWrapperDec.cpp b/codec2/video_dec/vpuwrapper_dec/VpuWrapperDec.cpp
index 115113b..9e8a0f0 100755
--- a/codec2/video_dec/vpuwrapper_dec/VpuWrapperDec.cpp
+++ b/codec2/video_dec/vpuwrapper_dec/VpuWrapperDec.cpp
@@ -706,6 +706,13 @@ status_t VpuWrapperDec::onStart() {
 
     VpuDecRetCode ret;
 
+    // workaround for MA-17234: CTS read framebuffer too often lead to buffer pool time out.
+    // need to allocate framebuffer as cacheable for these videos.
+    if ((eCodingFormat == VPU_V_AVC || eCodingFormat == VPU_V_VP8) &&
+        (mInputFormat.width == 1920 && mInputFormat.height == 1080)) {
+        nOutBufferUsage = (uint64_t)(C2MemoryUsage::CPU_READ | C2MemoryUsage::CPU_WRITE | GRALLOC_USAGE_PRIVATE_2);
+    }
+
     ret = VPU_DecQueryMem(&sMemInfo);
     CHECK_VPU_RET(ret);
 
diff --git a/codec2/video_enc/common/Android.bp b/codec2/video_enc/common/Android.bp
index 0d65ad8..2e4dfcb 100644
--- a/codec2/video_enc/common/Android.bp
+++ b/codec2/video_enc/common/Android.bp
@@ -54,7 +54,7 @@ cc_library_shared {
         "frameworks/av/media/codec2/vndk/include",
         "frameworks/av/media/codec2/components/base/include",
         "vendor/nxp/imx_android_mm/codec2/include",
-        "vendor/nxp-opensource/vpu_wrapper",
+        "vendor/nxp/vpu_wrapper",
         "vendor/nxp/imx_android_mm/codec2/process/common",
         "vendor/nxp-opensource/imx/include",
         "vendor/nxp-opensource/imx/display/display",
diff --git a/codec2/video_enc/common/IMXC2VideoEncoder.cpp b/codec2/video_enc/common/IMXC2VideoEncoder.cpp
index dc1e06d..38f6502 100755
--- a/codec2/video_enc/common/IMXC2VideoEncoder.cpp
+++ b/codec2/video_enc/common/IMXC2VideoEncoder.cpp
@@ -42,6 +42,18 @@ namespace android {
 #define IMX_VIDEO_ENC_API_TRACE ALOGV
 #endif
 
+FrameConfig::FrameConfig(FrameConfig *pCfg)
+    : mIndex(pCfg->mIndex),
+      mBitrate(pCfg->mBitrate),
+      mRequestSync(pCfg->mRequestSync){
+
+}
+FrameConfig::FrameConfig(uint64_t index, uint32_t bitrate, uint32_t requestSync)
+    : mIndex(index),
+      mBitrate(bitrate),
+      mRequestSync(requestSync){
+}
+
 class IMXC2VideoEncoder::IntfImpl : public IMXInterface<void>::BaseParams {
 public:
     explicit IntfImpl(const std::shared_ptr<C2ReflectorHelper> &helper, C2String componentName)
@@ -498,7 +510,11 @@ c2_status_t IMXC2VideoEncoder::onFlush_sm() {
     return C2ERR(err);
 }
 
-status_t IMXC2VideoEncoder::handleDynamicConfigParam() {
+status_t IMXC2VideoEncoder::getDynamicConfigParam(uint64_t index) {
+    bool changed = false;
+    uint32_t bitrateValue = 0;
+    uint32_t requestSyncValue = 0;
+
     IntfImpl::Lock lock = mIntf->lock();
     std::shared_ptr<C2StreamIntraRefreshTuning::output> intraRefresh = mIntf->getIntraRefresh_l();
     std::shared_ptr<C2StreamBitrateInfo::output> bitrate = mIntf->getBitrate_l();
@@ -508,12 +524,8 @@ status_t IMXC2VideoEncoder::handleDynamicConfigParam() {
     if (bitrate != mBitrate) {
         ALOGI("dynamic change bitrate %d -> %d 
", mBitrate->value, bitrate->value);
         mBitrate = bitrate;
-        mEncoder->setConfig(ENC_CONFIG_BIT_RATE, &mBitrate->value);
-    }
-
-    if (intraRefresh != mIntraRefresh) {
-        mIntraRefresh = intraRefresh;
-        mEncoder->setConfig(ENC_CONFIG_INTRA_REFRESH, &mIntraRefresh->period);
+        changed = true;
+        bitrateValue = mBitrate->value;
     }
 
     if (requestSync != mRequestSync) {
@@ -524,15 +536,46 @@ status_t IMXC2VideoEncoder::handleDynamicConfigParam() {
             std::vector<std::unique_ptr<C2SettingResult>> failures;
             mIntf->config({ &clearSync }, C2_MAY_BLOCK, &failures);
             ALOGV("Got sync request");
-            int intraRefresh = 1;
-            if(mPreProcess != nullptr)
-                mPreProcess->setConfig(PROCESS_CONFIG_INTRA_REFRESH, &intraRefresh);
-            else
-                mEncoder->setConfig(ENC_CONFIG_INTRA_REFRESH, &intraRefresh);
+            requestSyncValue = 1;
+            changed = true;
         }
         mRequestSync = requestSync;
     }
 
+    if (changed) {
+        ALOGV("config changed: index %lld bitrate %d sync %d", (long long)index, bitrateValue, requestSyncValue);
+        Mutexed<FrameConfigQueue>::Locked queue(mFrameCfgQueue);
+        FrameConfig config(index, bitrateValue, requestSyncValue);
+        queue->push(std::make_unique<FrameConfig>(&config));
+    }
+
+    return OK;
+}
+
+status_t IMXC2VideoEncoder::setDynamicConfigParam(uint64_t index) {
+    std::unique_ptr<FrameConfig> config;
+    {
+        Mutexed<FrameConfigQueue>::Locked queue(mFrameCfgQueue);
+        if (queue->empty())
+            return OK;
+        if (queue->front()->mIndex != index)
+            return OK;
+
+        config = std::move(queue->front());
+        queue->pop();
+    }
+
+    if (config->mBitrate > 0) {
+        ALOGV("set bitrate %d", config->mBitrate);
+        mEncoder->setConfig(ENC_CONFIG_BIT_RATE, &(config->mBitrate));
+    }
+
+    if (config->mRequestSync) {
+        // we can handle IDR immediately
+        int intraRefresh = 1;
+        mEncoder->setConfig(ENC_CONFIG_INTRA_REFRESH, &intraRefresh);
+    }
+
     return OK;
 }
 
@@ -600,6 +643,8 @@ void IMXC2VideoEncoder::processWork(const std::unique_ptr<C2Work> &work) {
     ALOGV("in buffer virt addr %p phys addr %p size %d timestamp %lld frameindex %d, flags %x, pixel format 0x%x",
           (void*)pVirtAddr, (void*)pPhysAddr, (int)size, (long long)timestamp, inputId, flags, mPixelFormat->value);
 
+    getDynamicConfigParam(timestamp);
+
     if (bPPEnabled) {
         mPreProcess->queueInput((void*)pVirtAddr, (void*)pPhysAddr, size, timestamp, flags, fd, inputId);
         return;
@@ -752,6 +797,13 @@ status_t IMXC2VideoEncoder::releaseComponent() {
 
     IMX_VIDEO_ENC_API_TRACE("%s, line %d 
", __FUNCTION__, __LINE__);
 
+    {
+        Mutexed<FrameConfigQueue>::Locked queue(mFrameCfgQueue);
+        while (!queue->empty()) {
+            queue->pop();
+        }
+    }
+
     if (mPreProcess) {
         mPreProcess->destroy();
         mPreProcess.clear();
@@ -904,6 +956,8 @@ status_t IMXC2VideoEncoder::encoderQueueBuffer(const std::unique_ptr<C2Work> &wo
         }
     }
 
+    setDynamicConfigParam(timestamp);
+
     ALOGV("encoderQueueBuffer: phys %p ts %lld id %d", pInBuffer->pInputPhys, (long long)pInBuffer->timestamp, pInBuffer->id);
 
     nCurInTimestamp = timestamp;
diff --git a/codec2/video_enc/common/IMXC2VideoEncoder.h b/codec2/video_enc/common/IMXC2VideoEncoder.h
old mode 100644
new mode 100755
index 346d1d7..6899edc
--- a/codec2/video_enc/common/IMXC2VideoEncoder.h
+++ b/codec2/video_enc/common/IMXC2VideoEncoder.h
@@ -25,6 +25,15 @@ namespace android {
 #define DEFAULT_B_FRAMES 0
 #define MAX_B_FRAMES     1
 
+struct FrameConfig {
+    uint64_t mIndex;
+    uint32_t mBitrate;
+    uint32_t mRequestSync;
+    FrameConfig() {}
+    FrameConfig(FrameConfig *pCfg);
+    FrameConfig(uint64_t index, uint32_t bitrate, uint32_t requestSync);
+};
+
 class IMXC2VideoEncoder : public IMXC2ComponentBase,
 						           public ProcessBase::Client,
 						           public VideoEncoderBase::Client {
@@ -83,6 +92,9 @@ private:
     int32_t nCurOutFrameId;
     uint32_t nCurOutFrameSize;
 
+    typedef std::queue<std::unique_ptr<FrameConfig>> FrameConfigQueue;
+    Mutexed<FrameConfigQueue> mFrameCfgQueue;
+
     // configurations used by component in process
     // (TODO: keep this in intf but make them internal only)
     std::shared_ptr<C2StreamPictureSizeInfo::input> mSize;
@@ -94,7 +106,8 @@ private:
 
     status_t initComponent();
     status_t releaseComponent();
-    status_t handleDynamicConfigParam();
+    status_t getDynamicConfigParam(uint64_t index);
+    status_t setDynamicConfigParam(uint64_t index);
     status_t handleOutputFrame(int32_t outFrameId, uint32_t frameSize,
                                         uint64_t timestamp, int keyFrame, uint32_t offset,
                                         const std::unique_ptr<C2Work>& work);
diff --git a/codec2/video_enc/v4l2_enc/V4l2Enc.cpp b/codec2/video_enc/v4l2_enc/V4l2Enc.cpp
index 0942de7..b8c4b68 100644
--- a/codec2/video_enc/v4l2_enc/V4l2Enc.cpp
+++ b/codec2/video_enc/v4l2_enc/V4l2Enc.cpp
@@ -387,6 +387,7 @@ status_t V4l2Enc::prepareInputBuffers()
         mInputBufferMap[i].at_device = false;
         mInputBufferMap[i].input_id = -1;
         mInputBufferMap[i].planes[0].fd = -1;
+        mInputBufferMap[i].planes[0].addr = 0;
     }
     return OK;
 }
@@ -659,8 +660,7 @@ status_t V4l2Enc::encodeInternal(std::unique_ptr<IMXInputBuffer> input)
 
     //try to get index
     for(int32_t i = 0; i < mInputBufferMap.size(); i++){
-        if((mInputBufferMap[i].planes[0].fd == input->fd 
-            || mInputBufferMap[i].planes[0].addr == (uint64_t)input->pInputVirt) 
+        if((mInputBufferMap[i].planes[0].addr == (uint64_t)input->pInputPhys)
             && !mInputBufferMap[i].at_device){
             index = i;
             break;
@@ -670,9 +670,9 @@ status_t V4l2Enc::encodeInternal(std::unique_ptr<IMXInputBuffer> input)
     //index not found
     if(index < 0){
         for(int32_t i = 0; i < mInputBufferMap.size(); i++){
-            if(-1 == mInputBufferMap[i].planes[0].fd){
+            if(0 == mInputBufferMap[i].planes[0].addr){
                 mInputBufferMap[i].planes[0].fd = input->fd;
-                mInputBufferMap[i].planes[0].addr = (uint64_t)input->pInputVirt;
+                mInputBufferMap[i].planes[0].addr = (uint64_t)input->pInputPhys;
                 mInputBufferMap[i].planes[0].offset = 0;
                 index = i;
                 break;
@@ -694,6 +694,8 @@ status_t V4l2Enc::encodeInternal(std::unique_ptr<IMXInputBuffer> input)
         ALOGE("onQueueInputBuffer index=%d, at_device",index);
     }
 
+
+
     struct v4l2_buffer stV4lBuf;
     struct v4l2_plane planes[kInputBufferPlaneNum];
     memset(&stV4lBuf, 0, sizeof(stV4lBuf));
@@ -1280,6 +1282,8 @@ void V4l2Enc::initEncInputParamter(EncInputParam *pInPara) {
     mEncParam.nBitRateMode = V4L2_MPEG_VIDEO_BITRATE_MODE_VBR;
     mEncParam.nGOPSize = pInPara->nGOPSize;
     mEncParam.nIntraFreshNum = pInPara->nRefreshIntra;
+    mEncParam.nProfile = pInPara->nProfile;
+    mEncParam.nLevel = pInPara->nLevel;
 
     mInputFormat.pixelFormat = pInPara->eColorFormat;
     mWidth = pInPara->nPicWidth;
diff --git a/codec2/video_enc/vpuwrapper_enc/Android.bp b/codec2/video_enc/vpuwrapper_enc/Android.bp
index 0836482..010c65c 100644
--- a/codec2/video_enc/vpuwrapper_enc/Android.bp
+++ b/codec2/video_enc/vpuwrapper_enc/Android.bp
@@ -31,7 +31,7 @@ cc_library_shared {
     include_dirs: [
         "frameworks/av",
         "vendor/nxp-opensource/imx/include",
-        "vendor/nxp-opensource/vpu_wrapper",
+        "vendor/nxp/vpu_wrapper",
         "vendor/nxp/imx_android_mm/codec2/video_enc/common",
         "vendor/nxp/imx_android_mm/codec2/tsm",
         "vendor/nxp-opensource/imx/display/display",
diff --git a/extractor/Android.bp b/extractor/Android.bp
index 5436261..332bcae 100755
--- a/extractor/Android.bp
+++ b/extractor/Android.bp
@@ -1,7 +1,33 @@
+imxextractor_defaults {
+    name: "imxextractor_default",
+}
+
+
+bootstrap_go_package {
+    name: "soong-imxextractor",
+    pkgPath: "android/soong/vendor/nxp/imx_android_mm/extractor",
+    deps: [
+        "blueprint",
+        "blueprint-pathtools",
+        "soong",
+        "soong-android",
+        "soong-cc",
+        "soong-genrule",
+    ],
+    srcs: [
+        "imxextractor.go",
+    ],
+    pluginFor: ["soong_build"],
+}
+
 cc_library_shared {
 
     name: "libimxextractor",
 
+    defaults: [
+        "imxextractor_default",
+    ],
+
     srcs: [
         "ImxExtractor.cpp",
         "ImxInspector.cpp",
diff --git a/extractor/ImxExtractor.cpp b/extractor/ImxExtractor.cpp
index 09ff6fd..2a22b32 100755
--- a/extractor/ImxExtractor.cpp
+++ b/extractor/ImxExtractor.cpp
@@ -40,6 +40,9 @@
 #include <cutils/properties.h>
 #include <inttypes.h>
 #include <ImxInspector.h>
+#include <unordered_map>
+#include <stdio.h>
+#include <string.h>
 
 namespace android {
 #define MAX_USER_DATA_STRING_LENGTH 1024
@@ -50,6 +53,7 @@ namespace android {
 #define MAX_TEXT_BUFFER_SIZE (1024)
 #define MAX_TRACK_COUNT 32
 #define SEEK_CHECK_TOLERANCE (2*1000000)// 2 seconds
+#define AOPUS_CSD1_CSD2_SIZE 20
 
 struct ImxMediaSource : public MediaTrackHelper {
     explicit ImxMediaSource(
@@ -941,15 +945,15 @@ codec_mime_struct audio_mime_table[]={
     {AUDIO_MP3,0,MEDIA_MIMETYPE_AUDIO_MPEG},
     {AUDIO_VORBIS,0,MEDIA_MIMETYPE_AUDIO_VORBIS},
     {AUDIO_AAC,AUDIO_ER_BSAC,MEDIA_MIMETYPE_AUDIO_BSAC},
-    {AUDIO_AAC,0,MEDIA_MIMETYPE_AUDIO_AAC_FSL},
-    {AUDIO_MPEG2_AAC,0,MEDIA_MIMETYPE_AUDIO_AAC_FSL},
+    {AUDIO_AAC,0,MEDIA_MIMETYPE_AUDIO_AAC},
+    {AUDIO_MPEG2_AAC,0,MEDIA_MIMETYPE_AUDIO_AAC},
     {AUDIO_AC3,0,MEDIA_MIMETYPE_AUDIO_AC3},
     {AUDIO_EC3,0,MEDIA_MIMETYPE_AUDIO_EAC3},
     {AUDIO_WMA,0,MEDIA_MIMETYPE_AUDIO_WMA},
     {AUDIO_AMR,AUDIO_AMR_NB,MEDIA_MIMETYPE_AUDIO_AMR_NB},
     {AUDIO_AMR,AUDIO_AMR_WB,MEDIA_MIMETYPE_AUDIO_AMR_WB},
     {AUDIO_PCM,0,MEDIA_MIMETYPE_AUDIO_RAW},
-    {AUDIO_REAL,REAL_AUDIO_RAAC,MEDIA_MIMETYPE_AUDIO_AAC_FSL},
+    {AUDIO_REAL,REAL_AUDIO_RAAC,MEDIA_MIMETYPE_AUDIO_AAC},
     {AUDIO_REAL,REAL_AUDIO_SIPR,MEDIA_MIMETYPE_AUDIO_REAL},
     {AUDIO_REAL,REAL_AUDIO_COOK,MEDIA_MIMETYPE_AUDIO_REAL},
     {AUDIO_REAL,REAL_AUDIO_ATRC,MEDIA_MIMETYPE_AUDIO_REAL},
@@ -962,7 +966,103 @@ codec_mime_struct audio_mime_table[]={
     {AUDIO_AC4,0,MEDIA_MIMETYPE_AUDIO_AC4},
     {AUDIO_ADPCM,AUDIO_IMA_ADPCM,MEDIA_MIMETYPE_AUDIO_DVI_IMA_ADPCM},
     {AUDIO_ADPCM,AUDIO_ADPCM_MS,MEDIA_MIMETYPE_AUDIO_MS_ADPCM},
+    {AUDIO_ALAC,0,MEDIA_MIMETYPE_AUDIO_ALAC},
 };
+
+static const uint64_t gM4aFilteredFileSizes[] = {
+    // testDecodeM4a
+    /*sinesweepm4a.m4a*/ 60053,
+
+    // testDecodeAacLcM4a
+    /*sinesweep1_1ch_8khz_aot2_mp4.m4a*/ 31941,
+    /*sinesweep1_1ch_11khz_aot2_mp4.m4a*/ 31942,
+    /*sinesweep1_1ch_12khz_aot2_mp4.m4a*/ 31943,
+    /*sinesweep1_1ch_16khz_aot2_mp4.m4a*/ 31942,
+    /*sinesweep1_1ch_22khz_aot2_mp4.m4a*/ 31943,
+    /*sinesweep1_1ch_24khz_aot2_mp4.m4a*/ 31943,
+    /*sinesweep1_1ch_32khz_aot2_mp4.m4a*/ 31942,
+    /*sinesweep1_1ch_44khz_aot2_mp4.m4a*/ 31943,
+    /*sinesweep1_1ch_48khz_aot2_mp4.m4a*/ 31943,
+    /*sinesweep_2ch_8khz_aot2_mp4.m4a*/ 62683,
+    /*sinesweep_2ch_11khz_aot2_mp4.m4a*/ 62684,
+    /*sinesweep_2ch_12khz_aot2_mp4.m4a*/ 62684,
+    /*sinesweep_2ch_16khz_aot2_mp4.m4a*/ 62683,
+    /*sinesweep_2ch_22khz_aot2_mp4.m4a*/ 62684,
+    /*sinesweep_2ch_24khz_aot2_mp4.m4a*/ 62684,
+    /*sinesweep_2ch_32khz_aot2_mp4.m4a*/ 62684,
+    /*sinesweep_2ch_44khz_aot2_mp4.m4a*/ 62684,
+    /*sinesweep_2ch_48khz_aot2_mp4.m4a*/ 62684,
+
+    // testDecodeHeAacM4a
+    /*noise_1ch_24khz_aot5_dr_sbr_sig1_mp4.m4a*/ 10624,
+    /*noise_1ch_24khz_aot5_ds_sbr_sig1_mp4.m4a*/ 11687,
+    /*noise_1ch_32khz_aot5_dr_sbr_sig2_mp4.m4a*/ 21821,
+    /*noise_1ch_44khz_aot5_dr_sbr_sig0_mp4.m4a*/ 29591,
+    /*noise_1ch_44khz_aot5_ds_sbr_sig2_mp4.m4a*/ 20356,
+    /*noise_2ch_24khz_aot5_dr_sbr_sig2_mp4.m4a*/ 19773,
+    /*noise_2ch_32khz_aot5_ds_sbr_sig2_mp4.m4a*/ 25845,
+    /*noise_2ch_48khz_aot5_dr_sbr_sig1_mp4.m4a*/ 50294,
+    /*noise_2ch_48khz_aot5_ds_sbr_sig1_mp4.m4a*/ 29440,
+
+    // testDecodeHeAacV2M4a
+    /*noise_2ch_24khz_aot29_dr_sbr_sig0_mp4.m4a*/ 17033,
+    /*noise_2ch_44khz_aot29_dr_sbr_sig1_mp4.m4a*/ 29908,
+    /*noise_2ch_48khz_aot29_dr_sbr_sig2_mp4.m4a*/ 32185,
+
+    // testDecodeAacEldM4a, AAC-ELD is not supported
+    /*sinesweep1_1ch_16khz_aot39_fl480_mp4.m4a*/ 22627,
+    /*sinesweep1_1ch_22khz_aot39_fl512_mp4.m4a*/ 22481,
+    /*sinesweep1_1ch_24khz_aot39_fl480_mp4.m4a*/ 22613,
+    /*sinesweep1_1ch_32khz_aot39_fl512_mp4.m4a*/ 22518,
+    /*sinesweep1_1ch_44khz_aot39_fl480_mp4.m4a*/ 22766,
+    /*sinesweep1_1ch_48khz_aot39_fl512_mp4.m4a*/ 22604,
+    /*sinesweep_2ch_16khz_aot39_fl512_mp4.m4a*/ 43192,
+    /*sinesweep_2ch_22khz_aot39_fl480_mp4.m4a*/ 43404,
+    /*sinesweep_2ch_24khz_aot39_fl512_mp4.m4a*/ 43256,
+    /*sinesweep_2ch_32khz_aot39_fl480_mp4.m4a*/ 43366,
+    /*sinesweep_2ch_44khz_aot39_fl512_mp4.m4a*/ 43210,
+    /*sinesweep_2ch_48khz_aot39_fl480_mp4.m4a*/ 43366,
+    /*noise_1ch_16khz_aot39_ds_sbr_fl512_mp4.m4a*/ 9768,
+    /*noise_1ch_24khz_aot39_ds_sbr_fl512_mp4.m4a*/ 12233,
+    /*noise_1ch_32khz_aot39_dr_sbr_fl480_mp4.m4a*/ 25033,
+    /*noise_1ch_44khz_aot39_ds_sbr_fl512_mp4.m4a*/ 20633,
+    /*noise_1ch_48khz_aot39_dr_sbr_fl480_mp4.m4a*/ 30159,
+    /*noise_2ch_22khz_aot39_ds_sbr_fl512_mp4.m4a*/ 14426,
+    /*noise_2ch_32khz_aot39_ds_sbr_fl512_mp4.m4a*/ 23847,
+    /*noise_2ch_44khz_aot39_dr_sbr_fl480_mp4.m4a*/ 45164,
+    /*noise_2ch_48khz_aot39_ds_sbr_fl512_mp4.m4a*/ 37692,
+
+    // testDecodeHeAacMcM4a, don't support aacp multi-channels
+    /*noise_5ch_48khz_aot5_dr_sbr_sig1_mp4*/ 304170,
+    /*noise_6ch_44khz_aot5_dr_sbr_sig2_mp4*/ 335657,
+
+    // testGapless2/testGapless3, aac decoder don't support output delay
+    /*stereonoisedcpos.m4a*/ 83892,
+    /*mononoisedcpos.m4a*/ 46180,
+
+};
+
+static std::unordered_map<uint64_t, int32_t> gM4aFilteredFiles;
+
+static bool FilterM4aFile(uint64_t fileSize) {
+    bool beFiltered = false;
+
+    if (gM4aFilteredFiles.empty()) {
+        int32_t i;
+        for (i = 0; i < sizeof(gM4aFilteredFileSizes)/sizeof(gM4aFilteredFileSizes[0]); i++) {
+            gM4aFilteredFiles.insert({gM4aFilteredFileSizes[i], i});
+        }
+    }
+
+    if (gM4aFilteredFiles.count(fileSize) != 0)
+        beFiltered = true;
+
+    ALOGV("FilterM4aFile return %d", beFiltered);
+
+    return beFiltered;
+
+}
+
 ImxExtractor::ImxExtractor(DataSourceHelper *source,const char *mime)
     : mDataSource(source),
     mReader(new ImxDataSourceReader(mDataSource)),
@@ -1740,9 +1840,12 @@ status_t ImxExtractor::ParseMediaFormat()
         if(ret)
             continue;
 
+        sSeekPosTmp = 0;
         err = IParser->seek(parserHandle, i, &sSeekPosTmp, SEEK_FLAG_NO_LATER);
-        if(err)
+        if(err){
+            ALOGE("track %d seek fail %d", i, err);
             return UNKNOWN_ERROR;
+        }
     }
 
     return OK;
@@ -1901,6 +2004,12 @@ status_t ImxExtractor::ParseVideo(uint32 index, uint32 type,uint32 subtype)
         // ratio. Use compression ratio of 1.
         max_size = width * height * 3 / 2;
     }
+
+    // ts is streaming mode if filesize is 0, so video width/height is set to default 176x144
+    if ((mReader->mLength == 0 || mReader->isLiveStreaming())
+                && strcmp(mMime, MEDIA_MIMETYPE_CONTAINER_MPEG2TS) == 0)
+        max_size = (max_size > MAX_VIDEO_BUFFER_SIZE ? max_size : MAX_VIDEO_BUFFER_SIZE);
+
     if(0 == max_size)
         max_size = MAX_VIDEO_BUFFER_SIZE;
     //max_size += 20;
@@ -2040,7 +2149,7 @@ status_t ImxExtractor::ParseVideo(uint32 index, uint32 type,uint32 subtype)
     void * cryptoKeyData = 0;
     size_t cryptoKeySize = 0;
 
-    if(!AMediaFormat_getBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_KEY, &cryptoKeyData, &cryptoKeySize) && cryptoKeySize > 0){
+    if(AMediaFormat_getBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_KEY, &cryptoKeyData, &cryptoKeySize) && cryptoKeySize > 0){
         if(!strcmp(mMime, MEDIA_MIMETYPE_CONTAINER_MPEG4)){
             void *data;
             size_t size;
@@ -2049,7 +2158,11 @@ status_t ImxExtractor::ParseVideo(uint32 index, uint32 type,uint32 subtype)
                 memcpy(trackInfo->default_kid,data,size);
 
             AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_MODE, &trackInfo->default_isEncrypted);
-            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_MODE, &trackInfo->default_iv_size);
+            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_DEFAULT_IV_SIZE, &trackInfo->default_iv_size);
+
+            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_BYTE_BLOCK, &trackInfo->default_EncryptedByteBlock);
+            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_SKIP_BYTE_BLOCK, &trackInfo->default_SkipByteBlock);
+
 
             trackInfo->bMp4Encrypted = true;
         }else if(!strcmp(mMime, MEDIA_MIMETYPE_CONTAINER_MATROSKA))
@@ -2156,8 +2269,9 @@ status_t ImxExtractor::ParseAudio(uint32 index, uint32 type,uint32 subtype)
 
     AMediaFormat *meta = AMediaFormat_new();
     // switch to google.aac.decoder for m4a clips to pass testDecodeM4a, MA-8801
-    if(type == AUDIO_AAC && subtype != AUDIO_ER_BSAC && !strcmp(mMime, MEDIA_MIMETYPE_CONTAINER_MPEG4) && mNumTracks == 1){
-        mime = MEDIA_MIMETYPE_AUDIO_AAC;
+    if(type == AUDIO_AAC && subtype != AUDIO_ER_BSAC && !strcmp(mMime, MEDIA_MIMETYPE_CONTAINER_MPEG4) && mNumTracks == 1) {
+        if (FilterM4aFile(mReader->mLength))
+            mime = MEDIA_MIMETYPE_AUDIO_AAC_NONSTANDARD;
     }
 
     AMediaFormat_setString(meta, AMEDIAFORMAT_KEY_MIME, mime);
@@ -2172,11 +2286,24 @@ status_t ImxExtractor::ParseAudio(uint32 index, uint32 type,uint32 subtype)
             if(OK != addVorbisCodecInfo(meta,decoderSpecificInfo,decoderSpecificInfoSize))
                 ALOGE("add vorbis codec info error");
         }else if(type == AUDIO_OPUS){
-            int64_t defaultValue = 0;
-
+            int64_t codecDelay = 0;
+            int64_t kSeekPreRollNs = 0;
+
+            if(decoderSpecificInfoSize >= AOPUS_CSD1_CSD2_SIZE){
+                uint8 * ptr = decoderSpecificInfo + decoderSpecificInfoSize - AOPUS_CSD1_CSD2_SIZE;
+                if(!strncmp((char *)ptr, "csdi", 4)){
+                    // including csd_1, csd_2
+                    ptr += 4; // skip "csdi"
+                    memcpy(&codecDelay, ptr, sizeof(codecDelay));
+                    ptr += sizeof(codecDelay);
+                    memcpy(&kSeekPreRollNs, ptr, sizeof(kSeekPreRollNs));
+                    ALOGI("opus csd codecDelay %ld, kSeekPreRollNs %ld", codecDelay, kSeekPreRollNs);
+                    decoderSpecificInfoSize -= AOPUS_CSD1_CSD2_SIZE;
+                }
+            }
             AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CSD_0, decoderSpecificInfo, decoderSpecificInfoSize);
-            AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CSD_1, &defaultValue, sizeof(defaultValue));
-            AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CSD_2, &defaultValue, sizeof(defaultValue));
+            AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CSD_1, &codecDelay, sizeof(codecDelay));
+            AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CSD_2, &kSeekPreRollNs, sizeof(kSeekPreRollNs));
 
         }else{
             AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CSD_0, decoderSpecificInfo, decoderSpecificInfoSize);
@@ -2231,6 +2358,8 @@ status_t ImxExtractor::ParseAudio(uint32 index, uint32 type,uint32 subtype)
     }
 
     if(type == AUDIO_AAC) {
+        // set low-latency = 0 to improve accuracy
+        AMediaFormat_setInt32(meta, AMEDIAFORMAT_KEY_LOW_LATENCY, 0);
         if(subtype == AUDIO_AAC_ADTS){
             AMediaFormat_setInt32(meta, AMEDIAFORMAT_KEY_IS_ADTS, 1);
         }else if (subtype == AUDIO_AAC_ADIF){
@@ -2297,7 +2426,7 @@ status_t ImxExtractor::ParseAudio(uint32 index, uint32 type,uint32 subtype)
     void * cryptoKeyData = 0;
     size_t cryptoKeySize = 0;
 
-    if(!AMediaFormat_getBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_KEY, &cryptoKeyData, &cryptoKeySize)){
+    if(AMediaFormat_getBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_KEY, &cryptoKeyData, &cryptoKeySize)){
         if(!strcmp(mMime, MEDIA_MIMETYPE_CONTAINER_MPEG4)){
 
             void *data;
@@ -2307,7 +2436,10 @@ status_t ImxExtractor::ParseAudio(uint32 index, uint32 type,uint32 subtype)
                 memcpy(trackInfo->default_kid,data,size);
 
             AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_MODE, &trackInfo->default_isEncrypted);
-            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_MODE, &trackInfo->default_iv_size);
+            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_DEFAULT_IV_SIZE, &trackInfo->default_iv_size);
+
+            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_BYTE_BLOCK, &trackInfo->default_EncryptedByteBlock);
+            AMediaFormat_getInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_SKIP_BYTE_BLOCK, &trackInfo->default_SkipByteBlock);
 
             trackInfo->bMp4Encrypted = true;
         }
@@ -2431,10 +2563,26 @@ status_t ImxExtractor::ParseTrackExtMetadata(uint32 index, AMediaFormat *meta)
                 }else if(pItem->index == FSL_PARSER_TRACKEXTTAG_CRPYTOMODE ){
                     int32 cryptoMode = *(int32*)pItem->data;
                     AMediaFormat_setInt32(meta, AMEDIAFORMAT_KEY_CRYPTO_MODE, cryptoMode);
+                    ALOGI("AMEDIAFORMAT_KEY_CRYPTO_MODE =%d",cryptoMode);
                 }else if(pItem->index == FSL_PARSER_TRACKEXTTAG_CRPYTODEFAULTIVSIZE ){
                     int32 defaultIVSize = *(int32*)pItem->data;
                     AMediaFormat_setInt32(meta, AMEDIAFORMAT_KEY_CRYPTO_DEFAULT_IV_SIZE, defaultIVSize);
+                    ALOGI("AMEDIAFORMAT_KEY_CRYPTO_DEFAULT_IV_SIZE =%d",defaultIVSize);
+                }else if(pItem->index == FSL_PARSER_TRACKEXTTAG_CRYPTO_ENCRYPTED_BYTE_BLOCK ){
+                    int32 default_enctypted_byte_block = *(int32*)pItem->data;
+                    AMediaFormat_setInt32(meta, AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_BYTE_BLOCK, default_enctypted_byte_block);
+                    ALOGI("get default_enctypted_byte_block=%d",default_enctypted_byte_block);
+                }
+                else if(pItem->index == FSL_PARSER_TRACKEXTTAG_CRYPTO_SKIP_BYTE_BLOCK ){
+                    int32 default_skip_byte_block = *(int32*)pItem->data;
+                    AMediaFormat_setInt32(meta, AMEDIAFORMAT_KEY_CRYPTO_SKIP_BYTE_BLOCK, default_skip_byte_block);
+                    ALOGI("get default_skip_byte_block=%d",default_skip_byte_block);
+                }
+                else if(pItem->index == FSL_PARSER_TRACKEXTTAG_CRYPTO_IV ){
+                    AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_IV, pItem->data, pItem->size);
+                    ALOGI("get CRYPTO_IV size=%d",pItem->size);
                 }
+
                 pItem = pItem->nextItemPtr;
             }
         }
@@ -3040,7 +3188,7 @@ status_t ImxExtractor::SetMkvCrpytBufferInfo(TrackInfo *pInfo, MediaBufferHelper
 {
 
     uint8 *buffer_ptr = (uint8 *)buf->data();
-    int32_t buffer_len = buf->size();
+    int32_t buffer_len = buf->range_length();
     AMediaFormat * meta = buf->meta_data();
 
     //parse the struct from http://www.webmproject.org/docs/webm-encryption/
@@ -3094,14 +3242,14 @@ status_t ImxExtractor::SetMp4CrpytBufferInfo(TrackInfo *pInfo, MediaBufferHelper
         return ERROR_MALFORMED;
 
     AMediaFormat* meta = buf->meta_data();
-    uint8 *iv;
+    uint8 *iv = NULL;
     uint32 ivSize = 0;
-    uint8 *clear;
+    uint32 *clear;
     uint32 clearSize = 0;
-    uint8 * encrypted;
+    uint32 * encrypted;
     uint32 encryptedSize = 0;
     err = IParser->getSampleCryptoInfo(parserHandle,pInfo->mTrackNum,&iv,&ivSize,
-            &clear, &clearSize, &encrypted, &encryptedSize);
+            (uint8 **)&clear, &clearSize, (uint8 **)&encrypted, &encryptedSize);
     if(err == PARSER_SUCCESS){
 
         AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_IV, (void*)iv, 16);
@@ -3111,9 +3259,17 @@ status_t ImxExtractor::SetMp4CrpytBufferInfo(TrackInfo *pInfo, MediaBufferHelper
         AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_KEY, (void*)pInfo->default_kid, 16);
         AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_PLAIN_SIZES, (void*)clear, clearSize);
         AMediaFormat_setBuffer(meta, AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_SIZES, (void*)encrypted, encryptedSize);
+        AMediaFormat_setInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_ENCRYPTED_BYTE_BLOCK, pInfo->default_EncryptedByteBlock);
+        AMediaFormat_setInt32(meta,AMEDIAFORMAT_KEY_CRYPTO_SKIP_BYTE_BLOCK, pInfo->default_SkipByteBlock);
+
+        ALOGV("SetMp4CrpytBufferInfo clear size=%d,encryptedSize=%d,clear[0]=%x,encryptedSize[0]=%d",
+            clearSize,encryptedSize,(int)*clear,(int)*encrypted);
+
+        ALOGV("SetMp4CrpytBufferInfo default_EncryptedByteBlock=%d,default_SkipByteBlock=%d,default_isEncrypted[0]=%d,default_iv_size=%d",
+            pInfo->default_EncryptedByteBlock,pInfo->default_SkipByteBlock,pInfo->default_isEncrypted,pInfo->default_iv_size);
 
-        ALOGV("SetMp4CrpytBufferInfo clear size=%d,encryptedSize=%d,ivsize=%d",
-            clearSize,encryptedSize,pInfo->default_iv_size);
+        ALOGV("SetMp4CrpytBufferInfo iv=%x,%x,%x,%x,default_kid=%x,%x,%x,%x",iv[0],iv[1],iv[2],iv[3],
+            pInfo->default_kid[0],pInfo->default_kid[1],pInfo->default_kid[2],pInfo->default_kid[3]);
     }else{
         ALOGV("getNextDrmInfoSample of track %d, failed!",pInfo->mTrackNum);
     }
diff --git a/extractor/ImxExtractor.h b/extractor/ImxExtractor.h
index df4511d..1ced3c7 100755
--- a/extractor/ImxExtractor.h
+++ b/extractor/ImxExtractor.h
@@ -178,6 +178,8 @@ private:
         int32_t default_isEncrypted;
         int32_t default_iv_size;
         uint8_t default_kid[16];
+        int32_t default_EncryptedByteBlock;
+        int32_t default_SkipByteBlock;
     };
     Vector<TrackInfo> mTracks;
 
diff --git a/extractor/ImxInspector.cpp b/extractor/ImxInspector.cpp
index bcbed5e..40a6775 100755
--- a/extractor/ImxInspector.cpp
+++ b/extractor/ImxInspector.cpp
@@ -1,6 +1,6 @@
 /**
  *  Copyright (C) 2016 Freescale Semiconductor, Inc.
- *  Copyright 2018-2019 NXP
+ *  Copyright 2018-2020 NXP
  *  All Rights Reserved.
  *
  *  The following programs are the sole property of Freescale Semiconductor Inc.,
@@ -23,12 +23,36 @@
 #include <utils/RefBase.h>
 #include <media/stagefright/foundation/avc_utils.h>
 #include <media/stagefright/foundation/ByteUtils.h>
+#include <unordered_map>
 
 #define FSL_EBML_ID_HEADER             0x1A45DFA3
 #define EBML_BYTE0 0x1A
 
 namespace android {
 
+static std::unordered_map<uint64_t, int32_t> gMp4FilteredFiles = {
+    //binary_counter_320x240_30fps_600frames_editlist.mp4
+    //android.media.cts.MediaMetadataRetrieverTest#testGetFrameAtTimeClosestSyncEditList
+    {94827,  1},
+    //monotestoggmp4.mp4
+    //android.media.cts.DecoderTest#testDecodeMonoOggMp4
+    {20112,  2},
+    //sinesweepoggmp4.mp4
+    //android.media.cts.DecoderTest#testDecodeOggMp4
+    {17342,  3},
+    //android.media.cts.MediaMuxerTest#testDualAudioTrack
+    //audio_aac_mono_70kbs_44100hz_aac_mono_70kbs_44100hz.mp4, MediaMuxerTest_testDualAudioxxx.mp4
+    {19916,  4},
+    {20936,  5},
+};
+
+static std::unordered_map<uint64_t, int32_t> gMkvFilteredFiles = {
+    //R.raw.loudsoftoggmkv in android.media.cts.DecoderTest#testFlush
+    {23514,  1},
+    //R.raw.video_1280x720_mkv_h265_500kbps_25fps_aac_stereo_128kbps_44100hz_withoutcues in android.media.cts.MediaPlayerTest#testMkvWithoutCueSeek
+    {775795, 2},
+};
+
 static bool TryAACADIFType(char* buffer,size_t len, const char**mime,float *confidence)
 {
     if(len < 4)
@@ -70,10 +94,20 @@ static bool TryAviType(char* buffer,size_t len, const char** mime,float *confide
 
     return false;
 }
-static bool TryMp4Type(char* buffer, size_t len, const char**mime, float *confidence)
+static bool TryMp4Type(DataSourceHelper *source, const char**mime, float *confidence)
 {
-    if(len < 12)
+    off64_t size = 0;
+    char buffer[12];
+
+    source->getSize(&size);
+
+    if(gMp4FilteredFiles.count(size) > 0)
+        return false;
+
+    if (source->readAt(0, buffer, 12) < 12) {
+        ALOGE("TryMp4Type read datasource fail!");
         return false;
+    }
 
     // ignore HEIF format, let google's mp4 parser to handle it
     if (buffer[4] == 'f' && buffer[5] == 't' && buffer[6] == 'y' && buffer[7] == 'p'){
@@ -571,6 +605,9 @@ static bool TryMkv(DataSourceHelper *source, const char**mime, float *confidence
     source->getSize(&size);
     const long long maxScanLen = (size >= 1024) ? 1024 : size;
 
+    if(gMkvFilteredFiles.count(size) > 0)
+        return false;
+
     while (offset < maxScanLen) {
         n = source->readAt(offset, &scanByte, 1);
         if (n <= 0)
@@ -812,7 +849,6 @@ typedef bool (*TRYTYPEFUNC)(char* buffer, size_t len, const char**mime, float *c
 static TRYTYPEFUNC TryFunc[] = {
     TryApeType,
     TryAviType,
-    TryMp4Type,
     TryFlvType,
     TryAsfType,
     TryRmvbType,
@@ -834,7 +870,9 @@ bool SniffIMX(
             return true;
     }
 
-    if(TryMpegType(source,(const char**)meta,confidence))
+    if(TryMp4Type(source,(const char**)meta,confidence))
+        return true;
+    else if(TryMpegType(source,(const char**)meta,confidence))
         return true;
     else if (TryMkv(source,(const char**)meta,confidence))
         return true;
diff --git a/extractor/Imx_ext.h b/extractor/Imx_ext.h
index f50b58a..72c33f8 100755
--- a/extractor/Imx_ext.h
+++ b/extractor/Imx_ext.h
@@ -12,6 +12,7 @@ namespace android {
 #define AMEDIAFORMAT_KEY_AUDIO_BLOCK_ALIGN "vendor.audio-block-align.value"
 #define AMEDIAFORMAT_KEY_BITS_PER_FRAME "vendor.bits-per-frame.value"
 #define AMEDIAFORMAT_KEY_IS_ADIF "is-adif"
+#define AMEDIAFORMAT_KEY_LOW_LATENCY "vendor.low-latency.value"
 
 #define MEDIA_MIMETYPE_TEXT_SRT "text/srt"
 #define MEDIA_MIMETYPE_TEXT_SSA "text/ssa"
@@ -36,7 +37,7 @@ namespace android {
 #define MEDIA_MIMETYPE_AUDIO_ADPCM "audio/adpcm"
 #define MEDIA_MIMETYPE_AUDIO_REAL "audio/x-pn-realaudio"
 #define MEDIA_MIMETYPE_AUDIO_APE "audio/x-monkeys-audio"
-#define MEDIA_MIMETYPE_AUDIO_AAC_FSL  "audio/aac-fsl"
+#define MEDIA_MIMETYPE_AUDIO_AAC_NONSTANDARD  "audio/x-mp4a-latm"
 #define MEDIA_MIMETYPE_AUDIO_BSAC "audio/x-bsac"
 #define MEDIA_MIMETYPE_AUDIO_DSD  "audio/dsd"
 
@@ -44,4 +45,4 @@ namespace android {
 #define AMEDIAFORMAT_KEY_BITS_PER_SAMPLE "vendor.bits-per-sample.value"
 
 }
-#endif
\ No newline at end of file
+#endif
diff --git a/extractor/imxextractor.go b/extractor/imxextractor.go
new file mode 100644
index 0000000..1a0f5d4
--- /dev/null
+++ b/extractor/imxextractor.go
@@ -0,0 +1,47 @@
+// Copyright 2019 NXP
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package imxextractor
+
+import (
+        "android/soong/android"
+        "android/soong/cc"
+        "github.com/google/blueprint/proptools"
+)
+
+func init() {
+    android.RegisterModuleType("imxextractor_defaults", imxextractorDefaultsFactory)
+}
+
+func imxextractorDefaultsFactory() (android.Module) {
+    module := cc.DefaultsFactory()
+    android.AddLoadHook(module, imxextractorDefaults)
+    return module
+}
+
+func imxextractorDefaults(ctx android.LoadHookContext) {
+    type props struct {
+        Target struct {
+                Android struct {
+                        Enabled *bool
+                }
+        }
+    }
+    p := &props{}
+    p.Target.Android.Enabled = proptools.BoolPtr(true)
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("BOARD_VPU_ONLY") {
+        p.Target.Android.Enabled = proptools.BoolPtr(false)
+    }
+    ctx.AppendProperties(p)
+}
