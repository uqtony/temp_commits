46e4e5fe8 max.yang 2020-05-05

AOS-165: [Post Sign] Create script to help for vbmeta's post signing

  1. python post_sign_vbmeta.py extract_sign_data --image IMAGE
     This script input vbmeta and output:
       - vbmeta.img-partial, which replaced the public key certificate
         and hash value for production purpose
       - vbmeta.img-to_sign, which need to send to CA server to sign, then
         get signature back

  2. python post_sign_vbmeta.py combine_sign_data --image IMAGE --sig SIGNATURE
     This script inputs above vbmata.img-partial image and signature (256 Bytes)
     from CA server, and then combine signature file into vbmata.img-partial
     the output is official vbmeta image

Change-Id: If5ccece0b34f88ac3b7a95dc3157c221fcb2a000

diff --git a/tools/releasetools/post_sign_vbmeta.py b/tools/releasetools/post_sign_vbmeta.py
new file mode 100644
index 000000000..911805383
--- /dev/null
+++ b/tools/releasetools/post_sign_vbmeta.py
@@ -0,0 +1,195 @@
+#!/usr/bin/env python
+
+"""
+Input a vbmeta image and a signature file (suppose to be 256 Bytes) which
+signed by RSA-2048 official key, this script should write public key
+certificate and signature into proper locations, the output vbmeta image
+should be official production image which can pass official key validation.
+
+Usage:
+  python post_sign_vbmeta.py extract_sign_data --image IMAGE
+  python post_sign_vbmeta.py combine_sign_data --image IMAGE --sig SIGNATURE
+
+"""
+
+import os
+import sys
+import subprocess
+import struct
+import argparse
+import shutil
+import hashlib
+
+# TODO: this official should be replaced by real official key after we get it
+official_key= [
+  0x00,0x00,0x08,0x00,0x02,0x1f,0x6f,0x49,0xd2,0x75,0xf0,0xa5,
+  0x96,0x99,0x63,0xde,0x0b,0x5c,0x53,0xe7,0xdd,0x6a,0x41,0x1a,
+  0x4b,0xb3,0xa6,0xab,0xcd,0xab,0xad,0x0d,0x8a,0x23,0x35,0xcd,
+  0xc1,0x45,0xe3,0x32,0xe1,0x06,0x0c,0xe3,0xaf,0xe2,0xa2,0x4d,
+  0xf4,0xe9,0xe2,0x34,0x16,0x20,0xa1,0xa4,0xad,0x82,0xb1,0x98,
+  0x5c,0xd4,0x62,0xfc,0xae,0x2b,0x1f,0x7c,0x6b,0xfa,0x0b,0x49,
+  0xda,0x58,0x98,0x5a,0x66,0x8a,0x3b,0x99,0x8d,0xe6,0x91,0xa4,
+  0x39,0x34,0xf6,0x7a,0xbf,0xa9,0x23,0x4b,0x47,0x77,0x88,0x84,
+  0x2d,0xca,0xfc,0x8a,0x40,0xb3,0xcd,0x30,0xe3,0x44,0xf3,0x8a,
+  0x36,0xc0,0xb9,0x4c,0xb9,0x8b,0xc0,0xbe,0xdd,0xf0,0x79,0x09,
+  0x43,0xe2,0xa9,0x4e,0xcd,0x2d,0xc9,0xd8,0x58,0x38,0xc8,0xdd,
+  0xf5,0x0a,0x65,0x6e,0x52,0x1f,0x21,0x22,0x7e,0xed,0x2e,0x0c,
+  0x53,0x2f,0x35,0x7e,0xf4,0xdf,0x9b,0xc7,0x11,0xa4,0xad,0x70,
+  0x3b,0xda,0xdc,0x9a,0xa7,0xd0,0xdd,0x80,0x88,0x77,0x13,0x6f,
+  0x00,0x8f,0xdf,0x80,0x9f,0xe2,0x23,0x3d,0x5b,0x47,0x70,0x59,
+  0x4f,0xff,0x6a,0xd4,0x75,0xd1,0x83,0x37,0x4c,0x73,0xa3,0x91,
+  0x3d,0x0d,0xa5,0xd5,0x36,0xd3,0x1f,0xb0,0x7f,0x86,0xf7,0xaf,
+  0x92,0x06,0x86,0xe1,0x2a,0x42,0xf2,0xfe,0x8e,0xa6,0x0c,0xef,
+  0x92,0x51,0xe1,0x26,0x8b,0xb2,0x57,0x1f,0x54,0x85,0x29,0xfa,
+  0xf5,0x04,0xc6,0xfe,0xfa,0xbf,0x31,0xda,0xec,0xd7,0xef,0x50,
+  0x21,0xc3,0x59,0x8c,0xd0,0xb8,0x4a,0x05,0x9b,0x1e,0xcf,0xbf,
+  0xae,0xf9,0x80,0x9c,0x3d,0x3a,0xa8,0x69,0x28,0x53,0x4d,0x07,
+  0x08,0x8d,0x3d,0xfa,0x16,0xc3,0xc2,0x75,0x63,0x90,0x0b,0x47,
+  0xbe,0x3f,0x88,0xa3,0xc2,0x25,0xd5,0xa5,0x37,0x60,0xd9,0xa3,
+  0x66,0xf8,0xb4,0x4b,0x30,0x69,0x38,0x4a,0x8a,0x45,0xb4,0xfb,
+  0x84,0x46,0xf2,0x15,0xcf,0x41,0xa8,0x6d,0xdf,0x30,0x9d,0xe1,
+  0x86,0x4b,0x4b,0x1a,0x50,0x6f,0x08,0x65,0x10,0xfb,0xbd,0x90,
+  0x85,0xf7,0x2a,0xba,0x19,0x99,0x4d,0xf3,0x9a,0x67,0x11,0x3d,
+  0xce,0x98,0x54,0x24,0xdd,0x0f,0xb4,0x59,0x88,0x38,0x8b,0x15,
+  0x16,0xf6,0x4f,0x56,0xe3,0xab,0x5d,0x69,0x6b,0xeb,0x03,0x99,
+  0xbb,0xae,0x7a,0xda,0xc5,0x50,0xfd,0x31,0x98,0x7d,0x93,0x60,
+  0xf5,0xaf,0x1e,0x0b,0x4b,0x19,0x60,0x61,0xaa,0xc5,0xc7,0x2d,
+  0x16,0x98,0xe5,0xe5,0x45,0x29,0x53,0xad,0xb3,0x00,0xcd,0x17,
+  0xbf,0xa5,0x50,0x7b,0x89,0x13,0x1f,0x0b,0xb5,0xa2,0xf2,0xf0,
+  0x0a,0x95,0x4b,0x7a,0x04,0x82,0x59,0x2e,0x7a,0xfe,0x51,0xc3,
+  0x72,0xc5,0xcb,0x78,0xd0,0xe4,0x1f,0x76,0x66,0xb2,0x80,0x8b,
+  0x33,0x4d,0x9d,0xe6,0x51,0xc2,0x41,0xff,0x49,0xea,0xda,0x78,
+  0xa9,0x05,0xc5,0x8d,0xf0,0x8b,0xea,0x86,0x06,0x96,0x8d,0x95,
+  0x68,0x3f,0x9a,0x9f,0x93,0x08,0x7c,0x47,0xff,0x03,0xd5,0x4c,
+  0x28,0xd5,0xca,0x8f,0xf9,0x92,0x06,0x1c,0xfb,0xbb,0xd2,0xfd,
+  0x8b,0xb2,0x28,0x09,0xcd,0x6c,0xfa,0x2c,0xa8,0xc9,0x0e,0xe7,
+  0x22,0x31,0xa9,0x50,0xd4,0xb7,0x55,0xf1,0x21,0xca,0x95,0x40,
+  0xfc,0xd1,0x87,0xae,0xf6,0x4f,0xe9,0xc3,0xa5,0xc7,0x3d,0xf5,
+  0xb4,0x48,0xcf,0x69]
+
+class AvbVBMetaHeader(object):
+  """A class for parsing and writing AVB vbmeta images.
+
+  Attributes:
+    The attributes correspond to the |AvbVBMetaImageHeader| struct defined in
+    avb_vbmeta_image.h.
+  """
+
+  SIZE = 256
+
+  # Keep in sync with |reserved0| and |reserved| field of
+  # |AvbVBMetaImageHeader|.
+  RESERVED0 = 4
+  RESERVED = 80
+
+  # Keep in sync with |AvbVBMetaImageHeader|.
+  FORMAT_STRING = ('!4s2L'  # magic, 2 x version
+                   '2Q'  # 2 x block size
+                   'L'  # algorithm type
+                   '2Q'  # offset, size (hash)
+                   '2Q'  # offset, size (signature)
+                   '2Q'  # offset, size (public key)
+                   '2Q'  # offset, size (public key metadata)
+                   '2Q'  # offset, size (descriptors)
+                   'Q'  # rollback_index
+                   'L' +  # flags
+                   str(RESERVED0) + 'x' +  # padding for reserved bytes
+                   '47sx' +  # NUL-terminated release string
+                   str(RESERVED) + 'x')  # padding for reserved bytes
+
+  def __init__(self, data=None):
+    assert struct.calcsize(self.FORMAT_STRING) == self.SIZE
+    (self.magic, self.required_libavb_version_major,
+     self.required_libavb_version_minor,
+     self.authentication_data_block_size, self.auxiliary_data_block_size,
+     self.algorithm_type, self.hash_offset, self.hash_size,
+     self.signature_offset, self.signature_size, self.public_key_offset,
+     self.public_key_size, self.public_key_metadata_offset,
+     self.public_key_metadata_size, self.descriptors_offset,
+     self.descriptors_size,
+     self.rollback_index,
+     self.flags,
+     self.release_string) = struct.unpack(self.FORMAT_STRING, data)
+
+    if self.magic != 'AVB0':
+      raise ValueError('Given image does not look like a vbmeta image.')
+
+def print_avb_header(hdr):
+  print('AvbVBMetaHeader size: {}'.format(AvbVBMetaHeader.SIZE))
+  print('authentication_data_block_size: {}'.format(hdr.authentication_data_block_size))
+  print('auxiliary_data_block_size: {}'.format(hdr.auxiliary_data_block_size))
+  print('hash_offset: {}, hash_size: {}'.format(hdr.hash_offset, hdr.hash_size))
+  print('signature_offset: {}, signature_size: {}'.format(hdr.signature_offset, hdr.signature_size))
+  print('public_key_offset: {}, public_key_size: {}'.format(hdr.public_key_offset, hdr.public_key_size))
+  print('public_key_metadata_offset: {}, public_key_metadata_size: {}'.format(hdr.public_key_metadata_offset, hdr.public_key_metadata_size))
+
+def extract_sign_data(args):
+  vbmeta_img_path    = os.path.abspath(args.image)
+  vbmeta_img_partial = vbmeta_img_path + "-partial"
+  vbmeta_to_sign     = vbmeta_img_path + "-to_sign"
+
+  shutil.copyfile(vbmeta_img_path, vbmeta_img_partial)
+  if os.path.isfile(vbmeta_to_sign):
+    os.remove(vbmeta_to_sign)
+
+  with open(vbmeta_img_partial, "rb+") as f_part, open(vbmeta_to_sign, "wb+") as f_to_sign:
+    hdr = AvbVBMetaHeader(f_part.read(AvbVBMetaHeader.SIZE))
+    #print_avb_header(hdr)
+
+    # write public cert into target image
+    f_part.seek(AvbVBMetaHeader.SIZE + hdr.authentication_data_block_size + hdr.public_key_offset, 0)
+    print('Wrting public_key into {} at offset {}'.format(vbmeta_img_partial, AvbVBMetaHeader.SIZE + hdr.authentication_data_block_size + hdr.public_key_offset))
+    f_part.write(bytearray(official_key))
+
+    # output header + auxiliary block as signing data
+    f_part.seek(0, 0)
+    f_to_sign.write(f_part.read(AvbVBMetaHeader.SIZE))
+    f_part.seek(AvbVBMetaHeader.SIZE + hdr.authentication_data_block_size, 0)
+    f_to_sign.write(f_part.read(hdr.auxiliary_data_block_size))
+
+    # Write hash into hash_offset
+    f_to_sign.seek(0, 0)
+    ha = hashlib.sha256()
+    ha.update(f_to_sign.read())
+    f_part.seek(AvbVBMetaHeader.SIZE + hdr.hash_offset, 0)
+    print('Wrting hash into {} at offset {}'.format(vbmeta_img_partial, AvbVBMetaHeader.SIZE + hdr.hash_offset))
+    f_part.write(bytearray(ha.digest()))
+
+    print('Writing Done')
+
+def combine_sign_data(args):
+  vbmeta_img_path   = os.path.abspath(args.image)
+  sig_bin_path      = os.path.abspath(args.sig)
+
+  # make sure RSA-2048 signature is 256 Bytes
+  assert os.stat(sig_bin_path).st_size == 256
+
+  # Parse/Validate vbmeta image and get header/authenticate/auxiliary block offsets
+  with open(vbmeta_img_path, "rb+") as f_img, open(sig_bin_path, "rb") as f_sig:
+    hdr = AvbVBMetaHeader(f_img.read(AvbVBMetaHeader.SIZE))
+    #print_avb_header(hdr)
+
+    # Replace the signature inside vbmeta image
+    f_img.seek(AvbVBMetaHeader.SIZE + hdr.signature_offset, 0)
+    print('Wrting {} into {} at offset {}'.format(sig_bin_path, vbmeta_img_path, AvbVBMetaHeader.SIZE + hdr.signature_offset))
+    f_img.write(f_sig.read())
+
+    print('Writing Done')
+
+def main(argv):
+  parser = argparse.ArgumentParser()
+  subparsers = parser.add_subparsers(title='subcommands')
+  sub_parser = subparsers.add_parser('extract_sign_data', help='Replace official public cert and output data need to be signed by CA')
+  sub_parser.add_argument('--image', help='Inputed vbmeta image', required=True)
+  sub_parser.set_defaults(func=extract_sign_data)
+
+  sub_parser = subparsers.add_parser('combine_sign_data', help='Restore signature into vbmeta image')
+  sub_parser.add_argument('--image', help='Inputed vbmeta image', required=True)
+  sub_parser.add_argument('--sig', help='Inputed signature get from CA Server', required=True)
+  sub_parser.set_defaults(func=combine_sign_data)
+
+  args = parser.parse_args(argv)
+  args.func(args)
+
+if __name__ == '__main__':
+  main(sys.argv[1:])
