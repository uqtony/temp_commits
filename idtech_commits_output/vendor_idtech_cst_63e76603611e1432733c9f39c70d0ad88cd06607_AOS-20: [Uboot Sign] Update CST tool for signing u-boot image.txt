63e7660 max.yang 2019-11-14

AOS-20: [Uboot Sign] Update CST tool for signing u-boot image

Download from link: https://www.nxp.com/webapp/sps/download/license.jsp?colCode=IMX_CST_TOOL
Verison: cst-3.1.0

Change-Id: Ib51a87f742012bf2dca6bc4c4083b0d43c716d69

diff --git a/release/LICENSE.nxp b/release/LICENSE.nxp
new file mode 100644
index 0000000..15b22f0
--- /dev/null
+++ b/release/LICENSE.nxp
@@ -0,0 +1,401 @@
+LA_OPT36 v2 August 2018
+ 
+ 
+SOFTWARE LICENSE AGREEMENT
+i.MX CODE SIGNING TOOL
+ 
+IMPORTANT.  Read the following NXP Software License Agreement
+(‚ÄúAgreement‚Äù) completely. By selecting the ‚ÄúI Accept‚Äù button at the end of this
+page, or by downloading, installing, or using the Licensed Software, you
+indicate that you accept the terms of the Agreement and you acknowledge that
+you have the authority, for yourself or on behalf of your company, to bind your
+company to these terms. You may then download or install the file. In the event
+of a conflict between the terms of this Agreement and any license terms and
+conditions for NXP‚Äôs proprietary software embedded anywhere in the Licensed
+Software file, the terms of this Agreement shall control.  If a separate
+license agreement for the Licensed Software has been signed by you and NXP, then
+that agreement shall govern your use of the Licensed Software and shall
+supersede this Agreement.
+
+This is a legal agreement between your employer, of which you are an authorized
+representative, or, if you have no employer, you as an individual (‚Äúyou‚Äù or
+‚ÄúLicensee‚Äù), and NXP B.V. (‚ÄúNXP‚Äù).  It concerns your rights to use the software
+provided to you in binary or source code form and any accompanying written
+materials (the ‚ÄúLicensed Software‚Äù). The Licensed Software may include any
+updates or error corrections or documentation relating to the Licensed Software
+provided to you by NXP under this Agreement. In consideration for NXP allowing
+you to access the Licensed Software, you are agreeing to be bound by the terms
+of this Agreement. If you do not agree to all of the terms of this Agreement, do
+not download or install the Licensed Software. If you change your mind later,
+stop using the Licensed Software and delete all copies of the Licensed Software
+in your possession or control. Any copies of the Licensed Software that you have
+already distributed, where permitted, and do not destroy will continue to be
+governed by this Agreement. Your prior use will also continue to be governed by
+this Agreement.
+ 
+Section 1.                Definitions
+
+1.1               ‚ÄúAffiliate‚Äù means, with respect to a party, any corporation or
+other legal entity that, at any time, directly or indirectly, Controls, is
+Controlled by, or is under common Control with such party (but only as long as
+such Control exists).  For the purpose of this definition, the term ‚ÄúControl‚Äù
+means (i) the beneficial ownership (whether direct or indirect) of more than
+fifty percent (50%) of the voting power of an entity or (ii) in the case of an
+entity that does not have outstanding voting shares or securities, the majority
+(i.e., more than fifty percent (50%)) of the equity interests in such entity is
+now or hereafter owned or controlled by another entity, either directly or indirectly.
+
+1.2              ‚ÄúAuthorized Employees‚Äù means your employees or contractors
+working at your premises on your behalf under a work for hire agreement
+
+1.3              "Authorized System" means the hardware system(s) or software
+program(s) marketed by you which contains an i.MX processor and for which the
+Licensed Software will be adapted by Licensor pursuant to this Agreement and
+with which the Licensed Software will be integrated.
+
+1.4              ‚ÄúEssential Patent‚Äù means a patent to the limited extent that
+infringement of such patent cannot be avoided in remaining compliant with the
+technology standards implicated by the usage of any of the Licensed Software,
+including optional implementation of such standards, on technical but not
+commercial grounds, taking into account normal technical practice and the state
+of the art generally available at the time of standardization.
+
+1.5              ‚ÄúIntellectual Property Rights‚Äù means any and all rights under
+statute, common law or equity in and under copyrights, trade secrets, and
+patents (including utility models), and analogous rights throughout the world,
+including any applications for and the right to apply for, any of the foregoing.
+
+1.6              "Licensed Software" means Licensor‚Äôs Code Signing Tools software
+and the associated documentation, and all updates thereto.
+
+1.7              ‚ÄúPurpose‚Äù means to enable Licensee to sign code for
+installation on a Licensor i.MX product.
+
+Section 2.                Licenses
+
+2.1              Open source software included in the Licensed Software is not licensed
+under the terms of this Agreement but is instead licensed under the terms of
+the applicable open source license(s), such as the BSD License, Apache License or
+the GNU Lesser General Public License. Your use of the open source software is
+subject to the terms of each applicable license. You must agree to the terms 
+of each applicable license, or you cannot use the open source software.
+
+2.2              For Licensed Software, Licensor grants you a world-wide,
+personal, non-transferable, non-exclusive, license, under Licensor‚Äôs Intellectual
+Property Rights solely in connection with the Purpose:
+
+(a)                to use, only as part of, or integrated within, Authorized
+Systems and not on a stand alone basis, the Licensed Software;
+
+(b)               to reproduce, only as part of, or integrated within,
+Authorized Systems and not on a stand alone basis, the Licensed Software;
+
+(c)                to distribute the Licensed Software in object code (machine
+readable) only as part of, or embedded within, Authorized Systems in object
+code form and not on a stand alone basis.  Notwithstanding the foregoing, those
+files marked as .h files (‚ÄúHeader files‚Äù) may be distributed in source or
+object code form, but only as part of, or embedded within Authorized Systems.
+
+(d)               to copy, use and distribute as needed, solely in connection
+with an Authorized System, the proprietary information for the purpose of
+developing, maintaining and supporting Authorized Systems with which the
+Licensed Software is integrated.
+
+2.3              You may use subcontractors on your premises to exercise your
+rights under Section 2.2 so long as you have an agreement in place with the
+subcontractor containing confidentiality restrictions no less stringent than
+those contained in this Agreement.  You will remain liable for your
+subcontractors‚Äô adherence to the terms of this Agreement and for any and all
+acts and omissions of such subcontractors with respect to this Agreement and
+the Licensed Software.
+
+2.4              You are solely responsible for obtaining any necessary third
+party approvals and any licenses for any necessary Essential Patents for their
+use in connection with technology that you incorporate into the your Authorized
+System (whether as part of the Licensed Software or not).
+
+2.5              The Licensed Software is licensed to you, not sold.  Title to
+Licensed Software delivered hereunder remains vested in Licensor or Licensor's licensor and
+cannot be assigned or transferred.  You are expressly forbidden from selling or
+otherwise distributing the Licensed Software, or any portion thereof, except as
+expressly permitted herein.  This Agreement does not grant to you any implied
+rights under any Licensor or third party intellectual property.
+
+2.6              You may not translate, reverse engineer, decompile, or
+disassemble the Licensed Software except to the extent applicable law
+specifically prohibits such restriction.  You must prohibit your sub-licensees
+from translating, reverse engineering, decompiling, or disassembling the
+Licensed Software except to the extent applicable law specifically prohibits
+such restriction.
+
+2.7              You must reproduce any and all of Licensor's (or its third party
+licensor‚Äôs) copyright notices and other proprietary legends on copies of
+Licensed Software.
+
+2.8              If you distribute the Licensed Software to the United States
+Government, then the Licensed Software is ‚Äúrestricted computer software‚Äù and is
+subject to FAR 52.227-19 (c)(1) and (c)(2).
+
+2.9              You grant to Licensor a non-exclusive, non-transferable,
+irrevocable, perpetual, worldwide, royalty-free, sub-licensable license under
+your Intellectual Property Rights to use without restriction and for any
+purpose any suggestion, comment or other feedback related to the Licensed
+Software (including, but not limited to, error corrections and bug fixes).
+
+2.10          The license granted in Section 2.2 does not include any license,
+right, power or authority to cause the Licensed Software, in whole or in part,
+to be subject to Open Source Licensing Terms.  You will not take or fail to take
+any action that could subject the Licensed Software to Open Source Licensing
+Terms. As used herein, ‚ÄúOpen Source Licensing Terms‚Äù means terms in any license
+for software which require, as a condition of use, modification and/or
+distribution of such software or other software incorporated into, derived from
+or distributed with such software (a ‚ÄúWork‚Äù), any of the following:  (a) the
+making available of source code or design information regarding the Work; (b)
+the granting of permission for creating derivative works regarding the Work; or
+(c) the granting of a license to any party under intellectual property rights
+regarding the Work.  By means of example and without limitation, Open Source
+Licensing Terms include the following licenses or distribution models: (i) the
+GNU General Public License (GPL) or Lesser/Library GPL (LGPL), (ii) the Artistic
+License (e.g. PERL), (iii) the Mozilla Public License, (iv) the Common Public
+License, (v) the Sun Community Source License (SCSL), (vi) the Sun Industry
+Standards Source License (SISSL), and (vii) the Open Software License.
+
+Section 3.                Intellectual Property Rights
+
+3.1              Your modifications to the Licensed Software, and all
+intellectual property rights associated with, and title thereto, will be the
+property of Licensor.  You agree to assign all, and hereby do assign all rights,
+title, and interest to any such modifications to the Licensed Software to Licensor
+and agree to provide all assistance reasonably requested by Licensor to establish,
+preserve or enforce such right.  Further, you agree to waive all moral rights
+relating to your modifications to the Licensed Software, including, without
+limitation, any and all rights of identification of authorship and any and all
+rights of approval, restriction, or limitation on use or subsequent
+modification.  Notwithstanding the foregoing, you will have the license rights
+granted in Section 2 hereto to any such modifications made by you or your
+licensor‚Äôs.
+
+Section 4.                Patent Covenant not to Sue
+
+4.1              As partial, material consideration for the rights granted to
+you under this Agreement, you covenant not to sue or otherwise assert your
+Patents against Licensor, a Licensor Affiliate or subsidiary, or a Licensor licensee of the
+Licensed Software for infringement of your Intellectual Property Rights by the
+manufacture, use, sale, offer for sale, importation or other disposition or
+promotion of the Licensed Software and/or any redistributed portions thereof.
+
+Section 5.                Term and Termination
+
+5.1              This Agreement will remain in effect unless terminated as
+provided herein.
+
+5.2              You may terminate this Agreement immediately upon written
+notice to Licensor at the address provided below.
+
+5.3              Either party may terminate this Agreement if the other party
+is in default of any of the terms and conditions of this Agreement, and
+termination is effective if the defaulting party fails to correct such default
+within 30 days after written notice thereof by the non-defaulting party to the
+defaulting party at the address below.
+
+5.4              Notwithstanding the foregoing, Licensor may terminate this
+Agreement immediately upon written notice if you:
+
+(a)                breach any of your confidentiality obligations or the
+license restrictions under this Agreement;
+
+(b)               become bankrupt or insolvent, or file a petition therefore;
+
+(c)                make an assignment for the benefit of its creditors;
+
+(d)               enter proceedings for winding up or dissolution;
+
+(e)                are dissolved; or
+
+(f)                are nationalized or is subject to the expropriation of all
+or substantially all of its business or assets.
+
+5.5              Upon termination of this Agreement, all licenses granted under
+Section 2 will expire, except that any licenses extended to end-users pursuant
+to Sections 2.2 (c) and 2.2 (d) which have been granted prior to such
+termination will survive.
+
+5.6              After termination of this Agreement by either party and upon
+Licensor‚Äôs written request, you will, at your discretion, return to the Licensor any
+confidential information including any and all copies thereof or furnish to Licensor
+at the address below, a statement certifying, with respect to the Licensed
+Software delivered hereunder that the original and all copies, except for
+archival copies to be used solely for dispute resolution purposes, in whole or
+in part, in any form, of the Licensed Software have been destroyed.
+
+5.7              Notwithstanding the termination of this Agreement for any
+reason, the terms of Sections 1, 2.4 ‚Äì 2.10, 3, 4, 5.6, 5.7, 7 and 8 will
+survive.
+
+Section 6.                Warranty
+
+6.1              Licensor warrants that for the 30 day period following your
+download of the Licensed Software that the Licensed Software as delivered is
+free of material defects in materials and workmanship.
+
+6.2              If Licensed Software is not as warranted, Licensor will, at its
+sole option, and as your exclusive remedy, either refund the fees associated
+with such Licensed Software, repair, or replace with the same or equivalent
+products that meet this warranty.  This warranty does not apply to Licensed
+Software that has been subjected to improper testing, assembly, mishandling,
+modification, or misuse, whether by you or by others.  This warranty will not
+be expanded, and no obligation or liability will arise, due to technical advice
+or assistance, qualification or testing data, computerized data, facilities or
+service Licensor may provide in connection with the Licensed Software.
+
+6.3              Licensor does not warrant that the functions contained in the
+Licensed Software will meet your requirements or that the operation of the
+Licensed Software will be uninterrupted or error free.
+
+6.4              The warranty recited in this Section 6 extends only to you.
+
+6.5              THIS WARRANTY RECITED IN THIS SECTION 6 IS IN LIEU OF ALL
+OTHER WARRANTIES, INCLUDING IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
+QUALITY OR FITNESS, AND THE WARRANTY AGAINST INFRINGEMENT SPECIFIED IN THE
+UNIFORM COMMERCIAL CODE. ALL OTHER WARRANTIES ARE EXPRESSLY DISCLAIMED TO THE
+FULL EXTENT SUCH MAY BE DISCLAIMED BY LAW.
+
+Section 7.                Indemnification
+
+7.1              You will defend, indemnify and hold harmless Licensor from any and
+all damages claims, liabilities, and costs (including reasonable attorney‚Äôs
+fees) related to your (including contractor‚Äôs and licensee‚Äôs) use of the
+Licensed Software and/or (2) your (including contractor‚Äôs and licensee‚Äôs)
+violation of the terms and conditions of this Agreement.  You are excused from
+this obligation to the extent any such claim arises solely from the Licensed
+Software as provided by Licensor.
+
+Section 8.                General Provisions
+
+8.1              Amendments and Waivers.       No amendment of any provision of
+this Agreement will be valid unless stated in writing and signed by authorized
+representatives of each of the parties.  No waiver by any party of any default,
+misrepresentation or covenant herein, whether intentional or not, will be
+deemed to extend any prior or subsequent default, misrepresentation, or
+covenant hereunder or affect in any way any rights arising by virtue of any
+prior or subsequent occurrence.
+
+8.2              Choice of Law.           This Agreement will be governed by,
+construed, and enforced in accordance with the laws of The Netherlands,
+without regard to conflicts of laws principles, will apply to all matters
+relating to this Agreement or the Licensed Software, and you agree that any
+litigation will be subject to the exclusive jurisdiction of the courts of
+Amsterdam, The Netherlands. The United Nations Convention on Contracts for the
+International Sale of Goods will not apply to this document.
+
+8.3              Confidential Information.  You will treat the Licensed
+Software as confidential information and you agree to retain the Licensed
+Software in confidence perpetually with respect to Licensed Software in source
+code form (human readable), or for a period of five (5) years from the date of
+termination of this Agreement, with respect to all other parts of the Licensed
+Software.  During this period you may not disclose any part of the Licensed
+Software to others than employees or contractors who have a need to know of the
+Licensed Software and who have executed written agreements obligating them to
+protect such Licensed Software.  You agree to use the same degree of care, but
+no less than a reasonable degree of care, with the Licensed Software as you do
+with your own confidential information. You may disclose Licensed Software to
+the extent required by a court or under operation of law or order provided that
+you notify Licensor of such requirement prior to disclosure, that you only disclose
+information required, and that the you allow Licensor the opportunity to object to
+such court or other legal body requiring such disclosure.
+
+8.4              Counterparts.  This Agreement may be executed in one or more
+original counterparts, all of which together will constitute one agreement, and
+facsimile signatures will have the same effect as original signatures.
+
+8.5              Entire Agreement.       This Agreement, including its
+attachments, constitutes the entire agreement between the parties regarding the
+subject matter hereof, and supersedes all prior communications, negotiations,
+understandings, agreements or representations, either written or oral, by or
+among the parties regarding such subject matter.
+
+8.6              Limitation of Liability.           IN NO EVENT WILL LICENSOR BE LIABLE,
+WHETHER IN CONTRACT, TORT, OR OTHERWISE, FOR ANY INCIDENTAL, SPECIAL, INDIRECT,
+CONSEQUENTIAL OR PUNITIVE DAMAGES, INCLUDING, BUT NOT LIMITED TO, DAMAGES FOR
+ANY LOSS OF USE, LOSS OF TIME, INCONVENIENCE, COMMERCIAL LOSS, OR LOST PROFITS,
+SAVINGS, OR REVENUES, TO THE FULL EXTENT SUCH MAY BE DISCLAIMED BY LAW. LICENSOR‚ÄôS
+TOTAL LIABILITY FOR ALL COSTS, DAMAGES, CLAIMS, OR LOSSES WHATSOEVER
+ARISING OUT OF OR IN CONNECTION WITH THIS AGREEMENT OR SOFTWARE SUPPLIED
+UNDER THIS AGREEMENT IS LIMITED TO THE AGGREGATE AMOUNT PAID BY YOU TO LICENSOR IN
+CONNECTION WITH THE SOFTWARE TO WHICH LOSSES OR DAMAGES ARE CLAIMED.
+
+8.7              Notices.           All notices and communications under this
+Agreement will be made in writing, and will be effective when received at the
+following addresses:
+
+Licensor:    NXP B.V.
+             High Tech Campus 60
+             5656 AG Eindhoven
+             The Netherlands
+
+             ATTN: Legal Department
+
+You:    The address provided at registration will be used.
+
+Either party may change its notice information upon notice to the other party.
+
+8.8              Relationship of the Parties.     The parties are independent
+contractors.  Nothing in this Agreement will be construed to create any
+partnership, joint venture, or similar relationship.  Neither party is
+authorized to bind the other to any obligations with third parties.
+
+8.9              Severability.  If any provision of this Agreement is held for
+any reason to be invalid or unenforceable the remaining provisions of this
+Agreement will be unimpaired and, unless a modification or replacement of the
+invalid or unenforceable provision is further held to deprive a party of a
+material benefit, in which case the Agreement will immediately terminate, the
+invalid or unenforceable provision will be replaced with a provision that is
+valid and enforceable and that comes closest to the parties‚Äô intention
+underlying the invalid or unenforceable provision.
+
+8.10          Succession and Assignment.   This Agreement will be binding upon
+and inure to the benefit of the parties and their permitted successors and
+assigns.  No portion of this Agreement may be assigned or otherwise transferred
+by you, without Licensor‚Äôs prior written consent. Licensor may assign this
+Agreement, or any part of this Agreement, in its sole discretion.
+
+8.11          Unauthorized Use.  The Licensed Software is not intended or
+authorized for use in anti-personnel landmines, and you agree that it will not
+be used for this purpose. Upon request from Licensor, you will furnish a written
+certification that you do not use or permit the use of the Licensed Software in
+anti-personnel landmines.  The Licensed Software is not intended or authorized
+for use in products surgically implanted into the body, for life support or for
+other products in which a product failure could cause personal injury or death.
+ If you permit the uses of Licensed Software for these unintended or
+ unauthorized uses, you will fully indemnify, defend, and hold harmless Licensor, its
+ Affiliates, subsidiaries, officers and directors, employees, and distributors
+ from all liability related to such use, including attorneys‚Äô fees and costs.
+
+8.12          Export.              Each party shall comply with all applicable
+export and import control laws and regulations including but not limited to
+the US Export Administration Regulation (including prohibited party lists
+issued by other federal governments), Catch-all regulations and all national
+and international embargoes. Each party further agrees that it will not
+knowingly transfer, divert, export or re-export, directly or indirectly, any
+product, software, including software source code, or technology restricted by
+such regulations or by other applicable national regulations, received from the
+other party under this Agreement, or any direct product of such software or
+technical data to any person, firm, entity, country or destination to which such
+transfer, diversion, export or re-export is restricted or prohibited, without
+obtaining prior written authorization from the applicable competent government
+authorities to the extent required by those laws. This provision shall survive
+termination or expiration of this Agreement.
+
+8.13          International Sale of Goods.  The United Nations Convention on
+Contracts for the International Sale of Goods will not apply to this document.
+
+8.14     Audit.  You will maintain accurate and up-to-date records pertaining
+to this Agreement and will grant Licensor or its authorized agent access to and
+copies of such records and information as requested by Licensor that pertain to your
+obligations under this Agreement.  Such access will be granted upon reasonable
+advance written notice, and be conducted during normal business hours with
+minimal impact to your business operations, and subject to confidentiality
+restrictions.  You will maintain such records for a period of at least three
+(3) years from the date of termination of this Agreement.  You must make prompt
+adjustment to compensate for any errors and/or omissions disclosed by such
+examination or audit.
diff --git a/release/LICENSE.openssl b/release/LICENSE.openssl
new file mode 100644
index 0000000..eb02631
--- /dev/null
+++ b/release/LICENSE.openssl
@@ -0,0 +1,131 @@
+CST statically links agains OpenSSL for the 'cst' and 'srktool'
+programs. Here is the OpenSSL license:
+
+
+
+  LICENSE ISSUES
+  ==============
+
+  The OpenSSL toolkit stays under a dual license, i.e. both the conditions of
+  the OpenSSL License and the original SSLeay license apply to the toolkit.
+  See below for the actual license texts. Actually both licenses are BSD-style
+  Open Source licenses. In case of any license issues related to OpenSSL
+  please contact openssl-core@openssl.org.
+
+  OpenSSL License
+  ---------------
+
+/* ====================================================================
+ * Copyright (c) 1998-2011 The OpenSSL Project.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in
+ *    the documentation and/or other materials provided with the
+ *    distribution.
+ *
+ * 3. All advertising materials mentioning features or use of this
+ *    software must display the following acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)"
+ *
+ * 4. The names "OpenSSL Toolkit" and "OpenSSL Project" must not be used to
+ *    endorse or promote products derived from this software without
+ *    prior written permission. For written permission, please contact
+ *    openssl-core@openssl.org.
+ *
+ * 5. Products derived from this software may not be called "OpenSSL"
+ *    nor may "OpenSSL" appear in their names without prior written
+ *    permission of the OpenSSL Project.
+ *
+ * 6. Redistributions of any form whatsoever must retain the following
+ *    acknowledgment:
+ *    "This product includes software developed by the OpenSSL Project
+ *    for use in the OpenSSL Toolkit (http://www.openssl.org/)"
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
+ * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
+ * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
+ * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+ * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+ * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
+ * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
+ * OF THE POSSIBILITY OF SUCH DAMAGE.
+ * ====================================================================
+ *
+ * This product includes cryptographic software written by Eric Young
+ * (eay@cryptsoft.com).  This product includes software written by Tim
+ * Hudson (tjh@cryptsoft.com).
+ *
+ */
+
+ Original SSLeay License
+ -----------------------
+
+/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
+ * All rights reserved.
+ *
+ * This package is an SSL implementation written
+ * by Eric Young (eay@cryptsoft.com).
+ * The implementation was written so as to conform with Netscapes SSL.
+ * 
+ * This library is free for commercial and non-commercial use as long as
+ * the following conditions are aheared to.  The following conditions
+ * apply to all code found in this distribution, be it the RC4, RSA,
+ * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
+ * included with this distribution is covered by the same copyright terms
+ * except that the holder is Tim Hudson (tjh@cryptsoft.com).
+ * 
+ * Copyright remains Eric Young's, and as such any Copyright notices in
+ * the code are not to be removed.
+ * If this package is used in a product, Eric Young should be given attribution
+ * as the author of the parts of the library used.
+ * This can be in the form of a textual message at program startup or
+ * in documentation (online or textual) provided with the package.
+ * 
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *    "This product includes cryptographic software written by
+ *     Eric Young (eay@cryptsoft.com)"
+ *    The word 'cryptographic' can be left out if the rouines from the library
+ *    being used are not cryptographic related :-).
+ * 4. If you include any Windows specific code (or a derivative thereof) from 
+ *    the apps directory (application code) you must include an acknowledgement:
+ *    "This product includes software written by Tim Hudson (tjh@cryptsoft.com)"
+ * 
+ * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ * 
+ * The licence and distribution terms for any publically available version or
+ * derivative of this code cannot be changed.  i.e. this code cannot simply be
+ * copied and put under another distribution licence
+ * [including the GNU Public Licence.]
+ */
+
diff --git a/release/Release_Notes.txt b/release/Release_Notes.txt
new file mode 100644
index 0000000..b92c846
--- /dev/null
+++ b/release/Release_Notes.txt
@@ -0,0 +1,167 @@
+                CST 3.1.0 Release Notes
+
+
+PROJECT(S):             CST
+DATE:                   September, 2018
+
+           COPYRIGHT ¬© 2017-2018 NXP
+           ALL RIGHTS RESERVED. PRESENCE OF COPYRIGHT
+           NOTICE IS NOT AN ACKNOWLEDGEMENT OF PUBLICATION.
+
+1 READ ME FIRST
+    This is the NXP Code Signing Tool (CST) for the High
+    Assurance Boot (HAB) library and the Advanced High Assurance
+    Boot (AHAB) subsystem. The CST provides software code
+    signing support designed for use with NXP processors that
+    integrate the HAB library in the internal boot ROM or the
+    AHAB subsystem. This release provides the features required
+    for the code signing for SoC supporting HAB version 3,
+    HAB version 4 and AHAB.
+
+1.1 REQUIREMENTS
+    This release supports Linux and Windows hosts
+    For Linux, the CST is known to work on Ubuntu 14.04 and later.
+    For Windows, the CST is known to work on Windows 7 and later
+
+    Most Linux distributions should work but they have not been fully
+    tested. If you run into library problems, see section 2.1 below
+    for instructions on how to relink CST.
+
+1.2 PROBLEM REPORTING INSTRUCTIONS
+    Problems with this release may be reported to your local NXP
+    representative or at community.nxp.com.
+
+
+2 NEW FEATURES & Fixes
+    The following is included in this release:
+
+2.1 Encrypted Boot support
+    This version of CST allows the user to relink the executable
+    to include support for generating encrypted boot images.
+
+    To relink on Ubuntu 14.04 machines, please first install binutils 2.26:
+        sudo apt-get install binutils-2.26
+        export PATH=/usr/lib/binutils-2.26/bin:${PATH}
+
+    To relink on 32 bit Linux machines:
+       This requires the GCC compiler and the OpenSSL header files and
+       library. For example on Ubuntu machines:
+       sudo apt-get install gcc libssl-dev
+
+       cd <CST install directory>/code/back_end/src
+       gcc -o cst -I ../hdr -L ../../../linux32/lib *.c \
+           -lfrontend -lcrypto
+       cp cst ../../../linux32
+
+    To relink on 64 bit Linux machines:
+       This requires the GCC compiler and the OpenSSL header files and
+       library. For example on Ubuntu machines:
+       sudo apt-get install gcc libssl-dev
+
+       cd <CST install directory/code/back_end/src
+       gcc -o cst -I ../hdr -L ../../../linux64/lib *.c -lfrontend -lcrypto
+       cp cst ../../../linux64
+
+    To relink on Windows machines:
+       This requires the MINGW compiler and OpenSSL header files and
+       library. The easiest way to get them is to install Cygwin
+
+       cd <CST install directory/code/back_end/src
+       i686-w64-mingw32-gcc -o cst.exe -I ../hdr -L ../../../mingw32/lib \
+         *.c -lfrontend -lcrypto -static -lgdi32 -lws2_32 -lz
+       cp cst.exe ../../../mingw32
+
+       If cst.exe crashes, please try to relink with the small C snippet
+       applink.c provided by OpenSSL (if applicable to your platform).
+       To do so, please add the compilation flag -DUSE_APPLINK.
+
+       i686-w64-mingw32-gcc -o cst.exe -I ../hdr -L ../../../mingw32/lib \
+         *.c -lfrontend -lcrypto -static -lgdi32 -lws2_32 -lz -DUSE_APPLINK
+
+        Please refer to https://www.openssl.org/docs/man1.1.0/crypto/OPENSSL_Applink.html
+        and https://www.openssl.org/docs/faq.html#PROG3
+
+    This was added in CST 2.3.0
+
+    Please note that there was an issue in 3.0.1 that prevented this
+    feature from working.
+
+2.2 64 bit native binaries
+    CST now includes both 32 and 64 bit native binaries. They are
+    located in the linux32 and linux64 directories, respectively.
+
+    This was added in CST 2.3.0
+
+2.3 Issue INIT RNG command
+    On closed i.MX devices with CAAM, HAB will initialize the RNG by
+    default. If the RNG trim fuses have not been set correctly, RNG
+    iniatialization will fail, causing the boot to fail.
+
+    To prevent HAB from initializing the RNG, you can add an UNLOCK
+    command to the CST input file.
+
+    This version of CST will add that command automatically if the CSF
+    includes "Engine = CAAM" in the header unless
+    explicitly told otherwise. The way to disable this behavior is to
+    add the following to the CST input file:
+        [Init]
+             Engine = CAAM
+             Features = RNG
+
+    This was added in CST 2.3.1, fixed in 2.3.2
+
+2.4 Changed CST input file handling
+    Previous versions of CST got the CSF input file on standard
+    input. This has changed. Now the input filename is supplied as a
+    command line argument.
+
+    Example:
+       cst --output csf.bin --input input.csf
+
+    This was added in CST 2.3.2
+
+2.5 Added unlock command for Manufacturing Protection
+    The new unlock command will cause HAB to keep the manufacturing
+    protection key in internal CAAM memory after boot.
+
+    This was added in CST 2.3.2
+
+2.6 Windows support
+    This version of CST adds support for Microsoft Windows.
+
+    This was added in CST 2.3.3
+
+2.7 Removed several commands
+    This version of CST removed support for the following commands:
+        Write Data
+        Clear Mask
+        Set Mask
+        Check All Clear
+        Check All Set
+        Check Any Clear
+        Check Any Set
+        Set MID
+
+    This was added in CST 2.3.3
+
+2.8 AHAB support
+    This version of CST adds support for AHAB.
+
+    This was added in CST 3.0.0
+
+2.9 ECDSA support for HAB4
+    This version of CST adds support for ECDSA for HAB4.
+    ECDSA support was added in HAB 4.5
+
+    This was added in CST 3.1.0
+
+3.0 OpenSSL 1.1.0
+    This version of CST adds support for OpenSSL 1.1.0.
+    Even if OpenSSL 1.0.2 is known to work with CST, OpenSSL 1.1.0
+    or later is recommended.
+
+    This was added in CST 3.1.0
+
+3 KNOWN ISSUES
+
+No known issues.
diff --git a/release/ca/openssl.cnf b/release/ca/openssl.cnf
new file mode 100644
index 0000000..e8eec8a
--- /dev/null
+++ b/release/ca/openssl.cnf
@@ -0,0 +1,97 @@
+#
+# OpenSSL configuration file.
+#
+
+# Establish working directory.
+
+dir					= .
+
+[ ca ]
+default_ca				= CA_default
+
+[ CA_default ]
+serial					= $dir/serial
+database				= $dir/index.txt
+new_certs_dir				= $dir
+certificate				= $dir/cacert.pem
+private_key				= $dir/ca_key.pem
+default_days				= 3650
+default_md				= sha256
+preserve				= no
+email_in_dn				= no
+nameopt					= default_ca
+certopt					= default_ca
+policy					= policy_match
+x509_extensions	                        = openssl_usr_cert     # Default extensions to add to the cert
+
+[ policy_match ]
+countryName				= optional
+stateOrProvinceName			= optional
+organizationName			= optional
+organizationalUnitName			= optional
+commonName				= supplied
+emailAddress				= optional
+
+[ req ]
+default_bits				= 2048			# Size of keys
+default_keyfile				= key.pem		# name of generated keys
+default_md				= sha256		# message digest algorithm
+string_mask				= nombstr		# permitted characters
+distinguished_name			= req_distinguished_name
+#req_extensions				= v3_req                # omit - openssl doesn't copy req extension
+x509_extensions	                        = v3_ca                 # The extentions to add to the self signed cert
+
+# Passwords for private keys if not present they will be prompted for
+# input_password = secret
+# output_password = secret
+
+[ req_distinguished_name ]
+# Variable name				Prompt string
+#-------------------------	  ----------------------------------
+countryName				= Country Name (2 letter code)
+countryName_default			= US
+commonName				= Common Name (hostname, IP, or your name)
+commonName_max				= 64
+
+#0.organizationName			= Organization Name (company)
+#organizationalUnitName			= Organizational Unit Name (department, division)
+#emailAddress				= Email Address
+#emailAddress_max			= 40
+#localityName				= Locality Name (city, district)
+#stateOrProvinceName			= State or Province Name (full name)
+#countryName_min				= 2
+#countryName_max				= 2
+
+# Default values for the above, for consistency and less typing.
+# Variable name				Value
+#------------------------	  ------------------------------
+0.organizationName_default		= My Company
+localityName_default			= My Town
+stateOrProvinceName_default		= State or Providence
+
+[ v3_usr ]
+# Standard openssl extensions on user certificates
+# These extensions are added when 'ca' signs a request.
+# This goes against PKIX guidelines but some CAs do it and some software
+# requires this to avoid interpreting an end user certificate as a CA.
+basicConstraints=CA:FALSE
+
+# PKIX recommendations harmless if included in all certificates.
+subjectKeyIdentifier=hash
+authorityKeyIdentifier=keyid,issuer
+
+[ v3_ca ]
+# PKIX-conformant extensions on CA certificates
+# PKIX recommendation.
+subjectKeyIdentifier=hash
+authorityKeyIdentifier=keyid:always,issuer:always
+
+# PKIX requires basicConstraints to be critical on CA certs (sec 4.2.1.9)
+basicConstraints = critical,CA:true
+
+# PKIX requires keyUsage present with keyCertSign on CA certs (sec 4.2.1.3)
+keyUsage = keyCertSign
+
+[ v3_req ]
+basicConstraints			= CA:FALSE
+subjectKeyIdentifier			= hash
diff --git a/release/ca/v3_ca.cnf b/release/ca/v3_ca.cnf
new file mode 100644
index 0000000..9785184
--- /dev/null
+++ b/release/ca/v3_ca.cnf
@@ -0,0 +1,11 @@
+# PKIX-conformant extensions on CA certificates
+
+# PKIX recommendation.
+subjectKeyIdentifier=hash
+authorityKeyIdentifier=keyid:always,issuer:always
+
+# PKIX requires basicConstraints to be critical on CA certs (sec 4.2.1.9)
+basicConstraints = critical,CA:true
+
+# PKIX requires keyUsage present with keyCertSign on CA certs (sec 4.2.1.3)
+keyUsage = keyCertSign
diff --git a/release/ca/v3_usr.cnf b/release/ca/v3_usr.cnf
new file mode 100644
index 0000000..1d008a8
--- /dev/null
+++ b/release/ca/v3_usr.cnf
@@ -0,0 +1,51 @@
+# Standard openssl extensions on user certificates
+
+# These extensions are added when 'ca' signs a request.
+
+# This goes against PKIX guidelines but some CAs do it and some software
+# requires this to avoid interpreting an end user certificate as a CA.
+
+basicConstraints=CA:FALSE
+
+# Here are some examples of the usage of nsCertType. If it is omitted
+# the certificate can be used for anything *except* object signing.
+
+# This is OK for an SSL server.
+# nsCertType			= server
+
+# For an object signing certificate this would be used.
+# nsCertType = objsign
+
+# For normal client use this is typical
+# nsCertType = client, email
+
+# and for everything including object signing:
+# nsCertType = client, email, objsign
+
+# This is typical in keyUsage for a client certificate.
+# keyUsage = nonRepudiation, digitalSignature, keyEncipherment
+
+# This will be displayed in Netscape's comment listbox.
+nsComment			= "OpenSSL Generated Certificate"
+
+# PKIX recommendations harmless if included in all certificates.
+subjectKeyIdentifier=hash
+authorityKeyIdentifier=keyid,issuer
+
+# This stuff is for subjectAltName and issuerAltname.
+# Import the email address.
+# subjectAltName=email:copy
+# An alternative to produce certificates that aren't
+# deprecated according to PKIX.
+# subjectAltName=email:move
+
+# Copy subject details
+# issuerAltName=issuer:copy
+
+#nsCaRevocationUrl		= http://www.domain.dom/ca-crl.pem
+#nsBaseUrl
+#nsRevocationUrl
+#nsRenewalUrl
+#nsCaPolicyUrl
+#nsSslServerName
+
diff --git a/release/code/back_end-hsm/LICENSE.oasis b/release/code/back_end-hsm/LICENSE.oasis
new file mode 100644
index 0000000..1c348fd
--- /dev/null
+++ b/release/code/back_end-hsm/LICENSE.oasis
@@ -0,0 +1,13 @@
+The CST package contains the sources and headers to replace the CST backend by
+this custom backend that can interact directly with an Hardware Security Module
+(HSM) by using the PKCS#11 interface definition. This custom backend includes a
+header from OASIS.
+
+Here is the OASIS license:
+
+/* Copyright (c) OASIS Open 2016. All Rights Reserved./
+ * /Distributed under the terms of the OASIS IPR Policy,
+ * [http://www.oasis-open.org/policies-guidelines/ipr], AS-IS, WITHOUT ANY
+ * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.
+ */
diff --git a/release/code/back_end-hsm/LICENSE.rsa b/release/code/back_end-hsm/LICENSE.rsa
new file mode 100644
index 0000000..8062757
--- /dev/null
+++ b/release/code/back_end-hsm/LICENSE.rsa
@@ -0,0 +1,21 @@
+The CST package contains the sources and headers to replace the CST backend by
+this custom backend that can interact directly with an Hardware Security Module
+(HSM) by using the PKCS#11 interface definition. This custom backend includes a
+header from RSA Security Inc.
+
+Here is the RSA license:
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
diff --git a/release/code/back_end-hsm/README.md b/release/code/back_end-hsm/README.md
new file mode 100644
index 0000000..32ce3cc
--- /dev/null
+++ b/release/code/back_end-hsm/README.md
@@ -0,0 +1,157 @@
+# HSM backend for CST
+
+# Introduction
+
+This project aims to provide a backend replacement for Code-Signing Tool to support Hardware Security Module (HSM).  It plug in alternative implementations for OpenSSL to perform cryptographic operations requested to sign codes for the NXP High Assurance Boot (HAB).
+
+The README file provides the information necessary to effectively use Code-Signing Tool with Hardware Security Module backend. It is primarily intended for users who are familiar with CST tool . 
+
+# Getting Started
+
+These instructions will get you a copy of the backend implementation and pre-built CST version up and running on your local machine for development and testing purposes. See deployment for notes on how to deploy the project on a Windows system. I didn't test the project on Linux environement yet.
+
+
+# Installation
+
+## Dependencies
+
+The CST-HSM backend depends on:
+
+ - OpenSSL 1.0.2x (required by the Frontend)
+ - Libconfig
+
+Make is required for building the software.
+
+1)	I nstall OpenSSL
+
+```
+    $ apt-get install openssl libssl-dev
+```
+
+libconfig  is C/C++ library for processing structured configuration files. It is used by CST to load HSM related configuration. 
+
+2)	Install libconfig
+
+```
+    $  apt-get install libconfig-dev
+```
+
+## Compile backend
+
+To compile backend and CST from souce
+
+Compile the backend source code using the following command:
+
+    $ make
+
+Options:
+OPENSSL_PATH Specify prefix of path of OpenSSL
+
+## Compile Code-Signing tool
+
+Copy libfrontend.a to project source folder them  compile CST using the following command:
+
+```
+$ make all
+```
+
+# Configuration
+
+CST requires having certificates on file system. To fulfill the requirement, you should pull the certificates used for signing to your file system using a utility which manage and use PKCS #11 security tokens. You can use the tool provided by your HSM vendor or any other alternative. In this manual we use p11tool.
+
+##  Install p11tool
+ 
+To perform interact with HSM you can use p11tool.
+
+    $ apt-get install gnutls-bin
+
+##   Locate Token URL
+
+1)	Make sure that a token is initialized on your HSM.
+2)	Locate the PKCS #11 interface implementation library provided by your HSM vendor. It will be used for p11tool and later by CST. 
+(e.g):
+Utimaco library is libcs_pkcs11_R2.so
+SoftHSM2 library is libsofthsm2.so
+3)	Find the Token URL to interact with the token.
+
+```
+$ p11tool --provider <pkcs11_provider_library_path> --list-tokens
+```
+
+    Token 0:
+            URL: pkcs11:model=SoftHSM%20v2;manufacturer=SoftHSM%20project;serial=9c1aeb00e05a348b;token=CST-HSM
+            Label: CST-HSM
+            Type: Generic token
+            Manufacturer: SoftHSM project
+            Model: SoftHSM v2
+            Serial: 9c1aeb00e05a348b
+            Module: (null)
+
+In this case Token URL is pkcs11:model=SoftHSM%20v2;manufacturer=SoftHSM%20project;serial=9c1aeb00e05a348b;token=CST-HSM
+
+##  Pull the public certificates
+
+Pull all certificates referenced on your Command Sequence File. Assume that a CSF and an IMG certificates were referenced.
+
+1)	List all certificates on HSM
+Locate certificate URL
+
+```
+$ p11tool --provider <pkcs11_provider_library_path> "<token-url>" --list-all-certs
+```
+
+2)	Pull CSF certificate from HSM
+Export the certificate to file system using its URL.
+
+```
+$ p11tool --provider <pkcs11_provider_library_path> --export "<cert_url>" --outfile CSF1_1_sha256_2048_65537_v3_ca_crt.pem
+```
+
+3)	Pull IMG certificate from HSM
+Export the certificate to file system using its URL.
+
+```
+$ p11tool --provider <pkcs11_provider_library_path> --export "<cert_url>" --outfile IMG1_1_sha256_2048_65537_v3_ca_crt.pem
+```
+
+##  Binding
+
+In the same folder as CST, create a hsm.cfg file. This file is used by CST to determine parameters to access HSM and to locate cryptographic objects needed for signing.  
+The configuration file specifies the following parameters.
+
+ - **hsm.module** contains the path to vendorís PKCS#11 implementation library
+ - **hsm.pin** specifies the User PIN, for security reason you may not specify this value, it will be asked at runtime.
+ - **hsm.slot** specifies the SLOT ID 
+ - **hsm.objects** is a lookup table which bind a cryptographic material on the file system to its Object ID on the HSM. This is needed since the current frontend implementation loads and checks certificates from the file system and then provide as argument the certificate path to the backend. 
+The backend can see a path only. To be load the required certificate and its private key from the HSM, the backend uses this lookup.  
+	- **hsm.objects.file** path to certificate on file system.
+	 -  **hsm.objects.id** Identifier of the same certificate on the HSM.
+
+   
+
+Please note that this Id will be used also to load the private key corresponding to the certificate. HSM binds certificates to private keys by giving the same Id for both objects and in some HSM implementation they should have the same Label also.
+
+    $ nano hsm.cfg
+
+Config example: 
+
+    hsm:
+    {
+      module = <pkcs11_provider_library_path> ";
+      pin = "123456";
+      slot = 0;
+      objects = (
+              { file  = "../../crts/CSF1_1_sha256_2048_65537_v3_usr_crt.pem";
+                id = "ec705018e9bf8ad60096e13cb2f0fbad";
+              },
+              { file  = "../../crts/IMG1_1_sha256_2048_65537_v3_usr_crt.pem";
+                id = "a0c8cac03985fb6dced29c97dc83aef7"; 
+              });  
+    };
+
+# Deployement
+
+Finally invoke the CST.
+
+    $ ./cst -i <infile> -o <outfile>
+    CSF Processed successfully and signed data available in <outfile>
diff --git a/release/code/back_end-hsm/doc/CST-HSM_UG.pdf b/release/code/back_end-hsm/doc/CST-HSM_UG.pdf
new file mode 100644
index 0000000..897de5a
Binary files /dev/null and b/release/code/back_end-hsm/doc/CST-HSM_UG.pdf differ
diff --git a/release/code/back_end-hsm/doc/HSM-CST-Architecture.pdf b/release/code/back_end-hsm/doc/HSM-CST-Architecture.pdf
new file mode 100644
index 0000000..02d3957
Binary files /dev/null and b/release/code/back_end-hsm/doc/HSM-CST-Architecture.pdf differ
diff --git a/release/code/back_end-hsm/doc/HSM-CST_QuickStart.pdf b/release/code/back_end-hsm/doc/HSM-CST_QuickStart.pdf
new file mode 100644
index 0000000..3d4af34
Binary files /dev/null and b/release/code/back_end-hsm/doc/HSM-CST_QuickStart.pdf differ
diff --git a/release/code/back_end-hsm/doc/HSM-CST_UG.pdf b/release/code/back_end-hsm/doc/HSM-CST_UG.pdf
new file mode 100644
index 0000000..26924f1
Binary files /dev/null and b/release/code/back_end-hsm/doc/HSM-CST_UG.pdf differ
diff --git a/release/code/back_end-hsm/src/Makefile b/release/code/back_end-hsm/src/Makefile
new file mode 100644
index 0000000..772e129
--- /dev/null
+++ b/release/code/back_end-hsm/src/Makefile
@@ -0,0 +1,82 @@
+#==============================================================================
+#
+#    File Name:  Makefile
+#
+#    General Description: Makefile for HSM backend for CST
+#
+#==============================================================================
+#
+#    Copyright 2018 NXP
+#
+# Presence of a copyright notice is not an acknowledgement of publication.
+# This software file listing contains information of NXP that is of a
+# confidential and proprietary nature and any viewing or use of this file is
+# prohibited without specific written permission from NXP
+#
+#==============================================================================
+
+#==============================================================================
+# Compiler/Linker/Archiver Commands
+#==============================================================================
+
+
+ifneq ($(ARCH),)
+ARCH := $(shell getconf LONG_BIT)
+endif
+
+$(info $$ARCH is [${ARCH}])
+
+C_FLAGS_32 := -m32
+C_FLAGS_64 := -m64
+
+LD_FLAGS_32 := 
+LD_FLAGS_64 := 
+
+DESTDIR=./
+PREFIX=./
+
+STATIC=libbackend.a
+
+CC = gcc
+#CFLAGS = -Wall -Winline -pipe -I./include -I$(OPENSSL_PATH)/include
+
+CFLAGS = $(C_FLAGS_$(ARCH)) -Wall -Wl,--export-all-symbols -w -Winline -pipe -I./include -I$(OPENSSL_PATH)/include 
+
+LDFLAGS = -L./lib 
+
+LIBS = -lssl -lcrypto -ldl -lpthread -lconfig
+
+ifeq ($(OS),Windows_NT)
+LIBS += -lpsapi -lgdi32
+endif
+
+SRC = backend.c config.c e_hsm.c e_hsm_err.c openssl_helper.c
+
+OBJ = $(SRC:.c=.o)
+
+ifeq ($(OPENSSL_PATH),)
+OPENSSL_PATH := $(ROOTPATH)/../openssl
+endif
+
+# Define -mno-ms-bitfields to get correct bit-field layout of packed structs
+LDFLAGS  += -I$(OPENSSL_PATH)/include -mno-ms-bitfields
+LDFLAGS += -L$(OPENSSL_PATH)/lib
+
+
+$(STATIC): $(OBJ)
+		@echo "[Link (Static) libbackend]"
+		@ar rcs $@ $^
+
+.c.o:
+		@echo [Compile] $<
+		@$(CC) -c $(CFLAGS) $< -o $@
+
+clean:
+		rm -f $(OBJ) *~ core tags *.bak Makefile.bak libbackend.*
+
+.PHONY: install
+#install: $(STATIC)
+#		@install -m 0755 $< $(DESTDIR)$(PREFIX)/lib
+
+all: install
+		$(CC)  $(C_FLAGS_$(ARCH)) -std=c99  -D_POSIX_C_SOURCE=200809L -Wall -Werror -g -Wall -o cst  libfrontend.a libbackend.a $(LDFLAGS) $(LIBS) -fno-builtin -fno-strict-aliasing -fno-common -DREMOVE_ENCRYPTION -Wl,--allow-multiple-definition
diff --git a/release/code/back_end-hsm/src/backend.c b/release/code/back_end-hsm/src/backend.c
new file mode 100644
index 0000000..ea59ba0
--- /dev/null
+++ b/release/code/back_end-hsm/src/backend.c
@@ -0,0 +1,1394 @@
+/*===========================================================================*/
+/**
+ @file    backend.c
+
+ @brief   Implements Code Signing Tool's Adaptation Layer API for the
+ Freescale reference Code Signing Tool.  This file is a
+ replacement for the original backend to implement a support 
+ for Hardware Security Module (HSM)
+
+ @verbatim
+ =============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+ =============================================================================
+ @endverbatim */
+
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <adapt_layer.h>
+#include <config.h>
+#include <e_hsm.h>
+
+#include <openssl/cms.h>
+#include <openssl/err.h>
+#include <openssl/objects.h>
+#include <openssl/evp.h>
+#include <openssl/x509.h>
+#include <openssl/pem.h>
+#include <openssl/bn.h>
+#include <openssl/engine.h>
+
+#define HASH_FNC ((void (*)(void *, const void*,size_t))gcry_md_write)
+
+#define fail_if_err(a) do { if(a) {                                       \
+                              fprintf (stderr, "%s:%d:
", \
+                              __FILE__, __LINE__);   \
+                              exit (1); }                              \
+                           } while(0)
+
+static CK_FUNCTION_LIST_PTR pFunctions = NULL;
+#define HASH_BYTES_SHA512         64
+#define HASH_BYTES_MAX            HASH_BYTES_SHA512
+#define MAX_ERR_STR_BYTES           120		/**< Max. error string bytes */
+#define MAX_CMS_DATA                4096   /**< Max bytes in CMS_ContentInfo */
+#define MAX_LINE_CHARS              1024   /**< Max. chars in output line    */
+
+/*===========================================================================
+ LOCAL FUNCTION PROTOTYPES
+ =============================================================================*/
+
+/** Converts hash_alg to an equivalent NID value for OpenSSL
+ *
+ * @param[in] hash_alg Hash digest algorithm from #hash_alg_t
+ *
+ * @pre hash_alg is a valid value from #hash_alg_t
+ *
+ * @returns Openssl NID value corresponding to a valid value for @a hash_alg,
+ *          NID_undef otherwise.
+ */
+static int32_t get_NID (hash_alg_t hash_alg);
+
+/** Generate raw PKCS#1 Signature Data
+ *
+ * Generates a raw PKCS#1 v1.5 signature for the given data file, signer
+ * certificate, and hash algorithm. The signature data is returned in
+ * a buffer provided by caller.
+ *
+ * @param[in] in_file string containing path to file with data to sign
+ *
+ * @param[in] key EVP_PKEY signing key
+ *
+ * @param[in] hash_alg hash algorithm from #hash_alg_t
+ *
+ * @param[out] sig_buf signature data buffer
+ *
+ * @param[in,out] sig_buf_bytes On input, contains size of @a sig_buf in bytes,
+ *                              On output, contains size of signature in bytes.
+ *
+ * @pre @a in_file, @a cert_file, @a key_file, @a sig_buf and @a sig_buf_bytes
+ *         must not be NULL.
+ *
+ * @post On success @a sig_buf is updated to hold the resulting signature and
+ *       @a sig_buf_bytes is updates to hold the length of the signature in
+ *       bytes
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_CRYPTO_API_ERROR An Openssl related error has occured
+ */
+int32_t gen_sig_data_raw (const char *in_file, EVP_PKEY * key,
+			  hash_alg_t hash_alg, uint8_t * sig_buf,
+			  int32_t * sig_buf_bytes);
+
+/** Generate CMS Signature Data
+ *
+ * Generates a CMS signature for the given data file, signer certificate, and
+ * hash algorithm. The signature data is returned in a buffer provided by
+ * caller.  Note that sign_data cannot be used here since that function
+ * requires an input buffer as an argument.  For large files it becomes
+ * unreasonable to allocate a contigous block of memory.
+ *
+ * @param[in] in_file string containing path to file with data to sign
+ *
+ * @param[in] x509 X509 signer certificate object
+ *
+ * @param[in] hash_alg hash algorithm from #hash_alg_t
+ *
+ * @param[out] sig_buf signature data buffer
+ *
+ * @param[in,out] sig_buf_bytes On input, contains size of @a sig_buf in bytes,
+ *                              On output, contains size of signature in bytes.
+ *
+ * @pre @a in_file, @a cert_file, @a key_file, @a sig_buf and @a sig_buf_bytes
+ *         must not be NULL.
+ *
+ * @post On success @a sig_buf is updated to hold the resulting signature and
+ *       @a sig_buf_bytes is updates to hold the length of the signature in
+ *       bytes
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_INVALID_ARGUMENT One of the input arguments is invalid
+ *
+ * @retval #CAL_CRYPTO_API_ERROR An Openssl related error has occured
+ */
+int32_t gen_sig_data_cms (const char *in_file, X509 * x509, EVP_PKEY * pkey,
+			  hash_alg_t hash_alg, uint8_t * sig_buf,
+			  size_t * sig_buf_bytes);
+
+/** Copies CMS Content Info with encrypted or signature data to buffer
+ *
+ * @param[in] cms CMS Content Info
+ *
+ * @param[in] bio_in input bio
+ *
+ * @param[out] data_buffer address to data buffer
+ *
+ * @param[in] data_buffer_size max size, [out] return size
+ *
+ * @param[in] flags CMS Flags
+ *
+ * @returns CAL_SUCCESS upon success
+ *
+ * @returns CAL_CRYPTO_API_ERROR when openssl BIO API fail
+ */
+int32_t cms_to_buf (CMS_ContentInfo * cms, BIO * bio_in,
+		    uint8_t * data_buffer, size_t * data_buffer_size,
+		    int32_t flags);
+
+/** generate_dek_key
+ *
+ * Uses openssl API to generate a random 128 bit AES key
+ *
+ * @param[out] key buffer to store the key data
+ *
+ * @param[in] len length of the key to generate
+ *
+ * @post if successful the random bytes are placed into output buffer
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @returns if successful function returns location CAL_SUCCESS.
+ */
+int32_t generate_dek_key (uint8_t * key, int32_t len);
+
+/**  write_plaintext_dek_key
+ *
+ * Writes the provide DEK to the give path. It will be encrypted
+ * under the certificate file if provided.
+ *
+ * @param[in] key input key data
+ *
+ * @param[in] key_bytes length of the input key
+ *
+ * @param[in] cert_file  certificate to encrypt the DEK
+ *
+ * @param[in] enc_file  destination file
+ *
+ * @post if successful the dek is written to the file
+ *
+ * @returns if successful function returns location CAL_SUCCESS.
+ */
+int32_t write_plaintext_dek_key (uint8_t * key, size_t key_bytes,
+				 const char *cert_file, const char *enc_file);
+
+/** encrypt_dek_key
+ *
+ * Uses openssl API to encrypt the key. Saves the encrypted structure to a file
+ *
+ * @param[in] key input key data
+ *
+ * @param[in] key_bytes length of the input key
+ *
+ * @param[in] cert filename of the RSA certificate, dek will be encrypted with
+ *
+ * @param[in] file encrypted data saved in the file
+ *
+ * @post if successful the file is created with the encrypted data
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @returns if successful function returns location CAL_SUCCESS.
+ */
+int32_t encrypt_dek_key (uint8_t * key, size_t key_bytes,
+			 const char *cert_file, const char *enc_file);
+
+/*--------------------------
+ get_NID
+ ---------------------------*/
+int32_t
+get_NID (hash_alg_t hash_alg)
+{
+  return OBJ_txt2nid (get_digest_name (hash_alg));
+}
+
+/*--------------------------
+ gen_sig_data_ecdsa
+ ---------------------------*/
+int32_t
+gen_sig_data_ecdsa (const char *in_file, EVP_PKEY * key,
+		    hash_alg_t hash_alg, uint8_t * sig_buf,
+		    size_t * sig_buf_bytes)
+{
+  BIO *bio_in = NULL;	    /**< BIO for in_file data    */
+  uint32_t key_size = 0;       /**< n of bytes of key param */
+  const EVP_MD *sign_md = NULL;	      /**< Digest name             */
+  uint8_t *hash = NULL;	      /**< Hash data of in_file    */
+  int32_t hash_bytes = 0;	/**< Length of hash buffer   */
+  uint8_t *sign = NULL;	      /**< Signature data in DER   */
+  uint32_t sign_bytes = 0;	 /**< Length of DER signature */
+  uint8_t *r = NULL, *s = NULL;	      /**< Raw signature data R&S  */
+  size_t bn_bytes = 0;	     /**< Length of R,S big num   */
+  ECDSA_SIG *sign_dec = NULL;	    /**< Raw signature data R|S  */
+  int32_t err_value = CAL_SUCCESS;	 /**< Return value            */
+  char err_str[MAX_ERR_STR_BYTES];	 /**< Error string            */
+  const BIGNUM *sig_r, *sig_s;			 /**< signature numbers defined as OpenSSL BIGNUM */
+
+  if (!key)
+    {
+      fprintf (stderr, "Invalid certificate or key
");
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  /* Set signature message digest alg */
+  sign_md = EVP_get_digestbyname (get_digest_name (hash_alg));
+  if (sign_md == NULL)
+    {
+      fprintf (stderr, "Invalid hash digest algorithm");
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  do
+    {
+      /* Read Data to be signed */
+      if (!(bio_in = BIO_new_file (in_file, "rb")))
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES, "Cannot open data file %s",
+		    in_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Generate hash of data from in_file */
+      hash_bytes = HASH_BYTES_MAX;
+      hash = OPENSSL_malloc (HASH_BYTES_MAX);
+
+      err_value = calculate_hash (in_file, hash_alg, hash, &hash_bytes);
+      if (err_value != CAL_SUCCESS)
+	{
+	  break;
+	}
+
+      /* Generate ECDSA signature with DER encoding */
+      sign_bytes = ECDSA_size (EVP_PKEY_get0_EC_KEY (key));
+      sign = OPENSSL_malloc (sign_bytes);
+
+      if (0 == ECDSA_sign (0 /* ignored */ , hash, hash_bytes, sign,
+			   &sign_bytes, EVP_PKEY_get0_EC_KEY (key)))
+	{
+	  fprintf (stderr, "Failed to generate ECDSA signature");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      sign_dec = d2i_ECDSA_SIG (NULL, (const uint8_t **) &sign, sign_bytes);
+      if (NULL == sign_dec)
+	{
+	  fprintf (stderr, "Failed to decode ECDSA signature");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Copy R|S to sig_buf */
+      memset (sig_buf, 0, *sig_buf_bytes);
+
+      key_size = EVP_PKEY_bits (key) >> 3;
+      if (EVP_PKEY_bits (key) & 0x7)
+	key_size += 1;		/* Valid for P-521 */
+
+      if ((key_size * 2) > *sig_buf_bytes)
+	{
+	  fprintf (stderr, "Signature buffer too small");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      *sig_buf_bytes = key_size * 2;
+
+      ECDSA_SIG_get0 (sign_dec, &sig_r, &sig_s);
+
+      r = get_bn (sig_r, &bn_bytes);
+      memcpy (sig_buf + (key_size - bn_bytes), r, bn_bytes);
+      free (r);
+
+      s = get_bn (sig_s, &bn_bytes);
+      memcpy (sig_buf + key_size + (key_size - bn_bytes), s, bn_bytes);
+      free (s);
+    }
+  while (0);
+
+  /* Print any Openssl errors */
+  if (err_value != CAL_SUCCESS)
+    {
+      ERR_print_errors_fp (stderr);
+    }
+
+  /* Close everything down */
+  if (bio_in)
+    BIO_free (bio_in);
+
+  return err_value;
+}
+
+/*--------------------------
+ gen_sig_data_cms
+ ---------------------------*/
+int32_t
+gen_sig_data_cms (const char *in_file, X509 * x509, EVP_PKEY * pkey,
+		  hash_alg_t hash_alg, uint8_t * sig_buf,
+		  size_t * sig_buf_bytes)
+{
+  BIO *bio_in = NULL;	    /**< BIO for in_file data */
+  CMS_ContentInfo *cms = NULL;	     /**< Ptr used with openssl API */
+  const EVP_MD *sign_md = NULL;	      /**< Ptr to digest name */
+  int32_t err_value = CAL_SUCCESS;	 /**< Used for return value */
+  FILE *pFile = NULL;
+	/** Array to hold error string */
+  char err_str[MAX_ERR_STR_BYTES];
+  /* flags set to match Openssl command line options for generating
+   *  signatures
+   */
+  int32_t flags = CMS_DETACHED | CMS_NOCERTS | CMS_NOSMIMECAP | CMS_BINARY;
+
+  if (!pkey || !x509)
+    {
+      fprintf (stderr, "Invalid certificate or key");
+      return CAL_INVALID_ARGUMENT;
+    }
+  /* Set signature message digest alg */
+  sign_md = EVP_get_digestbyname (get_digest_name (hash_alg));
+
+  if (sign_md == NULL)
+    {
+      fprintf (stderr, "Invalid hash digest algorithm");
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  do
+    {
+      /* Read Data to be signed */
+      if (!(bio_in = BIO_new_file (in_file, "rb")))
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Cannot open data file %s", in_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Generate CMS Signature - can only use CMS_sign if default
+       * MD is used which is SHA1 */
+      flags |= CMS_PARTIAL;
+
+      cms = CMS_sign (NULL, NULL, NULL, bio_in, flags);
+      if (!cms)
+	{
+	  fprintf (stderr, "Failed to initialize CMS signature");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      if (!CMS_add1_signer (cms, x509, pkey, sign_md, flags))
+	{
+	  fprintf (stderr, "Failed to generate CMS signature");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Finalize the signature */
+      if (!CMS_final (cms, bio_in, NULL, flags))
+	{
+	  fprintf (stderr, "Failed to finalize CMS signature");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Write CMS signature to output buffer - DER format */
+      err_value = cms_to_buf (cms, bio_in, sig_buf, sig_buf_bytes, flags);
+    }
+  while (0);
+
+  /* Print any Openssl errors */
+  if (err_value != CAL_SUCCESS)
+    {
+      ERR_print_errors_fp (stderr);
+    }
+
+  /* Close everything down */
+  if (cms)
+    CMS_ContentInfo_free (cms);
+  if (bio_in)
+    BIO_free (bio_in);
+
+  return err_value;
+}
+
+/*--------------------------
+ gen_sig_data_raw
+ ---------------------------*/
+int32_t
+gen_sig_data_raw (const char *in_file, EVP_PKEY * key,
+		  hash_alg_t hash_alg, uint8_t * sig_buf,
+		  int32_t * sig_buf_bytes)
+{
+
+  RSA *rsa = NULL;	 /**< Ptr to rsa of key data */
+  uint8_t *rsa_in = NULL;	/**< Mem ptr for hash data of in_file */
+  uint8_t *rsa_out = NULL;	 /**< Mem ptr for encrypted data */
+  int32_t rsa_inbytes;	     /**< Holds the length of rsa_in buf */
+  int32_t rsa_outbytes = 0;	  /**< Holds the length of rsa_out buf */
+  int32_t key_bytes;	   /**< Size of key data */
+  int32_t hash_nid;	  /**< hash id needed for RSA_sign() */
+	/** Array to hold error string */
+  char err_str[MAX_ERR_STR_BYTES];
+	/**< Holds the return error value */
+  int32_t err_value = CAL_CRYPTO_API_ERROR;
+  /*EVP_MD_CTX mdctx; */
+
+  do
+    {
+      rsa = EVP_PKEY_get1_RSA (key);
+      EVP_PKEY_free (key);
+
+      if (!rsa)
+	{
+	  fprintf (stderr,
+		   "Unable to extract RSA key for RAW PKCS#1 signature");
+	  break;
+	}
+
+      rsa_inbytes = HASH_BYTES_MAX;
+      rsa_in = (unsigned char *) OPENSSL_malloc (HASH_BYTES_MAX);
+      key_bytes = RSA_size (rsa);
+      rsa_out = (unsigned char *) OPENSSL_malloc (key_bytes);
+
+      /* Generate hash data of data from in_file */
+      err_value =
+	hsm_calculate_hash (in_file, hash_alg, rsa_in, &rsa_inbytes);
+      if (err_value != CAL_SUCCESS)
+	{
+	  break;
+	}
+
+      /* Compute signature.  Note: RSA_sign() adds the appropriate DER
+       * encoded prefix internally.
+       */
+      hash_nid = get_NID (hash_alg);
+      if (!RSA_sign (hash_nid, rsa_in, rsa_inbytes, rsa_out,
+		     (unsigned int *) &rsa_outbytes, rsa))
+	{
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  fprintf (stderr, "Unable to generate signature");
+	  break;
+	}
+      else
+	{
+	  err_value = CAL_SUCCESS;
+	}
+
+      /* Copy signature to sig_buf and update sig_buf_bytes */
+      *sig_buf_bytes = rsa_outbytes;
+      memcpy (sig_buf, rsa_out, rsa_outbytes);
+    }
+  while (0);
+
+  if (err_value != CAL_SUCCESS)
+    {
+      ERR_print_errors_fp (stderr);
+    }
+
+  if (rsa)
+    RSA_free (rsa);
+  if (rsa_in)
+    OPENSSL_free (rsa_in);
+  if (rsa_out)
+    OPENSSL_free (rsa_out);
+  return err_value;
+}
+
+X509 *
+ENGINE_load_certificate (ENGINE * e, const char *cert_id)
+{
+  struct
+  {
+    const char *cerid;
+    X509 *cert;
+  } lcer;
+  lcer.cerid = cert_id;
+  lcer.cert = NULL;
+  if (!ENGINE_ctrl_cmd (e, "LOAD_CERT", 0, &lcer, NULL, 0))
+    {
+      ERR_print_errors_fp (stderr);
+      return NULL;
+    }
+  return lcer.cert;
+}
+
+int32_t
+gen_sig_data (const char *in_file, const char *cert_file,
+	      hash_alg_t hash_alg, sig_fmt_t sig_fmt, uint8_t * sig_buf,
+	      size_t * sig_buf_bytes, func_mode_t mode)
+{
+
+  int32_t err = CAL_SUCCESS;	   /**< Used for return value */
+
+  CMS_ContentInfo *cms = NULL;
+
+  /* HSM related configuration */
+  hsm_config_t hsm_conf;
+  char *hsm_object_id = NULL;
+  char *hsm_slot_id = NULL;
+  X509 *x509 = NULL;
+  BIO *cbio, *kbio, *out;
+  BIO *bio_in = NULL;	    /**< BIO for in_file data */
+  int32_t flags = CMS_DETACHED | CMS_NOCERTS | CMS_NOSMIMECAP | CMS_BINARY;
+  EVP_PKEY *pkey = NULL;
+  hsm_object_t *hsm_objects = NULL;
+  const EVP_MD *sign_md = NULL;
+  ENGINE *eng;
+
+  /* Check for valid arguments */
+  if ((!in_file) || (!cert_file) || (!sig_buf) || (!sig_buf_bytes))
+    {
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  /* read HSM related configuration */
+  err = read_hsm_config ("hsm.cfg", &hsm_conf, &hsm_objects);
+  if (err)
+    {
+      fprintf (stderr, "Error reading configuration file
");
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  OpenSSL_add_all_algorithms ();
+  ERR_load_crypto_strings ();
+  ENGINE_load_dynamic ();
+
+  /* Create the HSM engine */
+  eng = engine_hsm ();
+  if (NULL == eng)
+    {
+      printf ("Error: %s
", ERR_reason_error_string (ERR_get_error ()));
+      exit (1);
+      exit (1);
+    }
+
+  /* Load vendor's cryptoki implementation library */
+  ENGINE_ctrl_cmd_string (eng, "MODULE_PATH", hsm_conf.module_path, 0);
+  /* Set SLOT ID */
+  hsm_slot_id = (char *) malloc (16);
+  snprintf (hsm_slot_id, 16, "%d", hsm_conf.slot);
+  ENGINE_ctrl_cmd_string (eng, "SLOT_ID", hsm_slot_id, 0);
+  /* Set User PIN */
+  ENGINE_ctrl_cmd_string (eng, "PIN", hsm_conf.pin, 0);
+
+  /* Initialise HSM engine */
+  err = ENGINE_init (eng);
+  if (err < 0)
+    {
+      fprintf (stderr,
+	       "*TEST: ERROR, COULD NOT INITIALIZE ENGINE
	ENGINE_init(eng) == %d
",
+	       err);
+      exit (1);
+    }
+#ifdef USE_HSM_DIGESTS
+  /* Use digest capabilities of HSM */
+  if (!ENGINE_set_default_digests (eng))
+    {
+      fprintf (stderr, "failed to set engine '%s' as default DIGESTS", "hsm");
+      ENGINE_free (eng);
+      exit (1);
+    }
+#endif
+  /* Use RSA capabilities of HSM */
+  if (!ENGINE_set_default_RSA (eng))
+    {
+      fprintf (stderr, "failed to set engine '%s' as default RSA", "hsm");
+      ENGINE_free (eng);
+      exit (1);
+    }
+
+
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
+  /* Use ECDSA capabilities of HSM */
+  if (!ENGINE_set_default_EC (eng))
+    {
+#else
+  /* Use ECDSA capabilities of HSM */
+  if (!ENGINE_set_default_ECDSA (eng))
+    {
+#endif
+      fprintf (stderr, "failed to set engine '%s' as default ECDSA", "hsm");
+      ENGINE_free (eng);
+      exit (1);
+    }
+
+  ENGINE_register_complete (eng);
+
+  /* get associated object id from HSM */
+  hsm_object_t *ptr = hsm_objects;
+  while (ptr != NULL)
+    {
+      if (strcmp (ptr->file, cert_file) == 0)
+	{
+	  hsm_object_id = ptr->id;
+	  break;
+	}
+      ptr = ptr->next;
+    }
+
+  if (!hsm_object_id)
+    {
+      fprintf (stderr, "Error: Can't find Object ID associated to %s
",
+	       cert_file);
+      return -1;
+    }
+
+  x509 = ENGINE_load_certificate (eng, hsm_object_id);
+  if (!x509)
+    {
+      fprintf (stderr, "Unable to load cert with id %s
", hsm_object_id);
+      return CAL_CRYPTO_API_ERROR;
+    }
+  pkey = ENGINE_load_private_key (eng, hsm_object_id, NULL, NULL);
+  if (!pkey)
+    {
+      fprintf (stderr, "Unable to load key with id %s
", hsm_object_id);
+      return CAL_CRYPTO_API_ERROR;
+    }
+
+  if (sig_fmt == SIG_FMT_ECDSA)
+    {
+      err = gen_sig_data_ecdsa (in_file, pkey, hash_alg, sig_buf,
+				sig_buf_bytes);
+    }
+  else if (sig_fmt == SIG_FMT_PKCS1)
+    {
+      err = gen_sig_data_raw (in_file, pkey, hash_alg, sig_buf,
+			      (int32_t *) sig_buf_bytes);
+    }
+  else if (sig_fmt == SIG_FMT_CMS)
+    {
+      err = gen_sig_data_cms (in_file, x509, pkey, hash_alg, sig_buf,
+			      sig_buf_bytes);
+    }
+  else
+    {
+      fprintf (stderr, "Invalid signature format");
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  ENGINE_finish (eng);
+  ENGINE_free (eng);
+  ENGINE_cleanup ();
+
+  if (x509)
+    X509_free (x509);
+  if (pkey)
+    EVP_PKEY_free (pkey);
+
+  return err;
+
+}
+
+/*--------------------------
+ cms_to_buf
+ ---------------------------*/
+int32_t
+cms_to_buf (CMS_ContentInfo * cms, BIO * bio_in, uint8_t * data_buffer,
+	    size_t * data_buffer_size, int32_t flags)
+{
+  int32_t err_value = CAL_SUCCESS;
+  BIO *bio_out = NULL;
+  BUF_MEM *buffer_memory;	/**< Used with BIO functions */
+
+  buffer_memory = BUF_MEM_new ();
+  buffer_memory->length = 0;
+  buffer_memory->data = (char *) data_buffer;
+  buffer_memory->max = *data_buffer_size;
+
+  do
+    {
+      if (!(bio_out = BIO_new (BIO_s_mem ())))
+	{
+	  fprintf (stderr, "Unable to allocate CMS signature result memory");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      BIO_set_mem_buf (bio_out, buffer_memory, BIO_NOCLOSE);
+
+      /* Convert cms to der format */
+      if (!i2d_CMS_bio_stream (bio_out, cms, bio_in, flags))
+	{
+	  fprintf (stderr, "Unable to convert CMS signature to DER format");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Get the size of bio out in data_buffer_size */
+      *data_buffer_size = BIO_ctrl_pending (bio_out);
+    }
+  while (0);
+
+  if (bio_out)
+    BIO_free (bio_out);
+  return err_value;
+}
+
+/*--------------------------
+ calculate_hash
+ ---------------------------*/
+int32_t
+hsm_calculate_hash (const char *in_file, hash_alg_t hash_alg,
+		    uint8_t * buf, int32_t * pbuf_bytes)
+{
+  const EVP_MD *sign_md;       /**< Ptr to digest name */
+  int32_t bio_bytes;	   /**< Length of bio data */
+  BIO *in = NULL;	/**< Ptr to BIO for reading data from in_file */
+  BIO *bmd = NULL;	 /**< Ptr to BIO with hash bytes */
+  BIO *inp;	  /**< Ptr to BIO for appending in with bmd */
+	/** Status initialized to API error */
+  int32_t err_value = CAL_CRYPTO_API_ERROR;
+
+  sign_md = EVP_get_digestbyname (get_digest_name (hash_alg));
+  if (sign_md == NULL)
+    {
+      return CAL_INVALID_ARGUMENT;
+    }
+
+  /* Read data to generate hash */
+  do
+    {
+
+      /* Create necessary bios */
+      in = BIO_new (BIO_s_file ());
+      bmd = BIO_new (BIO_f_md ());
+      if (in == NULL || bmd == NULL)
+	{
+	  break;
+	}
+
+      /* Set BIO to read filename in_file */
+      if (BIO_read_filename (in, in_file) <= 0)
+	{
+	  break;
+	}
+
+      /* Set BIO md to given hash */
+      if (!BIO_set_md (bmd, sign_md))
+	{
+	  break;
+	}
+
+      /* Appends BIO in to bmd */
+      inp = BIO_push (bmd, in);
+
+      /* Read data from file BIO */
+      do
+	{
+	  bio_bytes = BIO_read (inp, (uint8_t *) buf, *pbuf_bytes);
+	}
+      while (bio_bytes > 0);
+
+      /* Check for read error */
+      if (bio_bytes < 0)
+	{
+	  break;
+	}
+
+      /* Get the hash */
+      bio_bytes = BIO_gets (inp, (char *) buf, *pbuf_bytes);
+      if (bio_bytes <= 0)
+	{
+	  break;
+	}
+
+      /* Send the output bytes in pbuf_bytes */
+      *pbuf_bytes = bio_bytes;
+      err_value = CAL_SUCCESS;
+    }
+  while (0);
+
+  if (in != NULL)
+    BIO_free (in);
+  if (bmd != NULL)
+    BIO_free (bmd);
+
+  return err_value;
+}
+
+void
+chomp (char *s)
+{
+  while (*s && *s != '
' && *s != '')
+    s++;
+  *s = 0;
+}
+
+/*--------------------------
+ generate_dek_key
+ ---------------------------*/
+int32_t
+generate_dek_key (uint8_t * key, int32_t len)
+{
+  if (gen_random_bytes (key, len) != CAL_SUCCESS)
+    {
+      return CAL_CRYPTO_API_ERROR;
+    }
+
+  return CAL_SUCCESS;
+}
+
+/*--------------------------
+ write_plaintext_dek_key
+ ---------------------------*/
+int32_t
+write_plaintext_dek_key (uint8_t * key, size_t key_bytes,
+			 const char *cert_file, const char *enc_file)
+{
+  int32_t err_value = CAL_SUCCESS;	 /**< Return value */
+  char err_str[MAX_ERR_STR_BYTES];	 /**< Used in preparing error message */
+  FILE *fh = NULL;	 /**< File handle used with file api */
+#ifdef DEBUG
+  int32_t i = 0;       /**< Used in for loops */
+#endif
+
+  UNUSED (cert_file);
+
+  do
+    {
+      /* Save the buffer into enc_file */
+      if ((fh = fopen (enc_file, "wb")) == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Unable to create binary file %s", enc_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      if (fwrite (key, 1, key_bytes, fh) != key_bytes)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Unable to write to binary file %s", enc_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      fclose (fh);
+    }
+  while (0);
+
+  return err_value;
+}
+
+/*--------------------------
+ encrypt_dek_key
+ ---------------------------*/
+int32_t
+encrypt_dek_key (uint8_t * key, size_t key_bytes,
+		 const char *cert_file, const char *enc_file)
+{
+  X509 *cert = NULL;	   /**< Ptr to X509 certificate read data */
+  STACK_OF (X509) * recips = NULL;	/**< Ptr to X509 stack */
+  CMS_ContentInfo *cms = NULL;	     /**< Ptr to cms structure */
+  const EVP_CIPHER *cipher = NULL;	 /**< Ptr to EVP_CIPHER */
+  int32_t err_value = CAL_SUCCESS;	 /**< Return value */
+  char err_str[MAX_ERR_STR_BYTES];	 /**< Used in preparing error message */
+  BIO *bio_key = NULL;	     /**< Bio for the key data to encrypt */
+  uint8_t *enc_buf = NULL;	  /**< Ptr for encoded key data */
+  FILE *fh = NULL;	 /**< File handle used with file api */
+  size_t cms_info_size = MAX_CMS_DATA;	     /**< Size of cms content info*/
+#ifdef DEBUG
+  int32_t i = 0;       /**< Used in for loops */
+#endif
+
+  do
+    {
+      /* Read the certificate from cert_file */
+      cert = read_certificate (cert_file);
+      if (!cert)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Cannot open certificate file %s", cert_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Create recipient STACK and add recipient cert to it */
+      recips = sk_X509_new_null ();
+
+      if (!recips || !sk_X509_push (recips, cert))
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Cannot instantiate object STACK_OF(%s)", cert_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /*
+       * sk_X509_pop_free will free up recipient STACK and its contents
+       * so set cert to NULL so it isn't freed up twice.
+       */
+      cert = NULL;
+
+      /* Instantiate correct cipher */
+      if (key_bytes == (AES_KEY_LEN_128 / BYTE_SIZE_BITS))
+	cipher = EVP_aes_128_cbc ();
+      else if (key_bytes == (AES_KEY_LEN_192 / BYTE_SIZE_BITS))
+	cipher = EVP_aes_192_cbc ();
+      else if (key_bytes == (AES_KEY_LEN_256 / BYTE_SIZE_BITS))
+	cipher = EVP_aes_256_cbc ();
+      if (cipher == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Invalid cipher used for encrypting key %s", enc_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Allocate memory buffer BIO for input key */
+      bio_key = BIO_new_mem_buf (key, key_bytes);
+      if (!bio_key)
+	{
+	  fprintf (stderr, "Unable to allocate BIO memory");
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Encrypt content of the key with certificate */
+      cms = CMS_encrypt (recips, bio_key, cipher, CMS_BINARY | CMS_STREAM);
+      if (cms == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Failed to encrypt key data");
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Finalize the CMS content info structure */
+      if (!CMS_final (cms, bio_key, NULL, CMS_BINARY | CMS_STREAM))
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Failed to finalize cms data");
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Alloc mem to convert cms to binary and save it into enc_file */
+      enc_buf = malloc (MAX_CMS_DATA);
+      if (enc_buf == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Failed to allocate memory");
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+
+      /* Copy cms info into enc_buf */
+      err_value = cms_to_buf (cms, bio_key, enc_buf, &cms_info_size,
+			      CMS_BINARY);
+
+      /* Save the buffer into enc_file */
+      if ((fh = fopen (enc_file, "wb")) == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Unable to create binary file %s", enc_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      if (fwrite (enc_buf, 1, cms_info_size, fh) != cms_info_size)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Unable to write to binary file %s", enc_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      fclose (fh);
+#ifdef DEBUG
+      printf ("Encoded key ;");
+      for (i = 0; i < key_bytes; i++)
+	{
+	  printf ("%02x ", enc_buf[i]);
+	}
+      printf ("
");
+#endif
+    }
+  while (0);
+
+  if (cms)
+    CMS_ContentInfo_free (cms);
+  if (cert)
+    X509_free (cert);
+  if (recips)
+    sk_X509_pop_free (recips, X509_free);
+  if (bio_key)
+    BIO_free (bio_key);
+  return err_value;
+}
+
+void
+handle_errors (char *str, int32_t * err_value, char *err_str)
+{
+  snprintf (err_str, MAX_ERR_STR_BYTES - 1, "%s", str);
+  *err_value = CAL_CRYPTO_API_ERROR;
+}
+
+int32_t
+encryptccm (unsigned char *plaintext, int plaintext_len,
+	    unsigned char *aad, int aad_len, unsigned char *key, int key_len,
+	    unsigned char *iv, int iv_len, const char *out_file,
+	    unsigned char *tag, int tag_len, int32_t * err_value,
+	    char *err_str)
+{
+
+#ifdef REMOVE_ENCRYPTION
+  UNUSED (plaintext);
+  UNUSED (plaintext_len);
+  UNUSED (aad);
+  UNUSED (aad_len);
+  UNUSED (key);
+  UNUSED (key_len);
+  UNUSED (iv);
+  UNUSED (iv_len);
+  UNUSED (out_file);
+  UNUSED (tag);
+  UNUSED (tag_len);
+  UNUSED (err_value);
+  UNUSED (err_str);
+
+  return CAL_NO_CRYPTO_API_ERROR;
+#else
+  EVP_CIPHER_CTX *ctx;
+
+  int len;
+  int ciphertext_len;
+
+  unsigned char ciphertext[plaintext_len + EVP_MAX_BLOCK_LENGTH];
+
+  FILE *fho = NULL;
+  int err = 0;
+  do
+    {
+      /* Create and initialise the context */
+      if (!(ctx = EVP_CIPHER_CTX_new ()))
+	{
+	  handle_errors ("Failed to allocate ccm context structure",
+			 err_value, err_str);
+	  break;
+	}
+
+      /* Initialise the encryption operation. */
+      switch (key_len)
+	{
+	case 16:
+	  err =
+	    EVP_EncryptInit_ex (ctx, EVP_aes_128_ccm (), NULL, NULL, NULL);
+	  break;
+	case 24:
+	  err =
+	    EVP_EncryptInit_ex (ctx, EVP_aes_192_ccm (), NULL, NULL, NULL);
+	  break;
+	case 32:
+	  err =
+	    EVP_EncryptInit_ex (ctx, EVP_aes_256_ccm (), NULL, NULL, NULL);
+	  break;
+	default:
+	  handle_errors ("Failed to allocate ccm context structure",
+			 err_value, err_str);
+	  return *err_value;
+	}
+
+      if (err != 1)
+	{
+	  handle_errors ("Failed to initialize ccm context structure",
+			 err_value, err_str);
+	  break;
+	}
+
+      /*
+       * Setting IV len to 7. Not strictly necessary as this is the default
+       * but shown here for the purposes of this example
+       */
+      if (1 !=
+	  EVP_CIPHER_CTX_ctrl (ctx, EVP_CTRL_CCM_SET_IVLEN, iv_len, NULL))
+	{
+	  handle_errors ("Failed to initialize IV", err_value, err_str);
+	  break;
+	}
+
+      /* Set tag length */
+      EVP_CIPHER_CTX_ctrl (ctx, EVP_CTRL_CCM_SET_TAG, tag_len, NULL);
+
+      /* Initialise key and IV */
+      if (1 != EVP_EncryptInit_ex (ctx, NULL, NULL, key, iv))
+	{
+	  handle_errors ("Failed to intialize key", err_value, err_str);
+	  break;
+	}
+
+      /* Provide the total plaintext length */
+      if (1 != EVP_EncryptUpdate (ctx, NULL, &len, NULL, plaintext_len))
+	{
+	  handle_errors ("Failed to initialize length parameter", err_value,
+			 err_str);
+	  break;
+	}
+
+      /*
+       * Provide the message to be encrypted, and obtain the encrypted output.
+       * EVP_EncryptUpdate can only be called once for this
+       */
+      if (1 != EVP_EncryptUpdate (ctx, ciphertext, &len, plaintext,
+				  plaintext_len))
+	{
+	  handle_errors ("Failed to encrypt", err_value, err_str);
+	  break;
+	}
+      ciphertext_len = len;
+
+      /* Open out_file for writing */
+      fho = fopen (out_file, "wb");
+      if (fho == NULL)
+	{
+	  handle_errors ("Cannot open file", err_value, err_str);
+	  break;
+	}
+
+      /* Write encrypted data to out file */
+      if (fwrite (ciphertext, 1, ciphertext_len, fho) != ciphertext_len)
+	{
+	  handle_errors ("Cannot write file", err_value, err_str);
+	  break;
+	}
+
+      /*
+       * Finalise the encryption. Normally ciphertext bytes may be written at
+       * this stage, but this does not occur in CCM mode
+       */
+      if (1 != EVP_EncryptFinal_ex (ctx, ciphertext + len, &len))
+	{
+	  handle_errors ("Failed to finalize", err_value, err_str);
+	  break;
+	}
+      ciphertext_len += len;
+
+      /* Get the tag */
+      if (1 != EVP_CIPHER_CTX_ctrl (ctx, EVP_CTRL_CCM_GET_TAG, 16, tag))
+	{
+	  handle_errors ("Failed to get tag", err_value, err_str);
+	  break;
+	}
+
+    }
+  while (0);
+
+  /* Clean up */
+  EVP_CIPHER_CTX_free (ctx);
+
+  if (fho)
+    {
+      fclose (fho);
+    }
+
+  return *err_value;
+#endif
+}
+
+/*--------------------------
+ gen_auth_encrypted_data
+ ---------------------------*/
+int32_t
+gen_auth_encrypted_data (const char *in_file, const char *out_file,
+			 aead_alg_t aead_alg, uint8_t * aad, size_t aad_bytes,
+			 uint8_t * nonce, size_t nonce_bytes, uint8_t * mac,
+			 size_t mac_bytes, size_t key_bytes,
+			 const char *cert_file, const char *key_file,
+			 int reuse_dek)
+{
+  int32_t err_value = CAL_SUCCESS;	 /**< status of function calls */
+  char err_str[MAX_ERR_STR_BYTES];	 /**< Array to hold error string */
+  uint8_t key[MAX_AES_KEY_LENGTH];	 /**< Buffer for random key */
+  FILE *fh = NULL;	 /**< Used with files */
+  size_t file_size;	  /**< Size of in_file */
+  unsigned char *plaintext = NULL;	 /**< Array to read file data */
+  int32_t bytes_read;
+#ifdef DEBUG
+  int32_t i;	   /**< used in for loops */
+#endif
+
+  UNUSED (aead_alg);
+
+  do
+    {
+      /* Generate Nonce */
+      err_value = gen_random_bytes ((uint8_t *) nonce, nonce_bytes);
+      if (err_value != CAL_SUCCESS)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1, "Failed to get nonce");
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+#ifdef DEBUG
+      printf ("nonce bytes: ");
+      for (i = 0; i < nonce_bytes; i++)
+	{
+	  printf ("%02x ", nonce[i]);
+	}
+      printf ("
");
+#endif
+      if (reuse_dek)
+	{
+	  fh = fopen (key_file, "rb");
+	  if (fh == NULL)
+	    {
+	      snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+			"Unable to open dek file %s", key_file);
+	      fprintf (stderr, err_str);
+	      err_value = CAL_FILE_NOT_FOUND;
+	      break;
+	    }
+	  /* Read encrypted data into input_buffer */
+	  bytes_read = fread (key, 1, key_bytes, fh);
+	  if (bytes_read == 0)
+	    {
+	      snprintf (err_str, MAX_ERR_STR_BYTES - 1, "Cannot read file %s",
+			key_file);
+	      fprintf (stderr, err_str);
+	      err_value = CAL_FILE_NOT_FOUND;
+	      fclose (fh);
+	      break;
+	    }
+	  fclose (fh);
+	}
+      else
+	{
+	  /* Generate random aes key to use it for encrypting data */
+	  err_value = generate_dek_key (key, key_bytes);
+	  if (err_value)
+	    {
+	      snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+			"Failed to generate random key");
+	      fprintf (stderr, err_str);
+	      err_value = CAL_CRYPTO_API_ERROR;
+	      break;
+	    }
+	}
+
+#ifdef DEBUG
+      printf ("random key : ");
+      for (i = 0; i < key_bytes; i++)
+	{
+	  printf ("%02x ", key[i]);
+	}
+      printf ("
");
+#endif
+      if (cert_file != NULL)
+	{
+	  /* Encrypt key using cert file and save it in the key_file */
+	  err_value = encrypt_dek_key (key, key_bytes, cert_file, key_file);
+	  if (err_value)
+	    {
+	      snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+			"Failed to encrypt and save key");
+	      fprintf (stderr, err_str);
+	      err_value = CAL_CRYPTO_API_ERROR;
+	      break;
+	    }
+	}
+      else
+	{
+	  /* Save key in the key_file */
+	  err_value = write_plaintext_dek_key (key, key_bytes, cert_file,
+					       key_file);
+	  if (err_value)
+	    {
+	      snprintf (err_str, MAX_ERR_STR_BYTES - 1, "Failed to save key");
+	      fprintf (stderr, err_str);
+	      err_value = CAL_CRYPTO_API_ERROR;
+	      break;
+	    }
+	}
+      /* Get the size of in_file */
+      fh = fopen (in_file, "rb");
+      if (fh == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Unable to open binary file %s", in_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      fseek (fh, 0, SEEK_END);
+      file_size = ftell (fh);
+      plaintext = (unsigned char *) malloc (file_size);
+      ;
+      if (plaintext == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1,
+		    "Not enough allocated memory");
+	  fprintf (stderr, err_str);
+	  err_value = CAL_CRYPTO_API_ERROR;
+	  break;
+	}
+      fclose (fh);
+
+      fh = fopen (in_file, "rb");
+      if (fh == NULL)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1, "Cannot open file %s",
+		    in_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_FILE_NOT_FOUND;
+	  break;
+	}
+
+      /* Read encrypted data into input_buffer */
+      bytes_read = fread (plaintext, 1, file_size, fh);
+      /* Reached EOF? */
+      if (bytes_read == 0)
+	{
+	  snprintf (err_str, MAX_ERR_STR_BYTES - 1, "Cannot read file %s",
+		    out_file);
+	  fprintf (stderr, err_str);
+	  err_value = CAL_FILE_NOT_FOUND;
+	  break;
+	}
+
+      err_value = encryptccm (plaintext, file_size, aad, aad_bytes, key,
+			      key_bytes, nonce, nonce_bytes, out_file, mac,
+			      mac_bytes, &err_value, err_str);
+      if (err_value == CAL_NO_CRYPTO_API_ERROR)
+	{
+	  printf ("Encryption not enabled
");
+	  break;
+	}
+    }
+  while (0);
+
+  free (plaintext);
+
+  /* Clean up */
+  return err_value;
+}
diff --git a/release/code/back_end-hsm/src/config.c b/release/code/back_end-hsm/src/config.c
new file mode 100644
index 0000000..263771e
--- /dev/null
+++ b/release/code/back_end-hsm/src/config.c
@@ -0,0 +1,101 @@
+/*===========================================================================*/
+/**
+ @file    config.c
+
+ @brief   Implements an interface to load HSM related configuration and HSM objects
+ binding table.
+
+ @verbatim
+ =============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+ =============================================================================
+ @endverbatim */
+ 
+#include <config.h>
+
+int read_hsm_config(const char* config_file, hsm_config_t * config,
+		hsm_object_t** hsm_objects) {
+	/* When you are calling config_destroy() library will free all the memory allocated by it. */
+	/* So before calling config_destroy() you need to save your result some where else. */
+
+	config_t cfg, *cf;
+	const char *hsm_module = NULL;
+	const char *hsm_user = NULL;
+	const char *hsm_pin = NULL;
+	long long hsm_slot = 0;
+	config_setting_t *setting = NULL;
+	hsm_object_t * chsm_objects = NULL;
+
+	cf = &cfg;
+	config_init(cf);
+
+	if (!config_read_file(cf, config_file)) {
+		fprintf(stderr, "Error reading configuration file %s:%d - %s
",
+				config_error_file(cf), config_error_line(cf),
+				config_error_text(cf));
+		config_destroy(cf);
+		return 1;
+	}
+
+	if (config_lookup_string(cf, "hsm.module", &hsm_module)) {
+		strcpy(config->module_path, hsm_module);
+	} else {
+		printf("=> PKCS#11 MODULE PATH: ");
+		scanf("%256s", config->module_path);
+	}
+
+	if (config_lookup_string(cf, "hsm.pin", &hsm_pin)) {
+		strcpy(config->pin, hsm_pin);
+	} else {
+		printf("=> PIN: ");
+		scanf("%32s", config->pin);
+	}
+	if (config_lookup_int64(cf, "hsm.slot", &hsm_slot)) {
+		config->slot = hsm_slot;
+	} else {
+		printf("=> SLOT: ");
+		scanf("%ld", &config->slot);
+	}
+
+	/* Output a list of file-id mapping . */
+	setting = config_lookup(&cfg, "hsm.objects");
+	if (setting != NULL) {
+		unsigned int count = config_setting_length(setting);
+		unsigned int i;
+
+		for (i = 0; i < count; ++i) {
+			config_setting_t *hsm_object = config_setting_get_elem(setting, i);
+
+			const char *file, *id;
+
+			if (!(config_setting_lookup_string(hsm_object, "id", &id)
+					&& config_setting_lookup_string(hsm_object, "file", &file)))
+				continue;
+
+			hsm_object_t *hobject;
+			hobject = (hsm_object_t *) malloc(sizeof(hsm_object_t));
+
+			strcpy(hobject->id, id);
+			strcpy(hobject->file, file);
+
+			hobject->next = chsm_objects;
+			chsm_objects = hobject;
+
+		}
+
+		*hsm_objects = chsm_objects;
+
+	}
+
+	config_destroy(&cfg);
+
+	return 0;
+
+}
diff --git a/release/code/back_end-hsm/src/e_hsm.c b/release/code/back_end-hsm/src/e_hsm.c
new file mode 100644
index 0000000..a4dff1f
--- /dev/null
+++ b/release/code/back_end-hsm/src/e_hsm.c
@@ -0,0 +1,2074 @@
+/*===========================================================================*/
+/**
+ @file    e_hsm.c
+
+ @brief   Implements a built-in OpenSSL engine to provide a backend replacement
+ for Code-Signing Tool to support Hardware Security Module (HSM).  
+ It plugs in alternative implementations for OpenSSL to perform cryptographic 
+ operations requested to sign codes for the NXP High Assurance Boot (HAB) 
+ and Advanced  High Assurance Boot (AHAB).
+
+ The engine re-writes an implementation of RSA private encrypt function, 
+ ECDSA sign function and how public certificates and private keys are loaded
+ from the HSM to the appropriate data structure X509, RSA, EVP_PKEY and EC_KEY. 
+ 
+ Optionally SHA digest functions can be re-written also to be performed at the HSM level.
+
+ @verbatim
+ =============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+ =============================================================================
+ @endverbatim */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <pthread.h>
+#include <assert.h>
+#include <dlfcn.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <openssl/e_os2.h>
+#include <openssl/ossl_typ.h>
+#include <openssl/engine.h>
+#include <openssl/err.h>
+#include <openssl/bn.h>
+#include <openssl/pem.h>
+#include <openssl/rsa.h>
+#include <openssl/ecdsa.h>
+#include <openssl/objects.h>
+
+#ifndef OPENSSL_NO_HW
+#ifndef OPENSSL_NO_HW_HSM
+#include <cryptoki.h>
+#include <e_hsm_err.h>
+#include <e_hsm.h>
+#include <pkcs-11v2-20a3.h>
+
+#ifdef OLDER_OPENSSL
+#define MD_DATA(ctx) ((struct hsm_digest_ctx *)(ctx->md_data))
+#else
+#define MD_DATA(ctx) ((struct hsm_digest_ctx *)(EVP_MD_CTX_md_data(ctx)))
+#endif
+
+#ifdef HSM_DEBUG
+#define dbg_fprintf(args...) do { fprintf(stderr, args); fflush(stderr); } while (0)
+#else
+#define dbg_fprintf(args...)
+#endif
+/* Engine id & name used when creating the ENGINE */
+static const char *engine_hsm_id = "hsm";
+static const char *engine_hsm_name =
+  "Hardware Security Module engine support";
+/* Pointer to a CK_FUNCTION_LIST structure containing the function pointers to the standard PKCS#11 cryptoki library functions. */
+static CK_FUNCTION_LIST_PTR pFunctionList = NULL;
+/* Name of C_GetFunctionList function */
+static const char HSM_GET_FUNCTION_LIST[] = "C_GetFunctionList";
+#define SSL_SIG_LENGTH	36
+#define KEY_STORE 1
+static CK_BBOOL true = TRUE;
+static CK_BBOOL false = FALSE;
+
+#ifndef OPENSSL_NO_RSA
+/* Index for add handler of private key to RSA */
+static int rsa_privkey_idx = -1;
+/* Index for add handler of session to RSA */
+static int rsa_session_idx = -1;
+#endif
+
+#ifndef OPENSSL_NO_ECDSA
+/* Index for add handler of private key to ECDSA */
+static int ecdsa_privkey_idx = -1;
+static int ecdsa_session_idx = -1;
+#endif
+
+/* Initialization flag */
+static int HSM_Initialized = 0;
+
+/* DSO handle used for loading and unloading Cryptoki library library. */
+void *hsm_dso = NULL;
+
+/* DSO file name or path. .so on Linux or .dll on windows */
+char *HSM_LIBNAME = NULL;
+
+#if defined(WIN32)
+#define DLOPEN_FLAG RTLD_LAZY
+#else
+#define DLOPEN_FLAG (RTLD_NOW | RTLD_LOCAL)
+#endif
+
+/* The definitions for control commands specific to this engine */
+static const ENGINE_CMD_DEFN hsm_cmd_defns[] = { {HSM_CMD_MODULE_PATH,
+						  "MODULE_PATH",
+						  "Specifies the path to the 'pkcs#11' shared library",
+						  ENGINE_CMD_FLAG_STRING},
+  {HSM_CMD_SLOT_ID, "SLOT_ID",
+   "Specifies the slot containing the token to use",
+   ENGINE_CMD_FLAG_NUMERIC}, {HSM_CMD_PIN, "PIN", "Specifies the PIN",
+			      ENGINE_CMD_FLAG_STRING}, {HSM_CMD_LOAD_CERT,
+							"LOAD_CERT",
+							"Load certificate from token",
+							ENGINE_CMD_FLAG_STRING},
+  {0, NULL,
+   NULL, 0}
+};
+
+/* Engine constructor */
+ENGINE *engine_hsm (void);
+/* Needed if the ENGINE is being compiled into a self-contained shared-library. */
+static int bind_hsm (ENGINE * e);
+
+/* Initialisation function */
+static int hsm_init (ENGINE * e);
+static int hsm_finish (ENGINE * e);
+static int hsm_ctrl (ENGINE * e, int cmd, long i, void *p, void (*f) ());
+/* Destructor (complements the "engine_hsm()" constructor) */
+static int hsm_destroy (ENGINE * e);
+
+/* RSA functions */
+#ifndef OPENSSL_NO_RSA
+static int hsm_RSA_private_encrypt (int flen, const unsigned char *from,
+				    unsigned char *to, RSA * rsa,
+				    int padding);
+static int hsm_RSA_init (RSA * rsa);
+static int hsm_RSA_finish (RSA * rsa);
+#endif
+
+/* ECDSA functions */
+#ifndef OPENSSL_NO_ECDSA
+int hsm_ECDSA_sign_setup (EC_KEY * eckey, BN_CTX * ctx_in, BIGNUM ** kinvp,
+			  BIGNUM ** rp);
+static ECDSA_SIG *hsm_ECDSA_sign (const unsigned char *dgst, int dgst_len,
+				  const BIGNUM * kinv, const BIGNUM * rp,
+				  EC_KEY * ecdsa);
+#endif
+
+/* Digest functions */
+static inline int hsm_digest_init (EVP_MD_CTX * ctx, int alg);
+static int hsm_digest_update (EVP_MD_CTX * ctx, const void *in, size_t len);
+static int hsm_digest_copy (EVP_MD_CTX * out, const EVP_MD_CTX * in);
+static int hsm_digest_finish (EVP_MD_CTX * ctx, unsigned char *md);
+static inline int hsm_digest_cleanup (EVP_MD_CTX * ctx);
+/* SHA initialization functions */
+static inline int hsm_sha1_init (EVP_MD_CTX * ctx);
+static inline int hsm_sha224_init (EVP_MD_CTX * ctx);
+static inline int hsm_sha256_init (EVP_MD_CTX * ctx);
+static inline int hsm_sha384_init (EVP_MD_CTX * ctx);
+static inline int hsm_sha512_init (EVP_MD_CTX * ctx);
+
+static int pre_init_hsm (ENGINE * e);
+static int hsm_engine_digests (ENGINE * e, const EVP_MD ** digest,
+			       const int **nids, int nid);
+/* Hex string decoder */
+static unsigned char *hex2bin (const char *hexstr, size_t * size);
+/* Token and session management */
+struct token_session *hsm_get_session (void);
+void hsm_register_token (ENGINE * e, struct _token *tok);
+struct _token *hsm_add_token (CK_SLOT_ID slot_id);
+
+/* Wrapper for hsm_find_certificate */
+int load_certificate (ENGINE * e, void *p);
+/* Public certificate loader. It loads cert by id in DER format and convert it to PEM */
+static X509 *hsm_find_certificate (ENGINE * e, const char *cert_id);
+/* Private key loader. It only loads exponent and modulus together with object handler on token */
+static EVP_PKEY *hsm_load_privkey (ENGINE *, const char *key_id,
+				   UI_METHOD * ui_method,
+				   void *callback_data);
+
+#define HSM_MAX_ALGS 20
+
+
+#ifdef OPENSSL_NO_DYNAMIC_ENGINEX
+/* engine constructor */
+ENGINE *
+engine_hsm (void)
+{
+  hsm_token_list = NULL;
+  hsm_token = NULL;
+  dbg_fprintf ("%s
", __FUNCTION__);
+  ENGINE *ret = ENGINE_new ();
+  if (!ret)
+    {
+      return NULL;
+    }
+  if (!bind_helper (ret))
+    {
+      ENGINE_free (ret);
+      return NULL;
+    }
+  return ret;
+}
+
+void
+ENGINE_load_hsm (void)
+{
+  ENGINE *toadd = engine_hsm ();
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (!toadd)
+    return;
+  ENGINE_add (toadd);
+  ENGINE_free (toadd);
+  ERR_clear_error ();
+}
+#else
+static int
+bind_helper (ENGINE * e, const char *id)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if ((NULL != id) && (strcmp (id, engine_hsm_id) != 0))
+    return 0;
+  return (bind_hsm (e));
+}
+
+IMPLEMENT_DYNAMIC_CHECK_FN ()IMPLEMENT_DYNAMIC_BIND_FN (bind_helper)
+#endif
+     static int
+       num_digest_nids = 0;
+#ifdef OLDER_OPENSSL
+
+     const EVP_MD
+       hsm_sha1 = { NID_sha1, NID_sha1WithRSAEncryption,
+       SHA_DIGEST_LENGTH, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE, hsm_sha1_init,
+       hsm_digest_update, hsm_digest_finish, hsm_digest_copy,
+       hsm_digest_cleanup, EVP_PKEY_RSA_method, SHA_CBLOCK,
+       sizeof (struct hsm_digest_ctx)
+     };
+
+const EVP_MD hsm_sha224 = { NID_sha224, NID_sha224WithRSAEncryption,
+  SHA224_DIGEST_LENGTH, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE,
+  hsm_sha224_init, hsm_digest_update, hsm_digest_finish, hsm_digest_copy,
+  hsm_digest_cleanup, EVP_PKEY_RSA_method, SHA256_CBLOCK,
+  sizeof (struct hsm_digest_ctx)
+};
+
+const EVP_MD hsm_sha256 = { NID_sha256, NID_sha256WithRSAEncryption,
+  SHA256_DIGEST_LENGTH, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE,
+  hsm_sha256_init, hsm_digest_update, hsm_digest_finish, hsm_digest_copy,
+  hsm_digest_cleanup, EVP_PKEY_RSA_method, SHA256_CBLOCK,
+  sizeof (struct hsm_digest_ctx)
+};
+
+const EVP_MD hsm_sha384 = { NID_sha384, NID_sha384WithRSAEncryption,
+  SHA384_DIGEST_LENGTH, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE,
+  hsm_sha384_init, hsm_digest_update, hsm_digest_finish, hsm_digest_copy,
+  hsm_digest_cleanup, EVP_PKEY_RSA_method, SHA512_CBLOCK,
+  sizeof (struct hsm_digest_ctx)
+};
+
+const EVP_MD hsm_sha512 = { NID_sha512, NID_sha512WithRSAEncryption,
+  SHA512_DIGEST_LENGTH, EVP_MD_FLAG_PKEY_METHOD_SIGNATURE,
+  hsm_sha512_init, hsm_digest_update, hsm_digest_finish, hsm_digest_copy,
+  hsm_digest_cleanup, EVP_PKEY_RSA_method, SHA512_CBLOCK,
+  sizeof (struct hsm_digest_ctx)
+};
+
+#else
+
+#define DECLARE_DIGEST_EVP(dig, len, enc)				      \
+	static EVP_MD *dig##_md = NULL;						      \
+	static const EVP_MD *hsm_##dig(void)					      \
+	{									      \
+		if (dig##_md == NULL) {						      \
+			EVP_MD *md;						      \
+			if (( md = EVP_MD_meth_new(NID_##dig,			      \
+							NID_##dig##WithRSA##enc)) == NULL     \
+					|| !EVP_MD_meth_set_result_size(md, len##_DIGEST_LENGTH)   \
+					|| !EVP_MD_meth_set_input_blocksize(md, len##_CBLOCK)      \
+					|| !EVP_MD_meth_set_app_datasize(md, 		      \
+						sizeof(struct hsm_digest_ctx))     \
+					|| !EVP_MD_meth_set_flags(md, 0)			      \
+					|| !EVP_MD_meth_set_init(md, hsm_##dig##_init)	      \
+					|| !EVP_MD_meth_set_update(md, hsm_digest_update)	      \
+					|| !EVP_MD_meth_set_final(md, hsm_digest_finish)	      \
+					|| !EVP_MD_meth_set_copy(md, hsm_digest_copy)	      \
+					|| !EVP_MD_meth_set_cleanup(md, hsm_digest_cleanup)) {  \
+				EVP_MD_meth_free(md);				      \
+				md = NULL;					      \
+			}							      \
+			dig##_md = md;						      \
+		}								      \
+		return dig##_md;						      \
+	}									      \
+	\
+	static void hsm_##dig##_destroy(void)				      \
+	{									      \
+		EVP_MD_meth_free(dig##_md);					      \
+		dig##_md = NULL;						      \
+	}
+
+DECLARE_DIGEST_EVP (sha1, SHA, Encryption)
+DECLARE_DIGEST_EVP (sha224, SHA256, Encryption)
+DECLARE_DIGEST_EVP (sha256, SHA256, Encryption)
+DECLARE_DIGEST_EVP (sha384, SHA512, Encryption)
+DECLARE_DIGEST_EVP (sha512, SHA512, Encryption)
+#endif
+#ifndef OPENSSL_NO_RSA
+#ifdef OLDER_OPENSSL
+/*To sign images for HAB it is enough to implement rsa_priv_encrypt interface */
+     static RSA_METHOD hsm_rsa = { "PKCS#11 RSA", NULL,	/* rsa_pub_encrypt */
+       NULL,			/* rsa_pub_decrypt */
+       hsm_RSA_private_encrypt,	/* rsa_priv_encrypt */
+       NULL,			/* rsa_priv_decrypt */
+       NULL,			/* rsa_mod_exp */
+       NULL,			/* bn_mod_exp */
+       hsm_RSA_init,		/* init */
+       hsm_RSA_finish,		/* finish */
+       RSA_FLAG_SIGN_VER,	/* flags */
+       NULL,			/* app_data */
+       NULL,			/* rsa_sign */
+       NULL,			/* rsa_verify */
+       NULL			/* rsa_generate_key */
+     };
+#else
+     static RSA_METHOD *hsm_rsa = NULL;
+#endif
+
+/*RSA_METHOD *HSM_RSA(void)
+{
+return(&hsm_rsa);
+}*/
+#endif
+
+#ifndef OPENSSL_NO_ECDSA
+#ifdef OLDER_OPENSSL
+     static ECDSA_METHOD hsm_ecdsa = { "PKCS#11 ECDSA", hsm_ECDSA_sign,
+       hsm_ECDSA_sign_setup, NULL,	/* cdsa_do_verify */
+#if 0
+       NULL,			/* init */
+       NULL,			/* finish */
+#endif
+       0,			/* flags */
+       NULL			/* app_data */
+     };
+#else
+     static ECDSA_METHOD *hsm_ecdsa = NULL;
+#endif
+
+
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
+     static EC_KEY_METHOD *hsm_ec_meth = NULL;
+#endif
+
+/*ECDSA_METHOD *HSM_ECDSA(void)
+{
+return(&hsm_ecdsa);
+}*/
+#endif
+
+/* fork handler */
+     void hsm_atfork_init (void)
+{
+  dbg_fprintf ("hsm_atfork_init: called (pid %d)
", getpid ());
+  HSM_Initialized = 0;
+}
+
+/* On error, exit with error message and token return value */
+#define hsm_die(fn, reason, rv) \
+	{ \
+		char errbuf[20]; \
+		hsm_err(fn, reason); \
+		sprintf(errbuf, "%lx", rv); \
+		ERR_add_error_data(2, "HSM CK_RV=0x", errbuf); \
+	}
+
+struct token_session *
+hsm_get_session (void)
+{
+  CK_RV rv;
+  struct token_session *wrapper;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (!hsm_token)
+    {
+      hsm_err (HSM_F_GETSESSION, HSM_R_NO_SLOT_SELECTED);
+      return NULL;
+    }
+
+  wrapper = OPENSSL_malloc (sizeof (struct token_session));
+  if (!wrapper)
+    {
+      hsm_err (HSM_F_GETSESSION, HSM_R_MALLOC_FAILURE);
+      return NULL;
+    }
+  wrapper->token = hsm_token;
+
+  if (!HSM_Initialized)
+    {
+      rv = pFunctionList->C_Initialize (NULL);
+      if (rv != CKR_OK && rv != CKR_CRYPTOKI_ALREADY_INITIALIZED)
+	{
+	  hsm_die (HSM_F_GETSESSION, HSM_R_INITIALIZE, rv);
+	  return NULL;
+	}
+      HSM_Initialized = 1;
+    }
+
+  rv = pFunctionList->C_OpenSession (wrapper->token->slot_id,
+				     CKF_SERIAL_SESSION | CKF_RW_SESSION,
+				     NULL_PTR, NULL_PTR, &wrapper->session);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_GETSESSION, HSM_R_OPENSESSION, rv);
+      return NULL;
+    }
+
+  if (wrapper->token->pin)
+    {
+      rv = pFunctionList->C_Login (wrapper->session, CKU_USER,
+				   (CK_UTF8CHAR *) wrapper->token->pin,
+				   (CK_ULONG) strlen (wrapper->token->pin));
+
+      if (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN)
+	{
+	  hsm_die (HSM_F_GETSESSION, HSM_R_LOGIN, rv);
+	  return NULL;
+	}
+    }
+
+  return wrapper;
+}
+
+/* needed if the ENGINE is being compiled into a self-contained shared-library. */
+static int
+bind_hsm (ENGINE * e)
+{
+
+  int ret = 0;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  ERR_load_hsm_strings ();
+
+  if (!ENGINE_set_id (e, engine_hsm_id)
+      || !ENGINE_set_name (e, engine_hsm_name)
+      || !ENGINE_set_ctrl_function (e, hsm_ctrl)
+      || !ENGINE_set_init_function (e, hsm_init)
+      || !ENGINE_set_cmd_defns (e, hsm_cmd_defns)
+      || !ENGINE_set_destroy_function (e, hsm_destroy)
+      || !ENGINE_set_finish_function (e, hsm_finish)
+#ifdef USE_HSM_DIGESTS
+      || !ENGINE_set_digests (e, hsm_engine_digests)
+#endif
+    )
+    {
+      dbg_fprintf ("bind_hsm failed
");
+      goto end;
+    }
+  ret = 1;
+end:return ret;
+}
+
+#ifdef ENGINE_DYNAMIC_SUPPORT
+static int
+bind_helper (ENGINE * e, const char *id)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (id && (strcmp (id, engine_hsm_id) != 0))
+    return 0;
+  if (!bind_hsm (e))
+    return 0;
+  return 1;
+}
+
+IMPLEMENT_DYNAMIC_CHECK_FN ()IMPLEMENT_DYNAMIC_BIND_FN (bind_helper)
+#else
+ENGINE *
+engine_hsm (void)
+{
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  ENGINE *ret = ENGINE_new ();
+  if (!ret)
+    return NULL;
+  if (!bind_hsm (ret))
+    {
+      ENGINE_free (ret);
+      return NULL;
+    }
+
+  return ret;
+}
+
+void
+ENGINE_load_hsm (void)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  ENGINE *e_hsm = engine_hsm ();
+  if (!e_hsm)
+    return;
+  ENGINE_add (e_hsm);
+  ENGINE_free (e_hsm);
+  ERR_clear_error ();
+}
+#endif
+
+static int
+get_hsm_digests (const int **retnids)
+{
+  static int nids[HSM_MAX_ALGS];
+  int i, count = 0, *hsm_implemented_digests;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (hsm_token)
+    hsm_implemented_digests = hsm_token->hsm_implemented_digests;
+  else
+    {
+      hsm_err (HSM_F_GET_HSM_DIGESTS, HSM_R_NO_SLOT_SELECTED);
+      return 0;
+    }
+
+  memset (nids, 0, sizeof (nids));
+  *retnids = NULL;
+
+  for (i = 0; i < NUM_NID; i++)
+    {
+      if (hsm_implemented_digests[i])
+	{
+	  nids[count++] = i;
+	}
+    }
+
+  if (count)
+    *retnids = nids;
+
+  return count;
+}
+
+static int
+hsm_engine_digests (ENGINE * e, const EVP_MD ** digest,
+		    const int **nids, int nid)
+{
+  int ret = 1;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (!digest)
+    {
+      return get_hsm_digests (nids);
+    }
+  if (!hsm_token)
+    {
+      hsm_err (HSM_F_ENGINE_DIGESTS, HSM_R_NO_SLOT_SELECTED);
+      return 0;
+    }
+  if (hsm_token->hsm_implemented_digests[nid])
+    {
+      switch (nid)
+	{
+	case NID_sha1:
+#ifdef OLDER_OPENSSL
+	  *digest = &hsm_sha1;
+#else
+	  *digest = hsm_sha1 ();
+#endif
+	  break;
+	case NID_sha224:
+#ifdef OLDER_OPENSSL
+	  *digest = &hsm_sha224;
+#else
+	  *digest = hsm_sha224 ();
+#endif
+	  break;
+	case NID_sha256:
+#ifdef OLDER_OPENSSL
+	  *digest = &hsm_sha256;
+#else
+	  *digest = hsm_sha256 ();
+#endif
+	  break;
+	case NID_sha384:
+#ifdef OLDER_OPENSSL
+	  *digest = &hsm_sha384;
+#else
+	  *digest = hsm_sha384 ();
+#endif
+	  break;
+	case NID_sha512:
+#ifdef OLDER_OPENSSL
+	  *digest = &hsm_sha512;
+#else
+	  *digest = hsm_sha512 ();
+#endif
+	  break;
+	default:
+	  *digest = NULL;
+	  ret = 0;
+	  break;
+	}
+    }
+  return ret;
+}
+
+static const char *
+get_HSM_LIBNAME (void)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (HSM_LIBNAME)
+    return HSM_LIBNAME;
+}
+
+static void
+free_HSM_LIBNAME (void)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (HSM_LIBNAME)
+    OPENSSL_free ((void *) HSM_LIBNAME);
+  HSM_LIBNAME = NULL;
+}
+
+long
+set_HSM_LIBNAME (const char *name)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+  free_HSM_LIBNAME ();
+  return ((HSM_LIBNAME = BUF_strdup (name)) != NULL ? 1 : 0);
+}
+
+void
+hsm_register_token (ENGINE * e, struct _token *tok)
+{
+  CK_RV rv;
+  CK_ULONG mech_cnt;
+  CK_MECHANISM_TYPE_PTR mech_list;
+  int i;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (!tok)
+    return;
+
+  rv = pFunctionList->C_GetMechanismList (tok->slot_id, NULL_PTR, &mech_cnt);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_ADDTOKEN, HSM_R_GETMECHANISMLIST, rv);
+      goto err;
+    }
+
+  mech_list =
+    (CK_MECHANISM_TYPE_PTR) OPENSSL_malloc (mech_cnt *
+					    sizeof (CK_MECHANISM_TYPE));
+  if (mech_list == NULL)
+    {
+      hsm_die (HSM_F_ADDTOKEN, HSM_R_MALLOC_FAILURE, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_GetMechanismList (tok->slot_id, mech_list, &mech_cnt);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_ADDTOKEN, HSM_R_GETMECHANISMLIST, rv);
+      goto err_free;
+    }
+
+  for (i = 0; i < mech_cnt; i++)
+    {
+      switch (mech_list[i])
+	{
+	case CKM_RSA_PKCS_KEY_PAIR_GEN:
+	case CKM_RSA_PKCS:
+	case CKM_RSA_9796:
+	case CKM_RSA_X_509:
+	case CKM_RSA_PKCS_OAEP:
+	case CKM_RSA_X9_31:
+	case CKM_RSA_X9_31_KEY_PAIR_GEN:
+	case CKM_MD5_RSA_PKCS:
+#ifndef OPENSSL_NO_RSA
+	  dbg_fprintf ("%s: registering RSA
", __FUNCTION__);
+#ifdef OLDER_OPENSSL
+	  ENGINE_set_RSA (e, &hsm_rsa);
+#else
+	  ENGINE_set_RSA (e, hsm_rsa);
+	  hsm_rsa = RSA_meth_new ("PKCS#11 RSA", 0);
+	  if (hsm_rsa == NULL)
+	    {
+	      dbg_fprintf ("%s: registering RSA failed
", __FUNCTION__);
+	      goto err;
+	    }
+	  RSA_meth_set_priv_enc (hsm_rsa, hsm_RSA_private_encrypt);
+	  RSA_meth_set_init (hsm_rsa, hsm_RSA_init);
+	  RSA_meth_set_finish (hsm_rsa, hsm_RSA_finish);
+#endif
+	  ENGINE_set_load_privkey_function (e, hsm_load_privkey);
+
+#endif
+	  break;
+	case CKM_ECDSA:
+	case CKM_ECDSA_SHA1:
+	case CKM_ECDSA_SHA224:
+	case CKM_ECDSA_SHA256:
+	case CKM_ECDSA_SHA384:
+	case CKM_ECDSA_SHA512:
+#ifndef OPENSSL_NO_ECDSA
+	  dbg_fprintf ("%s: registering ECDSA
", __FUNCTION__);
+#ifdef OLDER_OPENSSL
+	  ENGINE_set_ECDSA (e, &hsm_ecdsa);
+#else
+
+#if OPENSSL_VERSION_NUMBER >= 0x10100000L && !defined(LIBRESSL_VERSION_NUMBER)
+
+	  int (*orig_sign) (int, const unsigned char *, int, unsigned char *,
+			    unsigned int *, const BIGNUM *, const BIGNUM *,
+			    EC_KEY *) = NULL;
+
+	  hsm_ec_meth =
+	    EC_KEY_METHOD_new ((EC_KEY_METHOD *) EC_KEY_OpenSSL ());
+	  EC_KEY_METHOD_get_sign (hsm_ec_meth, &orig_sign, NULL, NULL);
+	  EC_KEY_METHOD_set_sign (hsm_ec_meth, orig_sign, NULL,
+				  hsm_ECDSA_sign);
+	  ENGINE_set_EC (e, hsm_ec_meth);
+
+#else
+	  ENGINE_set_ECDSA (e, hsm_ecdsa);
+	  hsm_ecdsa = ECDSA_METHOD_new (NULL);
+	  if (hsm_ecdsa == NULL)
+	    {
+	      dbg_fprintf ("%s: registering ECDSA failed
", __FUNCTION__);
+	      goto err;
+	    }
+	  ECDSA_METHOD_set_name (hsm_ecdsa, "PKCS#11 ECDSA");
+	  ECDSA_METHOD_set_sign (hsm_ecdsa, hsm_ECDSA_sign);
+	  ECDSA_METHOD_set_sign_setup (hsm_ecdsa, hsm_ECDSA_sign_setup);
+#endif
+#endif
+	  ENGINE_set_load_privkey_function (e, hsm_load_privkey);
+#endif
+	  break;
+	case CKM_SHA_1:
+	  tok->hsm_implemented_digests[NID_sha1] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_SHA_1_HMAC:
+	case CKM_SHA_1_HMAC_GENERAL:
+	  tok->hsm_implemented_digests[NID_hmacWithSHA1] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_PBA_SHA1_WITH_SHA1_HMAC:
+	case CKM_SHA1_KEY_DERIVATION:
+	case CKM_SHA1_RSA_PKCS:
+	  tok->hsm_implemented_digests[NID_sha1WithRSAEncryption] = 1;
+	  num_digest_nids++;
+	  break;
+
+	case CKM_SHA224:
+	  tok->hsm_implemented_digests[NID_sha224] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_SHA224_KEY_DERIVATION:
+	case CKM_SHA224_RSA_PKCS:
+	  tok->hsm_implemented_digests[NID_sha224WithRSAEncryption] = 1;
+	  num_digest_nids++;
+	  break;
+
+	case CKM_SHA256:
+	  tok->hsm_implemented_digests[NID_sha256] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_SHA256_KEY_DERIVATION:
+	case CKM_SHA256_RSA_PKCS:
+	  tok->hsm_implemented_digests[NID_sha256WithRSAEncryption] = 1;
+	  num_digest_nids++;
+	  break;
+
+	case CKM_SHA384:
+	  tok->hsm_implemented_digests[NID_sha384] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_SHA384_KEY_DERIVATION:
+	case CKM_SHA384_RSA_PKCS:
+	  tok->hsm_implemented_digests[NID_sha384WithRSAEncryption] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_SHA512:
+	  tok->hsm_implemented_digests[NID_sha512] = 1;
+	  num_digest_nids++;
+	  break;
+	case CKM_SHA512_KEY_DERIVATION:
+	case CKM_SHA512_RSA_PKCS:
+	  tok->hsm_implemented_digests[NID_sha512WithRSAEncryption] = 1;
+	  num_digest_nids++;
+	  break;
+	default:
+	  break;
+	}
+    }
+
+err_free:OPENSSL_free (mech_list);
+err:return;
+}
+
+struct _token *
+hsm_add_token (CK_SLOT_ID slot_id)
+{
+  struct _token *new_tok =
+    (struct _token *) OPENSSL_malloc (sizeof (struct _token));
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (new_tok == NULL)
+    {
+      hsm_err (HSM_F_ADDTOKEN, HSM_R_MALLOC_FAILURE);
+      return NULL;
+    }
+
+  memset (new_tok, 0, sizeof (struct _token));
+  new_tok->slot_id = slot_id;
+  new_tok->pin = NULL;
+
+  new_tok->token_next = hsm_token_list;
+  hsm_token_list = new_tok;
+
+  return new_tok;
+}
+
+static int
+pre_init_hsm (ENGINE * e)
+{
+
+  CK_C_GetFunctionList p;
+  CK_RV rv = CKR_OK;
+  CK_INFO Info;
+  CK_SLOT_ID_PTR pSlotList;
+  CK_ULONG ulSlotCount;
+  CK_SLOT_INFO slotInfo;
+  struct _token *tok;
+  int i;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (hsm_dso)
+    {
+      hsm_err (HSM_F_PREINIT, HSM_R_ALREADY_LOADED);
+      goto err;
+    }
+
+  hsm_dso = dlopen (get_HSM_LIBNAME (), DLOPEN_FLAG);
+
+  if (hsm_dso == NULL)
+    {
+      hsm_err (HSM_F_PREINIT, HSM_R_DSO_FAILURE);
+      goto err;
+    }
+
+  p = (CK_C_GetFunctionList) dlsym (hsm_dso, HSM_GET_FUNCTION_LIST);
+  if (!p)
+    {
+      hsm_err (HSM_F_PREINIT, HSM_R_DSO_FAILURE);
+      goto err;
+    }
+
+  rv = p (&pFunctionList);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_PREINIT, HSM_R_DSO_FAILURE, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_Initialize (NULL);
+  if ((rv != CKR_OK) && (rv != CKR_CRYPTOKI_ALREADY_INITIALIZED))
+    {
+      hsm_die (HSM_F_PREINIT, HSM_R_INITIALIZE, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_GetInfo (&Info);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_PREINIT, HSM_R_GETINFO, rv);
+      pFunctionList->C_Finalize (NULL);
+      goto err;
+    }
+
+  /* get a list of slots in the system */
+  rv = pFunctionList->C_GetSlotList (TRUE, NULL_PTR, &ulSlotCount);
+  if ((rv != CKR_OK) || (ulSlotCount == 0))
+    {
+      hsm_die (HSM_F_PREINIT, HSM_R_GETSLOTLIST, rv);
+    }
+  else
+    {
+      pSlotList =
+	(CK_SLOT_ID_PTR) OPENSSL_malloc (ulSlotCount * sizeof (CK_SLOT_ID));
+      if (pSlotList != NULL)
+	{
+	  rv = pFunctionList->C_GetSlotList (TRUE, pSlotList, &ulSlotCount);
+	  if (rv != CKR_OK)
+	    {
+	      hsm_die (HSM_F_PREINIT, HSM_R_GETSLOTLIST, rv);
+	      pFunctionList->C_Finalize (NULL);
+	      OPENSSL_free (pSlotList);
+	      goto err;
+	    }
+
+	  for (i = 0; i < ulSlotCount; i++)
+	    {
+	      rv = pFunctionList->C_GetSlotInfo (pSlotList[i], &slotInfo);
+	      if (rv != CKR_OK)
+		{
+		  hsm_die (HSM_F_PREINIT, HSM_R_GETSLOTINFO, rv);
+		  pFunctionList->C_Finalize (NULL);
+		  OPENSSL_free (pSlotList);
+		  goto err;
+		}
+
+	      tok = hsm_add_token (pSlotList[i]);
+	      hsm_register_token (e, tok);
+	    }
+	  OPENSSL_free (pSlotList);
+	}
+    }
+
+  /* Indicate that we finished with the Cryptoki library */
+  pFunctionList->C_Finalize (NULL);
+  dlclose (hsm_dso);
+  hsm_dso = NULL;
+
+  return 1;
+
+err:if (hsm_dso)
+    dlclose (hsm_dso);
+  hsm_dso = NULL;
+  return 0;
+}
+
+/*Initialisation function */
+static int
+hsm_init (ENGINE * e)
+{
+  CK_C_GetFunctionList p;
+  CK_RV rv = CKR_OK;
+  CK_INFO Info;
+  CK_SLOT_ID_PTR pSlotList;
+  CK_ULONG ulSlotCount;
+  CK_SLOT_INFO slotInfo;
+  struct _token *tok;
+  int i;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (hsm_dso)
+    {
+      hsm_err (HSM_F_INIT, HSM_R_ALREADY_LOADED);
+      goto err;
+    }
+  /* Attempt to load PKCS#11 library */
+  hsm_dso = dlopen (get_HSM_LIBNAME (), DLOPEN_FLAG);
+
+  if (hsm_dso == NULL)
+    {
+      hsm_err (HSM_F_INIT, HSM_R_DSO_FAILURE);
+      goto err;
+    }
+
+  p = (CK_C_GetFunctionList) dlsym (hsm_dso, HSM_GET_FUNCTION_LIST);
+  if (!p)
+    {
+      hsm_err (HSM_F_INIT, HSM_R_DSO_FAILURE);
+      goto err;
+    }
+
+  rv = p (&pFunctionList);
+
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_INIT, HSM_R_DSO_FAILURE, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_Initialize (NULL_PTR);
+  if ((rv != CKR_OK) && (rv != CKR_CRYPTOKI_ALREADY_INITIALIZED))
+    {
+      hsm_die (HSM_F_INIT, HSM_R_INITIALIZE, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_GetInfo (&Info);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_INIT, HSM_R_GETINFO, rv);
+      pFunctionList->C_Finalize (NULL);
+      goto err;
+    }
+
+  rv = pFunctionList->C_GetSlotList (TRUE, NULL_PTR, &ulSlotCount);
+  if ((rv != CKR_OK) || (ulSlotCount == 0))
+    {
+      hsm_die (HSM_F_INIT, HSM_R_GETSLOTLIST, rv);
+    }
+  else
+    {
+      pSlotList =
+	(CK_SLOT_ID_PTR) OPENSSL_malloc (ulSlotCount * sizeof (CK_SLOT_ID));
+      if (pSlotList != NULL)
+	{
+	  rv = pFunctionList->C_GetSlotList (TRUE, pSlotList, &ulSlotCount);
+	  if (rv != CKR_OK)
+	    {
+	      hsm_die (HSM_F_INIT, HSM_R_GETSLOTLIST, rv);
+	      pFunctionList->C_Finalize (NULL);
+	      OPENSSL_free (pSlotList);
+	      goto err;
+	    }
+
+	  for (i = 0; i < ulSlotCount; i++)
+	    {
+	      rv = pFunctionList->C_GetSlotInfo (pSlotList[i], &slotInfo);
+	      if (rv != CKR_OK)
+		{
+		  hsm_die (HSM_F_INIT, HSM_R_GETSLOTINFO, rv);
+		  pFunctionList->C_Finalize (NULL);
+		  OPENSSL_free (pSlotList);
+		  goto err;
+		}
+
+	      tok = hsm_add_token (pSlotList[i]);
+	      hsm_register_token (e, tok);
+	    }
+	  OPENSSL_free (pSlotList);
+	}
+    }
+
+#ifndef OPENSSL_NO_RSA
+  if (rsa_privkey_idx == -1)
+    rsa_privkey_idx = RSA_get_ex_new_index (0, NULL, NULL, NULL, NULL);
+  if (rsa_session_idx == -1)
+    rsa_session_idx = RSA_get_ex_new_index (0, NULL, NULL, NULL, NULL);
+#endif
+
+#ifndef OPENSSL_NO_ECDSA
+  if (ecdsa_privkey_idx == -1)
+#ifdef OLDER_OPENSSL
+    ecdsa_privkey_idx = ECDSA_get_ex_new_index (0, NULL, NULL, NULL, 0);
+#else
+    ecdsa_privkey_idx = EC_KEY_get_ex_new_index (0, NULL, NULL, NULL, 0);
+#endif
+  if (ecdsa_session_idx == -1)
+#ifdef OLDER_OPENSSL
+    ecdsa_session_idx = ECDSA_get_ex_new_index (0, NULL, NULL, NULL, 0);
+#else
+    ecdsa_session_idx = EC_KEY_get_ex_new_index (0, NULL, NULL, NULL, 0);
+#endif
+#endif
+
+  if (hsm_token_list == NULL)
+    hsm_err (HSM_F_INIT, HSM_R_NOTOKENS);
+
+  HSM_Initialized = 1;
+
+  pthread_atfork (NULL, NULL, (void (*)()) hsm_atfork_init);
+
+  return 1;
+
+err:if (hsm_dso)
+    {
+      dlclose (hsm_dso);
+    }
+  hsm_dso = NULL;
+  return 0;
+}
+
+/* Destructor (complements the "engine_hsm()" constructor) */
+static int
+hsm_destroy (ENGINE * e)
+{
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+#ifndef OLDER_OPENSSL
+  hsm_sha1_destroy ();
+  hsm_sha224_destroy ();
+  hsm_sha256_destroy ();
+  hsm_sha384_destroy ();
+  hsm_sha512_destroy ();
+#endif
+
+  free_HSM_LIBNAME ();
+  ERR_unload_hsm_strings ();
+  return 1;
+}
+
+static int
+hsm_finish (ENGINE * e)
+{
+  struct _token *tmp;
+  struct token_session *wrapper = NULL;
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (hsm_dso == NULL)
+    {
+      hsm_err (HSM_F_FINISH, HSM_R_NOT_LOADED);
+      goto err;
+    }
+  assert (pFunctionList != NULL);
+
+  while (hsm_token_list)
+    {
+      tmp = hsm_token_list->token_next;
+      OPENSSL_free (hsm_token_list);
+      hsm_token_list = tmp;
+    }
+
+  pFunctionList->C_Finalize (NULL);
+
+  if (dlclose (hsm_dso))
+    {
+      hsm_err (HSM_F_FINISH, HSM_R_DSO_FAILURE);
+      goto err;
+    }
+  hsm_dso = NULL;
+  pFunctionList = NULL;
+
+  wrapper = hsm_get_session ();
+  OPENSSL_free (wrapper);
+
+  return 1;
+
+err:hsm_dso = NULL;
+  pFunctionList = NULL;
+  return 0;
+}
+
+/* Loads a certificate by its ID */
+int
+load_certificate (ENGINE * e, void *p)
+{
+  struct
+  {
+    const char *certid;
+    X509 *cert;
+  } *parms = p;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (parms->cert != NULL)
+    return 0;
+  parms->cert = hsm_find_certificate (e, parms->certid);
+  if (parms->cert == NULL)
+    return 0;
+
+  return 1;
+}
+
+static int
+hsm_ctrl (ENGINE * e, int cmd, long i, void *p, void (*f) ())
+{
+  int initialized = ((hsm_dso == NULL) ? 0 : 1);
+  struct _token *tok;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  switch (cmd)
+    {
+    case HSM_CMD_MODULE_PATH:
+      if (p == NULL)
+	{
+	  hsm_err (HSM_F_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+	  return 0;
+	}
+      if (initialized)
+	{
+	  /*hsm_err(HSM_F_CTRL, HSM_R_ALREADY_LOADED);
+	     return 0; */
+	}
+      if (!set_HSM_LIBNAME ((const char *) p))
+	return 0;
+      return pre_init_hsm (e);
+    case HSM_CMD_SLOT_ID:
+      tok = hsm_token_list;
+      while (tok)
+	{
+	  dbg_fprintf ("slot %ld found
", tok->slot_id);
+	  if (tok->slot_id == i)
+	    {
+	      hsm_token = tok;
+	      dbg_fprintf ("slot %ld selected
", i);
+	      return 1;
+	    }
+	  tok = tok->token_next;
+	}
+      hsm_err (HSM_F_CTRL, HSM_R_TOKEN_NOT_AVAILABLE);
+      return 0;
+    case HSM_CMD_PIN:
+      if (p == NULL)
+	{
+	  hsm_err (HSM_F_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+	  return 0;
+	}
+      if (!hsm_token)
+	{
+	  hsm_err (HSM_F_CTRL, HSM_R_NO_SLOT_SELECTED);
+	  return 0;
+	}
+      hsm_token->pin = OPENSSL_strdup (p);
+      break;
+    case HSM_CMD_LOAD_CERT:
+      if (p == NULL)
+	{
+	  hsm_err (HSM_F_CTRL, ERR_R_PASSED_NULL_PARAMETER);
+	  return 0;
+	}
+      return load_certificate (e, p);
+    default:
+      break;
+    }
+  /*hsm_err(HSM_F_CTRL, HSM_R_CTRL_COMMAND_NOT_IMPLEMENTED); */
+
+  return 0;
+}
+
+EVP_PKEY *
+hsm_find_privkey (CK_SESSION_HANDLE session, CK_BYTE_PTR * key_id,
+		  CK_ULONG key_len)
+{
+
+  EVP_PKEY *pkey = NULL;
+  CK_OBJECT_HANDLE hKey = CK_INVALID_HANDLE;
+  CK_ULONG matches;
+  CK_RV rv;
+  CK_ULONG exp_size = 0, mod_size = 0;
+  CK_BYTE_PTR mod = NULL;
+  CK_BYTE_PTR exp = NULL;
+  int i;
+  CK_ULONG kt;
+  BIGNUM *bnN = NULL;
+  BIGNUM *bnE = NULL;
+
+  CK_OBJECT_CLASS oKey = CKO_PRIVATE_KEY;
+
+  CK_ATTRIBUTE findobj_tmple[] = { {CKA_CLASS, &oKey, sizeof (CK_OBJECT_CLASS)}
+  ,
+  {CKA_ID, (void *) key_id, key_len}
+  };
+
+  CK_ATTRIBUTE key_type[] = { {CKA_CLASS, &oKey, sizeof (oKey)}
+  , {
+     CKA_KEY_TYPE, &kt, sizeof (kt)}
+  };
+
+  CK_ULONG ulCount = sizeof (findobj_tmple) / sizeof (CK_ATTRIBUTE);
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  rv = pFunctionList->C_FindObjectsInit (session, findobj_tmple, ulCount);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDKEY, HSM_R_FINDOBJECTSINIT, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_FindObjects (session, &hKey, 1, &matches);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDKEY, HSM_R_FINDOBJECTS, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_FindObjectsFinal (session);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDKEY, HSM_R_FINDOBJECTSFINAL, rv);
+      goto err;
+    }
+
+  dbg_fprintf ("Find: %d count: %ld
", rv, matches);
+
+  if (!matches)
+    {
+      dbg_fprintf ("Key not found on token
");
+      goto err;
+    }
+
+  /* get key type */
+  ulCount = sizeof (key_type) / sizeof (CK_ATTRIBUTE);
+  rv = pFunctionList->C_GetAttributeValue (session, hKey, key_type, ulCount);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDKEY, HSM_R_GETATTRIBUTVALUE, rv);
+      goto err;
+    }
+
+  if (kt == CKK_RSA)
+    {
+      CK_ATTRIBUTE pub_rsa_attrs[] = {
+	{CKA_PUBLIC_EXPONENT, exp, exp_size}
+	, {CKA_MODULUS, mod,
+	   mod_size}
+      };
+      RSA *rsa = RSA_new ();
+      ulCount = sizeof (pub_rsa_attrs) / sizeof (CK_ATTRIBUTE);
+      /*to pass X509_check_private_key we need to fill RSA with public key parameters */
+      rv = pFunctionList->C_GetAttributeValue (session, hKey, pub_rsa_attrs,
+					       ulCount);
+      if (rv != CKR_OK)
+	{
+	  hsm_die (HSM_F_FINDKEY, HSM_R_GETATTRIBUTVALUE, rv);
+	  goto err;
+	}
+      exp = (CK_BYTE_PTR) OPENSSL_malloc (pub_rsa_attrs[0].ulValueLen);
+      mod = (CK_BYTE_PTR) OPENSSL_malloc (pub_rsa_attrs[1].ulValueLen);
+      pub_rsa_attrs[0].pValue = exp;
+      pub_rsa_attrs[1].pValue = mod;
+
+      rv = pFunctionList->C_GetAttributeValue (session, hKey, pub_rsa_attrs,
+					       ulCount);
+
+      if (rv != CKR_OK)
+	{
+	  hsm_die (HSM_F_FINDKEY, HSM_R_GETATTRIBUTVALUE, rv);
+	  goto err;
+	}
+      if ((bnE = BN_bin2bn (pub_rsa_attrs[0].pValue,
+			    pub_rsa_attrs[0].ulValueLen, NULL)) == NULL)
+	{
+	  hsm_die (HSM_F_FINDKEY, HSM_R_BIGNUM, rv);
+	  goto err;
+	}
+
+      if ((bnN = BN_bin2bn (pub_rsa_attrs[1].pValue,
+			    pub_rsa_attrs[1].ulValueLen, NULL)) == NULL)
+	{
+	  hsm_die (HSM_F_FINDKEY, HSM_R_BIGNUM, rv);
+	  goto err;
+	}
+#ifdef OLDER_OPENSSL
+      rsa->e = bnE;
+      rsa->n = bnN;
+#else
+      if (!RSA_set0_key (rsa, bnN, bnE, NULL))
+	{
+	  hsm_die (HSM_F_FINDKEY, HSM_R_BIGNUM, rv);
+	  goto err;
+	}
+#endif
+      RSA_set_ex_data (rsa, rsa_privkey_idx, (void *) hKey);
+      pkey = EVP_PKEY_new ();
+      EVP_PKEY_set1_RSA (pkey, rsa);
+#ifdef HSM_DEBUG
+      fprintf (stdout, "e: %s
", BN_bn2dec (bnE));
+      fprintf (stdout, "n: %s
", BN_bn2dec (bnN));
+#endif
+    }
+  else if (kt == CKK_EC)
+    {
+      CK_ATTRIBUTE ecdsa_pub[] = { {CKA_ID, NULL, 0}
+      , {CKA_CLASS,
+	 &oKey, sizeof (oKey)}
+      , {CKA_KEY_TYPE, &kt, sizeof (kt)}
+      };
+      CK_ATTRIBUTE ecdsa_attrs[] = { {CKA_EC_PARAMS, NULL, 0}
+      , {
+	 CKA_EC_POINT, NULL, 0}
+      };
+      CK_OBJECT_HANDLE hPbKey;
+      CK_ULONG found;
+      oKey = CKO_PUBLIC_KEY;
+
+      if (((rv = pFunctionList->C_GetAttributeValue (session, hKey,
+						     ecdsa_pub, 1)) == CKR_OK)
+	  && ((ecdsa_pub[0].pValue = OPENSSL_malloc (ecdsa_pub[0].ulValueLen))
+	      != NULL)
+	  &&
+	  ((rv =
+	    pFunctionList->C_GetAttributeValue (session, hKey, ecdsa_pub,
+						1)) == CKR_OK)
+	  && ((rv = pFunctionList->C_FindObjectsInit (session, ecdsa_pub, 3))
+	      == CKR_OK)
+	  &&
+	  ((rv =
+	    pFunctionList->C_FindObjects (session, &hPbKey, 1,
+					  &found)) == CKR_OK)
+	  && ((rv = pFunctionList->C_FindObjectsFinal (session)) == CKR_OK)
+	  &&
+	  ((rv =
+	    pFunctionList->C_GetAttributeValue (session, hPbKey, ecdsa_attrs,
+						2)) == CKR_OK)
+	  &&
+	  ((ecdsa_attrs[0].pValue =
+	    OPENSSL_malloc (ecdsa_attrs[0].ulValueLen)) != NULL)
+	  &&
+	  ((ecdsa_attrs[1].pValue =
+	    OPENSSL_malloc (ecdsa_attrs[1].ulValueLen)) != NULL)
+	  &&
+	  ((rv =
+	    pFunctionList->C_GetAttributeValue (session, hPbKey, ecdsa_attrs,
+						2)) == CKR_OK))
+	{
+
+	  const unsigned char *ptr1 = ecdsa_attrs[0].pValue;
+	  const unsigned char *ptr2 = ecdsa_attrs[1].pValue;
+	  CK_ULONG len1 = ecdsa_attrs[0].ulValueLen;
+	  CK_ULONG len2 = ecdsa_attrs[1].ulValueLen;
+	  ASN1_OCTET_STRING *point = NULL;
+	  EC_KEY *ecdsa = NULL;
+
+	  /* Fill pirvate key with public key parameters to pass the certificate/private key consistency check later */
+	  if ((point = d2i_ASN1_OCTET_STRING (NULL, &ptr2, len2)))
+	    {
+	      /* Pointing to OCTET STRING content */
+	      ptr2 = point->data;
+	      len2 = point->length;
+	    }
+	  else
+	    {
+	      /* No OCTET STRING */
+	      ptr2 = ecdsa_attrs[1].pValue;
+	    }
+
+	  if ((d2i_ECParameters (&ecdsa, &ptr1, len1) == NULL)
+	      || (o2i_ECPublicKey (&ecdsa, &ptr2, len2) == NULL))
+	    {
+	      EC_KEY_free (ecdsa);
+	      ecdsa = NULL;
+	    }
+
+	  EC_KEY_set_private_key (ecdsa, BN_value_one ());
+
+	  if (point)
+	    {
+	      ASN1_STRING_free (point);
+	    }
+
+	  if (ecdsa)
+	    {
+	      if ((pkey = EVP_PKEY_new ()) != NULL)
+		{
+
+#ifdef OLDER_OPENSSL
+		  ECDSA_set_ex_data (ecdsa, ecdsa_privkey_idx, hKey);
+#else
+		  EC_KEY_set_ex_data (ecdsa, ecdsa_privkey_idx, hKey);
+#endif
+		  EVP_PKEY_set1_EC_KEY (pkey, ecdsa);
+		}
+	    }
+	}
+
+    }				// else if (kt == CKK_EC)
+err:return pkey;
+}
+
+/* Public certificate loader. It loads cert by id in DER format and convert it to PEM */
+static X509 *
+hsm_find_certificate (ENGINE * e, const char *cert_id)
+{
+  X509 *x509 = NULL;
+  BIO *cbio = NULL;
+  struct token_session *wrapper = NULL;
+  CK_SESSION_HANDLE hSession = NULL;
+  CK_OBJECT_CLASS ObjClass = CKO_CERTIFICATE;
+  CK_ULONG cert_size = 0;
+  CK_ULONG ulCount = 0;
+  CK_OBJECT_HANDLE hCert = CK_INVALID_HANDLE;
+  CK_RV rv;
+  CK_ULONG matches;
+  CK_BYTE_PTR cert_der = NULL;
+  unsigned char *hcert_id = NULL;
+  size_t hcert_idlen;
+
+  CK_ATTRIBUTE findobj_tmple[] = { {CKA_CLASS, &ObjClass, sizeof (ObjClass)}
+  , {
+     CKA_ID, (void *) 0, 0}
+  };
+
+  CK_ATTRIBUTE attrval_tmple[] = { {CKA_VALUE, cert_der, cert_size}, {CKA_ID,
+								      (void *)
+								      0, 0}
+  };
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (hSession == CK_INVALID_HANDLE || !hSession)
+    {
+      wrapper = hsm_get_session ();
+      if (!wrapper)
+	return 0;
+      hSession = wrapper->session;
+    }
+
+  ulCount = sizeof (findobj_tmple) / sizeof (CK_ATTRIBUTE);
+
+  hcert_id = hex2bin (cert_id, &hcert_idlen);
+  findobj_tmple[1].pValue = hcert_id;
+  findobj_tmple[1].ulValueLen = hcert_idlen;
+
+  rv =
+    pFunctionList->C_FindObjectsInit (wrapper->session, findobj_tmple,
+				      ulCount);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDCERT, HSM_R_FINDOBJECTSINIT, rv);
+      goto err;
+    }
+
+  rv = pFunctionList->C_FindObjects (wrapper->session, &hCert, 1, &matches);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDCERT, HSM_R_FINDOBJECTS, rv);
+      goto err;
+    }
+
+  if (!matches)
+    {
+      dbg_fprintf ("Cert %s not found on token
", cert_id);
+      hsm_die (HSM_F_FINDCERT, HSM_R_FINDOBJECTS, rv);
+      goto err;
+    }
+
+  ulCount = sizeof (attrval_tmple) / sizeof (CK_ATTRIBUTE);
+
+  rv =
+    pFunctionList->C_GetAttributeValue (wrapper->session, hCert,
+					attrval_tmple, ulCount);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDCERT, HSM_R_GETATTRIBUTVALUE, rv);
+      goto err;
+    }
+
+  cert_der = (CK_BYTE_PTR) OPENSSL_malloc (attrval_tmple[0].ulValueLen);
+  attrval_tmple[0].pValue = cert_der;
+
+  rv =
+    pFunctionList->C_GetAttributeValue (wrapper->session, hCert,
+					attrval_tmple, ulCount);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDCERT, HSM_R_GETATTRIBUTVALUE, rv);
+      goto err;
+    }
+
+  if ((cbio =
+       BIO_new_mem_buf (cert_der, attrval_tmple[0].ulValueLen)) == NULL)
+    {
+      goto err;
+    }
+  if (!d2i_X509_bio (cbio, &x509))
+    goto err;
+#ifdef HSM_DEBUG
+  PEM_write_X509 (stdout, x509);
+#endif
+  rv = pFunctionList->C_FindObjectsFinal (wrapper->session);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_FINDCERT, HSM_R_FINDOBJECTSFINAL, rv);
+      goto err;
+    }
+err:BIO_free (cbio);
+  return x509;
+
+}
+
+static EVP_PKEY *
+hsm_load_privkey (ENGINE * e, const char *key_id,
+		  UI_METHOD * ui_method, void *callback_data)
+{
+
+  EVP_PKEY *pkey = NULL;
+  RSA *rsa = NULL;
+  unsigned char *hkey_id;
+  size_t hkey_idlen;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (!key_id)
+    goto err;
+
+  struct token_session *wrapper = NULL;
+  CK_SESSION_HANDLE session = CK_INVALID_HANDLE;
+  wrapper = hsm_get_session ();
+  if (!wrapper)
+    return 0;
+  dbg_fprintf ("%d: created new session
", __LINE__);
+  session = wrapper->session;
+  hkey_id = hex2bin (key_id, &hkey_idlen);
+  pkey = hsm_find_privkey (session, (CK_BYTE_PTR *) hkey_id,
+			   (CK_ULONG) hkey_idlen);
+err:return pkey;
+}
+
+static int
+hsm_RSA_init (RSA * rsa)
+{
+  struct token_session *wrapper;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  wrapper = hsm_get_session ();
+  if (wrapper)
+    RSA_set_ex_data (rsa, rsa_session_idx, (void *) wrapper->session);
+
+  RSA_blinding_off (rsa);
+
+  return 1;
+}
+
+static int
+hsm_RSA_finish (RSA * rsa)
+{
+  CK_RV rv;
+
+  struct token_session *wrapper = NULL;
+  CK_SESSION_HANDLE session;
+  int err = 0;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+#ifdef OLDER_OPENSSL
+  if (rsa->_method_mod_n != NULL)
+    BN_MONT_CTX_free (rsa->_method_mod_n);
+  if (rsa->_method_mod_p != NULL)
+    BN_MONT_CTX_free (rsa->_method_mod_p);
+  if (rsa->_method_mod_q != NULL)
+    BN_MONT_CTX_free (rsa->_method_mod_q);
+#endif
+
+  session = (CK_SESSION_HANDLE) RSA_get_ex_data (rsa, rsa_session_idx);
+
+  if (session == CK_INVALID_HANDLE || !session)
+    {
+      wrapper = hsm_get_session ();
+      if (!wrapper)
+	return 0;
+      session = wrapper->session;
+    }
+
+  rv = pFunctionList->C_CloseSession (session);
+  RSA_set_ex_data (rsa, rsa_session_idx, (void *) CK_INVALID_HANDLE);
+  err = 1;
+out:
+  return err;
+}
+
+static int
+hsm_RSA_private_encrypt (int flen, const unsigned char *from,
+			 unsigned char *to, RSA * rsa, int padding)
+{
+  CK_ULONG ulSignatureLen = 0;
+  CK_RV rv;
+  CK_MECHANISM Mechanism_rsa = { CKM_RSA_PKCS, NULL, 0 };
+  CK_MECHANISM *pMechanism = &Mechanism_rsa;
+  CK_OBJECT_HANDLE hpkey = CK_INVALID_HANDLE;
+  struct token_session *wrapper = NULL;
+  CK_SESSION_HANDLE session;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  if (padding != RSA_PKCS1_PADDING)
+    {
+      hsm_err (HSM_F_RSA_PRIV_ENC, HSM_R_UNKNOWN_PADDING_TYPE);
+      return -1;
+    }
+
+  session = (CK_SESSION_HANDLE) RSA_get_ex_data (rsa, rsa_session_idx);
+  if (session == CK_INVALID_HANDLE || !session)
+    {
+      wrapper = hsm_get_session ();
+      if (!wrapper)
+	return 0;
+
+      dbg_fprintf ("%d: created new session
", __LINE__);
+      session = wrapper->session;
+      RSA_set_ex_data (rsa, rsa_session_idx, (void *) session);
+    }
+
+  hpkey = (CK_OBJECT_HANDLE) RSA_get_ex_data (rsa, rsa_privkey_idx);
+  if (hpkey == CK_INVALID_HANDLE)
+    {
+      hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGNINIT, rv);
+      goto out;
+    }
+
+  if (hpkey != CK_INVALID_HANDLE)
+    {
+      rv = pFunctionList->C_SignInit (session, pMechanism, hpkey);
+      if (rv != CKR_OK)
+	{
+	  hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGNINIT, rv);
+	  ulSignatureLen = -1;
+	  goto out;
+	}
+
+      rv = pFunctionList->C_Sign (session, (unsigned char *) from, flen,
+				  NULL_PTR, &ulSignatureLen);
+      if (rv != CKR_OK)
+	{
+	  hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGN, rv);
+	  ulSignatureLen = -1;
+	  goto out;
+	}
+
+      rv = pFunctionList->C_Sign (session, (unsigned char *) from, flen, to,
+				  &ulSignatureLen);
+      if (rv != CKR_OK)
+	{
+	  hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGN, rv);
+	  ulSignatureLen = -1;
+	  goto out;
+	}
+
+    }
+
+out:
+  return ulSignatureLen;
+}
+
+static inline int
+get_mech (int alg, EVP_CIPHER_CTX * ctx)
+{
+  switch (alg)
+    {
+    case alg_sha:
+      return CKM_SHA_1;
+    case alg_sha224:
+      return CKM_SHA224;
+    case alg_sha256:
+      return CKM_SHA256;
+    case alg_sha384:
+      return CKM_SHA384;
+    case alg_sha512:
+      return CKM_SHA512;
+    default:
+      return -1;
+    }
+}
+
+int
+hsm_ECDSA_sign_setup (EC_KEY * eckey, BN_CTX * ctx_in, BIGNUM ** kinvp,
+		      BIGNUM ** rp)
+{
+  struct token_session *wrapper;
+  dbg_fprintf ("%s
", __FUNCTION__);
+  wrapper = hsm_get_session ();
+  if (wrapper)
+    {
+#ifdef OLDER_OPENSSL
+      ECDSA_set_ex_data (eckey, ecdsa_session_idx, (void *) wrapper->session);
+#else
+      EC_KEY_set_ex_data (eckey, ecdsa_session_idx,
+			  (void *) wrapper->session);
+#endif
+    }
+
+  return 1;
+}
+
+static ECDSA_SIG *
+hsm_ECDSA_sign (const unsigned char *dgst, int dgst_len,
+		const BIGNUM * kinv, const BIGNUM * rp, EC_KEY * ecdsa)
+{
+
+  CK_MECHANISM mech = { CKM_ECDSA, NULL_PTR, 0 };
+  CK_ULONG tlen = 0;
+  CK_RV rv;
+  CK_OBJECT_HANDLE hpkey = CK_INVALID_HANDLE;
+  struct token_session *wrapper = NULL;
+  CK_SESSION_HANDLE session;
+  CK_BYTE_PTR buf = NULL;
+  ECDSA_SIG *rval;
+  BIGNUM *r, *s;
+  int nlen;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+#ifdef OLDER_OPENSSL
+  session = (CK_SESSION_HANDLE) ECDSA_get_ex_data (ecdsa, ecdsa_session_idx);
+#else
+  session = (CK_SESSION_HANDLE) EC_KEY_get_ex_data (ecdsa, ecdsa_session_idx);
+#endif
+
+  if (session == CK_INVALID_HANDLE || !session)
+    {
+      wrapper = hsm_get_session ();
+      if (!wrapper)
+	return NULL;
+
+      dbg_fprintf ("%d: created new session
", __LINE__);
+      session = wrapper->session;
+#ifdef OLDER_OPENSSL
+      ECDSA_set_ex_data (ecdsa, ecdsa_session_idx, (void *) session);
+#else
+      EC_KEY_set_ex_data (ecdsa, ecdsa_session_idx, (void *) session);
+#endif
+
+    }
+
+#ifdef OLDER_OPENSSL
+  hpkey = (CK_OBJECT_HANDLE) ECDSA_get_ex_data (ecdsa, ecdsa_privkey_idx);
+#else
+  hpkey = (CK_OBJECT_HANDLE) EC_KEY_get_ex_data (ecdsa, ecdsa_privkey_idx);
+#endif
+
+  if (hpkey == CK_INVALID_HANDLE)
+    {
+      hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGNINIT, rv);
+      return NULL;
+    }
+
+  if (((rv = pFunctionList->C_SignInit (session, &mech, hpkey)) != CKR_OK))
+    {
+      hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGNINIT, rv);
+      return NULL;
+    }
+  /* Make a call to C_Sign to find out the size of the signature */
+  rv = pFunctionList->C_Sign (session, (CK_BYTE *) dgst, dgst_len, NULL,
+			      &tlen);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGN, rv);
+      return NULL;
+    }
+
+  if ((buf = OPENSSL_malloc (tlen)) == NULL)
+    {
+      hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_MALLOC_FAILURE, rv);
+      return NULL;
+    }
+
+  rv =
+    pFunctionList->C_Sign (session, (CK_BYTE *) dgst, dgst_len, buf, &tlen);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGN, rv);
+      OPENSSL_free (buf);
+      return NULL;
+    }
+
+  nlen = tlen / 2;
+  r = BN_new ();
+  s = BN_new ();
+  BN_bin2bn (&buf[0], nlen, r);
+  BN_bin2bn (&buf[nlen], nlen, s);
+#ifdef HSM_DEBUG
+  fprintf (stdout, "r: %s
", BN_bn2dec (r));
+  fprintf (stdout, "s: %s
", BN_bn2dec (s));
+#endif
+  if ((rval = ECDSA_SIG_new ()) != NULL)
+    {
+#ifdef OLDER_OPENSSL
+      rval->r = r;
+      rval->s = s;
+#else
+      if (!ECDSA_SIG_set0 (rval, r, s))
+	{
+	  hsm_die (HSM_F_RSA_PRIV_ENC, HSM_R_SIGN, rv);
+	  rval = NULL;
+	}
+#endif
+    }
+  OPENSSL_free (buf);
+  return rval;
+
+}
+
+static inline int
+hsm_sha1_init (EVP_MD_CTX * ctx)
+{
+  return hsm_digest_init (ctx, alg_sha);
+}
+
+static inline int
+hsm_sha224_init (EVP_MD_CTX * ctx)
+{
+  return hsm_digest_init (ctx, alg_sha224);
+}
+
+static inline int
+hsm_sha256_init (EVP_MD_CTX * ctx)
+{
+  return hsm_digest_init (ctx, alg_sha256);
+}
+
+static inline int
+hsm_sha384_init (EVP_MD_CTX * ctx)
+{
+  return hsm_digest_init (ctx, alg_sha384);
+}
+
+static inline int
+hsm_sha512_init (EVP_MD_CTX * ctx)
+{
+  return hsm_digest_init (ctx, alg_sha512);
+}
+
+static inline int
+hsm_digest_init (EVP_MD_CTX * ctx, int alg)
+{
+  CK_RV rv;
+  struct token_session *wrapper = NULL;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  wrapper = hsm_get_session ();
+
+  if (!wrapper)
+    return 0;
+
+  MD_DATA (ctx)->token = wrapper->token;
+  MD_DATA (ctx)->session = wrapper->session;
+
+  dbg_fprintf ("%s, alg = %d
", __FUNCTION__, alg);
+
+  MD_DATA (ctx)->alg = alg;
+
+  CK_MECHANISM_TYPE mech = get_mech (MD_DATA (ctx)->alg, NULL);
+  CK_MECHANISM mechanism = { mech, NULL, 0 };
+
+  rv = pFunctionList->C_DigestInit (MD_DATA (ctx)->session, &mechanism);
+  if (rv != CKR_OK)
+    {
+
+      hsm_die (HSM_F_DIGESTFINISH, HSM_R_DIGESTINIT, rv);
+      pFunctionList->C_CloseSession (MD_DATA (ctx)->session);
+      return 0;
+    }
+
+  return 1;
+}
+
+static int
+hsm_digest_update (EVP_MD_CTX * ctx, const void *in, size_t len)
+{
+  CK_RV rv;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  if (!MD_DATA (ctx))
+    {
+      hsm_err (HSM_F_DIGESTUPDATE, HSM_R_PASSED_NULL_PARAMETER);
+      return 0;
+    }
+
+  rv =
+    pFunctionList->C_DigestUpdate (MD_DATA (ctx)->session, (CK_BYTE_PTR) in,
+				   len);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_DIGESTUPDATE, HSM_R_DIGESTUPDATE, rv);
+      return 0;
+    }
+
+  MD_DATA (ctx)->len += len;
+
+  return 1;
+}
+
+static int
+hsm_digest_finish (EVP_MD_CTX * ctx, unsigned char *md)
+{
+  CK_ULONG len = EVP_MD_CTX_size (ctx);
+  CK_RV rv;
+  int ret = 0, i;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  rv = pFunctionList->C_DigestFinal (MD_DATA (ctx)->session, md, &len);
+  if (rv != CKR_OK)
+    {
+      hsm_die (HSM_F_DIGESTFINISH, HSM_R_DIGESTFINAL, rv);
+      goto out_endsession;
+    }
+
+  ret = 1;
+
+out_endsession:pFunctionList->C_CloseSession (MD_DATA (ctx)->session);
+  MD_DATA (ctx)->session = CK_INVALID_HANDLE;
+  return ret;
+}
+
+static int
+hsm_digest_copy (EVP_MD_CTX * dst, const EVP_MD_CTX * src)
+{
+  CK_RV rv;
+  CK_ULONG opstatelen;
+  CK_BYTE_PTR opstate;
+
+  /*if (EVP_MD_CTX_test_flags(src, EVP_MD_CTX_FLAG_NO_INIT))
+     return 1; */
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+
+  /* get a copy of the cryptographic operations state of a session from src context */
+  rv = pFunctionList->C_GetOperationState (MD_DATA (src)->session, NULL_PTR,
+					   &opstatelen);
+  if (rv != CKR_OK && rv != CKR_FUNCTION_NOT_SUPPORTED)
+    {
+      hsm_die (HSM_F_DIGESTCOPY, HSM_R_DIGESTUPDATE, rv);
+      return 0;
+    }
+
+  opstate = (CK_BYTE_PTR) OPENSSL_malloc (opstatelen);
+  rv = pFunctionList->C_GetOperationState (MD_DATA (src)->session, opstate,
+					   &opstatelen);
+  if (rv != CKR_OK && rv != CKR_FUNCTION_NOT_SUPPORTED)
+    {
+      hsm_die (HSM_F_DIGESTCOPY, HSM_R_DIGESTUPDATE, rv);
+      return 0;
+    }
+
+  /* init a new session for the dst context */
+  rv = hsm_digest_init (dst, MD_DATA (src)->alg);
+
+  /* restore the cryptographic activities of a session to dst context */
+  rv = pFunctionList->C_SetOperationState (MD_DATA (dst)->session, opstate,
+					   opstatelen, 0, 0);
+  if (rv != CKR_OK && rv != CKR_FUNCTION_NOT_SUPPORTED)
+    {
+      hsm_die (HSM_F_DIGESTCOPY, HSM_R_DIGESTUPDATE, rv);
+      return 0;
+    }
+
+  OPENSSL_free (opstate);
+
+  return 1;
+}
+
+static inline int
+hsm_digest_cleanup (EVP_MD_CTX * ctx)
+{
+  return 1;
+}
+
+void hsm_engine_destructor (void) __attribute__ ((destructor));
+
+void
+hsm_engine_destructor (void)
+{
+  struct _token *tmp;
+
+  dbg_fprintf ("%s
", __FUNCTION__);
+  while (hsm_token_list)
+    {
+      tmp = hsm_token_list->token_next;
+      OPENSSL_free (hsm_token_list);
+      hsm_token_list = tmp;
+    }
+}
+
+/*Objects IDs are specified as hex string we need to convert them to byte array for the token */
+static unsigned char *
+hex2bin (const char *hexstr, size_t * size)
+{
+  size_t hexstrLen = strlen (hexstr);
+  size_t bytesLen = hexstrLen / 2;
+  unsigned char *bytes = (unsigned char *) OPENSSL_malloc (bytesLen);
+
+  int count = 0;
+  const char *pos = hexstr;
+
+  for (count = 0; count < bytesLen; count++)
+    {
+      sscanf (pos, "%2hhx", &bytes[count]);
+      pos += 2;
+    }
+
+  if (size != NULL)
+    *size = bytesLen;
+
+  return bytes;
+}
+
+#endif
+#endif
diff --git a/release/code/back_end-hsm/src/e_hsm_err.c b/release/code/back_end-hsm/src/e_hsm_err.c
new file mode 100644
index 0000000..6f762aa
--- /dev/null
+++ b/release/code/back_end-hsm/src/e_hsm_err.c
@@ -0,0 +1,164 @@
+/*===========================================================================*/
+/**
+ @file    e_hsm_err.c
+
+ @brief   Error routines, messages and status codes for HSM engine.
+
+ @verbatim
+ =============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+ =============================================================================
+ @endverbatim */
+ 
+#include <stdio.h>
+#include <openssl/err.h>
+#include "e_hsm_err.h"
+
+/* BEGIN ERROR CODES */
+#ifndef OPENSSL_NO_ERR
+static ERR_STRING_DATA hsm_str_functs[]=
+{
+    {ERR_PACK(0,HSM_F_INIT,0),	    "HSM_INIT"},
+    {ERR_PACK(0,HSM_F_FINISH,0),	    "HSM_FINISH"},
+    {ERR_PACK(0,HSM_F_DESTROY,0),	    "HSM_DESTROY"},
+    {ERR_PACK(0,HSM_F_CTRL,0),	    "HSM_CTRL"},
+    {ERR_PACK(0,HSM_F_RSA_INIT,0),	    "HSM_RSA_INIT"},
+    {ERR_PACK(0,HSM_F_RSA_FINISH,0),	    "HSM_RSA_FINISH"},
+    {ERR_PACK(0,HSM_F_FINDKEY,0),"HSM_FINDKEY"},
+    {ERR_PACK(0,HSM_F_RSA_GEN_KEY,0),    "HSM_RSA_GEN_KEY"},
+    {ERR_PACK(0,HSM_F_RSA_PUB_ENC,0),    "HSM_RSA_PUB_ENC"},
+    {ERR_PACK(0,HSM_F_RSA_PRIV_ENC,0),   "HSM_RSA_PRIV_ENC"},
+    {ERR_PACK(0,HSM_F_RSA_PUB_DEC,0),    "HSM_RSA_PUB_DEC"},
+    {ERR_PACK(0,HSM_F_RSA_PRIV_DEC,0),   "HSM_RSA_PRIV_DEC"},
+    {ERR_PACK(0,HSM_F_RSA_SIGN,0),	    "HSM_RSA_SIGN"},
+    {ERR_PACK(0,HSM_F_RSA_VERIFY,0),	    "HSM_RSA_VERIFY"},
+    {ERR_PACK(0,HSM_F_RAND_ADD,0),	    "HSM_RAND_ADD"},
+    {ERR_PACK(0,HSM_F_RAND_BYTES,0),	    "HSM_RAND_BYTES"},
+    {ERR_PACK(0,HSM_F_GETSESSION,0),	    "HSM_GETSESSION"},
+    {ERR_PACK(0,HSM_F_FREESESSION,0),    "HSM_FREESESSION"},
+    {ERR_PACK(0,HSM_F_INITKEY,0),        "HSM_INITKEY"},
+    {ERR_PACK(0,HSM_F_DIGESTINIT,0),    "HSM_DIGESTINIT"},
+    {ERR_PACK(0,HSM_F_DIGESTUPDATE,0),    "HSM_DIGESTUPDATE"},
+    {ERR_PACK(0,HSM_F_DIGESTFINISH,0),    "HSM_DIGESTFINISH"},
+    {ERR_PACK(0,HSM_F_CIPHER_UPDATE,0),    "HSM_CIPHER_UPDATE"},
+    {ERR_PACK(0,HSM_F_PREINIT,0),    "HSM_PREINIT"},
+    {ERR_PACK(0,HSM_F_ADDTOKEN,0),    "HSM_ADDTOKEN"},
+    {ERR_PACK(0,HSM_F_LOAD_PRIVKEY,0),    "HSM_LOAD_PRIVKEY"},
+    {ERR_PACK(0,HSM_F_LOAD_PUBKEY,0),    "HSM_LOAD_PUBKEY"},
+    {ERR_PACK(0,HSM_F_DIGESTCOPY,0),    "HSM_DIGESTCOPY"},
+    {ERR_PACK(0,HSM_F_GET_HSM_CIPHERS,0),	    "HSM_GET_HSM_CIPHERS"},
+    {ERR_PACK(0,HSM_F_GET_HSM_DIGESTS,0),	    "HSM_GET_HSM_DIGESTS"},
+    {ERR_PACK(0,HSM_F_ENGINE_CIPHERS,0),	    "HSM_ENGINE_CIPHERS"},
+    {ERR_PACK(0,HSM_F_ENGINE_DIGESTS,0),	    "HSM_ENGINE_DIGESTS"},
+	{ERR_PACK(0,HSM_F_FINDCERT,0),"HSM_FINDCERT"},
+    {0,NULL}
+};
+
+static ERR_STRING_DATA hsm_str_reasons[]=
+{
+    {HSM_R_ALREADY_LOADED                 ,"PKCS#11 DSO already loaded"},
+    {HSM_R_DSO_FAILURE                    ,"unable to load PKCS#11 DSO"},
+    {HSM_R_NOT_LOADED                     ,"PKCS#11 DSO not loaded"},
+    {HSM_R_PASSED_NULL_PARAMETER          ,"null parameter passed"},
+    {HSM_R_COMMAND_NOT_IMPLEMENTED        ,"command not implemented"},
+    {HSM_R_INITIALIZE                     ,"C_Initialize failed"},
+    {HSM_R_FINALIZE                       ,"C_Finalize failed"},
+    {HSM_R_GETINFO                        ,"C_GetInfo faile"},
+    {HSM_R_GETSLOTLIST                    ,"C_GetSlotList failed"},
+    {HSM_R_NO_MODULUS_OR_NO_EXPONENT      ,"no modulus or no exponent"},
+    {HSM_R_ATTRIBUT_SENSITIVE_OR_INVALID  ,"attrribute sensitive or invalid	"},
+    {HSM_R_GETATTRIBUTVALUE               ,"C_GetAttributeValue failed"},
+    {HSM_R_NO_MODULUS                     ,"no modulus"},
+    {HSM_R_NO_EXPONENT                    ,"no exponent"},
+    {HSM_R_FINDOBJECTSINIT                ,"C_FindObjectsInit failed"},
+    {HSM_R_FINDOBJECTS                    ,"C_FindObjects failed"},
+    {HSM_R_FINDOBJECTSFINAL               ,"C_FindObjectsFinal failed"},
+    {HSM_R_OBJECT_NOT_FOUND               ,"object not found"},
+    {HSM_R_CREATEOBJECT                   ,"C_CreateObject failed"},
+    {HSM_R_DESTROYOBJECT                  ,"C_DestroyObject failed"},
+    {HSM_R_OPENSESSION                    ,"C_OpenSession failed"},
+    {HSM_R_CLOSESESSION                   ,"C_CloseSession failed"},
+    {HSM_R_ENCRYPTINIT                    ,"C_EncryptInit failed"},
+    {HSM_R_ENCRYPT                        ,"C_Encrypt failed"},
+    {HSM_R_SIGNINIT                       ,"C_SignInit failed"},
+    {HSM_R_SIGN                           ,"C_Sign failed"},
+    {HSM_R_DECRYPTINIT                    ,"C_DecryptInit failed"},
+    {HSM_R_DECRYPT                        ,"C_Decrypt failed"},
+    {HSM_R_VERIFYINIT                     ,"C_VerifyRecover failed"},
+    {HSM_R_VERIFY                         ,"C_Verify failed	"},
+    {HSM_R_VERIFYRECOVERINIT              ,"C_VerifyRecoverInit failed"},
+    {HSM_R_VERIFYRECOVER                  ,"C_VerifyRecover failed"},
+    {HSM_R_GEN_KEY                        ,"C_GenerateKeyPair failed"},
+    {HSM_R_SEEDRANDOM                     ,"C_SeedRandom failed"},
+    {HSM_R_GENERATERANDOM                 ,"C_GenerateRandom failed"},
+    {HSM_R_INVALID_MESSAGE_LENGTH         ,"invalid message length"},
+    {HSM_R_UNKNOWN_ALGORITHM_TYPE         ,"unknown algorithm type"},
+    {HSM_R_UNKNOWN_ASN1_OBJECT_ID         ,"unknown asn1 onject id"},
+    {HSM_R_UNKNOWN_PADDING_TYPE           ,"unknown padding type"},
+    {HSM_R_DIGEST_TOO_BIG                 ,"digest too big"},
+    {HSM_R_MALLOC_FAILURE                 ,"malloc failure"},
+    {HSM_R_CTRL_COMMAND_NOT_IMPLEMENTED   ,"control command not implemented"},
+    {HSM_R_GETSLOTINFO		     ,"C_GetSlotInfo failed"},
+    {HSM_R_GETMECHANISMLIST		     ,"C_GetMechanismList failed"},
+    {HSM_R_GETMECHANISMINFO		     ,"C_GetMechanismInfo failed"},
+    {HSM_R_BADMECHANISM		     ,"bad mechanism"},
+    {HSM_R_DIGESTINIT		     ,"C_DigestInit failed"},
+    {HSM_R_DIGESTUPDATE		     ,"C_DigestUpdate failed"},
+    {HSM_R_DIGESTFINAL		     ,"C_DigestFinal failed"},
+    {HSM_R_NOTOKENS			     ,"no hardware tokens found"},
+    {HSM_R_NOTOKENFORALGORITHM	     ,"no tokens available to accelerate algorithm"},
+    {HSM_R_DIGEST			     ,"C_Digest failed"},
+    {HSM_R_TOKEN_NOT_AVAILABLE            ,"Token in requested slot is not available"},
+    {HSM_R_NO_SLOT_SELECTED		     ,"No slot selected, please add slot = <num> to your"
+					      " hsm.cfg configuration file"},
+	{HSM_R_LOGIN			     ,"C_Login failed"},
+	{HSM_R_BIGNUM			     ,"BN_bin2bn failed"},
+    {0,NULL}
+};
+
+#endif	
+
+static int hsm_lib_error_code=0;
+static int hsm_error_init=1;
+
+void ERR_load_hsm_strings(void)
+{
+    if (hsm_lib_error_code == 0)
+	hsm_lib_error_code = ERR_get_next_error_library();
+
+    if (hsm_error_init)
+    {
+	hsm_error_init=0;
+#ifndef OPENSSL_NO_ERR
+	ERR_load_strings(hsm_lib_error_code,hsm_str_functs);
+	ERR_load_strings(hsm_lib_error_code,hsm_str_reasons);
+#endif
+    }
+}
+
+void ERR_unload_hsm_strings(void)
+{
+    if (hsm_error_init == 0)
+    {
+#ifndef OPENSSL_NO_ERR
+	ERR_unload_strings(hsm_lib_error_code,hsm_str_functs);
+	ERR_unload_strings(hsm_lib_error_code,hsm_str_reasons);
+#endif
+	hsm_error_init = 1;
+    }
+}
+
+void ERR_hsm_error(int function, int reason, char *file, int line)
+{
+    if (hsm_lib_error_code == 0)
+	hsm_lib_error_code=ERR_get_next_error_library();
+    ERR_PUT_error(hsm_lib_error_code,function,reason,file,line);
+    //ERR_print_errors_fp(stderr);
+}
diff --git a/release/code/back_end-hsm/src/include/adapt_layer.h b/release/code/back_end-hsm/src/include/adapt_layer.h
new file mode 100644
index 0000000..dff37a1
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/adapt_layer.h
@@ -0,0 +1,296 @@
+#ifndef ADAPT_LAYER_H
+#define ADAPT_LAYER_H
+/*===========================================================================*/
+/**
+    @file    adapt_layer.h
+
+    @brief   CST adaptation layer interface
+
+@verbatim
+=============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                            INCLUDE FILES
+=============================================================================*/
+#include <stdint.h>
+
+/*===========================================================================
+                              CONSTANTS
+=============================================================================*/
+
+/*===========================================================================
+                                MACROS
+=============================================================================*/
+#define UNUSED(expr)                (void)(expr)
+
+#define CAL_SUCCESS                 ( 0) /* Operation completed successfully */
+#define CAL_FILE_NOT_FOUND          (-1) /* Error when file does not exist   */
+#define CAL_INVALID_SIG_DATA_SIZE   (-2) /* Error when sig data size invalid */
+#define CAL_FAILED_FILE_CREATE      (-3) /* Error unable to create file      */
+#define CAL_MAC_LEN_INCORRECT       (-4) /* Error MAC len is incorrect       */
+#define CAL_INVALID_ARGUMENT        (-5) /* Error argument passed is invalid */
+#define CAL_CRYPTO_API_ERROR        (-6) /* Error with openssl API           */
+#define CAL_INSUFFICIENT_BUFFER_LEN (-7) /* Buffer length is not sufficient  */
+#define CAL_DATA_COMPARE_FAILED     (-8) /* Data comparison operation failed */
+#define CAL_RAND_SEED_ERROR         (-9) /* Failure to run rand_seed         */
+#define CAL_RAND_API_ERROR         (-10) /* Failure in RAND_bytes            */
+#define CAL_NO_CRYPTO_API_ERROR    (-11) /* Error when Encryption is disabled*/
+#define CAL_INVALID_SIGNATURE      (-12) /* Error when verifying isignature  */
+#define CAL_LAST_ERROR            (-100) /* Max error codes for adapt layer  */
+
+#define FILE_BUF_SIZE             (1024) /* 1K buf for file read/file write  */
+
+#define MAX_AES_KEY_LENGTH          (32) /* Max bytes in AES key             */
+#define AES_BLOCK_BYTES             (16)           /**< Max. AES block bytes */
+#define FLAG_BYTES                   (1)                  /**< Bytes in Flag */
+#define BYTE_SIZE_BITS               (8)       /**< Number of bits in a byte */
+
+#define SIG_REQ_FILENAME   "sig_req.txt" /**< Signing request filename       */
+
+/*===========================================================================
+                                ENUMS
+=============================================================================*/
+typedef enum func_mode_e
+{
+    MODE_UNDEF = 0,     /**< Undefined functional mode */
+    MODE_NOMINAL,       /**< Execution in normal mode  */
+    MODE_HSM,           /**< Execution in HSM mode     */
+} func_mode_t;
+
+typedef enum _SIG_FMT
+{
+    SIG_FMT_UNDEF = 0,  /**< Undefined signature format */
+    SIG_FMT_PKCS1,      /**< RAW PKCS#1 signature format */
+    SIG_FMT_CMS,        /**< CMS (PKCS#7) signature format */
+    SIG_FMT_ECDSA,      /**< ECDSA signature format. R|S concatanated */
+} sig_fmt_t;
+
+
+/** Hash Digetst Algorithm */
+typedef enum hash_alg
+{
+    SHA_1 = 0,          /**< SHA-1 Digest Algorithm */
+    SHA_256,            /**< SHA-256 Digest Algorithm */
+    SHA_384,            /**< SHA-384 Digest Algorithm */
+    SHA_512,            /**< SHA-512 Digest Algorithm */
+    INVALID_DIGEST      /**< Invalid Digest Algorithm */
+} hash_alg_t;
+
+/** AES key lengths supported */
+typedef enum aes_key_bits
+{
+    AES_KEY_LEN_128 = 128, /**< 128 bits */
+    AES_KEY_LEN_192 = 192, /**< 192 bits */
+    AES_KEY_LEN_256 = 256, /**< 256 bits */
+} aes_key_bits_t;
+
+/** Encryption algorithms supported */
+typedef enum aead_alg
+{
+    AES_CCM = 0 /**< Default encryption algorithm supported */
+} aead_alg_t;
+
+/*===========================================================================
+                    STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+
+typedef struct _AEAD {
+    uint8_t *uch;
+} AEAD_t;
+
+/*===========================================================================
+                     GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+
+/*===========================================================================
+                         FUNCTION PROTOTYPES
+=============================================================================*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Converts given digest value to equivalent OpenSSL string
+ *
+ * @param[in] hash_alg one of #hash_alg_t
+ *
+ * @returns Openssl string corresponding the given hash algorithm in
+ *          @a hash_alg, if @a hash_alg is not valid #HASH_ALG_INVALID
+ *          is returned.
+ */
+char *
+get_digest_name(hash_alg_t hash_alg);
+
+/** Generate Signature Data
+ *
+ * Generates a signature for the given data file, signer certificate,
+ * hash algorithm and signature format. The signature data is returned
+ * in a buffer provided by caller.
+ *
+ * @param[in] in_file path to file with binary data to sign
+ *
+ * @param[in] cert_file path to signer certificate file
+ *
+ * @param[in] hash_alg hash algorithm in #hash_alg_t
+ *
+ * @param[in] sig_fmt signature format in #sig_fmt_t
+ *
+ * @param[out] sig_buf buffer to return signature data
+ *
+ * @param[in,out] sig_buf_bytes input size of sig_buf allocated by caller
+ *                              output size of signature data returned by API
+ *
+ * @post Errors are printed to STDERR
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_FILE_NOT_FOUND invalid path in one of the arguments
+ *
+ * @retval #CAL_INVALID_SIG_DATA_SIZE size insufficient to generate sig data
+ *
+ * @retval #CAL_INVALID_ARGUMENT one of the input arguments is invalid
+ */
+int32_t gen_sig_data(const char* in_file,
+                     const char* cert_file,
+                     hash_alg_t hash_alg,
+                     sig_fmt_t sig_fmt,
+                     uint8_t* sig_buf,
+                     size_t *sig_buf_bytes,
+                     func_mode_t mode);
+
+/** Generate authenticated encrypted data
+ *
+ * API generates authenticated encrypted data for given plain-text data file
+ *
+ * @param[in] in_file plaintext, extracted and concatenated as for signing
+ *
+ * @param[out] out_file ciphertext (file name is input)
+ *
+ * @param[in] aead_alg only AES_CCM supported for now.
+ *
+ * @param[out] aad additional authenticated data
+ *
+ * @param[in] aad_bytes size of aad (additional authenticated data)
+ *
+ * @param[out] nonce nonce bytes to return
+ *
+ * @param[in] nonce_bytes size of nonce
+ *
+ * @param[out] mac output MAC
+ *
+ * @param[in] mac_bytes size of MAC
+ *
+ * @param[in] key_bytes size of symmetric key
+ *
+ * @param[in] cert_file certificate for DEK (data enctyption key) encryption
+ *
+ * @param[out] key_file encrypted symmetric key (file name is input)
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_FILE_NOT_FOUND invalid path in one of the arguments
+ *
+ * @retval #CAL_FAILED_FILE_CREATE the output file cannot be created
+ *
+ * @retval #CAL_MAC_LEN_INCORRECT the mac_bytes is not correct
+ */
+int32_t gen_auth_encrypted_data(const char* in_file,
+                     const char* out_file,
+                     aead_alg_t aead_alg,
+                     uint8_t *aad,
+                     size_t aad_bytes,
+                     uint8_t *nonce,
+                     size_t nonce_bytes,
+                     uint8_t *mac,
+                     size_t mac_bytes,
+                     size_t key_bytes,
+                     const char* cert_file,
+                     const char* key_file,
+                     int reuse_dek);
+
+/** Computes hash digest from a given input file
+ *
+ * This function differs from the generate_hash() function in
+ * openssl_helper.c in that this function will hash an arbitrary amount of
+ * data contained in @in_file. The generate_hash expects the data in a
+ * contigous memory array with the data length already known.
+ *
+ * @param[in] in_file Character string holding the input data filename.
+ *
+ * @param[in] hash_alg Hash digest algorithm from #hash_alg_t
+ *
+ * @param[in,out] buf on input, used to read input data when computing
+ *                hash value, on output holds the resulting hash value.
+ *
+ * @param[in,out] pbuf_bytes on input, holds the size of @a buf ib bytes,
+ *                on output pbuf_bytes is updated to hold the size of the
+ *                resulting hash in bytes.
+ *
+ * @pre @a in_file, @a buf, and @a pbuf_bytes must not be NULL
+ *
+ * @post On success @a buf is updated to hold the hash digest result and
+ *       @a pbuf_bytes is updated to hold the length of the hash in bytes
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_INVALID_ARGUMENTif @a hash_alg contains an unsupported
+ *         algorithm
+ *
+ * @retval #CAL_CRYPTO_API_ERROR otherwise
+ */
+int32_t
+calculate_hash(const char *in_file,
+               hash_alg_t hash_alg,
+               uint8_t *buf,
+               int32_t *pbuf_bytes);
+
+/** Verify Signature Data
+ *
+ * Verifies a signature for the given data file, signer certificate,
+ * hash algorithm and signature format. The signature data is given
+ * in a buffer provided by caller.
+ *
+ * @param[in] in_file path to file with binary data to sign
+ *
+ * @param[in] cert_file path to signer certificate file
+ *
+ * @param[in] hash_alg hash algorithm in #hash_alg_t
+ *
+ * @param[in] sig_fmt signature format in #sig_fmt_t
+ *
+ * @param[in] sig_buf buffer to give signature data
+ *
+ * @param[in] sig_buf_bytes input size of sig_buf allocated by caller
+ *
+ * @post Errors are printed to STDERR
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_FILE_NOT_FOUND invalid path in one of the arguments
+ *
+ * @retval #CAL_INVALID_SIGNATURE invalid signature
+ *
+ * @retval #CAL_INVALID_ARGUMENT one of the input arguments is invalid
+ */
+int32_t
+ver_sig_data(const char *in_file,
+             const char *cert_file,
+             hash_alg_t hash_alg,
+             sig_fmt_t  sig_fmt,
+             uint8_t    *sig_buf,
+             size_t     sig_buf_bytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ADAPT_LAYER_H */
diff --git a/release/code/back_end-hsm/src/include/config.h b/release/code/back_end-hsm/src/include/config.h
new file mode 100644
index 0000000..c8a9fbd
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/config.h
@@ -0,0 +1,54 @@
+#ifndef ___CONFIG_H_INC___
+#define ___CONFIG_H_INC___
+/*===========================================================================*/
+/**
+ @file    config.h
+
+ @brief   Header file for config.c
+
+ @verbatim
+ =============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+ =============================================================================
+ @endverbatim */
+
+
+#define LIBCONFIG_STATIC
+
+#include <libconfig.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+
+#define MAX_PATH 260
+#define MAX_PIN_LEN 255
+#define MAX_AUTH_LEN 32
+#define MAX_ID_LEN 128
+
+/* This should definitively be removed in future version */
+/* In this version we should have it since we can't modify the frontend to support providing HSM objects ID in CSF file */
+typedef struct hsm_object {
+	char id[MAX_ID_LEN]; /*HSM Object ID*/
+	char file[MAX_PATH]; /*Object path on file system*/
+	struct hsm_object *next;
+} hsm_object_t;
+
+typedef struct hsm_config {
+	unsigned char module_path[MAX_PATH];
+	unsigned char pin[MAX_PIN_LEN];
+	unsigned long slot;
+} hsm_config_t;
+
+int read_hsm_config(const char* config_file, hsm_config_t * config,
+		hsm_object_t** hsm_objects);
+
+#endif /* ___CONFIG_H_INC___ */
+
diff --git a/release/code/back_end-hsm/src/include/cryptoki.h b/release/code/back_end-hsm/src/include/cryptoki.h
new file mode 100644
index 0000000..0295e34
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/cryptoki.h
@@ -0,0 +1,82 @@
+/* cryptoki.h include file for PKCS #11. */
+/* $Revision: 1.4 $ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki)" in all material mentioning or referencing this software.
+
+ * License is also granted to make and use derivative works provided that
+ * such works are identified as "derived from the RSA Security Inc. PKCS #11
+ * Cryptographic Token Interface (Cryptoki)" in all material mentioning or 
+ * referencing the derived work.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* This is a sample file containing the top level include directives
+ * for building Win32 Cryptoki libraries and applications.
+ */
+
+#ifndef ___CRYPTOKI_H_INC___
+#define ___CRYPTOKI_H_INC___
+
+#ifdef WIN32
+#pragma pack(push, cryptoki, 1)
+
+/* Specifies that the function is a DLL entry point. */
+//#define CK_IMPORT_SPEC __declspec(dllimport)  /* RVE: delete this to compile a static library */
+#define CK_IMPORT_SPEC
+#else
+#define CK_IMPORT_SPEC 
+#endif
+
+/* Define CRYPTOKI_EXPORTS during the build of cryptoki libraries. Do
+ * not define it in applications.
+ */
+#ifdef CRYPTOKI_EXPORTS
+  #ifdef WIN32
+    /* Specified that the function is an exported DLL entry point. */
+    #define CK_EXPORT_SPEC __declspec(dllexport)
+  #else
+    #define CK_EXPORT_SPEC CK_IMPORT_SPEC
+  #endif
+#else
+#define CK_EXPORT_SPEC CK_IMPORT_SPEC 
+#endif
+
+/* Ensures the calling convention for Win32 builds */
+#ifdef WIN32
+#define CK_CALL_SPEC __cdecl
+#else
+#define CK_CALL_SPEC 
+#endif
+
+#define CK_PTR *
+
+#define CK_DEFINE_FUNCTION(returnType, name) \
+  returnType CK_EXPORT_SPEC CK_CALL_SPEC name
+
+#define CK_DECLARE_FUNCTION(returnType, name) \
+  returnType CK_EXPORT_SPEC CK_CALL_SPEC name
+
+#define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+  returnType CK_IMPORT_SPEC (CK_CALL_SPEC CK_PTR name)
+
+#define CK_CALLBACK_FUNCTION(returnType, name) \
+  returnType (CK_CALL_SPEC CK_PTR name)
+
+#ifndef NULL_PTR
+#define NULL_PTR 0
+#endif
+
+#include "pkcs11.h"
+
+#ifdef WIN32
+#pragma pack(pop, cryptoki)
+#endif
+
+#endif /* ___CRYPTOKI_H_INC___ */
+
diff --git a/release/code/back_end-hsm/src/include/e_hsm.h b/release/code/back_end-hsm/src/include/e_hsm.h
new file mode 100644
index 0000000..ca80837
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/e_hsm.h
@@ -0,0 +1,101 @@
+/*===========================================================================*/
+/**
+ *
+ * Filename           : e_hsm.c
+ * Author             : Marouene Boubakri <marouene.boubakri@nxp.com>
+ * Description        : HSM engine for OpenSSL
+ * Creation Date      : 23.05.2018,
+ * Version            : 1.0.0
+ *
+
+@verbatim
+=============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+=============================================================================
+@endverbatim */
+
+#ifndef _E_HSM_H_
+#define _E_HSM_H_
+
+/* Number of NID's that exist in OpenSSL 1.0.0a */
+#define NUM_NID 893
+
+#include <openssl/engine.h>
+#include <cryptoki.h>
+
+#if OPENSSL_VERSION_NUMBER < 0x10100000L
+#define OLDER_OPENSSL
+#endif
+
+#define HSM_CMD_MODULE_PATH		(ENGINE_CMD_BASE)
+#define HSM_CMD_SLOT_ID		(ENGINE_CMD_BASE + 1)
+#define HSM_CMD_PIN		(ENGINE_CMD_BASE + 2)
+#define HSM_CMD_LOAD_CERT		(ENGINE_CMD_BASE + 3)
+
+struct _token {
+	struct _token *token_next; /* next token in list of all tokens */
+	CK_SLOT_ID slot_id; /* slot ID of this token */
+	CK_BYTE_PTR pin; /*slot pin for this token */
+	int hsm_implemented_ciphers[NUM_NID];
+	int hsm_implemented_digests[NUM_NID];
+};
+
+struct _token *hsm_token_list;
+struct _token *hsm_token;
+
+enum alg_type {
+	alg_rsa = 1,
+	alg_des,
+	alg_tdes,
+	alg_sha,
+	alg_dh,
+	alg_aes,
+	alg_ripemd,
+	alg_ssl3,
+	alg_md5,
+	alg_rand,
+	alg_sha224,
+	alg_sha256,
+	alg_sha384,
+	alg_sha512
+};
+
+struct token_session {
+	struct _token *token;
+	CK_SESSION_HANDLE session;
+};
+
+struct hsm_digest_ctx {
+	int alg;
+	int len;
+	struct _token *token;
+	CK_SESSION_HANDLE session;
+};
+
+struct ecdsa_method {
+    const char *name;
+    ECDSA_SIG *(*ecdsa_do_sign) (const unsigned char *dgst, int dgst_len,
+                                 EC_KEY *eckey);
+    int (*ecdsa_sign_setup) (EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv,
+                             BIGNUM **r);
+    int (*ecdsa_do_verify) (const unsigned char *dgst, int dgst_len,
+                            const ECDSA_SIG *sig, EC_KEY *eckey);
+# if 0
+    int (*init) (EC_KEY *eckey);
+    int (*finish) (EC_KEY *eckey);
+# endif
+    int flags;
+    void *app_data;
+};
+
+
+typedef struct ecdsa_method ECDSA_METHOD;
+
+#endif
diff --git a/release/code/back_end-hsm/src/include/e_hsm_err.h b/release/code/back_end-hsm/src/include/e_hsm_err.h
new file mode 100644
index 0000000..2d68abf
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/e_hsm_err.h
@@ -0,0 +1,122 @@
+#ifndef _E_HSM_ERR_H_
+#define _E_HSM_ERR_H_
+/*===========================================================================*/
+/**
+ @file    e_hsm_err.h
+
+ @brief   Header file for e_hsm_err.c
+
+ @verbatim
+ =============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+ =============================================================================
+ @endverbatim */
+
+void ERR_load_hsm_strings(void);
+void ERR_unload_hsm_strings(void);
+void ERR_hsm_error(int function, int reason, char *file, int line);
+#define hsm_err(f,r) ERR_hsm_error((f),(r),__FILE__,__LINE__)
+
+/* Error codes for the HSM functions. */
+
+/* Function codes. */
+
+#define HSM_F_INIT 100
+#define HSM_F_FINISH 101
+#define HSM_F_DESTROY 102
+#define HSM_F_CTRL 103
+#define HSM_F_RSA_INIT 104
+#define HSM_F_RSA_FINISH 105
+#define HSM_F_FINDKEY 106
+#define HSM_F_RSA_GEN_KEY 107
+#define HSM_F_RSA_PUB_ENC 108
+#define HSM_F_RSA_PRIV_ENC 109
+#define HSM_F_RSA_PUB_DEC 110
+#define HSM_F_RSA_PRIV_DEC 111
+#define HSM_F_RSA_SIGN 112
+#define HSM_F_RSA_VERIFY 113
+#define HSM_F_RAND_ADD 114
+#define HSM_F_RAND_BYTES 115
+#define HSM_F_GETSESSION 116
+#define HSM_F_FREESESSION 117
+#define HSM_F_LOAD_PUBKEY 118
+#define HSM_F_LOAD_PRIVKEY 119
+#define HSM_F_ADDTOKEN 120
+#define HSM_F_INITKEY 121
+#define HSM_F_DIGESTINIT 122
+#define HSM_F_DIGESTUPDATE 123
+#define HSM_F_DIGESTFINISH 124
+#define HSM_F_CIPHER_UPDATE 125
+#define HSM_F_PREINIT 126
+#define HSM_F_DIGESTCOPY 127
+#define HSM_F_ENGINE_DIGESTS 128
+#define HSM_F_ENGINE_CIPHERS 129
+#define HSM_F_GET_HSM_DIGESTS 130
+#define HSM_F_GET_HSM_CIPHERS 131
+#define HSM_F_FINDCERT 132
+
+/* Reason codes. */
+#define HSM_R_ALREADY_LOADED 100
+#define HSM_R_DSO_FAILURE 101
+#define HSM_R_NOT_LOADED 102
+#define HSM_R_PASSED_NULL_PARAMETER 103
+#define HSM_R_COMMAND_NOT_IMPLEMENTED 104
+#define HSM_R_INITIALIZE 105
+#define HSM_R_FINALIZE 106
+#define HSM_R_GETINFO 107
+#define HSM_R_GETSLOTLIST 108
+#define HSM_R_NO_MODULUS_OR_NO_EXPONENT 109
+#define HSM_R_ATTRIBUT_SENSITIVE_OR_INVALID 110
+#define HSM_R_GETATTRIBUTVALUE 111
+#define HSM_R_NO_MODULUS 112
+#define HSM_R_NO_EXPONENT 113
+#define HSM_R_FINDOBJECTSINIT 114
+#define HSM_R_FINDOBJECTS 115
+#define HSM_R_FINDOBJECTSFINAL 116
+#define HSM_R_OBJECT_NOT_FOUND 117
+#define HSM_R_CREATEOBJECT 118
+#define HSM_R_DESTROYOBJECT 119
+#define HSM_R_OPENSESSION 120
+#define HSM_R_CLOSESESSION 121
+#define HSM_R_ENCRYPTINIT 122
+#define HSM_R_ENCRYPT 123
+#define HSM_R_SIGNINIT 124
+#define HSM_R_SIGN 125
+#define HSM_R_DECRYPTINIT 126
+#define HSM_R_DECRYPT 127
+#define HSM_R_VERIFYINIT 128
+#define HSM_R_VERIFY 129
+#define HSM_R_VERIFYRECOVERINIT 130
+#define HSM_R_VERIFYRECOVER 131
+#define HSM_R_GEN_KEY 132
+#define HSM_R_SEEDRANDOM 133
+#define HSM_R_GENERATERANDOM 134
+#define HSM_R_INVALID_MESSAGE_LENGTH 135
+#define HSM_R_UNKNOWN_ALGORITHM_TYPE 136
+#define HSM_R_UNKNOWN_ASN1_OBJECT_ID 137
+#define HSM_R_UNKNOWN_PADDING_TYPE 138
+#define HSM_R_DIGEST_TOO_BIG 139
+#define HSM_R_MALLOC_FAILURE 140
+#define HSM_R_CTRL_COMMAND_NOT_IMPLEMENTED 141
+#define HSM_R_GETSLOTINFO 142
+#define HSM_R_GETMECHANISMLIST 143
+#define HSM_R_GETMECHANISMINFO 144
+#define HSM_R_BADMECHANISM 145
+#define HSM_R_DIGESTINIT 146
+#define HSM_R_DIGESTUPDATE 147
+#define HSM_R_DIGESTFINAL 148
+#define HSM_R_NOTOKENS 149
+#define HSM_R_NOTOKENFORALGORITHM 150
+#define HSM_R_DIGEST 151
+#define HSM_R_TOKEN_NOT_AVAILABLE 152
+#define HSM_R_NO_SLOT_SELECTED 153
+#define HSM_R_LOGIN 154
+#define HSM_R_BIGNUM 155
+#endif
diff --git a/release/code/back_end-hsm/src/include/pkcs-11v2-20a3.h b/release/code/back_end-hsm/src/include/pkcs-11v2-20a3.h
new file mode 100644
index 0000000..46b0290
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/pkcs-11v2-20a3.h
@@ -0,0 +1,124 @@
+/* pkcs-11v2-20a3.h include file for the PKCS #11 Version 2.20 Amendment 3
+   document. */
+
+/* $Revision$ */
+
+/* License to copy and use this software is granted provided that it is
+ * identified as "RSA Security Inc. PKCS #11 Cryptographic Token Interface
+ * (Cryptoki) Version 2.20 Amendment 3" in all material mentioning or
+ * referencing this software.
+
+ * RSA Security Inc. makes no representations concerning either the 
+ * merchantability of this software or the suitability of this software for
+ * any particular purpose. It is provided "as is" without express or implied
+ * warranty of any kind.
+ */
+
+/* This file is preferably included after inclusion of pkcs11.h */
+
+#ifndef _PKCS_11V2_20A3_H_
+#define _PKCS_11V2_20A3_H_ 1
+
+/* Are the definitions of this file already included in pkcs11t.h ? */
+#ifndef CKK_CAMELLIA
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Key types */
+
+/* Camellia is new for PKCS #11 v2.20 amendment 3 */
+#define CKK_CAMELLIA                   0x00000025
+/* ARIA is new for PKCS #11 v2.20 amendment 3 */
+#define CKK_ARIA                       0x00000026
+
+
+/* Mask-generating functions */
+
+/* SHA-224 is new for PKCS #11 v2.20 amendment 3 */
+#define CKG_MGF1_SHA224                0x00000005
+
+
+/* Mechanism Identifiers */
+
+/* SHA-224 is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_SHA224                     0x00000255
+#define CKM_SHA224_HMAC                0x00000256
+#define CKM_SHA224_HMAC_GENERAL        0x00000257
+
+/* SHA-224 key derivation is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_SHA224_KEY_DERIVATION      0x00000396
+
+/* SHA-224 RSA mechanisms are new for PKCS #11 v2.20 amendment 3 */
+#define CKM_SHA224_RSA_PKCS            0x00000046
+#define CKM_SHA224_RSA_PKCS_PSS        0x00000047
+
+/* AES counter mode is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_AES_CTR                    0x00001086
+
+/* Camellia is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_CAMELLIA_KEY_GEN           0x00000550
+#define CKM_CAMELLIA_ECB               0x00000551
+#define CKM_CAMELLIA_CBC               0x00000552
+#define CKM_CAMELLIA_MAC               0x00000553
+#define CKM_CAMELLIA_MAC_GENERAL       0x00000554
+#define CKM_CAMELLIA_CBC_PAD           0x00000555
+#define CKM_CAMELLIA_ECB_ENCRYPT_DATA  0x00000556
+#define CKM_CAMELLIA_CBC_ENCRYPT_DATA  0x00000557
+#define CKM_CAMELLIA_CTR               0x00000558
+
+/* ARIA is new for PKCS #11 v2.20 amendment 3 */
+#define CKM_ARIA_KEY_GEN               0x00000560
+#define CKM_ARIA_ECB                   0x00000561
+#define CKM_ARIA_CBC                   0x00000562
+#define CKM_ARIA_MAC                   0x00000563
+#define CKM_ARIA_MAC_GENERAL           0x00000564
+#define CKM_ARIA_CBC_PAD               0x00000565
+#define CKM_ARIA_ECB_ENCRYPT_DATA      0x00000566
+#define CKM_ARIA_CBC_ENCRYPT_DATA      0x00000567
+
+
+/* Mechanism parameters */
+
+/* CK_AES_CTR_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_AES_CTR_PARAMS {
+    CK_ULONG ulCounterBits;
+    CK_BYTE cb[16];
+} CK_AES_CTR_PARAMS;
+
+typedef CK_AES_CTR_PARAMS CK_PTR CK_AES_CTR_PARAMS_PTR;
+
+/* CK_CAMELLIA_CTR_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_CAMELLIA_CTR_PARAMS {
+    CK_ULONG ulCounterBits;
+    CK_BYTE cb[16];
+} CK_CAMELLIA_CTR_PARAMS;
+
+typedef CK_CAMELLIA_CTR_PARAMS CK_PTR CK_CAMELLIA_CTR_PARAMS_PTR;
+
+/* CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE      iv[16];
+    CK_BYTE_PTR  pData;
+    CK_ULONG     length;
+} CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+/* CK_ARIA_CBC_ENCRYPT_DATA_PARAMS is new for PKCS #11 v2.20 amendment 3 */
+typedef struct CK_ARIA_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE      iv[16];
+    CK_BYTE_PTR  pData;
+    CK_ULONG     length;
+} CK_ARIA_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_ARIA_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_ARIA_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif
+
+#endif
diff --git a/release/code/back_end-hsm/src/include/pkcs11.h b/release/code/back_end-hsm/src/include/pkcs11.h
new file mode 100644
index 0000000..0d78dd7
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/pkcs11.h
@@ -0,0 +1,265 @@
+/* Copyright (c) OASIS Open 2016. All Rights Reserved./
+ * /Distributed under the terms of the OASIS IPR Policy,
+ * [http://www.oasis-open.org/policies-guidelines/ipr], AS-IS, WITHOUT ANY
+ * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.
+ */
+        
+/* Latest version of the specification:
+ * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/pkcs11-base-v2.40.html
+ */
+
+#ifndef _PKCS11_H_
+#define _PKCS11_H_ 1
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Before including this file (pkcs11.h) (or pkcs11t.h by
+ * itself), 5 platform-specific macros must be defined.  These
+ * macros are described below, and typical definitions for them
+ * are also given.  Be advised that these definitions can depend
+ * on both the platform and the compiler used (and possibly also
+ * on whether a Cryptoki library is linked statically or
+ * dynamically).
+ *
+ * In addition to defining these 5 macros, the packing convention
+ * for Cryptoki structures should be set.  The Cryptoki
+ * convention on packing is that structures should be 1-byte
+ * aligned.
+ *
+ * If you're using Microsoft Developer Studio 5.0 to produce
+ * Win32 stuff, this might be done by using the following
+ * preprocessor directive before including pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(push, cryptoki, 1)
+ *
+ * and using the following preprocessor directive after including
+ * pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(pop, cryptoki)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to produce Win16 stuff, this might be done by using
+ * the following preprocessor directive before including
+ * pkcs11.h or pkcs11t.h:
+ *
+ * #pragma pack(1)
+ *
+ * In a UNIX environment, you're on your own for this.  You might
+ * not need to do (or be able to do!) anything.
+ *
+ *
+ * Now for the macros:
+ *
+ *
+ * 1. CK_PTR: The indirection string for making a pointer to an
+ * object.  It can be used like this:
+ *
+ * typedef CK_BYTE CK_PTR CK_BYTE_PTR;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to produce
+ * Win32 stuff, it might be defined by:
+ *
+ * #define CK_PTR *
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to produce Win16 stuff, it might be defined by:
+ *
+ * #define CK_PTR far *
+ *
+ * In a typical UNIX environment, it might be defined by:
+ *
+ * #define CK_PTR *
+ *
+ *
+ * 2. CK_DECLARE_FUNCTION(returnType, name): A macro which makes
+ * an importable Cryptoki library function declaration out of a
+ * return type and a function name.  It should be used in the
+ * following fashion:
+ *
+ * extern CK_DECLARE_FUNCTION(CK_RV, C_Initialize)(
+ *   CK_VOID_PTR pReserved
+ * );
+ *
+ * If you're using Microsoft Developer Studio 5.0 to declare a
+ * function in a Win32 Cryptoki .dll, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType __declspec(dllimport) name
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to declare a function in a Win16 Cryptoki .dll, it
+ * might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType __export _far _pascal name
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION(returnType, name) \
+ *   returnType name
+ *
+ *
+ * 3. CK_DECLARE_FUNCTION_POINTER(returnType, name): A macro
+ * which makes a Cryptoki API function pointer declaration or
+ * function pointer type declaration out of a return type and a
+ * function name.  It should be used in the following fashion:
+ *
+ * // Define funcPtr to be a pointer to a Cryptoki API function
+ * // taking arguments args and returning CK_RV.
+ * CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtr)(args);
+ *
+ * or
+ *
+ * // Define funcPtrType to be the type of a pointer to a
+ * // Cryptoki API function taking arguments args and returning
+ * // CK_RV, and then define funcPtr to be a variable of type
+ * // funcPtrType.
+ * typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, funcPtrType)(args);
+ * funcPtrType funcPtr;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to access
+ * functions in a Win32 Cryptoki .dll, in might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType __declspec(dllimport) (* name)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to access functions in a Win16 Cryptoki .dll, it might
+ * be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType __export _far _pascal (* name)
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_DECLARE_FUNCTION_POINTER(returnType, name) \
+ *   returnType (* name)
+ *
+ *
+ * 4. CK_CALLBACK_FUNCTION(returnType, name): A macro which makes
+ * a function pointer type for an application callback out of
+ * a return type for the callback and a name for the callback.
+ * It should be used in the following fashion:
+ *
+ * CK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);
+ *
+ * to declare a function pointer, myCallback, to a callback
+ * which takes arguments args and returns a CK_RV.  It can also
+ * be used like this:
+ *
+ * typedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);
+ * myCallbackType myCallback;
+ *
+ * If you're using Microsoft Developer Studio 5.0 to do Win32
+ * Cryptoki development, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType (* name)
+ *
+ * If you're using an earlier version of Microsoft Developer
+ * Studio to do Win16 development, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType _far _pascal (* name)
+ *
+ * In a UNIX environment, it might be defined by:
+ *
+ * #define CK_CALLBACK_FUNCTION(returnType, name) \
+ *   returnType (* name)
+ *
+ *
+ * 5. NULL_PTR: This macro is the value of a NULL pointer.
+ *
+ * In any ANSI/ISO C environment (and in many others as well),
+ * this should best be defined by
+ *
+ * #ifndef NULL_PTR
+ * #define NULL_PTR 0
+ * #endif
+ */
+
+
+/* All the various Cryptoki types and #define'd values are in the
+ * file pkcs11t.h.
+ */
+#include "pkcs11t.h"
+
+#define __PASTE(x,y)      x##y
+
+
+/* ==============================================================
+ * Define the "extern" form of all the entry points.
+ * ==============================================================
+ */
+
+#define CK_NEED_ARG_LIST  1
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  extern CK_DECLARE_FUNCTION(CK_RV, name)
+
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes.
+ */
+#include "pkcs11f.h"
+
+#undef CK_NEED_ARG_LIST
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+/* ==============================================================
+ * Define the typedef form of all the entry points.  That is, for
+ * each Cryptoki function C_XXX, define a type CK_C_XXX which is
+ * a pointer to that kind of function.
+ * ==============================================================
+ */
+
+#define CK_NEED_ARG_LIST  1
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  typedef CK_DECLARE_FUNCTION_POINTER(CK_RV, __PASTE(CK_,name))
+
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes.
+ */
+#include "pkcs11f.h"
+
+#undef CK_NEED_ARG_LIST
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+/* ==============================================================
+ * Define structed vector of entry points.  A CK_FUNCTION_LIST
+ * contains a CK_VERSION indicating a library's Cryptoki version
+ * and then a whole slew of function pointers to the routines in
+ * the library.  This type was declared, but not defined, in
+ * pkcs11t.h.
+ * ==============================================================
+ */
+
+#define CK_PKCS11_FUNCTION_INFO(name) \
+  __PASTE(CK_,name) name;
+
+struct CK_FUNCTION_LIST {
+
+  CK_VERSION    version;  /* Cryptoki version */
+
+/* Pile all the function pointers into the CK_FUNCTION_LIST. */
+/* pkcs11f.h has all the information about the Cryptoki
+ * function prototypes.
+ */
+#include "pkcs11f.h"
+
+};
+
+#undef CK_PKCS11_FUNCTION_INFO
+
+
+#undef __PASTE
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _PKCS11_H_ */
+
diff --git a/release/code/back_end-hsm/src/include/pkcs11ext.h b/release/code/back_end-hsm/src/include/pkcs11ext.h
new file mode 100644
index 0000000..65bdc79
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/pkcs11ext.h
@@ -0,0 +1,27 @@
+/*===========================================================================*/
+/**
+
+@verbatim
+=============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+=============================================================================
+@endverbatim */
+
+#ifndef PKCS11EXT_H
+#define PKCS11EXT_H
+
+#define CKM_TLS1_PRE_MASTER_KEY_GEN 	 CKM_VENDOR_DEFINED+CKM_SSL3_PRE_MASTER_KEY_GEN
+#define CKM_TLS1_MASTER_KEY_DERIVE  	 CKM_VENDOR_DEFINED+CKM_SSL3_MASTER_KEY_DERIVE 
+#define CKM_TLS1_KEY_AND_MAC_DERIVE 	 CKM_VENDOR_DEFINED+CKM_SSL3_KEY_AND_MAC_DERIVE
+#define CKM_TLS1_MD5_MAC            	 CKM_VENDOR_DEFINED+CKM_SSL3_MD5_MAC           
+#define CKM_TLS1_SHA1_MAC           	 CKM_VENDOR_DEFINED+CKM_SSL3_SHA1_MAC          
+#define CKM_RSA_PKCS_KEY_PAIR_GEN_POOL   CKM_VENDOR_DEFINED+CKM_RSA_PKCS_KEY_PAIR_GEN
+
+#endif
diff --git a/release/code/back_end-hsm/src/include/pkcs11f.h b/release/code/back_end-hsm/src/include/pkcs11f.h
new file mode 100644
index 0000000..ed90aff
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/pkcs11f.h
@@ -0,0 +1,939 @@
+/* Copyright (c) OASIS Open 2016. All Rights Reserved./
+ * /Distributed under the terms of the OASIS IPR Policy,
+ * [http://www.oasis-open.org/policies-guidelines/ipr], AS-IS, WITHOUT ANY
+ * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.
+ */
+        
+/* Latest version of the specification:
+ * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/pkcs11-base-v2.40.html
+ */
+
+/* This header file contains pretty much everything about all the
+ * Cryptoki function prototypes.  Because this information is
+ * used for more than just declaring function prototypes, the
+ * order of the functions appearing herein is important, and
+ * should not be altered.
+ */
+
+/* General-purpose */
+
+/* C_Initialize initializes the Cryptoki library. */
+CK_PKCS11_FUNCTION_INFO(C_Initialize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_VOID_PTR   pInitArgs  /* if this is not NULL_PTR, it gets
+                            * cast to CK_C_INITIALIZE_ARGS_PTR
+                            * and dereferenced
+                            */
+);
+#endif
+
+
+/* C_Finalize indicates that an application is done with the
+ * Cryptoki library.
+ */
+CK_PKCS11_FUNCTION_INFO(C_Finalize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_VOID_PTR   pReserved  /* reserved.  Should be NULL_PTR */
+);
+#endif
+
+
+/* C_GetInfo returns general information about Cryptoki. */
+CK_PKCS11_FUNCTION_INFO(C_GetInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_INFO_PTR   pInfo  /* location that receives information */
+);
+#endif
+
+
+/* C_GetFunctionList returns the function list. */
+CK_PKCS11_FUNCTION_INFO(C_GetFunctionList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_FUNCTION_LIST_PTR_PTR ppFunctionList  /* receives pointer to
+                                            * function list
+                                            */
+);
+#endif
+
+
+
+/* Slot and token management */
+
+/* C_GetSlotList obtains a list of slots in the system. */
+CK_PKCS11_FUNCTION_INFO(C_GetSlotList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_BBOOL       tokenPresent,  /* only slots with tokens */
+  CK_SLOT_ID_PTR pSlotList,     /* receives array of slot IDs */
+  CK_ULONG_PTR   pulCount       /* receives number of slots */
+);
+#endif
+
+
+/* C_GetSlotInfo obtains information about a particular slot in
+ * the system.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetSlotInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID       slotID,  /* the ID of the slot */
+  CK_SLOT_INFO_PTR pInfo    /* receives the slot information */
+);
+#endif
+
+
+/* C_GetTokenInfo obtains information about a particular token
+ * in the system.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetTokenInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID        slotID,  /* ID of the token's slot */
+  CK_TOKEN_INFO_PTR pInfo    /* receives the token information */
+);
+#endif
+
+
+/* C_GetMechanismList obtains a list of mechanism types
+ * supported by a token.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetMechanismList)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,          /* ID of token's slot */
+  CK_MECHANISM_TYPE_PTR pMechanismList,  /* gets mech. array */
+  CK_ULONG_PTR          pulCount         /* gets # of mechs. */
+);
+#endif
+
+
+/* C_GetMechanismInfo obtains information about a particular
+ * mechanism possibly supported by a token.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetMechanismInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,  /* ID of the token's slot */
+  CK_MECHANISM_TYPE     type,    /* type of mechanism */
+  CK_MECHANISM_INFO_PTR pInfo    /* receives mechanism info */
+);
+#endif
+
+
+/* C_InitToken initializes a token. */
+CK_PKCS11_FUNCTION_INFO(C_InitToken)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID      slotID,    /* ID of the token's slot */
+  CK_UTF8CHAR_PTR pPin,      /* the SO's initial PIN */
+  CK_ULONG        ulPinLen,  /* length in bytes of the PIN */
+  CK_UTF8CHAR_PTR pLabel     /* 32-byte token label (blank padded) */
+);
+#endif
+
+
+/* C_InitPIN initializes the normal user's PIN. */
+CK_PKCS11_FUNCTION_INFO(C_InitPIN)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_UTF8CHAR_PTR   pPin,      /* the normal user's PIN */
+  CK_ULONG          ulPinLen   /* length in bytes of the PIN */
+);
+#endif
+
+
+/* C_SetPIN modifies the PIN of the user who is logged in. */
+CK_PKCS11_FUNCTION_INFO(C_SetPIN)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_UTF8CHAR_PTR   pOldPin,   /* the old PIN */
+  CK_ULONG          ulOldLen,  /* length of the old PIN */
+  CK_UTF8CHAR_PTR   pNewPin,   /* the new PIN */
+  CK_ULONG          ulNewLen   /* length of the new PIN */
+);
+#endif
+
+
+
+/* Session management */
+
+/* C_OpenSession opens a session between an application and a
+ * token.
+ */
+CK_PKCS11_FUNCTION_INFO(C_OpenSession)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID            slotID,        /* the slot's ID */
+  CK_FLAGS              flags,         /* from CK_SESSION_INFO */
+  CK_VOID_PTR           pApplication,  /* passed to callback */
+  CK_NOTIFY             Notify,        /* callback function */
+  CK_SESSION_HANDLE_PTR phSession      /* gets session handle */
+);
+#endif
+
+
+/* C_CloseSession closes a session between an application and a
+ * token.
+ */
+CK_PKCS11_FUNCTION_INFO(C_CloseSession)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_CloseAllSessions closes all sessions with a token. */
+CK_PKCS11_FUNCTION_INFO(C_CloseAllSessions)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SLOT_ID     slotID  /* the token's slot */
+);
+#endif
+
+
+/* C_GetSessionInfo obtains information about the session. */
+CK_PKCS11_FUNCTION_INFO(C_GetSessionInfo)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE   hSession,  /* the session's handle */
+  CK_SESSION_INFO_PTR pInfo      /* receives session info */
+);
+#endif
+
+
+/* C_GetOperationState obtains the state of the cryptographic operation
+ * in a session.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetOperationState)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,             /* session's handle */
+  CK_BYTE_PTR       pOperationState,      /* gets state */
+  CK_ULONG_PTR      pulOperationStateLen  /* gets state length */
+);
+#endif
+
+
+/* C_SetOperationState restores the state of the cryptographic
+ * operation in a session.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SetOperationState)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR      pOperationState,      /* holds state */
+  CK_ULONG         ulOperationStateLen,  /* holds state length */
+  CK_OBJECT_HANDLE hEncryptionKey,       /* en/decryption key */
+  CK_OBJECT_HANDLE hAuthenticationKey    /* sign/verify key */
+);
+#endif
+
+
+/* C_Login logs a user into a token. */
+CK_PKCS11_FUNCTION_INFO(C_Login)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_USER_TYPE      userType,  /* the user type */
+  CK_UTF8CHAR_PTR   pPin,      /* the user's PIN */
+  CK_ULONG          ulPinLen   /* the length of the PIN */
+);
+#endif
+
+
+/* C_Logout logs a user out from a token. */
+CK_PKCS11_FUNCTION_INFO(C_Logout)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Object management */
+
+/* C_CreateObject creates a new object. */
+CK_PKCS11_FUNCTION_INFO(C_CreateObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,   /* the object's template */
+  CK_ULONG          ulCount,     /* attributes in template */
+  CK_OBJECT_HANDLE_PTR phObject  /* gets new object's handle. */
+);
+#endif
+
+
+/* C_CopyObject copies an object, creating a new object for the
+ * copy.
+ */
+CK_PKCS11_FUNCTION_INFO(C_CopyObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,    /* the session's handle */
+  CK_OBJECT_HANDLE     hObject,     /* the object's handle */
+  CK_ATTRIBUTE_PTR     pTemplate,   /* template for new object */
+  CK_ULONG             ulCount,     /* attributes in template */
+  CK_OBJECT_HANDLE_PTR phNewObject  /* receives handle of copy */
+);
+#endif
+
+
+/* C_DestroyObject destroys an object. */
+CK_PKCS11_FUNCTION_INFO(C_DestroyObject)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hObject    /* the object's handle */
+);
+#endif
+
+
+/* C_GetObjectSize gets the size of an object in bytes. */
+CK_PKCS11_FUNCTION_INFO(C_GetObjectSize)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,   /* the object's handle */
+  CK_ULONG_PTR      pulSize    /* receives size of object */
+);
+#endif
+
+
+/* C_GetAttributeValue obtains the value of one or more object
+ * attributes.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetAttributeValue)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,    /* the object's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* specifies attrs; gets vals */
+  CK_ULONG          ulCount     /* attributes in template */
+);
+#endif
+
+
+/* C_SetAttributeValue modifies the value of one or more object
+ * attributes.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SetAttributeValue)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_OBJECT_HANDLE  hObject,    /* the object's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* specifies attrs and values */
+  CK_ULONG          ulCount     /* attributes in template */
+);
+#endif
+
+
+/* C_FindObjectsInit initializes a search for token and session
+ * objects that match a template.
+ */
+CK_PKCS11_FUNCTION_INFO(C_FindObjectsInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_ATTRIBUTE_PTR  pTemplate,  /* attribute values to match */
+  CK_ULONG          ulCount     /* attrs in search template */
+);
+#endif
+
+
+/* C_FindObjects continues a search for token and session
+ * objects that match a template, obtaining additional object
+ * handles.
+ */
+CK_PKCS11_FUNCTION_INFO(C_FindObjects)
+#ifdef CK_NEED_ARG_LIST
+(
+ CK_SESSION_HANDLE    hSession,          /* session's handle */
+ CK_OBJECT_HANDLE_PTR phObject,          /* gets obj. handles */
+ CK_ULONG             ulMaxObjectCount,  /* max handles to get */
+ CK_ULONG_PTR         pulObjectCount     /* actual # returned */
+);
+#endif
+
+
+/* C_FindObjectsFinal finishes a search for token and session
+ * objects.
+ */
+CK_PKCS11_FUNCTION_INFO(C_FindObjectsFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+
+/* Encryption and decryption */
+
+/* C_EncryptInit initializes an encryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_EncryptInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the encryption mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of encryption key */
+);
+#endif
+
+
+/* C_Encrypt encrypts single-part data. */
+CK_PKCS11_FUNCTION_INFO(C_Encrypt)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pData,               /* the plaintext data */
+  CK_ULONG          ulDataLen,           /* bytes of plaintext */
+  CK_BYTE_PTR       pEncryptedData,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedDataLen  /* gets c-text size */
+);
+#endif
+
+
+/* C_EncryptUpdate continues a multiple-part encryption
+ * operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_EncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,           /* session's handle */
+  CK_BYTE_PTR       pPart,              /* the plaintext data */
+  CK_ULONG          ulPartLen,          /* plaintext data len */
+  CK_BYTE_PTR       pEncryptedPart,     /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen /* gets c-text size */
+);
+#endif
+
+
+/* C_EncryptFinal finishes a multiple-part encryption
+ * operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_EncryptFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,                /* session handle */
+  CK_BYTE_PTR       pLastEncryptedPart,      /* last c-text */
+  CK_ULONG_PTR      pulLastEncryptedPartLen  /* gets last size */
+);
+#endif
+
+
+/* C_DecryptInit initializes a decryption operation. */
+CK_PKCS11_FUNCTION_INFO(C_DecryptInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the decryption mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of decryption key */
+);
+#endif
+
+
+/* C_Decrypt decrypts encrypted data in a single part. */
+CK_PKCS11_FUNCTION_INFO(C_Decrypt)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,           /* session's handle */
+  CK_BYTE_PTR       pEncryptedData,     /* ciphertext */
+  CK_ULONG          ulEncryptedDataLen, /* ciphertext length */
+  CK_BYTE_PTR       pData,              /* gets plaintext */
+  CK_ULONG_PTR      pulDataLen          /* gets p-text size */
+);
+#endif
+
+
+/* C_DecryptUpdate continues a multiple-part decryption
+ * operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DecryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* encrypted data */
+  CK_ULONG          ulEncryptedPartLen,  /* input length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* p-text size */
+);
+#endif
+
+
+/* C_DecryptFinal finishes a multiple-part decryption
+ * operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DecryptFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pLastPart,      /* gets plaintext */
+  CK_ULONG_PTR      pulLastPartLen  /* p-text size */
+);
+#endif
+
+
+
+/* Message digesting */
+
+/* C_DigestInit initializes a message-digesting operation. */
+CK_PKCS11_FUNCTION_INFO(C_DigestInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism  /* the digesting mechanism */
+);
+#endif
+
+
+/* C_Digest digests data in a single part. */
+CK_PKCS11_FUNCTION_INFO(C_Digest)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_BYTE_PTR       pData,        /* data to be digested */
+  CK_ULONG          ulDataLen,    /* bytes of data to digest */
+  CK_BYTE_PTR       pDigest,      /* gets the message digest */
+  CK_ULONG_PTR      pulDigestLen  /* gets digest length */
+);
+#endif
+
+
+/* C_DigestUpdate continues a multiple-part message-digesting
+ * operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DigestUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* data to be digested */
+  CK_ULONG          ulPartLen  /* bytes of data to be digested */
+);
+#endif
+
+
+/* C_DigestKey continues a multi-part message-digesting
+ * operation, by digesting the value of a secret key as part of
+ * the data already digested.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DigestKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_OBJECT_HANDLE  hKey       /* secret key to digest */
+);
+#endif
+
+
+/* C_DigestFinal finishes a multiple-part message-digesting
+ * operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DigestFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_BYTE_PTR       pDigest,      /* gets the message digest */
+  CK_ULONG_PTR      pulDigestLen  /* gets byte count of digest */
+);
+#endif
+
+
+
+/* Signing and MACing */
+
+/* C_SignInit initializes a signature (private key encryption)
+ * operation, where the signature is (will be) an appendix to
+ * the data, and plaintext cannot be recovered from the
+ * signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SignInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the signature mechanism */
+  CK_OBJECT_HANDLE  hKey         /* handle of signature key */
+);
+#endif
+
+
+/* C_Sign signs (encrypts with private key) data in a single
+ * part, where the signature is (will be) an appendix to the
+ * data, and plaintext cannot be recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_Sign)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pData,           /* the data to sign */
+  CK_ULONG          ulDataLen,       /* count of bytes to sign */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+/* C_SignUpdate continues a multiple-part signature operation,
+ * where the signature is (will be) an appendix to the data,
+ * and plaintext cannot be recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SignUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* the data to sign */
+  CK_ULONG          ulPartLen  /* count of bytes to sign */
+);
+#endif
+
+
+/* C_SignFinal finishes a multiple-part signature operation,
+ * returning the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SignFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+/* C_SignRecoverInit initializes a signature operation, where
+ * the data can be recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SignRecoverInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,   /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism, /* the signature mechanism */
+  CK_OBJECT_HANDLE  hKey        /* handle of the signature key */
+);
+#endif
+
+
+/* C_SignRecover signs data in a single operation, where the
+ * data can be recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SignRecover)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pData,           /* the data to sign */
+  CK_ULONG          ulDataLen,       /* count of bytes to sign */
+  CK_BYTE_PTR       pSignature,      /* gets the signature */
+  CK_ULONG_PTR      pulSignatureLen  /* gets signature length */
+);
+#endif
+
+
+
+/* Verifying signatures and MACs */
+
+/* C_VerifyInit initializes a verification operation, where the
+ * signature is an appendix to the data, and plaintext cannot
+ * cannot be recovered from the signature (e.g. DSA).
+ */
+CK_PKCS11_FUNCTION_INFO(C_VerifyInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the verification mechanism */
+  CK_OBJECT_HANDLE  hKey         /* verification key */
+);
+#endif
+
+
+/* C_Verify verifies a signature in a single-part operation,
+ * where the signature is an appendix to the data, and plaintext
+ * cannot be recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_Verify)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pData,          /* signed data */
+  CK_ULONG          ulDataLen,      /* length of signed data */
+  CK_BYTE_PTR       pSignature,     /* signature */
+  CK_ULONG          ulSignatureLen  /* signature length*/
+);
+#endif
+
+
+/* C_VerifyUpdate continues a multiple-part verification
+ * operation, where the signature is an appendix to the data,
+ * and plaintext cannot be recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_VerifyUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pPart,     /* signed data */
+  CK_ULONG          ulPartLen  /* length of signed data */
+);
+#endif
+
+
+/* C_VerifyFinal finishes a multiple-part verification
+ * operation, checking the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_VerifyFinal)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,       /* the session's handle */
+  CK_BYTE_PTR       pSignature,     /* signature to verify */
+  CK_ULONG          ulSignatureLen  /* signature length */
+);
+#endif
+
+
+/* C_VerifyRecoverInit initializes a signature verification
+ * operation, where the data is recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_VerifyRecoverInit)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,  /* the verification mechanism */
+  CK_OBJECT_HANDLE  hKey         /* verification key */
+);
+#endif
+
+
+/* C_VerifyRecover verifies a signature in a single-part
+ * operation, where the data is recovered from the signature.
+ */
+CK_PKCS11_FUNCTION_INFO(C_VerifyRecover)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_BYTE_PTR       pSignature,      /* signature to verify */
+  CK_ULONG          ulSignatureLen,  /* signature length */
+  CK_BYTE_PTR       pData,           /* gets signed data */
+  CK_ULONG_PTR      pulDataLen       /* gets signed data len */
+);
+#endif
+
+
+
+/* Dual-function cryptographic operations */
+
+/* C_DigestEncryptUpdate continues a multiple-part digesting
+ * and encryption operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DigestEncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pPart,               /* the plaintext data */
+  CK_ULONG          ulPartLen,           /* plaintext length */
+  CK_BYTE_PTR       pEncryptedPart,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen  /* gets c-text length */
+);
+#endif
+
+
+/* C_DecryptDigestUpdate continues a multiple-part decryption and
+ * digesting operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DecryptDigestUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* ciphertext */
+  CK_ULONG          ulEncryptedPartLen,  /* ciphertext length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* gets plaintext len */
+);
+#endif
+
+
+/* C_SignEncryptUpdate continues a multiple-part signing and
+ * encryption operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SignEncryptUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pPart,               /* the plaintext data */
+  CK_ULONG          ulPartLen,           /* plaintext length */
+  CK_BYTE_PTR       pEncryptedPart,      /* gets ciphertext */
+  CK_ULONG_PTR      pulEncryptedPartLen  /* gets c-text length */
+);
+#endif
+
+
+/* C_DecryptVerifyUpdate continues a multiple-part decryption and
+ * verify operation.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DecryptVerifyUpdate)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,            /* session's handle */
+  CK_BYTE_PTR       pEncryptedPart,      /* ciphertext */
+  CK_ULONG          ulEncryptedPartLen,  /* ciphertext length */
+  CK_BYTE_PTR       pPart,               /* gets plaintext */
+  CK_ULONG_PTR      pulPartLen           /* gets p-text length */
+);
+#endif
+
+
+
+/* Key management */
+
+/* C_GenerateKey generates a secret key, creating a new key
+ * object.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GenerateKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,    /* the session's handle */
+  CK_MECHANISM_PTR     pMechanism,  /* key generation mech. */
+  CK_ATTRIBUTE_PTR     pTemplate,   /* template for new key */
+  CK_ULONG             ulCount,     /* # of attrs in template */
+  CK_OBJECT_HANDLE_PTR phKey        /* gets handle of new key */
+);
+#endif
+
+
+/* C_GenerateKeyPair generates a public-key/private-key pair,
+ * creating new key objects.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GenerateKeyPair)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,                    /* session handle */
+  CK_MECHANISM_PTR     pMechanism,                  /* key-gen mech. */
+  CK_ATTRIBUTE_PTR     pPublicKeyTemplate,          /* template for pub. key */
+  CK_ULONG             ulPublicKeyAttributeCount,   /* # pub. attrs. */
+  CK_ATTRIBUTE_PTR     pPrivateKeyTemplate,         /* template for priv. key */
+  CK_ULONG             ulPrivateKeyAttributeCount,  /* # priv.  attrs. */
+  CK_OBJECT_HANDLE_PTR phPublicKey,                 /* gets pub. key handle */
+  CK_OBJECT_HANDLE_PTR phPrivateKey                 /* gets priv. key handle */
+);
+#endif
+
+
+/* C_WrapKey wraps (i.e., encrypts) a key. */
+CK_PKCS11_FUNCTION_INFO(C_WrapKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,        /* the session's handle */
+  CK_MECHANISM_PTR  pMechanism,      /* the wrapping mechanism */
+  CK_OBJECT_HANDLE  hWrappingKey,    /* wrapping key */
+  CK_OBJECT_HANDLE  hKey,            /* key to be wrapped */
+  CK_BYTE_PTR       pWrappedKey,     /* gets wrapped key */
+  CK_ULONG_PTR      pulWrappedKeyLen /* gets wrapped key size */
+);
+#endif
+
+
+/* C_UnwrapKey unwraps (decrypts) a wrapped key, creating a new
+ * key object.
+ */
+CK_PKCS11_FUNCTION_INFO(C_UnwrapKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,          /* session's handle */
+  CK_MECHANISM_PTR     pMechanism,        /* unwrapping mech. */
+  CK_OBJECT_HANDLE     hUnwrappingKey,    /* unwrapping key */
+  CK_BYTE_PTR          pWrappedKey,       /* the wrapped key */
+  CK_ULONG             ulWrappedKeyLen,   /* wrapped key len */
+  CK_ATTRIBUTE_PTR     pTemplate,         /* new key template */
+  CK_ULONG             ulAttributeCount,  /* template length */
+  CK_OBJECT_HANDLE_PTR phKey              /* gets new handle */
+);
+#endif
+
+
+/* C_DeriveKey derives a key from a base key, creating a new key
+ * object.
+ */
+CK_PKCS11_FUNCTION_INFO(C_DeriveKey)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE    hSession,          /* session's handle */
+  CK_MECHANISM_PTR     pMechanism,        /* key deriv. mech. */
+  CK_OBJECT_HANDLE     hBaseKey,          /* base key */
+  CK_ATTRIBUTE_PTR     pTemplate,         /* new key template */
+  CK_ULONG             ulAttributeCount,  /* template length */
+  CK_OBJECT_HANDLE_PTR phKey              /* gets new handle */
+);
+#endif
+
+
+
+/* Random number generation */
+
+/* C_SeedRandom mixes additional seed material into the token's
+ * random number generator.
+ */
+CK_PKCS11_FUNCTION_INFO(C_SeedRandom)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,  /* the session's handle */
+  CK_BYTE_PTR       pSeed,     /* the seed material */
+  CK_ULONG          ulSeedLen  /* length of seed material */
+);
+#endif
+
+
+/* C_GenerateRandom generates random data. */
+CK_PKCS11_FUNCTION_INFO(C_GenerateRandom)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession,    /* the session's handle */
+  CK_BYTE_PTR       RandomData,  /* receives the random data */
+  CK_ULONG          ulRandomLen  /* # of bytes to generate */
+);
+#endif
+
+
+
+/* Parallel function management */
+
+/* C_GetFunctionStatus is a legacy function; it obtains an
+ * updated status of a function running in parallel with an
+ * application.
+ */
+CK_PKCS11_FUNCTION_INFO(C_GetFunctionStatus)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_CancelFunction is a legacy function; it cancels a function
+ * running in parallel.
+ */
+CK_PKCS11_FUNCTION_INFO(C_CancelFunction)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_SESSION_HANDLE hSession  /* the session's handle */
+);
+#endif
+
+
+/* C_WaitForSlotEvent waits for a slot event (token insertion,
+ * removal, etc.) to occur.
+ */
+CK_PKCS11_FUNCTION_INFO(C_WaitForSlotEvent)
+#ifdef CK_NEED_ARG_LIST
+(
+  CK_FLAGS flags,        /* blocking/nonblocking flag */
+  CK_SLOT_ID_PTR pSlot,  /* location that receives the slot ID */
+  CK_VOID_PTR pRserved   /* reserved.  Should be NULL_PTR */
+);
+#endif
+
diff --git a/release/code/back_end-hsm/src/include/pkcs11t.h b/release/code/back_end-hsm/src/include/pkcs11t.h
new file mode 100644
index 0000000..c13e67c
--- /dev/null
+++ b/release/code/back_end-hsm/src/include/pkcs11t.h
@@ -0,0 +1,2003 @@
+/* Copyright (c) OASIS Open 2016. All Rights Reserved./
+ * /Distributed under the terms of the OASIS IPR Policy,
+ * [http://www.oasis-open.org/policies-guidelines/ipr], AS-IS, WITHOUT ANY
+ * IMPLIED OR EXPRESS WARRANTY; there is no warranty of MERCHANTABILITY, FITNESS FOR A
+ * PARTICULAR PURPOSE or NONINFRINGEMENT of the rights of others.
+ */
+        
+/* Latest version of the specification:
+ * http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/pkcs11-base-v2.40.html
+ */
+
+/* See top of pkcs11.h for information about the macros that
+ * must be defined and the structure-packing conventions that
+ * must be set before including this file.
+ */
+
+#ifndef _PKCS11T_H_
+#define _PKCS11T_H_ 1
+
+#define CRYPTOKI_VERSION_MAJOR          2
+#define CRYPTOKI_VERSION_MINOR          40
+#define CRYPTOKI_VERSION_AMENDMENT      0
+
+#define CK_TRUE         1
+#define CK_FALSE        0
+
+#ifndef CK_DISABLE_TRUE_FALSE
+#ifndef FALSE
+#define FALSE CK_FALSE
+#endif
+#ifndef TRUE
+#define TRUE CK_TRUE
+#endif
+#endif
+
+/* an unsigned 8-bit value */
+typedef unsigned char     CK_BYTE;
+
+/* an unsigned 8-bit character */
+typedef CK_BYTE           CK_CHAR;
+
+/* an 8-bit UTF-8 character */
+typedef CK_BYTE           CK_UTF8CHAR;
+
+/* a BYTE-sized Boolean flag */
+typedef CK_BYTE           CK_BBOOL;
+
+/* an unsigned value, at least 32 bits long */
+typedef unsigned long int CK_ULONG;
+
+/* a signed value, the same size as a CK_ULONG */
+typedef long int          CK_LONG;
+
+/* at least 32 bits; each bit is a Boolean flag */
+typedef CK_ULONG          CK_FLAGS;
+
+
+/* some special values for certain CK_ULONG variables */
+#define CK_UNAVAILABLE_INFORMATION      (~0UL)
+#define CK_EFFECTIVELY_INFINITE         0UL
+
+
+typedef CK_BYTE     CK_PTR   CK_BYTE_PTR;
+typedef CK_CHAR     CK_PTR   CK_CHAR_PTR;
+typedef CK_UTF8CHAR CK_PTR   CK_UTF8CHAR_PTR;
+typedef CK_ULONG    CK_PTR   CK_ULONG_PTR;
+typedef void        CK_PTR   CK_VOID_PTR;
+
+/* Pointer to a CK_VOID_PTR-- i.e., pointer to pointer to void */
+typedef CK_VOID_PTR CK_PTR CK_VOID_PTR_PTR;
+
+
+/* The following value is always invalid if used as a session
+ * handle or object handle
+ */
+#define CK_INVALID_HANDLE       0UL
+
+
+typedef struct CK_VERSION {
+  CK_BYTE       major;  /* integer portion of version number */
+  CK_BYTE       minor;  /* 1/100ths portion of version number */
+} CK_VERSION;
+
+typedef CK_VERSION CK_PTR CK_VERSION_PTR;
+
+
+typedef struct CK_INFO {
+  CK_VERSION    cryptokiVersion;     /* Cryptoki interface ver */
+  CK_UTF8CHAR   manufacturerID[32];  /* blank padded */
+  CK_FLAGS      flags;               /* must be zero */
+  CK_UTF8CHAR   libraryDescription[32];  /* blank padded */
+  CK_VERSION    libraryVersion;          /* version of library */
+} CK_INFO;
+
+typedef CK_INFO CK_PTR    CK_INFO_PTR;
+
+
+/* CK_NOTIFICATION enumerates the types of notifications that
+ * Cryptoki provides to an application
+ */
+typedef CK_ULONG CK_NOTIFICATION;
+#define CKN_SURRENDER           0UL
+#define CKN_OTP_CHANGED         1UL
+
+typedef CK_ULONG          CK_SLOT_ID;
+
+typedef CK_SLOT_ID CK_PTR CK_SLOT_ID_PTR;
+
+
+/* CK_SLOT_INFO provides information about a slot */
+typedef struct CK_SLOT_INFO {
+  CK_UTF8CHAR   slotDescription[64];  /* blank padded */
+  CK_UTF8CHAR   manufacturerID[32];   /* blank padded */
+  CK_FLAGS      flags;
+
+  CK_VERSION    hardwareVersion;  /* version of hardware */
+  CK_VERSION    firmwareVersion;  /* version of firmware */
+} CK_SLOT_INFO;
+
+/* flags: bit flags that provide capabilities of the slot
+ *      Bit Flag              Mask        Meaning
+ */
+#define CKF_TOKEN_PRESENT     0x00000001UL  /* a token is there */
+#define CKF_REMOVABLE_DEVICE  0x00000002UL  /* removable devices*/
+#define CKF_HW_SLOT           0x00000004UL  /* hardware slot */
+
+typedef CK_SLOT_INFO CK_PTR CK_SLOT_INFO_PTR;
+
+
+/* CK_TOKEN_INFO provides information about a token */
+typedef struct CK_TOKEN_INFO {
+  CK_UTF8CHAR   label[32];           /* blank padded */
+  CK_UTF8CHAR   manufacturerID[32];  /* blank padded */
+  CK_UTF8CHAR   model[16];           /* blank padded */
+  CK_CHAR       serialNumber[16];    /* blank padded */
+  CK_FLAGS      flags;               /* see below */
+
+  CK_ULONG      ulMaxSessionCount;     /* max open sessions */
+  CK_ULONG      ulSessionCount;        /* sess. now open */
+  CK_ULONG      ulMaxRwSessionCount;   /* max R/W sessions */
+  CK_ULONG      ulRwSessionCount;      /* R/W sess. now open */
+  CK_ULONG      ulMaxPinLen;           /* in bytes */
+  CK_ULONG      ulMinPinLen;           /* in bytes */
+  CK_ULONG      ulTotalPublicMemory;   /* in bytes */
+  CK_ULONG      ulFreePublicMemory;    /* in bytes */
+  CK_ULONG      ulTotalPrivateMemory;  /* in bytes */
+  CK_ULONG      ulFreePrivateMemory;   /* in bytes */
+  CK_VERSION    hardwareVersion;       /* version of hardware */
+  CK_VERSION    firmwareVersion;       /* version of firmware */
+  CK_CHAR       utcTime[16];           /* time */
+} CK_TOKEN_INFO;
+
+/* The flags parameter is defined as follows:
+ *      Bit Flag                    Mask        Meaning
+ */
+#define CKF_RNG                     0x00000001UL  /* has random # generator */
+#define CKF_WRITE_PROTECTED         0x00000002UL  /* token is write-protected */
+#define CKF_LOGIN_REQUIRED          0x00000004UL  /* user must login */
+#define CKF_USER_PIN_INITIALIZED    0x00000008UL  /* normal user's PIN is set */
+
+/* CKF_RESTORE_KEY_NOT_NEEDED.  If it is set,
+ * that means that *every* time the state of cryptographic
+ * operations of a session is successfully saved, all keys
+ * needed to continue those operations are stored in the state
+ */
+#define CKF_RESTORE_KEY_NOT_NEEDED  0x00000020UL
+
+/* CKF_CLOCK_ON_TOKEN.  If it is set, that means
+ * that the token has some sort of clock.  The time on that
+ * clock is returned in the token info structure
+ */
+#define CKF_CLOCK_ON_TOKEN          0x00000040UL
+
+/* CKF_PROTECTED_AUTHENTICATION_PATH.  If it is
+ * set, that means that there is some way for the user to login
+ * without sending a PIN through the Cryptoki library itself
+ */
+#define CKF_PROTECTED_AUTHENTICATION_PATH 0x00000100UL
+
+/* CKF_DUAL_CRYPTO_OPERATIONS.  If it is true,
+ * that means that a single session with the token can perform
+ * dual simultaneous cryptographic operations (digest and
+ * encrypt; decrypt and digest; sign and encrypt; and decrypt
+ * and sign)
+ */
+#define CKF_DUAL_CRYPTO_OPERATIONS  0x00000200UL
+
+/* CKF_TOKEN_INITIALIZED. If it is true, the
+ * token has been initialized using C_InitializeToken or an
+ * equivalent mechanism outside the scope of PKCS #11.
+ * Calling C_InitializeToken when this flag is set will cause
+ * the token to be reinitialized.
+ */
+#define CKF_TOKEN_INITIALIZED       0x00000400UL
+
+/* CKF_SECONDARY_AUTHENTICATION. If it is
+ * true, the token supports secondary authentication for
+ * private key objects.
+ */
+#define CKF_SECONDARY_AUTHENTICATION  0x00000800UL
+
+/* CKF_USER_PIN_COUNT_LOW. If it is true, an
+ * incorrect user login PIN has been entered at least once
+ * since the last successful authentication.
+ */
+#define CKF_USER_PIN_COUNT_LOW       0x00010000UL
+
+/* CKF_USER_PIN_FINAL_TRY. If it is true,
+ * supplying an incorrect user PIN will it to become locked.
+ */
+#define CKF_USER_PIN_FINAL_TRY       0x00020000UL
+
+/* CKF_USER_PIN_LOCKED. If it is true, the
+ * user PIN has been locked. User login to the token is not
+ * possible.
+ */
+#define CKF_USER_PIN_LOCKED          0x00040000UL
+
+/* CKF_USER_PIN_TO_BE_CHANGED. If it is true,
+ * the user PIN value is the default value set by token
+ * initialization or manufacturing, or the PIN has been
+ * expired by the card.
+ */
+#define CKF_USER_PIN_TO_BE_CHANGED   0x00080000UL
+
+/* CKF_SO_PIN_COUNT_LOW. If it is true, an
+ * incorrect SO login PIN has been entered at least once since
+ * the last successful authentication.
+ */
+#define CKF_SO_PIN_COUNT_LOW         0x00100000UL
+
+/* CKF_SO_PIN_FINAL_TRY. If it is true,
+ * supplying an incorrect SO PIN will it to become locked.
+ */
+#define CKF_SO_PIN_FINAL_TRY         0x00200000UL
+
+/* CKF_SO_PIN_LOCKED. If it is true, the SO
+ * PIN has been locked. SO login to the token is not possible.
+ */
+#define CKF_SO_PIN_LOCKED            0x00400000UL
+
+/* CKF_SO_PIN_TO_BE_CHANGED. If it is true,
+ * the SO PIN value is the default value set by token
+ * initialization or manufacturing, or the PIN has been
+ * expired by the card.
+ */
+#define CKF_SO_PIN_TO_BE_CHANGED     0x00800000UL
+
+#define CKF_ERROR_STATE              0x01000000UL
+
+typedef CK_TOKEN_INFO CK_PTR CK_TOKEN_INFO_PTR;
+
+
+/* CK_SESSION_HANDLE is a Cryptoki-assigned value that
+ * identifies a session
+ */
+typedef CK_ULONG          CK_SESSION_HANDLE;
+
+typedef CK_SESSION_HANDLE CK_PTR CK_SESSION_HANDLE_PTR;
+
+
+/* CK_USER_TYPE enumerates the types of Cryptoki users */
+typedef CK_ULONG          CK_USER_TYPE;
+/* Security Officer */
+#define CKU_SO                  0UL
+/* Normal user */
+#define CKU_USER                1UL
+/* Context specific */
+#define CKU_CONTEXT_SPECIFIC    2UL
+
+/* CK_STATE enumerates the session states */
+typedef CK_ULONG          CK_STATE;
+#define CKS_RO_PUBLIC_SESSION   0UL
+#define CKS_RO_USER_FUNCTIONS   1UL
+#define CKS_RW_PUBLIC_SESSION   2UL
+#define CKS_RW_USER_FUNCTIONS   3UL
+#define CKS_RW_SO_FUNCTIONS     4UL
+
+/* CK_SESSION_INFO provides information about a session */
+typedef struct CK_SESSION_INFO {
+  CK_SLOT_ID    slotID;
+  CK_STATE      state;
+  CK_FLAGS      flags;          /* see below */
+  CK_ULONG      ulDeviceError;  /* device-dependent error code */
+} CK_SESSION_INFO;
+
+/* The flags are defined in the following table:
+ *      Bit Flag                Mask        Meaning
+ */
+#define CKF_RW_SESSION          0x00000002UL /* session is r/w */
+#define CKF_SERIAL_SESSION      0x00000004UL /* no parallel    */
+
+typedef CK_SESSION_INFO CK_PTR CK_SESSION_INFO_PTR;
+
+
+/* CK_OBJECT_HANDLE is a token-specific identifier for an
+ * object
+ */
+typedef CK_ULONG          CK_OBJECT_HANDLE;
+
+typedef CK_OBJECT_HANDLE CK_PTR CK_OBJECT_HANDLE_PTR;
+
+
+/* CK_OBJECT_CLASS is a value that identifies the classes (or
+ * types) of objects that Cryptoki recognizes.  It is defined
+ * as follows:
+ */
+typedef CK_ULONG          CK_OBJECT_CLASS;
+
+/* The following classes of objects are defined: */
+#define CKO_DATA              0x00000000UL
+#define CKO_CERTIFICATE       0x00000001UL
+#define CKO_PUBLIC_KEY        0x00000002UL
+#define CKO_PRIVATE_KEY       0x00000003UL
+#define CKO_SECRET_KEY        0x00000004UL
+#define CKO_HW_FEATURE        0x00000005UL
+#define CKO_DOMAIN_PARAMETERS 0x00000006UL
+#define CKO_MECHANISM         0x00000007UL
+#define CKO_OTP_KEY           0x00000008UL
+
+#define CKO_VENDOR_DEFINED    0x80000000UL
+
+typedef CK_OBJECT_CLASS CK_PTR CK_OBJECT_CLASS_PTR;
+
+/* CK_HW_FEATURE_TYPE is a value that identifies the hardware feature type
+ * of an object with CK_OBJECT_CLASS equal to CKO_HW_FEATURE.
+ */
+typedef CK_ULONG          CK_HW_FEATURE_TYPE;
+
+/* The following hardware feature types are defined */
+#define CKH_MONOTONIC_COUNTER  0x00000001UL
+#define CKH_CLOCK              0x00000002UL
+#define CKH_USER_INTERFACE     0x00000003UL
+#define CKH_VENDOR_DEFINED     0x80000000UL
+
+/* CK_KEY_TYPE is a value that identifies a key type */
+typedef CK_ULONG          CK_KEY_TYPE;
+
+/* the following key types are defined: */
+#define CKK_RSA                 0x00000000UL
+#define CKK_DSA                 0x00000001UL
+#define CKK_DH                  0x00000002UL
+#define CKK_ECDSA               0x00000003UL /* Deprecated */
+#define CKK_EC                  0x00000003UL
+#define CKK_X9_42_DH            0x00000004UL
+#define CKK_KEA                 0x00000005UL
+#define CKK_GENERIC_SECRET      0x00000010UL
+#define CKK_RC2                 0x00000011UL
+#define CKK_RC4                 0x00000012UL
+#define CKK_DES                 0x00000013UL
+#define CKK_DES2                0x00000014UL
+#define CKK_DES3                0x00000015UL
+#define CKK_CAST                0x00000016UL
+#define CKK_CAST3               0x00000017UL
+#define CKK_CAST5               0x00000018UL /* Deprecated */
+#define CKK_CAST128             0x00000018UL
+#define CKK_RC5                 0x00000019UL
+#define CKK_IDEA                0x0000001AUL
+#define CKK_SKIPJACK            0x0000001BUL
+#define CKK_BATON               0x0000001CUL
+#define CKK_JUNIPER             0x0000001DUL
+#define CKK_CDMF                0x0000001EUL
+#define CKK_AES                 0x0000001FUL
+#define CKK_BLOWFISH            0x00000020UL
+#define CKK_TWOFISH             0x00000021UL
+#define CKK_SECURID             0x00000022UL
+#define CKK_HOTP                0x00000023UL
+#define CKK_ACTI                0x00000024UL
+#define CKK_CAMELLIA            0x00000025UL
+#define CKK_ARIA                0x00000026UL
+
+#define CKK_MD5_HMAC            0x00000027UL
+#define CKK_SHA_1_HMAC          0x00000028UL
+#define CKK_RIPEMD128_HMAC      0x00000029UL
+#define CKK_RIPEMD160_HMAC      0x0000002AUL
+#define CKK_SHA256_HMAC         0x0000002BUL
+#define CKK_SHA384_HMAC         0x0000002CUL
+#define CKK_SHA512_HMAC         0x0000002DUL
+#define CKK_SHA224_HMAC         0x0000002EUL
+
+#define CKK_SEED                0x0000002FUL
+#define CKK_GOSTR3410           0x00000030UL
+#define CKK_GOSTR3411           0x00000031UL
+#define CKK_GOST28147           0x00000032UL
+
+
+
+#define CKK_VENDOR_DEFINED      0x80000000UL
+
+
+/* CK_CERTIFICATE_TYPE is a value that identifies a certificate
+ * type
+ */
+typedef CK_ULONG          CK_CERTIFICATE_TYPE;
+
+#define CK_CERTIFICATE_CATEGORY_UNSPECIFIED     0UL
+#define CK_CERTIFICATE_CATEGORY_TOKEN_USER      1UL
+#define CK_CERTIFICATE_CATEGORY_AUTHORITY       2UL
+#define CK_CERTIFICATE_CATEGORY_OTHER_ENTITY    3UL
+
+#define CK_SECURITY_DOMAIN_UNSPECIFIED     0UL
+#define CK_SECURITY_DOMAIN_MANUFACTURER    1UL
+#define CK_SECURITY_DOMAIN_OPERATOR        2UL
+#define CK_SECURITY_DOMAIN_THIRD_PARTY     3UL
+
+
+/* The following certificate types are defined: */
+#define CKC_X_509               0x00000000UL
+#define CKC_X_509_ATTR_CERT     0x00000001UL
+#define CKC_WTLS                0x00000002UL
+#define CKC_VENDOR_DEFINED      0x80000000UL
+
+
+/* CK_ATTRIBUTE_TYPE is a value that identifies an attribute
+ * type
+ */
+typedef CK_ULONG          CK_ATTRIBUTE_TYPE;
+
+/* The CKF_ARRAY_ATTRIBUTE flag identifies an attribute which
+ * consists of an array of values.
+ */
+#define CKF_ARRAY_ATTRIBUTE     0x40000000UL
+
+/* The following OTP-related defines relate to the CKA_OTP_FORMAT attribute */
+#define CK_OTP_FORMAT_DECIMAL           0UL
+#define CK_OTP_FORMAT_HEXADECIMAL       1UL
+#define CK_OTP_FORMAT_ALPHANUMERIC      2UL
+#define CK_OTP_FORMAT_BINARY            3UL
+
+/* The following OTP-related defines relate to the CKA_OTP_..._REQUIREMENT
+ * attributes
+ */
+#define CK_OTP_PARAM_IGNORED            0UL
+#define CK_OTP_PARAM_OPTIONAL           1UL
+#define CK_OTP_PARAM_MANDATORY          2UL
+
+/* The following attribute types are defined: */
+#define CKA_CLASS              0x00000000UL
+#define CKA_TOKEN              0x00000001UL
+#define CKA_PRIVATE            0x00000002UL
+#define CKA_LABEL              0x00000003UL
+#define CKA_APPLICATION        0x00000010UL
+#define CKA_VALUE              0x00000011UL
+#define CKA_OBJECT_ID          0x00000012UL
+#define CKA_CERTIFICATE_TYPE   0x00000080UL
+#define CKA_ISSUER             0x00000081UL
+#define CKA_SERIAL_NUMBER      0x00000082UL
+#define CKA_AC_ISSUER          0x00000083UL
+#define CKA_OWNER              0x00000084UL
+#define CKA_ATTR_TYPES         0x00000085UL
+#define CKA_TRUSTED            0x00000086UL
+#define CKA_CERTIFICATE_CATEGORY        0x00000087UL
+#define CKA_JAVA_MIDP_SECURITY_DOMAIN   0x00000088UL
+#define CKA_URL                         0x00000089UL
+#define CKA_HASH_OF_SUBJECT_PUBLIC_KEY  0x0000008AUL
+#define CKA_HASH_OF_ISSUER_PUBLIC_KEY   0x0000008BUL
+#define CKA_NAME_HASH_ALGORITHM         0x0000008CUL
+#define CKA_CHECK_VALUE                 0x00000090UL
+
+#define CKA_KEY_TYPE           0x00000100UL
+#define CKA_SUBJECT            0x00000101UL
+#define CKA_ID                 0x00000102UL
+#define CKA_SENSITIVE          0x00000103UL
+#define CKA_ENCRYPT            0x00000104UL
+#define CKA_DECRYPT            0x00000105UL
+#define CKA_WRAP               0x00000106UL
+#define CKA_UNWRAP             0x00000107UL
+#define CKA_SIGN               0x00000108UL
+#define CKA_SIGN_RECOVER       0x00000109UL
+#define CKA_VERIFY             0x0000010AUL
+#define CKA_VERIFY_RECOVER     0x0000010BUL
+#define CKA_DERIVE             0x0000010CUL
+#define CKA_START_DATE         0x00000110UL
+#define CKA_END_DATE           0x00000111UL
+#define CKA_MODULUS            0x00000120UL
+#define CKA_MODULUS_BITS       0x00000121UL
+#define CKA_PUBLIC_EXPONENT    0x00000122UL
+#define CKA_PRIVATE_EXPONENT   0x00000123UL
+#define CKA_PRIME_1            0x00000124UL
+#define CKA_PRIME_2            0x00000125UL
+#define CKA_EXPONENT_1         0x00000126UL
+#define CKA_EXPONENT_2         0x00000127UL
+#define CKA_COEFFICIENT        0x00000128UL
+#define CKA_PUBLIC_KEY_INFO    0x00000129UL
+#define CKA_PRIME              0x00000130UL
+#define CKA_SUBPRIME           0x00000131UL
+#define CKA_BASE               0x00000132UL
+
+#define CKA_PRIME_BITS         0x00000133UL
+#define CKA_SUBPRIME_BITS      0x00000134UL
+#define CKA_SUB_PRIME_BITS     CKA_SUBPRIME_BITS
+
+#define CKA_VALUE_BITS         0x00000160UL
+#define CKA_VALUE_LEN          0x00000161UL
+#define CKA_EXTRACTABLE        0x00000162UL
+#define CKA_LOCAL              0x00000163UL
+#define CKA_NEVER_EXTRACTABLE  0x00000164UL
+#define CKA_ALWAYS_SENSITIVE   0x00000165UL
+#define CKA_KEY_GEN_MECHANISM  0x00000166UL
+
+#define CKA_MODIFIABLE         0x00000170UL
+#define CKA_COPYABLE           0x00000171UL
+
+#define CKA_DESTROYABLE        0x00000172UL
+
+#define CKA_ECDSA_PARAMS       0x00000180UL /* Deprecated */
+#define CKA_EC_PARAMS          0x00000180UL
+
+#define CKA_EC_POINT           0x00000181UL
+
+#define CKA_SECONDARY_AUTH     0x00000200UL /* Deprecated */
+#define CKA_AUTH_PIN_FLAGS     0x00000201UL /* Deprecated */
+
+#define CKA_ALWAYS_AUTHENTICATE  0x00000202UL
+
+#define CKA_WRAP_WITH_TRUSTED    0x00000210UL
+#define CKA_WRAP_TEMPLATE        (CKF_ARRAY_ATTRIBUTE|0x00000211UL)
+#define CKA_UNWRAP_TEMPLATE      (CKF_ARRAY_ATTRIBUTE|0x00000212UL)
+#define CKA_DERIVE_TEMPLATE      (CKF_ARRAY_ATTRIBUTE|0x00000213UL)
+
+#define CKA_OTP_FORMAT                0x00000220UL
+#define CKA_OTP_LENGTH                0x00000221UL
+#define CKA_OTP_TIME_INTERVAL         0x00000222UL
+#define CKA_OTP_USER_FRIENDLY_MODE    0x00000223UL
+#define CKA_OTP_CHALLENGE_REQUIREMENT 0x00000224UL
+#define CKA_OTP_TIME_REQUIREMENT      0x00000225UL
+#define CKA_OTP_COUNTER_REQUIREMENT   0x00000226UL
+#define CKA_OTP_PIN_REQUIREMENT       0x00000227UL
+#define CKA_OTP_COUNTER               0x0000022EUL
+#define CKA_OTP_TIME                  0x0000022FUL
+#define CKA_OTP_USER_IDENTIFIER       0x0000022AUL
+#define CKA_OTP_SERVICE_IDENTIFIER    0x0000022BUL
+#define CKA_OTP_SERVICE_LOGO          0x0000022CUL
+#define CKA_OTP_SERVICE_LOGO_TYPE     0x0000022DUL
+
+#define CKA_GOSTR3410_PARAMS            0x00000250UL
+#define CKA_GOSTR3411_PARAMS            0x00000251UL
+#define CKA_GOST28147_PARAMS            0x00000252UL
+
+#define CKA_HW_FEATURE_TYPE             0x00000300UL
+#define CKA_RESET_ON_INIT               0x00000301UL
+#define CKA_HAS_RESET                   0x00000302UL
+
+#define CKA_PIXEL_X                     0x00000400UL
+#define CKA_PIXEL_Y                     0x00000401UL
+#define CKA_RESOLUTION                  0x00000402UL
+#define CKA_CHAR_ROWS                   0x00000403UL
+#define CKA_CHAR_COLUMNS                0x00000404UL
+#define CKA_COLOR                       0x00000405UL
+#define CKA_BITS_PER_PIXEL              0x00000406UL
+#define CKA_CHAR_SETS                   0x00000480UL
+#define CKA_ENCODING_METHODS            0x00000481UL
+#define CKA_MIME_TYPES                  0x00000482UL
+#define CKA_MECHANISM_TYPE              0x00000500UL
+#define CKA_REQUIRED_CMS_ATTRIBUTES     0x00000501UL
+#define CKA_DEFAULT_CMS_ATTRIBUTES      0x00000502UL
+#define CKA_SUPPORTED_CMS_ATTRIBUTES    0x00000503UL
+#define CKA_ALLOWED_MECHANISMS          (CKF_ARRAY_ATTRIBUTE|0x00000600UL)
+
+#define CKA_VENDOR_DEFINED              0x80000000UL
+
+/* CK_ATTRIBUTE is a structure that includes the type, length
+ * and value of an attribute
+ */
+typedef struct CK_ATTRIBUTE {
+  CK_ATTRIBUTE_TYPE type;
+  CK_VOID_PTR       pValue;
+  CK_ULONG          ulValueLen;  /* in bytes */
+} CK_ATTRIBUTE;
+
+typedef CK_ATTRIBUTE CK_PTR CK_ATTRIBUTE_PTR;
+
+/* CK_DATE is a structure that defines a date */
+typedef struct CK_DATE{
+  CK_CHAR       year[4];   /* the year ("1900" - "9999") */
+  CK_CHAR       month[2];  /* the month ("01" - "12") */
+  CK_CHAR       day[2];    /* the day   ("01" - "31") */
+} CK_DATE;
+
+
+/* CK_MECHANISM_TYPE is a value that identifies a mechanism
+ * type
+ */
+typedef CK_ULONG          CK_MECHANISM_TYPE;
+
+/* the following mechanism types are defined: */
+#define CKM_RSA_PKCS_KEY_PAIR_GEN      0x00000000UL
+#define CKM_RSA_PKCS                   0x00000001UL
+#define CKM_RSA_9796                   0x00000002UL
+#define CKM_RSA_X_509                  0x00000003UL
+
+#define CKM_MD2_RSA_PKCS               0x00000004UL
+#define CKM_MD5_RSA_PKCS               0x00000005UL
+#define CKM_SHA1_RSA_PKCS              0x00000006UL
+
+#define CKM_RIPEMD128_RSA_PKCS         0x00000007UL
+#define CKM_RIPEMD160_RSA_PKCS         0x00000008UL
+#define CKM_RSA_PKCS_OAEP              0x00000009UL
+
+#define CKM_RSA_X9_31_KEY_PAIR_GEN     0x0000000AUL
+#define CKM_RSA_X9_31                  0x0000000BUL
+#define CKM_SHA1_RSA_X9_31             0x0000000CUL
+#define CKM_RSA_PKCS_PSS               0x0000000DUL
+#define CKM_SHA1_RSA_PKCS_PSS          0x0000000EUL
+
+#define CKM_DSA_KEY_PAIR_GEN           0x00000010UL
+#define CKM_DSA                        0x00000011UL
+#define CKM_DSA_SHA1                   0x00000012UL
+#define CKM_DSA_SHA224                 0x00000013UL
+#define CKM_DSA_SHA256                 0x00000014UL
+#define CKM_DSA_SHA384                 0x00000015UL
+#define CKM_DSA_SHA512                 0x00000016UL
+
+#define CKM_DH_PKCS_KEY_PAIR_GEN       0x00000020UL
+#define CKM_DH_PKCS_DERIVE             0x00000021UL
+
+#define CKM_X9_42_DH_KEY_PAIR_GEN      0x00000030UL
+#define CKM_X9_42_DH_DERIVE            0x00000031UL
+#define CKM_X9_42_DH_HYBRID_DERIVE     0x00000032UL
+#define CKM_X9_42_MQV_DERIVE           0x00000033UL
+
+#define CKM_SHA256_RSA_PKCS            0x00000040UL
+#define CKM_SHA384_RSA_PKCS            0x00000041UL
+#define CKM_SHA512_RSA_PKCS            0x00000042UL
+#define CKM_SHA256_RSA_PKCS_PSS        0x00000043UL
+#define CKM_SHA384_RSA_PKCS_PSS        0x00000044UL
+#define CKM_SHA512_RSA_PKCS_PSS        0x00000045UL
+
+#define CKM_SHA224_RSA_PKCS            0x00000046UL
+#define CKM_SHA224_RSA_PKCS_PSS        0x00000047UL
+
+#define CKM_SHA512_224                 0x00000048UL
+#define CKM_SHA512_224_HMAC            0x00000049UL
+#define CKM_SHA512_224_HMAC_GENERAL    0x0000004AUL
+#define CKM_SHA512_224_KEY_DERIVATION  0x0000004BUL
+#define CKM_SHA512_256                 0x0000004CUL
+#define CKM_SHA512_256_HMAC            0x0000004DUL
+#define CKM_SHA512_256_HMAC_GENERAL    0x0000004EUL
+#define CKM_SHA512_256_KEY_DERIVATION  0x0000004FUL
+
+#define CKM_SHA512_T                   0x00000050UL
+#define CKM_SHA512_T_HMAC              0x00000051UL
+#define CKM_SHA512_T_HMAC_GENERAL      0x00000052UL
+#define CKM_SHA512_T_KEY_DERIVATION    0x00000053UL
+
+#define CKM_RC2_KEY_GEN                0x00000100UL
+#define CKM_RC2_ECB                    0x00000101UL
+#define CKM_RC2_CBC                    0x00000102UL
+#define CKM_RC2_MAC                    0x00000103UL
+
+#define CKM_RC2_MAC_GENERAL            0x00000104UL
+#define CKM_RC2_CBC_PAD                0x00000105UL
+
+#define CKM_RC4_KEY_GEN                0x00000110UL
+#define CKM_RC4                        0x00000111UL
+#define CKM_DES_KEY_GEN                0x00000120UL
+#define CKM_DES_ECB                    0x00000121UL
+#define CKM_DES_CBC                    0x00000122UL
+#define CKM_DES_MAC                    0x00000123UL
+
+#define CKM_DES_MAC_GENERAL            0x00000124UL
+#define CKM_DES_CBC_PAD                0x00000125UL
+
+#define CKM_DES2_KEY_GEN               0x00000130UL
+#define CKM_DES3_KEY_GEN               0x00000131UL
+#define CKM_DES3_ECB                   0x00000132UL
+#define CKM_DES3_CBC                   0x00000133UL
+#define CKM_DES3_MAC                   0x00000134UL
+
+#define CKM_DES3_MAC_GENERAL           0x00000135UL
+#define CKM_DES3_CBC_PAD               0x00000136UL
+#define CKM_DES3_CMAC_GENERAL          0x00000137UL
+#define CKM_DES3_CMAC                  0x00000138UL
+#define CKM_CDMF_KEY_GEN               0x00000140UL
+#define CKM_CDMF_ECB                   0x00000141UL
+#define CKM_CDMF_CBC                   0x00000142UL
+#define CKM_CDMF_MAC                   0x00000143UL
+#define CKM_CDMF_MAC_GENERAL           0x00000144UL
+#define CKM_CDMF_CBC_PAD               0x00000145UL
+
+#define CKM_DES_OFB64                  0x00000150UL
+#define CKM_DES_OFB8                   0x00000151UL
+#define CKM_DES_CFB64                  0x00000152UL
+#define CKM_DES_CFB8                   0x00000153UL
+
+#define CKM_MD2                        0x00000200UL
+
+#define CKM_MD2_HMAC                   0x00000201UL
+#define CKM_MD2_HMAC_GENERAL           0x00000202UL
+
+#define CKM_MD5                        0x00000210UL
+
+#define CKM_MD5_HMAC                   0x00000211UL
+#define CKM_MD5_HMAC_GENERAL           0x00000212UL
+
+#define CKM_SHA_1                      0x00000220UL
+
+#define CKM_SHA_1_HMAC                 0x00000221UL
+#define CKM_SHA_1_HMAC_GENERAL         0x00000222UL
+
+#define CKM_RIPEMD128                  0x00000230UL
+#define CKM_RIPEMD128_HMAC             0x00000231UL
+#define CKM_RIPEMD128_HMAC_GENERAL     0x00000232UL
+#define CKM_RIPEMD160                  0x00000240UL
+#define CKM_RIPEMD160_HMAC             0x00000241UL
+#define CKM_RIPEMD160_HMAC_GENERAL     0x00000242UL
+
+#define CKM_SHA256                     0x00000250UL
+#define CKM_SHA256_HMAC                0x00000251UL
+#define CKM_SHA256_HMAC_GENERAL        0x00000252UL
+#define CKM_SHA224                     0x00000255UL
+#define CKM_SHA224_HMAC                0x00000256UL
+#define CKM_SHA224_HMAC_GENERAL        0x00000257UL
+#define CKM_SHA384                     0x00000260UL
+#define CKM_SHA384_HMAC                0x00000261UL
+#define CKM_SHA384_HMAC_GENERAL        0x00000262UL
+#define CKM_SHA512                     0x00000270UL
+#define CKM_SHA512_HMAC                0x00000271UL
+#define CKM_SHA512_HMAC_GENERAL        0x00000272UL
+#define CKM_SECURID_KEY_GEN            0x00000280UL
+#define CKM_SECURID                    0x00000282UL
+#define CKM_HOTP_KEY_GEN               0x00000290UL
+#define CKM_HOTP                       0x00000291UL
+#define CKM_ACTI                       0x000002A0UL
+#define CKM_ACTI_KEY_GEN               0x000002A1UL
+
+#define CKM_CAST_KEY_GEN               0x00000300UL
+#define CKM_CAST_ECB                   0x00000301UL
+#define CKM_CAST_CBC                   0x00000302UL
+#define CKM_CAST_MAC                   0x00000303UL
+#define CKM_CAST_MAC_GENERAL           0x00000304UL
+#define CKM_CAST_CBC_PAD               0x00000305UL
+#define CKM_CAST3_KEY_GEN              0x00000310UL
+#define CKM_CAST3_ECB                  0x00000311UL
+#define CKM_CAST3_CBC                  0x00000312UL
+#define CKM_CAST3_MAC                  0x00000313UL
+#define CKM_CAST3_MAC_GENERAL          0x00000314UL
+#define CKM_CAST3_CBC_PAD              0x00000315UL
+/* Note that CAST128 and CAST5 are the same algorithm */
+#define CKM_CAST5_KEY_GEN              0x00000320UL
+#define CKM_CAST128_KEY_GEN            0x00000320UL
+#define CKM_CAST5_ECB                  0x00000321UL
+#define CKM_CAST128_ECB                0x00000321UL
+#define CKM_CAST5_CBC                  0x00000322UL /* Deprecated */
+#define CKM_CAST128_CBC                0x00000322UL
+#define CKM_CAST5_MAC                  0x00000323UL /* Deprecated */
+#define CKM_CAST128_MAC                0x00000323UL
+#define CKM_CAST5_MAC_GENERAL          0x00000324UL /* Deprecated */
+#define CKM_CAST128_MAC_GENERAL        0x00000324UL
+#define CKM_CAST5_CBC_PAD              0x00000325UL /* Deprecated */
+#define CKM_CAST128_CBC_PAD            0x00000325UL
+#define CKM_RC5_KEY_GEN                0x00000330UL
+#define CKM_RC5_ECB                    0x00000331UL
+#define CKM_RC5_CBC                    0x00000332UL
+#define CKM_RC5_MAC                    0x00000333UL
+#define CKM_RC5_MAC_GENERAL            0x00000334UL
+#define CKM_RC5_CBC_PAD                0x00000335UL
+#define CKM_IDEA_KEY_GEN               0x00000340UL
+#define CKM_IDEA_ECB                   0x00000341UL
+#define CKM_IDEA_CBC                   0x00000342UL
+#define CKM_IDEA_MAC                   0x00000343UL
+#define CKM_IDEA_MAC_GENERAL           0x00000344UL
+#define CKM_IDEA_CBC_PAD               0x00000345UL
+#define CKM_GENERIC_SECRET_KEY_GEN     0x00000350UL
+#define CKM_CONCATENATE_BASE_AND_KEY   0x00000360UL
+#define CKM_CONCATENATE_BASE_AND_DATA  0x00000362UL
+#define CKM_CONCATENATE_DATA_AND_BASE  0x00000363UL
+#define CKM_XOR_BASE_AND_DATA          0x00000364UL
+#define CKM_EXTRACT_KEY_FROM_KEY       0x00000365UL
+#define CKM_SSL3_PRE_MASTER_KEY_GEN    0x00000370UL
+#define CKM_SSL3_MASTER_KEY_DERIVE     0x00000371UL
+#define CKM_SSL3_KEY_AND_MAC_DERIVE    0x00000372UL
+
+#define CKM_SSL3_MASTER_KEY_DERIVE_DH  0x00000373UL
+#define CKM_TLS_PRE_MASTER_KEY_GEN     0x00000374UL
+#define CKM_TLS_MASTER_KEY_DERIVE      0x00000375UL
+#define CKM_TLS_KEY_AND_MAC_DERIVE     0x00000376UL
+#define CKM_TLS_MASTER_KEY_DERIVE_DH   0x00000377UL
+
+#define CKM_TLS_PRF                    0x00000378UL
+
+#define CKM_SSL3_MD5_MAC               0x00000380UL
+#define CKM_SSL3_SHA1_MAC              0x00000381UL
+#define CKM_MD5_KEY_DERIVATION         0x00000390UL
+#define CKM_MD2_KEY_DERIVATION         0x00000391UL
+#define CKM_SHA1_KEY_DERIVATION        0x00000392UL
+
+#define CKM_SHA256_KEY_DERIVATION      0x00000393UL
+#define CKM_SHA384_KEY_DERIVATION      0x00000394UL
+#define CKM_SHA512_KEY_DERIVATION      0x00000395UL
+#define CKM_SHA224_KEY_DERIVATION      0x00000396UL
+
+#define CKM_PBE_MD2_DES_CBC            0x000003A0UL
+#define CKM_PBE_MD5_DES_CBC            0x000003A1UL
+#define CKM_PBE_MD5_CAST_CBC           0x000003A2UL
+#define CKM_PBE_MD5_CAST3_CBC          0x000003A3UL
+#define CKM_PBE_MD5_CAST5_CBC          0x000003A4UL /* Deprecated */
+#define CKM_PBE_MD5_CAST128_CBC        0x000003A4UL
+#define CKM_PBE_SHA1_CAST5_CBC         0x000003A5UL /* Deprecated */
+#define CKM_PBE_SHA1_CAST128_CBC       0x000003A5UL
+#define CKM_PBE_SHA1_RC4_128           0x000003A6UL
+#define CKM_PBE_SHA1_RC4_40            0x000003A7UL
+#define CKM_PBE_SHA1_DES3_EDE_CBC      0x000003A8UL
+#define CKM_PBE_SHA1_DES2_EDE_CBC      0x000003A9UL
+#define CKM_PBE_SHA1_RC2_128_CBC       0x000003AAUL
+#define CKM_PBE_SHA1_RC2_40_CBC        0x000003ABUL
+
+#define CKM_PKCS5_PBKD2                0x000003B0UL
+
+#define CKM_PBA_SHA1_WITH_SHA1_HMAC    0x000003C0UL
+
+#define CKM_WTLS_PRE_MASTER_KEY_GEN         0x000003D0UL
+#define CKM_WTLS_MASTER_KEY_DERIVE          0x000003D1UL
+#define CKM_WTLS_MASTER_KEY_DERIVE_DH_ECC   0x000003D2UL
+#define CKM_WTLS_PRF                        0x000003D3UL
+#define CKM_WTLS_SERVER_KEY_AND_MAC_DERIVE  0x000003D4UL
+#define CKM_WTLS_CLIENT_KEY_AND_MAC_DERIVE  0x000003D5UL
+
+#define CKM_TLS10_MAC_SERVER                0x000003D6UL
+#define CKM_TLS10_MAC_CLIENT                0x000003D7UL
+#define CKM_TLS12_MAC                       0x000003D8UL
+#define CKM_TLS12_KDF                       0x000003D9UL
+#define CKM_TLS12_MASTER_KEY_DERIVE         0x000003E0UL
+#define CKM_TLS12_KEY_AND_MAC_DERIVE        0x000003E1UL
+#define CKM_TLS12_MASTER_KEY_DERIVE_DH      0x000003E2UL
+#define CKM_TLS12_KEY_SAFE_DERIVE           0x000003E3UL
+#define CKM_TLS_MAC                         0x000003E4UL
+#define CKM_TLS_KDF                         0x000003E5UL
+
+#define CKM_KEY_WRAP_LYNKS             0x00000400UL
+#define CKM_KEY_WRAP_SET_OAEP          0x00000401UL
+
+#define CKM_CMS_SIG                    0x00000500UL
+#define CKM_KIP_DERIVE                 0x00000510UL
+#define CKM_KIP_WRAP                   0x00000511UL
+#define CKM_KIP_MAC                    0x00000512UL
+
+#define CKM_CAMELLIA_KEY_GEN           0x00000550UL
+#define CKM_CAMELLIA_ECB               0x00000551UL
+#define CKM_CAMELLIA_CBC               0x00000552UL
+#define CKM_CAMELLIA_MAC               0x00000553UL
+#define CKM_CAMELLIA_MAC_GENERAL       0x00000554UL
+#define CKM_CAMELLIA_CBC_PAD           0x00000555UL
+#define CKM_CAMELLIA_ECB_ENCRYPT_DATA  0x00000556UL
+#define CKM_CAMELLIA_CBC_ENCRYPT_DATA  0x00000557UL
+#define CKM_CAMELLIA_CTR               0x00000558UL
+
+#define CKM_ARIA_KEY_GEN               0x00000560UL
+#define CKM_ARIA_ECB                   0x00000561UL
+#define CKM_ARIA_CBC                   0x00000562UL
+#define CKM_ARIA_MAC                   0x00000563UL
+#define CKM_ARIA_MAC_GENERAL           0x00000564UL
+#define CKM_ARIA_CBC_PAD               0x00000565UL
+#define CKM_ARIA_ECB_ENCRYPT_DATA      0x00000566UL
+#define CKM_ARIA_CBC_ENCRYPT_DATA      0x00000567UL
+
+#define CKM_SEED_KEY_GEN               0x00000650UL
+#define CKM_SEED_ECB                   0x00000651UL
+#define CKM_SEED_CBC                   0x00000652UL
+#define CKM_SEED_MAC                   0x00000653UL
+#define CKM_SEED_MAC_GENERAL           0x00000654UL
+#define CKM_SEED_CBC_PAD               0x00000655UL
+#define CKM_SEED_ECB_ENCRYPT_DATA      0x00000656UL
+#define CKM_SEED_CBC_ENCRYPT_DATA      0x00000657UL
+
+#define CKM_SKIPJACK_KEY_GEN           0x00001000UL
+#define CKM_SKIPJACK_ECB64             0x00001001UL
+#define CKM_SKIPJACK_CBC64             0x00001002UL
+#define CKM_SKIPJACK_OFB64             0x00001003UL
+#define CKM_SKIPJACK_CFB64             0x00001004UL
+#define CKM_SKIPJACK_CFB32             0x00001005UL
+#define CKM_SKIPJACK_CFB16             0x00001006UL
+#define CKM_SKIPJACK_CFB8              0x00001007UL
+#define CKM_SKIPJACK_WRAP              0x00001008UL
+#define CKM_SKIPJACK_PRIVATE_WRAP      0x00001009UL
+#define CKM_SKIPJACK_RELAYX            0x0000100aUL
+#define CKM_KEA_KEY_PAIR_GEN           0x00001010UL
+#define CKM_KEA_KEY_DERIVE             0x00001011UL
+#define CKM_KEA_DERIVE                 0x00001012UL
+#define CKM_FORTEZZA_TIMESTAMP         0x00001020UL
+#define CKM_BATON_KEY_GEN              0x00001030UL
+#define CKM_BATON_ECB128               0x00001031UL
+#define CKM_BATON_ECB96                0x00001032UL
+#define CKM_BATON_CBC128               0x00001033UL
+#define CKM_BATON_COUNTER              0x00001034UL
+#define CKM_BATON_SHUFFLE              0x00001035UL
+#define CKM_BATON_WRAP                 0x00001036UL
+
+#define CKM_ECDSA_KEY_PAIR_GEN         0x00001040UL /* Deprecated */
+#define CKM_EC_KEY_PAIR_GEN            0x00001040UL
+
+#define CKM_ECDSA                      0x00001041UL
+#define CKM_ECDSA_SHA1                 0x00001042UL
+#define CKM_ECDSA_SHA224               0x00001043UL
+#define CKM_ECDSA_SHA256               0x00001044UL
+#define CKM_ECDSA_SHA384               0x00001045UL
+#define CKM_ECDSA_SHA512               0x00001046UL
+
+#define CKM_ECDH1_DERIVE               0x00001050UL
+#define CKM_ECDH1_COFACTOR_DERIVE      0x00001051UL
+#define CKM_ECMQV_DERIVE               0x00001052UL
+
+#define CKM_ECDH_AES_KEY_WRAP          0x00001053UL
+#define CKM_RSA_AES_KEY_WRAP           0x00001054UL
+
+#define CKM_JUNIPER_KEY_GEN            0x00001060UL
+#define CKM_JUNIPER_ECB128             0x00001061UL
+#define CKM_JUNIPER_CBC128             0x00001062UL
+#define CKM_JUNIPER_COUNTER            0x00001063UL
+#define CKM_JUNIPER_SHUFFLE            0x00001064UL
+#define CKM_JUNIPER_WRAP               0x00001065UL
+#define CKM_FASTHASH                   0x00001070UL
+
+#define CKM_AES_KEY_GEN                0x00001080UL
+#define CKM_AES_ECB                    0x00001081UL
+#define CKM_AES_CBC                    0x00001082UL
+#define CKM_AES_MAC                    0x00001083UL
+#define CKM_AES_MAC_GENERAL            0x00001084UL
+#define CKM_AES_CBC_PAD                0x00001085UL
+#define CKM_AES_CTR                    0x00001086UL
+#define CKM_AES_GCM                    0x00001087UL
+#define CKM_AES_CCM                    0x00001088UL
+#define CKM_AES_CTS                    0x00001089UL
+#define CKM_AES_CMAC                   0x0000108AUL
+#define CKM_AES_CMAC_GENERAL           0x0000108BUL
+
+#define CKM_AES_XCBC_MAC               0x0000108CUL
+#define CKM_AES_XCBC_MAC_96            0x0000108DUL
+#define CKM_AES_GMAC                   0x0000108EUL
+
+#define CKM_BLOWFISH_KEY_GEN           0x00001090UL
+#define CKM_BLOWFISH_CBC               0x00001091UL
+#define CKM_TWOFISH_KEY_GEN            0x00001092UL
+#define CKM_TWOFISH_CBC                0x00001093UL
+#define CKM_BLOWFISH_CBC_PAD           0x00001094UL
+#define CKM_TWOFISH_CBC_PAD            0x00001095UL
+
+#define CKM_DES_ECB_ENCRYPT_DATA       0x00001100UL
+#define CKM_DES_CBC_ENCRYPT_DATA       0x00001101UL
+#define CKM_DES3_ECB_ENCRYPT_DATA      0x00001102UL
+#define CKM_DES3_CBC_ENCRYPT_DATA      0x00001103UL
+#define CKM_AES_ECB_ENCRYPT_DATA       0x00001104UL
+#define CKM_AES_CBC_ENCRYPT_DATA       0x00001105UL
+
+#define CKM_GOSTR3410_KEY_PAIR_GEN     0x00001200UL
+#define CKM_GOSTR3410                  0x00001201UL
+#define CKM_GOSTR3410_WITH_GOSTR3411   0x00001202UL
+#define CKM_GOSTR3410_KEY_WRAP         0x00001203UL
+#define CKM_GOSTR3410_DERIVE           0x00001204UL
+#define CKM_GOSTR3411                  0x00001210UL
+#define CKM_GOSTR3411_HMAC             0x00001211UL
+#define CKM_GOST28147_KEY_GEN          0x00001220UL
+#define CKM_GOST28147_ECB              0x00001221UL
+#define CKM_GOST28147                  0x00001222UL
+#define CKM_GOST28147_MAC              0x00001223UL
+#define CKM_GOST28147_KEY_WRAP         0x00001224UL
+
+#define CKM_DSA_PARAMETER_GEN          0x00002000UL
+#define CKM_DH_PKCS_PARAMETER_GEN      0x00002001UL
+#define CKM_X9_42_DH_PARAMETER_GEN     0x00002002UL
+#define CKM_DSA_PROBABLISTIC_PARAMETER_GEN    0x00002003UL
+#define CKM_DSA_SHAWE_TAYLOR_PARAMETER_GEN    0x00002004UL
+
+#define CKM_AES_OFB                    0x00002104UL
+#define CKM_AES_CFB64                  0x00002105UL
+#define CKM_AES_CFB8                   0x00002106UL
+#define CKM_AES_CFB128                 0x00002107UL
+
+#define CKM_AES_CFB1                   0x00002108UL
+#define CKM_AES_KEY_WRAP               0x00002109UL     /* WAS: 0x00001090 */
+#define CKM_AES_KEY_WRAP_PAD           0x0000210AUL     /* WAS: 0x00001091 */
+
+#define CKM_RSA_PKCS_TPM_1_1           0x00004001UL
+#define CKM_RSA_PKCS_OAEP_TPM_1_1      0x00004002UL
+
+#define CKM_VENDOR_DEFINED             0x80000000UL
+
+typedef CK_MECHANISM_TYPE CK_PTR CK_MECHANISM_TYPE_PTR;
+
+
+/* CK_MECHANISM is a structure that specifies a particular
+ * mechanism
+ */
+typedef struct CK_MECHANISM {
+  CK_MECHANISM_TYPE mechanism;
+  CK_VOID_PTR       pParameter;
+  CK_ULONG          ulParameterLen;  /* in bytes */
+} CK_MECHANISM;
+
+typedef CK_MECHANISM CK_PTR CK_MECHANISM_PTR;
+
+
+/* CK_MECHANISM_INFO provides information about a particular
+ * mechanism
+ */
+typedef struct CK_MECHANISM_INFO {
+    CK_ULONG    ulMinKeySize;
+    CK_ULONG    ulMaxKeySize;
+    CK_FLAGS    flags;
+} CK_MECHANISM_INFO;
+
+/* The flags are defined as follows:
+ *      Bit Flag               Mask          Meaning */
+#define CKF_HW                 0x00000001UL  /* performed by HW */
+
+/* Specify whether or not a mechanism can be used for a particular task */
+#define CKF_ENCRYPT            0x00000100UL
+#define CKF_DECRYPT            0x00000200UL
+#define CKF_DIGEST             0x00000400UL
+#define CKF_SIGN               0x00000800UL
+#define CKF_SIGN_RECOVER       0x00001000UL
+#define CKF_VERIFY             0x00002000UL
+#define CKF_VERIFY_RECOVER     0x00004000UL
+#define CKF_GENERATE           0x00008000UL
+#define CKF_GENERATE_KEY_PAIR  0x00010000UL
+#define CKF_WRAP               0x00020000UL
+#define CKF_UNWRAP             0x00040000UL
+#define CKF_DERIVE             0x00080000UL
+
+/* Describe a token's EC capabilities not available in mechanism
+ * information.
+ */
+#define CKF_EC_F_P             0x00100000UL
+#define CKF_EC_F_2M            0x00200000UL
+#define CKF_EC_ECPARAMETERS    0x00400000UL
+#define CKF_EC_NAMEDCURVE      0x00800000UL
+#define CKF_EC_UNCOMPRESS      0x01000000UL
+#define CKF_EC_COMPRESS        0x02000000UL
+
+#define CKF_EXTENSION          0x80000000UL
+
+typedef CK_MECHANISM_INFO CK_PTR CK_MECHANISM_INFO_PTR;
+
+/* CK_RV is a value that identifies the return value of a
+ * Cryptoki function
+ */
+typedef CK_ULONG          CK_RV;
+
+#define CKR_OK                                0x00000000UL
+#define CKR_CANCEL                            0x00000001UL
+#define CKR_HOST_MEMORY                       0x00000002UL
+#define CKR_SLOT_ID_INVALID                   0x00000003UL
+
+#define CKR_GENERAL_ERROR                     0x00000005UL
+#define CKR_FUNCTION_FAILED                   0x00000006UL
+
+#define CKR_ARGUMENTS_BAD                     0x00000007UL
+#define CKR_NO_EVENT                          0x00000008UL
+#define CKR_NEED_TO_CREATE_THREADS            0x00000009UL
+#define CKR_CANT_LOCK                         0x0000000AUL
+
+#define CKR_ATTRIBUTE_READ_ONLY               0x00000010UL
+#define CKR_ATTRIBUTE_SENSITIVE               0x00000011UL
+#define CKR_ATTRIBUTE_TYPE_INVALID            0x00000012UL
+#define CKR_ATTRIBUTE_VALUE_INVALID           0x00000013UL
+
+#define CKR_ACTION_PROHIBITED                 0x0000001BUL
+
+#define CKR_DATA_INVALID                      0x00000020UL
+#define CKR_DATA_LEN_RANGE                    0x00000021UL
+#define CKR_DEVICE_ERROR                      0x00000030UL
+#define CKR_DEVICE_MEMORY                     0x00000031UL
+#define CKR_DEVICE_REMOVED                    0x00000032UL
+#define CKR_ENCRYPTED_DATA_INVALID            0x00000040UL
+#define CKR_ENCRYPTED_DATA_LEN_RANGE          0x00000041UL
+#define CKR_FUNCTION_CANCELED                 0x00000050UL
+#define CKR_FUNCTION_NOT_PARALLEL             0x00000051UL
+
+#define CKR_FUNCTION_NOT_SUPPORTED            0x00000054UL
+
+#define CKR_KEY_HANDLE_INVALID                0x00000060UL
+
+#define CKR_KEY_SIZE_RANGE                    0x00000062UL
+#define CKR_KEY_TYPE_INCONSISTENT             0x00000063UL
+
+#define CKR_KEY_NOT_NEEDED                    0x00000064UL
+#define CKR_KEY_CHANGED                       0x00000065UL
+#define CKR_KEY_NEEDED                        0x00000066UL
+#define CKR_KEY_INDIGESTIBLE                  0x00000067UL
+#define CKR_KEY_FUNCTION_NOT_PERMITTED        0x00000068UL
+#define CKR_KEY_NOT_WRAPPABLE                 0x00000069UL
+#define CKR_KEY_UNEXTRACTABLE                 0x0000006AUL
+
+#define CKR_MECHANISM_INVALID                 0x00000070UL
+#define CKR_MECHANISM_PARAM_INVALID           0x00000071UL
+
+#define CKR_OBJECT_HANDLE_INVALID             0x00000082UL
+#define CKR_OPERATION_ACTIVE                  0x00000090UL
+#define CKR_OPERATION_NOT_INITIALIZED         0x00000091UL
+#define CKR_PIN_INCORRECT                     0x000000A0UL
+#define CKR_PIN_INVALID                       0x000000A1UL
+#define CKR_PIN_LEN_RANGE                     0x000000A2UL
+
+#define CKR_PIN_EXPIRED                       0x000000A3UL
+#define CKR_PIN_LOCKED                        0x000000A4UL
+
+#define CKR_SESSION_CLOSED                    0x000000B0UL
+#define CKR_SESSION_COUNT                     0x000000B1UL
+#define CKR_SESSION_HANDLE_INVALID            0x000000B3UL
+#define CKR_SESSION_PARALLEL_NOT_SUPPORTED    0x000000B4UL
+#define CKR_SESSION_READ_ONLY                 0x000000B5UL
+#define CKR_SESSION_EXISTS                    0x000000B6UL
+
+#define CKR_SESSION_READ_ONLY_EXISTS          0x000000B7UL
+#define CKR_SESSION_READ_WRITE_SO_EXISTS      0x000000B8UL
+
+#define CKR_SIGNATURE_INVALID                 0x000000C0UL
+#define CKR_SIGNATURE_LEN_RANGE               0x000000C1UL
+#define CKR_TEMPLATE_INCOMPLETE               0x000000D0UL
+#define CKR_TEMPLATE_INCONSISTENT             0x000000D1UL
+#define CKR_TOKEN_NOT_PRESENT                 0x000000E0UL
+#define CKR_TOKEN_NOT_RECOGNIZED              0x000000E1UL
+#define CKR_TOKEN_WRITE_PROTECTED             0x000000E2UL
+#define CKR_UNWRAPPING_KEY_HANDLE_INVALID     0x000000F0UL
+#define CKR_UNWRAPPING_KEY_SIZE_RANGE         0x000000F1UL
+#define CKR_UNWRAPPING_KEY_TYPE_INCONSISTENT  0x000000F2UL
+#define CKR_USER_ALREADY_LOGGED_IN            0x00000100UL
+#define CKR_USER_NOT_LOGGED_IN                0x00000101UL
+#define CKR_USER_PIN_NOT_INITIALIZED          0x00000102UL
+#define CKR_USER_TYPE_INVALID                 0x00000103UL
+
+#define CKR_USER_ANOTHER_ALREADY_LOGGED_IN    0x00000104UL
+#define CKR_USER_TOO_MANY_TYPES               0x00000105UL
+
+#define CKR_WRAPPED_KEY_INVALID               0x00000110UL
+#define CKR_WRAPPED_KEY_LEN_RANGE             0x00000112UL
+#define CKR_WRAPPING_KEY_HANDLE_INVALID       0x00000113UL
+#define CKR_WRAPPING_KEY_SIZE_RANGE           0x00000114UL
+#define CKR_WRAPPING_KEY_TYPE_INCONSISTENT    0x00000115UL
+#define CKR_RANDOM_SEED_NOT_SUPPORTED         0x00000120UL
+
+#define CKR_RANDOM_NO_RNG                     0x00000121UL
+
+#define CKR_DOMAIN_PARAMS_INVALID             0x00000130UL
+
+#define CKR_CURVE_NOT_SUPPORTED               0x00000140UL
+
+#define CKR_BUFFER_TOO_SMALL                  0x00000150UL
+#define CKR_SAVED_STATE_INVALID               0x00000160UL
+#define CKR_INFORMATION_SENSITIVE             0x00000170UL
+#define CKR_STATE_UNSAVEABLE                  0x00000180UL
+
+#define CKR_CRYPTOKI_NOT_INITIALIZED          0x00000190UL
+#define CKR_CRYPTOKI_ALREADY_INITIALIZED      0x00000191UL
+#define CKR_MUTEX_BAD                         0x000001A0UL
+#define CKR_MUTEX_NOT_LOCKED                  0x000001A1UL
+
+#define CKR_NEW_PIN_MODE                      0x000001B0UL
+#define CKR_NEXT_OTP                          0x000001B1UL
+
+#define CKR_EXCEEDED_MAX_ITERATIONS           0x000001B5UL
+#define CKR_FIPS_SELF_TEST_FAILED             0x000001B6UL
+#define CKR_LIBRARY_LOAD_FAILED               0x000001B7UL
+#define CKR_PIN_TOO_WEAK                      0x000001B8UL
+#define CKR_PUBLIC_KEY_INVALID                0x000001B9UL
+
+#define CKR_FUNCTION_REJECTED                 0x00000200UL
+
+#define CKR_VENDOR_DEFINED                    0x80000000UL
+
+
+/* CK_NOTIFY is an application callback that processes events */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_NOTIFY)(
+  CK_SESSION_HANDLE hSession,     /* the session's handle */
+  CK_NOTIFICATION   event,
+  CK_VOID_PTR       pApplication  /* passed to C_OpenSession */
+);
+
+
+/* CK_FUNCTION_LIST is a structure holding a Cryptoki spec
+ * version and pointers of appropriate types to all the
+ * Cryptoki functions
+ */
+typedef struct CK_FUNCTION_LIST CK_FUNCTION_LIST;
+
+typedef CK_FUNCTION_LIST CK_PTR CK_FUNCTION_LIST_PTR;
+
+typedef CK_FUNCTION_LIST_PTR CK_PTR CK_FUNCTION_LIST_PTR_PTR;
+
+
+/* CK_CREATEMUTEX is an application callback for creating a
+ * mutex object
+ */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_CREATEMUTEX)(
+  CK_VOID_PTR_PTR ppMutex  /* location to receive ptr to mutex */
+);
+
+
+/* CK_DESTROYMUTEX is an application callback for destroying a
+ * mutex object
+ */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_DESTROYMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_LOCKMUTEX is an application callback for locking a mutex */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_LOCKMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_UNLOCKMUTEX is an application callback for unlocking a
+ * mutex
+ */
+typedef CK_CALLBACK_FUNCTION(CK_RV, CK_UNLOCKMUTEX)(
+  CK_VOID_PTR pMutex  /* pointer to mutex */
+);
+
+
+/* CK_C_INITIALIZE_ARGS provides the optional arguments to
+ * C_Initialize
+ */
+typedef struct CK_C_INITIALIZE_ARGS {
+  CK_CREATEMUTEX CreateMutex;
+  CK_DESTROYMUTEX DestroyMutex;
+  CK_LOCKMUTEX LockMutex;
+  CK_UNLOCKMUTEX UnlockMutex;
+  CK_FLAGS flags;
+  CK_VOID_PTR pReserved;
+} CK_C_INITIALIZE_ARGS;
+
+/* flags: bit flags that provide capabilities of the slot
+ *      Bit Flag                           Mask       Meaning
+ */
+#define CKF_LIBRARY_CANT_CREATE_OS_THREADS 0x00000001UL
+#define CKF_OS_LOCKING_OK                  0x00000002UL
+
+typedef CK_C_INITIALIZE_ARGS CK_PTR CK_C_INITIALIZE_ARGS_PTR;
+
+
+/* additional flags for parameters to functions */
+
+/* CKF_DONT_BLOCK is for the function C_WaitForSlotEvent */
+#define CKF_DONT_BLOCK     1
+
+/* CK_RSA_PKCS_MGF_TYPE  is used to indicate the Message
+ * Generation Function (MGF) applied to a message block when
+ * formatting a message block for the PKCS #1 OAEP encryption
+ * scheme.
+ */
+typedef CK_ULONG CK_RSA_PKCS_MGF_TYPE;
+
+typedef CK_RSA_PKCS_MGF_TYPE CK_PTR CK_RSA_PKCS_MGF_TYPE_PTR;
+
+/* The following MGFs are defined */
+#define CKG_MGF1_SHA1         0x00000001UL
+#define CKG_MGF1_SHA256       0x00000002UL
+#define CKG_MGF1_SHA384       0x00000003UL
+#define CKG_MGF1_SHA512       0x00000004UL
+#define CKG_MGF1_SHA224       0x00000005UL
+
+/* CK_RSA_PKCS_OAEP_SOURCE_TYPE  is used to indicate the source
+ * of the encoding parameter when formatting a message block
+ * for the PKCS #1 OAEP encryption scheme.
+ */
+typedef CK_ULONG CK_RSA_PKCS_OAEP_SOURCE_TYPE;
+
+typedef CK_RSA_PKCS_OAEP_SOURCE_TYPE CK_PTR CK_RSA_PKCS_OAEP_SOURCE_TYPE_PTR;
+
+/* The following encoding parameter sources are defined */
+#define CKZ_DATA_SPECIFIED    0x00000001UL
+
+/* CK_RSA_PKCS_OAEP_PARAMS provides the parameters to the
+ * CKM_RSA_PKCS_OAEP mechanism.
+ */
+typedef struct CK_RSA_PKCS_OAEP_PARAMS {
+        CK_MECHANISM_TYPE hashAlg;
+        CK_RSA_PKCS_MGF_TYPE mgf;
+        CK_RSA_PKCS_OAEP_SOURCE_TYPE source;
+        CK_VOID_PTR pSourceData;
+        CK_ULONG ulSourceDataLen;
+} CK_RSA_PKCS_OAEP_PARAMS;
+
+typedef CK_RSA_PKCS_OAEP_PARAMS CK_PTR CK_RSA_PKCS_OAEP_PARAMS_PTR;
+
+/* CK_RSA_PKCS_PSS_PARAMS provides the parameters to the
+ * CKM_RSA_PKCS_PSS mechanism(s).
+ */
+typedef struct CK_RSA_PKCS_PSS_PARAMS {
+        CK_MECHANISM_TYPE    hashAlg;
+        CK_RSA_PKCS_MGF_TYPE mgf;
+        CK_ULONG             sLen;
+} CK_RSA_PKCS_PSS_PARAMS;
+
+typedef CK_RSA_PKCS_PSS_PARAMS CK_PTR CK_RSA_PKCS_PSS_PARAMS_PTR;
+
+typedef CK_ULONG CK_EC_KDF_TYPE;
+
+/* The following EC Key Derivation Functions are defined */
+#define CKD_NULL                 0x00000001UL
+#define CKD_SHA1_KDF             0x00000002UL
+
+/* The following X9.42 DH key derivation functions are defined */
+#define CKD_SHA1_KDF_ASN1        0x00000003UL
+#define CKD_SHA1_KDF_CONCATENATE 0x00000004UL
+#define CKD_SHA224_KDF           0x00000005UL
+#define CKD_SHA256_KDF           0x00000006UL
+#define CKD_SHA384_KDF           0x00000007UL
+#define CKD_SHA512_KDF           0x00000008UL
+#define CKD_CPDIVERSIFY_KDF      0x00000009UL
+
+
+/* CK_ECDH1_DERIVE_PARAMS provides the parameters to the
+ * CKM_ECDH1_DERIVE and CKM_ECDH1_COFACTOR_DERIVE mechanisms,
+ * where each party contributes one key pair.
+ */
+typedef struct CK_ECDH1_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+} CK_ECDH1_DERIVE_PARAMS;
+
+typedef CK_ECDH1_DERIVE_PARAMS CK_PTR CK_ECDH1_DERIVE_PARAMS_PTR;
+
+/*
+ * CK_ECDH2_DERIVE_PARAMS provides the parameters to the
+ * CKM_ECMQV_DERIVE mechanism, where each party contributes two key pairs.
+ */
+typedef struct CK_ECDH2_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+} CK_ECDH2_DERIVE_PARAMS;
+
+typedef CK_ECDH2_DERIVE_PARAMS CK_PTR CK_ECDH2_DERIVE_PARAMS_PTR;
+
+typedef struct CK_ECMQV_DERIVE_PARAMS {
+  CK_EC_KDF_TYPE kdf;
+  CK_ULONG ulSharedDataLen;
+  CK_BYTE_PTR pSharedData;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+  CK_OBJECT_HANDLE publicKey;
+} CK_ECMQV_DERIVE_PARAMS;
+
+typedef CK_ECMQV_DERIVE_PARAMS CK_PTR CK_ECMQV_DERIVE_PARAMS_PTR;
+
+/* Typedefs and defines for the CKM_X9_42_DH_KEY_PAIR_GEN and the
+ * CKM_X9_42_DH_PARAMETER_GEN mechanisms
+ */
+typedef CK_ULONG CK_X9_42_DH_KDF_TYPE;
+typedef CK_X9_42_DH_KDF_TYPE CK_PTR CK_X9_42_DH_KDF_TYPE_PTR;
+
+/* CK_X9_42_DH1_DERIVE_PARAMS provides the parameters to the
+ * CKM_X9_42_DH_DERIVE key derivation mechanism, where each party
+ * contributes one key pair
+ */
+typedef struct CK_X9_42_DH1_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+} CK_X9_42_DH1_DERIVE_PARAMS;
+
+typedef struct CK_X9_42_DH1_DERIVE_PARAMS CK_PTR CK_X9_42_DH1_DERIVE_PARAMS_PTR;
+
+/* CK_X9_42_DH2_DERIVE_PARAMS provides the parameters to the
+ * CKM_X9_42_DH_HYBRID_DERIVE and CKM_X9_42_MQV_DERIVE key derivation
+ * mechanisms, where each party contributes two key pairs
+ */
+typedef struct CK_X9_42_DH2_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+} CK_X9_42_DH2_DERIVE_PARAMS;
+
+typedef CK_X9_42_DH2_DERIVE_PARAMS CK_PTR CK_X9_42_DH2_DERIVE_PARAMS_PTR;
+
+typedef struct CK_X9_42_MQV_DERIVE_PARAMS {
+  CK_X9_42_DH_KDF_TYPE kdf;
+  CK_ULONG ulOtherInfoLen;
+  CK_BYTE_PTR pOtherInfo;
+  CK_ULONG ulPublicDataLen;
+  CK_BYTE_PTR pPublicData;
+  CK_ULONG ulPrivateDataLen;
+  CK_OBJECT_HANDLE hPrivateData;
+  CK_ULONG ulPublicDataLen2;
+  CK_BYTE_PTR pPublicData2;
+  CK_OBJECT_HANDLE publicKey;
+} CK_X9_42_MQV_DERIVE_PARAMS;
+
+typedef CK_X9_42_MQV_DERIVE_PARAMS CK_PTR CK_X9_42_MQV_DERIVE_PARAMS_PTR;
+
+/* CK_KEA_DERIVE_PARAMS provides the parameters to the
+ * CKM_KEA_DERIVE mechanism
+ */
+typedef struct CK_KEA_DERIVE_PARAMS {
+  CK_BBOOL      isSender;
+  CK_ULONG      ulRandomLen;
+  CK_BYTE_PTR   pRandomA;
+  CK_BYTE_PTR   pRandomB;
+  CK_ULONG      ulPublicDataLen;
+  CK_BYTE_PTR   pPublicData;
+} CK_KEA_DERIVE_PARAMS;
+
+typedef CK_KEA_DERIVE_PARAMS CK_PTR CK_KEA_DERIVE_PARAMS_PTR;
+
+
+/* CK_RC2_PARAMS provides the parameters to the CKM_RC2_ECB and
+ * CKM_RC2_MAC mechanisms.  An instance of CK_RC2_PARAMS just
+ * holds the effective keysize
+ */
+typedef CK_ULONG          CK_RC2_PARAMS;
+
+typedef CK_RC2_PARAMS CK_PTR CK_RC2_PARAMS_PTR;
+
+
+/* CK_RC2_CBC_PARAMS provides the parameters to the CKM_RC2_CBC
+ * mechanism
+ */
+typedef struct CK_RC2_CBC_PARAMS {
+  CK_ULONG      ulEffectiveBits;  /* effective bits (1-1024) */
+  CK_BYTE       iv[8];            /* IV for CBC mode */
+} CK_RC2_CBC_PARAMS;
+
+typedef CK_RC2_CBC_PARAMS CK_PTR CK_RC2_CBC_PARAMS_PTR;
+
+
+/* CK_RC2_MAC_GENERAL_PARAMS provides the parameters for the
+ * CKM_RC2_MAC_GENERAL mechanism
+ */
+typedef struct CK_RC2_MAC_GENERAL_PARAMS {
+  CK_ULONG      ulEffectiveBits;  /* effective bits (1-1024) */
+  CK_ULONG      ulMacLength;      /* Length of MAC in bytes */
+} CK_RC2_MAC_GENERAL_PARAMS;
+
+typedef CK_RC2_MAC_GENERAL_PARAMS CK_PTR \
+  CK_RC2_MAC_GENERAL_PARAMS_PTR;
+
+
+/* CK_RC5_PARAMS provides the parameters to the CKM_RC5_ECB and
+ * CKM_RC5_MAC mechanisms
+ */
+typedef struct CK_RC5_PARAMS {
+  CK_ULONG      ulWordsize;  /* wordsize in bits */
+  CK_ULONG      ulRounds;    /* number of rounds */
+} CK_RC5_PARAMS;
+
+typedef CK_RC5_PARAMS CK_PTR CK_RC5_PARAMS_PTR;
+
+
+/* CK_RC5_CBC_PARAMS provides the parameters to the CKM_RC5_CBC
+ * mechanism
+ */
+typedef struct CK_RC5_CBC_PARAMS {
+  CK_ULONG      ulWordsize;  /* wordsize in bits */
+  CK_ULONG      ulRounds;    /* number of rounds */
+  CK_BYTE_PTR   pIv;         /* pointer to IV */
+  CK_ULONG      ulIvLen;     /* length of IV in bytes */
+} CK_RC5_CBC_PARAMS;
+
+typedef CK_RC5_CBC_PARAMS CK_PTR CK_RC5_CBC_PARAMS_PTR;
+
+
+/* CK_RC5_MAC_GENERAL_PARAMS provides the parameters for the
+ * CKM_RC5_MAC_GENERAL mechanism
+ */
+typedef struct CK_RC5_MAC_GENERAL_PARAMS {
+  CK_ULONG      ulWordsize;   /* wordsize in bits */
+  CK_ULONG      ulRounds;     /* number of rounds */
+  CK_ULONG      ulMacLength;  /* Length of MAC in bytes */
+} CK_RC5_MAC_GENERAL_PARAMS;
+
+typedef CK_RC5_MAC_GENERAL_PARAMS CK_PTR \
+  CK_RC5_MAC_GENERAL_PARAMS_PTR;
+
+/* CK_MAC_GENERAL_PARAMS provides the parameters to most block
+ * ciphers' MAC_GENERAL mechanisms.  Its value is the length of
+ * the MAC
+ */
+typedef CK_ULONG          CK_MAC_GENERAL_PARAMS;
+
+typedef CK_MAC_GENERAL_PARAMS CK_PTR CK_MAC_GENERAL_PARAMS_PTR;
+
+typedef struct CK_DES_CBC_ENCRYPT_DATA_PARAMS {
+  CK_BYTE      iv[8];
+  CK_BYTE_PTR  pData;
+  CK_ULONG     length;
+} CK_DES_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_DES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_DES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+typedef struct CK_AES_CBC_ENCRYPT_DATA_PARAMS {
+  CK_BYTE      iv[16];
+  CK_BYTE_PTR  pData;
+  CK_ULONG     length;
+} CK_AES_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_AES_CBC_ENCRYPT_DATA_PARAMS CK_PTR CK_AES_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+/* CK_SKIPJACK_PRIVATE_WRAP_PARAMS provides the parameters to the
+ * CKM_SKIPJACK_PRIVATE_WRAP mechanism
+ */
+typedef struct CK_SKIPJACK_PRIVATE_WRAP_PARAMS {
+  CK_ULONG      ulPasswordLen;
+  CK_BYTE_PTR   pPassword;
+  CK_ULONG      ulPublicDataLen;
+  CK_BYTE_PTR   pPublicData;
+  CK_ULONG      ulPAndGLen;
+  CK_ULONG      ulQLen;
+  CK_ULONG      ulRandomLen;
+  CK_BYTE_PTR   pRandomA;
+  CK_BYTE_PTR   pPrimeP;
+  CK_BYTE_PTR   pBaseG;
+  CK_BYTE_PTR   pSubprimeQ;
+} CK_SKIPJACK_PRIVATE_WRAP_PARAMS;
+
+typedef CK_SKIPJACK_PRIVATE_WRAP_PARAMS CK_PTR \
+  CK_SKIPJACK_PRIVATE_WRAP_PARAMS_PTR;
+
+
+/* CK_SKIPJACK_RELAYX_PARAMS provides the parameters to the
+ * CKM_SKIPJACK_RELAYX mechanism
+ */
+typedef struct CK_SKIPJACK_RELAYX_PARAMS {
+  CK_ULONG      ulOldWrappedXLen;
+  CK_BYTE_PTR   pOldWrappedX;
+  CK_ULONG      ulOldPasswordLen;
+  CK_BYTE_PTR   pOldPassword;
+  CK_ULONG      ulOldPublicDataLen;
+  CK_BYTE_PTR   pOldPublicData;
+  CK_ULONG      ulOldRandomLen;
+  CK_BYTE_PTR   pOldRandomA;
+  CK_ULONG      ulNewPasswordLen;
+  CK_BYTE_PTR   pNewPassword;
+  CK_ULONG      ulNewPublicDataLen;
+  CK_BYTE_PTR   pNewPublicData;
+  CK_ULONG      ulNewRandomLen;
+  CK_BYTE_PTR   pNewRandomA;
+} CK_SKIPJACK_RELAYX_PARAMS;
+
+typedef CK_SKIPJACK_RELAYX_PARAMS CK_PTR \
+  CK_SKIPJACK_RELAYX_PARAMS_PTR;
+
+
+typedef struct CK_PBE_PARAMS {
+  CK_BYTE_PTR      pInitVector;
+  CK_UTF8CHAR_PTR  pPassword;
+  CK_ULONG         ulPasswordLen;
+  CK_BYTE_PTR      pSalt;
+  CK_ULONG         ulSaltLen;
+  CK_ULONG         ulIteration;
+} CK_PBE_PARAMS;
+
+typedef CK_PBE_PARAMS CK_PTR CK_PBE_PARAMS_PTR;
+
+
+/* CK_KEY_WRAP_SET_OAEP_PARAMS provides the parameters to the
+ * CKM_KEY_WRAP_SET_OAEP mechanism
+ */
+typedef struct CK_KEY_WRAP_SET_OAEP_PARAMS {
+  CK_BYTE       bBC;     /* block contents byte */
+  CK_BYTE_PTR   pX;      /* extra data */
+  CK_ULONG      ulXLen;  /* length of extra data in bytes */
+} CK_KEY_WRAP_SET_OAEP_PARAMS;
+
+typedef CK_KEY_WRAP_SET_OAEP_PARAMS CK_PTR CK_KEY_WRAP_SET_OAEP_PARAMS_PTR;
+
+typedef struct CK_SSL3_RANDOM_DATA {
+  CK_BYTE_PTR  pClientRandom;
+  CK_ULONG     ulClientRandomLen;
+  CK_BYTE_PTR  pServerRandom;
+  CK_ULONG     ulServerRandomLen;
+} CK_SSL3_RANDOM_DATA;
+
+
+typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS {
+  CK_SSL3_RANDOM_DATA RandomInfo;
+  CK_VERSION_PTR pVersion;
+} CK_SSL3_MASTER_KEY_DERIVE_PARAMS;
+
+typedef struct CK_SSL3_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+  CK_SSL3_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+typedef struct CK_SSL3_KEY_MAT_OUT {
+  CK_OBJECT_HANDLE hClientMacSecret;
+  CK_OBJECT_HANDLE hServerMacSecret;
+  CK_OBJECT_HANDLE hClientKey;
+  CK_OBJECT_HANDLE hServerKey;
+  CK_BYTE_PTR      pIVClient;
+  CK_BYTE_PTR      pIVServer;
+} CK_SSL3_KEY_MAT_OUT;
+
+typedef CK_SSL3_KEY_MAT_OUT CK_PTR CK_SSL3_KEY_MAT_OUT_PTR;
+
+
+typedef struct CK_SSL3_KEY_MAT_PARAMS {
+  CK_ULONG                ulMacSizeInBits;
+  CK_ULONG                ulKeySizeInBits;
+  CK_ULONG                ulIVSizeInBits;
+  CK_BBOOL                bIsExport;
+  CK_SSL3_RANDOM_DATA     RandomInfo;
+  CK_SSL3_KEY_MAT_OUT_PTR pReturnedKeyMaterial;
+} CK_SSL3_KEY_MAT_PARAMS;
+
+typedef CK_SSL3_KEY_MAT_PARAMS CK_PTR CK_SSL3_KEY_MAT_PARAMS_PTR;
+
+typedef struct CK_TLS_PRF_PARAMS {
+  CK_BYTE_PTR  pSeed;
+  CK_ULONG     ulSeedLen;
+  CK_BYTE_PTR  pLabel;
+  CK_ULONG     ulLabelLen;
+  CK_BYTE_PTR  pOutput;
+  CK_ULONG_PTR pulOutputLen;
+} CK_TLS_PRF_PARAMS;
+
+typedef CK_TLS_PRF_PARAMS CK_PTR CK_TLS_PRF_PARAMS_PTR;
+
+typedef struct CK_WTLS_RANDOM_DATA {
+  CK_BYTE_PTR pClientRandom;
+  CK_ULONG    ulClientRandomLen;
+  CK_BYTE_PTR pServerRandom;
+  CK_ULONG    ulServerRandomLen;
+} CK_WTLS_RANDOM_DATA;
+
+typedef CK_WTLS_RANDOM_DATA CK_PTR CK_WTLS_RANDOM_DATA_PTR;
+
+typedef struct CK_WTLS_MASTER_KEY_DERIVE_PARAMS {
+  CK_MECHANISM_TYPE   DigestMechanism;
+  CK_WTLS_RANDOM_DATA RandomInfo;
+  CK_BYTE_PTR         pVersion;
+} CK_WTLS_MASTER_KEY_DERIVE_PARAMS;
+
+typedef CK_WTLS_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+  CK_WTLS_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+typedef struct CK_WTLS_PRF_PARAMS {
+  CK_MECHANISM_TYPE DigestMechanism;
+  CK_BYTE_PTR       pSeed;
+  CK_ULONG          ulSeedLen;
+  CK_BYTE_PTR       pLabel;
+  CK_ULONG          ulLabelLen;
+  CK_BYTE_PTR       pOutput;
+  CK_ULONG_PTR      pulOutputLen;
+} CK_WTLS_PRF_PARAMS;
+
+typedef CK_WTLS_PRF_PARAMS CK_PTR CK_WTLS_PRF_PARAMS_PTR;
+
+typedef struct CK_WTLS_KEY_MAT_OUT {
+  CK_OBJECT_HANDLE hMacSecret;
+  CK_OBJECT_HANDLE hKey;
+  CK_BYTE_PTR      pIV;
+} CK_WTLS_KEY_MAT_OUT;
+
+typedef CK_WTLS_KEY_MAT_OUT CK_PTR CK_WTLS_KEY_MAT_OUT_PTR;
+
+typedef struct CK_WTLS_KEY_MAT_PARAMS {
+  CK_MECHANISM_TYPE       DigestMechanism;
+  CK_ULONG                ulMacSizeInBits;
+  CK_ULONG                ulKeySizeInBits;
+  CK_ULONG                ulIVSizeInBits;
+  CK_ULONG                ulSequenceNumber;
+  CK_BBOOL                bIsExport;
+  CK_WTLS_RANDOM_DATA     RandomInfo;
+  CK_WTLS_KEY_MAT_OUT_PTR pReturnedKeyMaterial;
+} CK_WTLS_KEY_MAT_PARAMS;
+
+typedef CK_WTLS_KEY_MAT_PARAMS CK_PTR CK_WTLS_KEY_MAT_PARAMS_PTR;
+
+typedef struct CK_CMS_SIG_PARAMS {
+  CK_OBJECT_HANDLE      certificateHandle;
+  CK_MECHANISM_PTR      pSigningMechanism;
+  CK_MECHANISM_PTR      pDigestMechanism;
+  CK_UTF8CHAR_PTR       pContentType;
+  CK_BYTE_PTR           pRequestedAttributes;
+  CK_ULONG              ulRequestedAttributesLen;
+  CK_BYTE_PTR           pRequiredAttributes;
+  CK_ULONG              ulRequiredAttributesLen;
+} CK_CMS_SIG_PARAMS;
+
+typedef CK_CMS_SIG_PARAMS CK_PTR CK_CMS_SIG_PARAMS_PTR;
+
+typedef struct CK_KEY_DERIVATION_STRING_DATA {
+  CK_BYTE_PTR pData;
+  CK_ULONG    ulLen;
+} CK_KEY_DERIVATION_STRING_DATA;
+
+typedef CK_KEY_DERIVATION_STRING_DATA CK_PTR \
+  CK_KEY_DERIVATION_STRING_DATA_PTR;
+
+
+/* The CK_EXTRACT_PARAMS is used for the
+ * CKM_EXTRACT_KEY_FROM_KEY mechanism.  It specifies which bit
+ * of the base key should be used as the first bit of the
+ * derived key
+ */
+typedef CK_ULONG CK_EXTRACT_PARAMS;
+
+typedef CK_EXTRACT_PARAMS CK_PTR CK_EXTRACT_PARAMS_PTR;
+
+/* CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE is used to
+ * indicate the Pseudo-Random Function (PRF) used to generate
+ * key bits using PKCS #5 PBKDF2.
+ */
+typedef CK_ULONG CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE;
+
+typedef CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE CK_PTR \
+                        CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE_PTR;
+
+#define CKP_PKCS5_PBKD2_HMAC_SHA1          0x00000001UL
+#define CKP_PKCS5_PBKD2_HMAC_GOSTR3411     0x00000002UL
+#define CKP_PKCS5_PBKD2_HMAC_SHA224        0x00000003UL
+#define CKP_PKCS5_PBKD2_HMAC_SHA256        0x00000004UL
+#define CKP_PKCS5_PBKD2_HMAC_SHA384        0x00000005UL
+#define CKP_PKCS5_PBKD2_HMAC_SHA512        0x00000006UL
+#define CKP_PKCS5_PBKD2_HMAC_SHA512_224    0x00000007UL
+#define CKP_PKCS5_PBKD2_HMAC_SHA512_256    0x00000008UL
+
+/* CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE is used to indicate the
+ * source of the salt value when deriving a key using PKCS #5
+ * PBKDF2.
+ */
+typedef CK_ULONG CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE;
+
+typedef CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE CK_PTR \
+                        CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE_PTR;
+
+/* The following salt value sources are defined in PKCS #5 v2.0. */
+#define CKZ_SALT_SPECIFIED        0x00000001UL
+
+/* CK_PKCS5_PBKD2_PARAMS is a structure that provides the
+ * parameters to the CKM_PKCS5_PBKD2 mechanism.
+ */
+typedef struct CK_PKCS5_PBKD2_PARAMS {
+        CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE           saltSource;
+        CK_VOID_PTR                                pSaltSourceData;
+        CK_ULONG                                   ulSaltSourceDataLen;
+        CK_ULONG                                   iterations;
+        CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;
+        CK_VOID_PTR                                pPrfData;
+        CK_ULONG                                   ulPrfDataLen;
+        CK_UTF8CHAR_PTR                            pPassword;
+        CK_ULONG_PTR                               ulPasswordLen;
+} CK_PKCS5_PBKD2_PARAMS;
+
+typedef CK_PKCS5_PBKD2_PARAMS CK_PTR CK_PKCS5_PBKD2_PARAMS_PTR;
+
+/* CK_PKCS5_PBKD2_PARAMS2 is a corrected version of the CK_PKCS5_PBKD2_PARAMS
+ * structure that provides the parameters to the CKM_PKCS5_PBKD2 mechanism
+ * noting that the ulPasswordLen field is a CK_ULONG and not a CK_ULONG_PTR.
+ */
+typedef struct CK_PKCS5_PBKD2_PARAMS2 {
+        CK_PKCS5_PBKDF2_SALT_SOURCE_TYPE saltSource;
+        CK_VOID_PTR pSaltSourceData;
+        CK_ULONG ulSaltSourceDataLen;
+        CK_ULONG iterations;
+        CK_PKCS5_PBKD2_PSEUDO_RANDOM_FUNCTION_TYPE prf;
+        CK_VOID_PTR pPrfData;
+        CK_ULONG ulPrfDataLen;
+        CK_UTF8CHAR_PTR pPassword;
+        CK_ULONG ulPasswordLen;
+} CK_PKCS5_PBKD2_PARAMS2;
+
+typedef CK_PKCS5_PBKD2_PARAMS2 CK_PTR CK_PKCS5_PBKD2_PARAMS2_PTR;
+
+typedef CK_ULONG CK_OTP_PARAM_TYPE;
+typedef CK_OTP_PARAM_TYPE CK_PARAM_TYPE; /* backward compatibility */
+
+typedef struct CK_OTP_PARAM {
+    CK_OTP_PARAM_TYPE type;
+    CK_VOID_PTR pValue;
+    CK_ULONG ulValueLen;
+} CK_OTP_PARAM;
+
+typedef CK_OTP_PARAM CK_PTR CK_OTP_PARAM_PTR;
+
+typedef struct CK_OTP_PARAMS {
+    CK_OTP_PARAM_PTR pParams;
+    CK_ULONG ulCount;
+} CK_OTP_PARAMS;
+
+typedef CK_OTP_PARAMS CK_PTR CK_OTP_PARAMS_PTR;
+
+typedef struct CK_OTP_SIGNATURE_INFO {
+    CK_OTP_PARAM_PTR pParams;
+    CK_ULONG ulCount;
+} CK_OTP_SIGNATURE_INFO;
+
+typedef CK_OTP_SIGNATURE_INFO CK_PTR CK_OTP_SIGNATURE_INFO_PTR;
+
+#define CK_OTP_VALUE          0UL
+#define CK_OTP_PIN            1UL
+#define CK_OTP_CHALLENGE      2UL
+#define CK_OTP_TIME           3UL
+#define CK_OTP_COUNTER        4UL
+#define CK_OTP_FLAGS          5UL
+#define CK_OTP_OUTPUT_LENGTH  6UL
+#define CK_OTP_OUTPUT_FORMAT  7UL
+
+#define CKF_NEXT_OTP          0x00000001UL
+#define CKF_EXCLUDE_TIME      0x00000002UL
+#define CKF_EXCLUDE_COUNTER   0x00000004UL
+#define CKF_EXCLUDE_CHALLENGE 0x00000008UL
+#define CKF_EXCLUDE_PIN       0x00000010UL
+#define CKF_USER_FRIENDLY_OTP 0x00000020UL
+
+typedef struct CK_KIP_PARAMS {
+    CK_MECHANISM_PTR  pMechanism;
+    CK_OBJECT_HANDLE  hKey;
+    CK_BYTE_PTR       pSeed;
+    CK_ULONG          ulSeedLen;
+} CK_KIP_PARAMS;
+
+typedef CK_KIP_PARAMS CK_PTR CK_KIP_PARAMS_PTR;
+
+typedef struct CK_AES_CTR_PARAMS {
+    CK_ULONG ulCounterBits;
+    CK_BYTE cb[16];
+} CK_AES_CTR_PARAMS;
+
+typedef CK_AES_CTR_PARAMS CK_PTR CK_AES_CTR_PARAMS_PTR;
+
+typedef struct CK_GCM_PARAMS {
+    CK_BYTE_PTR       pIv;
+    CK_ULONG          ulIvLen;
+    CK_ULONG          ulIvBits;
+    CK_BYTE_PTR       pAAD;
+    CK_ULONG          ulAADLen;
+    CK_ULONG          ulTagBits;
+} CK_GCM_PARAMS;
+
+typedef CK_GCM_PARAMS CK_PTR CK_GCM_PARAMS_PTR;
+
+typedef struct CK_CCM_PARAMS {
+    CK_ULONG          ulDataLen;
+    CK_BYTE_PTR       pNonce;
+    CK_ULONG          ulNonceLen;
+    CK_BYTE_PTR       pAAD;
+    CK_ULONG          ulAADLen;
+    CK_ULONG          ulMACLen;
+} CK_CCM_PARAMS;
+
+typedef CK_CCM_PARAMS CK_PTR CK_CCM_PARAMS_PTR;
+
+/* Deprecated. Use CK_GCM_PARAMS */
+typedef struct CK_AES_GCM_PARAMS {
+  CK_BYTE_PTR pIv;
+  CK_ULONG ulIvLen;
+  CK_ULONG ulIvBits;
+  CK_BYTE_PTR pAAD;
+  CK_ULONG ulAADLen;
+  CK_ULONG ulTagBits;
+} CK_AES_GCM_PARAMS;
+
+typedef CK_AES_GCM_PARAMS CK_PTR CK_AES_GCM_PARAMS_PTR;
+
+/* Deprecated. Use CK_CCM_PARAMS */
+typedef struct CK_AES_CCM_PARAMS {
+    CK_ULONG          ulDataLen;
+    CK_BYTE_PTR       pNonce;
+    CK_ULONG          ulNonceLen;
+    CK_BYTE_PTR       pAAD;
+    CK_ULONG          ulAADLen;
+    CK_ULONG          ulMACLen;
+} CK_AES_CCM_PARAMS;
+
+typedef CK_AES_CCM_PARAMS CK_PTR CK_AES_CCM_PARAMS_PTR;
+
+typedef struct CK_CAMELLIA_CTR_PARAMS {
+    CK_ULONG          ulCounterBits;
+    CK_BYTE           cb[16];
+} CK_CAMELLIA_CTR_PARAMS;
+
+typedef CK_CAMELLIA_CTR_PARAMS CK_PTR CK_CAMELLIA_CTR_PARAMS_PTR;
+
+typedef struct CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE           iv[16];
+    CK_BYTE_PTR       pData;
+    CK_ULONG          length;
+} CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS CK_PTR \
+                                CK_CAMELLIA_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+typedef struct CK_ARIA_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE           iv[16];
+    CK_BYTE_PTR       pData;
+    CK_ULONG          length;
+} CK_ARIA_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_ARIA_CBC_ENCRYPT_DATA_PARAMS CK_PTR \
+                                CK_ARIA_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+typedef struct CK_DSA_PARAMETER_GEN_PARAM {
+    CK_MECHANISM_TYPE  hash;
+    CK_BYTE_PTR        pSeed;
+    CK_ULONG           ulSeedLen;
+    CK_ULONG           ulIndex;
+} CK_DSA_PARAMETER_GEN_PARAM;
+
+typedef CK_DSA_PARAMETER_GEN_PARAM CK_PTR CK_DSA_PARAMETER_GEN_PARAM_PTR;
+
+typedef struct CK_ECDH_AES_KEY_WRAP_PARAMS {
+    CK_ULONG           ulAESKeyBits;
+    CK_EC_KDF_TYPE     kdf;
+    CK_ULONG           ulSharedDataLen;
+    CK_BYTE_PTR        pSharedData;
+} CK_ECDH_AES_KEY_WRAP_PARAMS;
+
+typedef CK_ECDH_AES_KEY_WRAP_PARAMS CK_PTR CK_ECDH_AES_KEY_WRAP_PARAMS_PTR;
+
+typedef CK_ULONG CK_JAVA_MIDP_SECURITY_DOMAIN;
+
+typedef CK_ULONG CK_CERTIFICATE_CATEGORY;
+
+typedef struct CK_RSA_AES_KEY_WRAP_PARAMS {
+    CK_ULONG                      ulAESKeyBits;
+    CK_RSA_PKCS_OAEP_PARAMS_PTR   pOAEPParams;
+} CK_RSA_AES_KEY_WRAP_PARAMS;
+
+typedef CK_RSA_AES_KEY_WRAP_PARAMS CK_PTR CK_RSA_AES_KEY_WRAP_PARAMS_PTR;
+
+typedef struct CK_TLS12_MASTER_KEY_DERIVE_PARAMS {
+    CK_SSL3_RANDOM_DATA       RandomInfo;
+    CK_VERSION_PTR            pVersion;
+    CK_MECHANISM_TYPE         prfHashMechanism;
+} CK_TLS12_MASTER_KEY_DERIVE_PARAMS;
+
+typedef CK_TLS12_MASTER_KEY_DERIVE_PARAMS CK_PTR \
+                                CK_TLS12_MASTER_KEY_DERIVE_PARAMS_PTR;
+
+typedef struct CK_TLS12_KEY_MAT_PARAMS {
+    CK_ULONG                  ulMacSizeInBits;
+    CK_ULONG                  ulKeySizeInBits;
+    CK_ULONG                  ulIVSizeInBits;
+    CK_BBOOL                  bIsExport;
+    CK_SSL3_RANDOM_DATA       RandomInfo;
+    CK_SSL3_KEY_MAT_OUT_PTR   pReturnedKeyMaterial;
+    CK_MECHANISM_TYPE         prfHashMechanism;
+} CK_TLS12_KEY_MAT_PARAMS;
+
+typedef CK_TLS12_KEY_MAT_PARAMS CK_PTR CK_TLS12_KEY_MAT_PARAMS_PTR;
+
+typedef struct CK_TLS_KDF_PARAMS {
+    CK_MECHANISM_TYPE         prfMechanism;
+    CK_BYTE_PTR               pLabel;
+    CK_ULONG                  ulLabelLength;
+    CK_SSL3_RANDOM_DATA       RandomInfo;
+    CK_BYTE_PTR               pContextData;
+    CK_ULONG                  ulContextDataLength;
+} CK_TLS_KDF_PARAMS;
+
+typedef CK_TLS_KDF_PARAMS CK_PTR CK_TLS_KDF_PARAMS_PTR;
+
+typedef struct CK_TLS_MAC_PARAMS {
+    CK_MECHANISM_TYPE         prfHashMechanism;
+    CK_ULONG                  ulMacLength;
+    CK_ULONG                  ulServerOrClient;
+} CK_TLS_MAC_PARAMS;
+
+typedef CK_TLS_MAC_PARAMS CK_PTR CK_TLS_MAC_PARAMS_PTR;
+
+typedef struct CK_GOSTR3410_DERIVE_PARAMS {
+    CK_EC_KDF_TYPE            kdf;
+    CK_BYTE_PTR               pPublicData;
+    CK_ULONG                  ulPublicDataLen;
+    CK_BYTE_PTR               pUKM;
+    CK_ULONG                  ulUKMLen;
+} CK_GOSTR3410_DERIVE_PARAMS;
+
+typedef CK_GOSTR3410_DERIVE_PARAMS CK_PTR CK_GOSTR3410_DERIVE_PARAMS_PTR;
+
+typedef struct CK_GOSTR3410_KEY_WRAP_PARAMS {
+    CK_BYTE_PTR               pWrapOID;
+    CK_ULONG                  ulWrapOIDLen;
+    CK_BYTE_PTR               pUKM;
+    CK_ULONG                  ulUKMLen;
+    CK_OBJECT_HANDLE          hKey;
+} CK_GOSTR3410_KEY_WRAP_PARAMS;
+
+typedef CK_GOSTR3410_KEY_WRAP_PARAMS CK_PTR CK_GOSTR3410_KEY_WRAP_PARAMS_PTR;
+
+typedef struct CK_SEED_CBC_ENCRYPT_DATA_PARAMS {
+    CK_BYTE                   iv[16];
+    CK_BYTE_PTR               pData;
+    CK_ULONG                  length;
+} CK_SEED_CBC_ENCRYPT_DATA_PARAMS;
+
+typedef CK_SEED_CBC_ENCRYPT_DATA_PARAMS CK_PTR \
+                                        CK_SEED_CBC_ENCRYPT_DATA_PARAMS_PTR;
+
+#endif /* _PKCS11T_H_ */
+
diff --git a/release/code/back_end-hsm/src/openssl_helper.c b/release/code/back_end-hsm/src/openssl_helper.c
new file mode 100644
index 0000000..e07d21d
--- /dev/null
+++ b/release/code/back_end-hsm/src/openssl_helper.c
@@ -0,0 +1,133 @@
+/*===========================================================================*/
+/**
+    @file    openssl_helper.c
+
+    @brief   Provide functions to backward support OpenSSL 1.0.2.
+
+@verbatim
+=============================================================================
+
+    Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of publication.
+This software file listing contains information of NXP that is of a
+confidential and proprietary nature and any viewing or use of this file is
+prohibited without specific written permission from NXP
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                                INCLUDE FILES
+=============================================================================*/
+#include <openssl/evp.h>
+#include <openssl/rsa.h>
+#include <openssl/ecdsa.h>
+
+/*===========================================================================
+                                FUNCTIONS
+=============================================================================*/
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+
+static void *
+OPENSSL_zalloc(size_t num)
+{
+    void *ret = OPENSSL_malloc(num);
+
+    if (ret != NULL) {
+        memset(ret, 0, num);
+    }
+    return ret;
+}
+
+void
+ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)
+{
+    if (pr != NULL) {
+        *pr = sig->r;
+    }
+    if (ps != NULL) {
+        *ps = sig->s;
+    }
+}
+
+int
+ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s)
+{
+    if (r == NULL || s == NULL) {
+        return 0;
+    }
+    BN_clear_free(sig->r);
+    BN_clear_free(sig->s);
+    sig->r = r;
+    sig->s = s;
+    return 1;
+}
+
+void
+EVP_MD_CTX_free(EVP_MD_CTX *ctx)
+{
+    EVP_MD_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+}
+
+EVP_MD_CTX *
+EVP_MD_CTX_new(void)
+{
+    return OPENSSL_zalloc(sizeof(EVP_MD_CTX));
+}
+
+EC_KEY *
+EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey)
+{
+    return (pkey->pkey.ec);
+}
+
+RSA *
+EVP_PKEY_get0_RSA(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_RSA) {
+        return NULL;
+    }
+    return pkey->pkey.rsa;
+}
+
+void
+RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
+{
+    if (n != NULL) {
+        *n = r->n;
+    }
+    if (e != NULL) {
+        *e = r->e;
+    }
+    if (d != NULL) {
+       *d = r->d;
+    }
+}
+
+#endif
+
+/*===========================================================================
+                               GLOBAL FUNCTIONS
+=============================================================================*/
+
+/*--------------------------
+  openssl_initialize
+---------------------------*/
+
+void
+openssl_initialize(void)
+{
+#if defined _WIN32 || defined __CYGWIN__
+    /* Required to avoid OpenSSL runtime errors on Win32 platforms */
+    /* See: https://www.openssl.org/docs/faq.html#PROG3 */
+    OPENSSL_malloc_init();
+#endif
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+    ERR_load_crypto_strings();
+    OpenSSL_add_all_algorithms();
+#endif
+}
diff --git a/release/code/back_end/hdr/adapt_layer.h b/release/code/back_end/hdr/adapt_layer.h
new file mode 100644
index 0000000..ef4eb0a
--- /dev/null
+++ b/release/code/back_end/hdr/adapt_layer.h
@@ -0,0 +1,300 @@
+#ifndef ADAPT_LAYER_H
+#define ADAPT_LAYER_H
+/*===========================================================================*/
+/**
+    @file    adapt_layer.h
+
+    @brief   CST adaptation layer interface
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011-2015 All rights reserved.
+        Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                            INCLUDE FILES
+=============================================================================*/
+#include <stdint.h>
+
+/*===========================================================================
+                              CONSTANTS
+=============================================================================*/
+
+/*===========================================================================
+                                MACROS
+=============================================================================*/
+#define UNUSED(expr)                (void)(expr)
+
+#define CAL_SUCCESS                 ( 0) /* Operation completed successfully */
+#define CAL_FILE_NOT_FOUND          (-1) /* Error when file does not exist   */
+#define CAL_INVALID_SIG_DATA_SIZE   (-2) /* Error when sig data size invalid */
+#define CAL_FAILED_FILE_CREATE      (-3) /* Error unable to create file      */
+#define CAL_MAC_LEN_INCORRECT       (-4) /* Error MAC len is incorrect       */
+#define CAL_INVALID_ARGUMENT        (-5) /* Error argument passed is invalid */
+#define CAL_CRYPTO_API_ERROR        (-6) /* Error with openssl API           */
+#define CAL_INSUFFICIENT_BUFFER_LEN (-7) /* Buffer length is not sufficient  */
+#define CAL_DATA_COMPARE_FAILED     (-8) /* Data comparison operation failed */
+#define CAL_RAND_SEED_ERROR         (-9) /* Failure to run rand_seed         */
+#define CAL_RAND_API_ERROR         (-10) /* Failure in RAND_bytes            */
+#define CAL_NO_CRYPTO_API_ERROR    (-11) /* Error when Encryption is disabled*/
+#define CAL_INVALID_SIGNATURE      (-12) /* Error when verifying isignature  */
+#define CAL_LAST_ERROR            (-100) /* Max error codes for adapt layer  */
+
+#define FILE_BUF_SIZE             (1024) /* 1K buf for file read/file write  */
+
+#define MAX_AES_KEY_LENGTH          (32) /* Max bytes in AES key             */
+#define AES_BLOCK_BYTES             (16)           /**< Max. AES block bytes */
+#define FLAG_BYTES                   (1)                  /**< Bytes in Flag */
+#define BYTE_SIZE_BITS               (8)       /**< Number of bits in a byte */
+
+#define SIG_REQ_FILENAME   "sig_req.txt" /**< Signing request filename       */
+
+/*===========================================================================
+                                ENUMS
+=============================================================================*/
+typedef enum func_mode_e
+{
+    MODE_UNDEF = 0,     /**< Undefined functional mode */
+    MODE_NOMINAL,       /**< Execution in normal mode  */
+    MODE_HSM,           /**< Execution in HSM mode     */
+} func_mode_t;
+
+typedef enum _SIG_FMT
+{
+    SIG_FMT_UNDEF = 0,  /**< Undefined signature format */
+    SIG_FMT_PKCS1,      /**< RAW PKCS#1 signature format */
+    SIG_FMT_CMS,        /**< CMS (PKCS#7) signature format */
+    SIG_FMT_ECDSA,      /**< ECDSA signature format. R|S concatanated */
+    SIG_FMT_AEAD,       /**< Proprietary AEAD MAC format */
+} sig_fmt_t;
+
+
+/** Hash Digetst Algorithm */
+typedef enum hash_alg
+{
+    SHA_1 = 0,          /**< SHA-1 Digest Algorithm */
+    SHA_256,            /**< SHA-256 Digest Algorithm */
+    SHA_384,            /**< SHA-384 Digest Algorithm */
+    SHA_512,            /**< SHA-512 Digest Algorithm */
+    INVALID_DIGEST      /**< Invalid Digest Algorithm */
+} hash_alg_t;
+
+/** AES key lengths supported */
+typedef enum aes_key_bits
+{
+    AES_KEY_LEN_128 = 128, /**< 128 bits */
+    AES_KEY_LEN_192 = 192, /**< 192 bits */
+    AES_KEY_LEN_256 = 256, /**< 256 bits */
+} aes_key_bits_t;
+
+/** Encryption algorithms supported */
+typedef enum aead_alg
+{
+    AES_CCM = 0 /**< Default encryption algorithm supported */
+} aead_alg_t;
+
+/*===========================================================================
+                    STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+
+typedef struct _AEAD {
+    uint8_t *uch;
+} AEAD_t;
+
+/*===========================================================================
+                     GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+
+/*===========================================================================
+                         FUNCTION PROTOTYPES
+=============================================================================*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** Converts given digest value to equivalent OpenSSL string
+ *
+ * @param[in] hash_alg one of #hash_alg_t
+ *
+ * @returns Openssl string corresponding the given hash algorithm in
+ *          @a hash_alg, if @a hash_alg is not valid #HASH_ALG_INVALID
+ *          is returned.
+ */
+char *
+get_digest_name(hash_alg_t hash_alg);
+
+/** Generate Signature Data
+ *
+ * Generates a signature for the given data file, signer certificate,
+ * hash algorithm and signature format. The signature data is returned
+ * in a buffer provided by caller.
+ *
+ * @param[in] in_file path to file with binary data to sign
+ *
+ * @param[in] cert_file path to signer certificate file
+ *
+ * @param[in] hash_alg hash algorithm in #hash_alg_t
+ *
+ * @param[in] sig_fmt signature format in #sig_fmt_t
+ *
+ * @param[out] sig_buf buffer to return signature data
+ *
+ * @param[in,out] sig_buf_bytes input size of sig_buf allocated by caller
+ *                              output size of signature data returned by API
+ *
+ * @post Errors are printed to STDERR
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_FILE_NOT_FOUND invalid path in one of the arguments
+ *
+ * @retval #CAL_INVALID_SIG_DATA_SIZE size insufficient to generate sig data
+ *
+ * @retval #CAL_INVALID_ARGUMENT one of the input arguments is invalid
+ */
+int32_t gen_sig_data(const char* in_file,
+                     const char* cert_file,
+                     hash_alg_t hash_alg,
+                     sig_fmt_t sig_fmt,
+                     uint8_t* sig_buf,
+                     size_t *sig_buf_bytes,
+                     func_mode_t mode);
+
+/** Generate authenticated encrypted data
+ *
+ * API generates authenticated encrypted data for given plain-text data file
+ *
+ * @param[in] in_file plaintext, extracted and concatenated as for signing
+ *
+ * @param[out] out_file ciphertext (file name is input)
+ *
+ * @param[in] aead_alg only AES_CCM supported for now.
+ *
+ * @param[out] aad additional authenticated data
+ *
+ * @param[in] aad_bytes size of aad (additional authenticated data)
+ *
+ * @param[out] nonce nonce bytes to return
+ *
+ * @param[in] nonce_bytes size of nonce
+ *
+ * @param[out] mac output MAC
+ *
+ * @param[in] mac_bytes size of MAC
+ *
+ * @param[in] key_bytes size of symmetric key
+ *
+ * @param[in] cert_file certificate for DEK (data enctyption key) encryption
+ *
+ * @param[out] key_file encrypted symmetric key (file name is input)
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_FILE_NOT_FOUND invalid path in one of the arguments
+ *
+ * @retval #CAL_FAILED_FILE_CREATE the output file cannot be created
+ *
+ * @retval #CAL_MAC_LEN_INCORRECT the mac_bytes is not correct
+ */
+int32_t gen_auth_encrypted_data(const char* in_file,
+                     const char* out_file,
+                     aead_alg_t aead_alg,
+                     uint8_t *aad,
+                     size_t aad_bytes,
+                     uint8_t *nonce,
+                     size_t nonce_bytes,
+                     uint8_t *mac,
+                     size_t mac_bytes,
+                     size_t key_bytes,
+                     const char* cert_file,
+                     const char* key_file,
+                     int reuse_dek);
+
+/** Computes hash digest from a given input file
+ *
+ * This function differs from the generate_hash() function in
+ * openssl_helper.c in that this function will hash an arbitrary amount of
+ * data contained in @in_file. The generate_hash expects the data in a
+ * contigous memory array with the data length already known.
+ *
+ * @param[in] in_file Character string holding the input data filename.
+ *
+ * @param[in] hash_alg Hash digest algorithm from #hash_alg_t
+ *
+ * @param[in,out] buf on input, used to read input data when computing
+ *                hash value, on output holds the resulting hash value.
+ *
+ * @param[in,out] pbuf_bytes on input, holds the size of @a buf ib bytes,
+ *                on output pbuf_bytes is updated to hold the size of the
+ *                resulting hash in bytes.
+ *
+ * @pre @a in_file, @a buf, and @a pbuf_bytes must not be NULL
+ *
+ * @post On success @a buf is updated to hold the hash digest result and
+ *       @a pbuf_bytes is updated to hold the length of the hash in bytes
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_INVALID_ARGUMENTif @a hash_alg contains an unsupported
+ *         algorithm
+ *
+ * @retval #CAL_CRYPTO_API_ERROR otherwise
+ */
+int32_t
+calculate_hash(const char *in_file,
+               hash_alg_t hash_alg,
+               uint8_t *buf,
+               int32_t *pbuf_bytes);
+
+/** Verify Signature Data
+ *
+ * Verifies a signature for the given data file, signer certificate,
+ * hash algorithm and signature format. The signature data is given
+ * in a buffer provided by caller.
+ *
+ * @param[in] in_file path to file with binary data to sign
+ *
+ * @param[in] cert_file path to signer certificate file
+ *
+ * @param[in] hash_alg hash algorithm in #hash_alg_t
+ *
+ * @param[in] sig_fmt signature format in #sig_fmt_t
+ *
+ * @param[in] sig_buf buffer to give signature data
+ *
+ * @param[in] sig_buf_bytes input size of sig_buf allocated by caller
+ *
+ * @post Errors are printed to STDERR
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_FILE_NOT_FOUND invalid path in one of the arguments
+ *
+ * @retval #CAL_INVALID_SIGNATURE invalid signature
+ *
+ * @retval #CAL_INVALID_ARGUMENT one of the input arguments is invalid
+ */
+int32_t
+ver_sig_data(const char *in_file,
+             const char *cert_file,
+             hash_alg_t hash_alg,
+             sig_fmt_t  sig_fmt,
+             uint8_t    *sig_buf,
+             size_t     sig_buf_bytes);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* ADAPT_LAYER_H */
diff --git a/release/code/back_end/hdr/openssl_helper.h b/release/code/back_end/hdr/openssl_helper.h
new file mode 100644
index 0000000..ddfe6af
--- /dev/null
+++ b/release/code/back_end/hdr/openssl_helper.h
@@ -0,0 +1,364 @@
+#ifndef __OPENSSL_HELPER_H
+#define __OPENSSL_HELPER_H
+/*===========================================================================*/
+/**
+    @file    openssl_helper.h
+
+    @brief   Provide helper functions to ease openssl tasks and also defines
+             common macros that can used across different tools
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011, 2012. All rights reserved.
+        Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                                INCLUDE FILES
+=============================================================================*/
+#include "adapt_layer.h"
+#include <openssl/bn.h>
+#include <openssl/bio.h>
+#include <openssl/pem.h>
+
+/*===========================================================================
+                                 CONSTANTS
+=============================================================================*/
+
+#define TRUE                      1 /**< Success val returned by functions */
+#define FALSE                     0 /**< Failure val returned by functions */
+
+#define X509_UTCTIME_STRING_BYTES 13 /**< Expected length of validity period
+                                       *   strings in X.509 certificates using
+                                       *   UTCTime format
+                                       */
+#define X509_GENTIME_STRING_BYTES 15 /**< Expected length of validity period
+                                       *   strings in X.509 certificates using
+                                       *   Generalized Time format
+                                       */
+#define PEM_FILE_EXTENSION        ".pem"   /* PEM file extention */
+#define PEM_FILE_EXTENSION_BYTES  4        /* Length of pem extention */
+
+/* Message digest string definitions */
+#define HASH_ALG_SHA1             "sha1"   /**< String macro for sha1 */
+#define HASH_ALG_SHA256           "sha256" /**< String macro for sha256 */
+#define HASH_ALG_SHA384           "sha384" /**< String macro for sha384 */
+#define HASH_ALG_SHA512           "sha512" /**< String macro for sha512 */
+#define HASH_ALG_INVALID          "null"   /**< String macro for invalid hash */
+
+/* Message digest length definitions */
+#define HASH_BYTES_SHA1           20   /**< Size of SHA1 output bytes */
+#define HASH_BYTES_SHA256         32   /**< Size of SHA256 output bytes */
+#define HASH_BYTES_SHA384         48   /**< Size of SHA384 output bytes */
+#define HASH_BYTES_SHA512         64   /**< Size of SHA512 output bytes */
+#define HASH_BYTES_MAX            HASH_BYTES_SHA512
+
+/* X509 certificate definitions */
+#define X509_USR_CERT             0x0 /**< User certificate */
+#define X509_CA_CERT              0x1 /**< CA certificate */
+
+/*===========================================================================
+                                 CONSTANTS
+=============================================================================*/
+
+/** Extracts a byte from a given 32 bit word value
+ *
+ * @param [in] val value to extract byte from
+ *
+ * @param [in] bit_shift Number of bits to shift @a val left before
+ *                       extracting the least significant byte
+ *
+ * @returns the least significant byte after shifting @a val to the left
+ *          by @a bit_shift bits
+ */
+#define EXTRACT_BYTE(val, bit_shift) \
+    (((val) >> (bit_shift)) & 0xFF)
+
+/*============================================================================
+                                      ENUMS
+=============================================================================*/
+
+typedef enum cst_status
+{
+    CST_FAILURE = FALSE,
+    CST_SUCCESS = TRUE
+} cst_status_t;
+
+/*============================================================================
+                           STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+
+/*============================================================================
+                           GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+
+/*===========================================================================
+                               OPENSSL 1.0.2 SUPPORT
+=============================================================================*/
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+
+#define OPENSSL_malloc_init CRYPTO_malloc_init
+#define X509_get0_notBefore X509_get_notBefore
+#define X509_get0_notAfter  X509_get_notAfter
+
+void
+ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);
+
+int
+ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s);
+
+void
+EVP_MD_CTX_free(EVP_MD_CTX *ctx);
+
+EVP_MD_CTX *
+EVP_MD_CTX_new(void);
+
+EC_KEY *
+EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey);
+
+RSA *
+EVP_PKEY_get0_RSA(EVP_PKEY *pkey);
+
+void
+RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);
+
+#endif
+
+/*============================================================================
+                                FUNCTION PROTOTYPES
+=============================================================================*/
+
+/** openssl_initialize
+ *
+ * Initializes the openssl library.  This function must be called once
+ * by the program using any of the openssl helper functions
+ *
+ */
+extern void
+openssl_initialize();
+
+/** Unix time
+ *
+ * Converts the validity time provided in X.509 certificates to Unix time
+ * required for WTLS certificates.
+ *
+ * @param[in] x509_time String with format: YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ
+ *
+ * @pre  Input X.509 certificate has validity period.
+ *
+ * @returns 32 bit time in UNIX format if successful, 0 otherwise
+ */
+extern uint32_t
+unix_time(const char *x509_time);
+
+/** Computes hash digest
+ *
+ * Calls openssl API to generate hash for the given data in buf.
+ *
+ * @param[in] buf, binary data for hashing
+ *
+ * @param[in] msg_bytes, size in bytes for binary data
+ *
+ * @param[in] hash_alg, character string containing hash algorithm,
+ *                      "sha1" or "sha256"
+ *
+ * @param[out] hash_bytes, size of digest result in bytes
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @pre  @a buf and @a hash_alg are not NULL.
+ *
+ * @post It is the responsibilty of the caller to free the memory allocated by
+ *       this function holding the computed hash result.
+ *
+ * @returns The location of the digest result if successful, NULL otherwise
+ */
+extern uint8_t *
+generate_hash(const uint8_t *buf, size_t msg_bytes, const char *hash_alg,
+              size_t *hash_bytes);
+
+/** get_bn
+ *
+ * Extracts data from an openssl BIGNUM type to a byte array.  Used
+ * for extracting certificate data such as an RSA public key modulus.
+ *
+ * @param[in] a      BIG_NUM structure
+ *
+ * @param[out] bytes size of resulting byte array
+ *
+ * @pre @a a and @a bytes are not NULL
+ *
+ * @post It is the responsibilty of the caller to free the memory allocated by
+ *       this function holding the big number result.
+ *
+ * @returns location of resulting byte array or NULL if failed to alloc mem.
+ */
+extern uint8_t*
+get_bn(const BIGNUM *a, size_t *bytes);
+
+
+/** sign_data
+ *
+ * Signs a data buffer with a given private key
+ *
+ * @param[in] skey       signer private key
+ *
+ * @param[in] bptr       location of data buffer to digitally sign
+ *
+ * @param[in] hash_alg   hash digest algorithm
+ *
+ * @param[out] sig_bytes size of resulting signature buffer
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @post It is the responsibilty of the caller to free the memory allocated by
+ *       this function holding the signature  result.
+ *
+ * @returns if successful returns location of resulting byte array otherwise
+ * NULL.
+ */
+extern uint8_t*
+sign_data(const EVP_PKEY *skey, const BUF_MEM *bptr, hash_alg_t hash_alg,
+          size_t *sig_bytes);
+
+/** write_cert_file
+ *
+ * Writes WTLS certificate data to a binary file
+ *
+ * @param[in] filename    filename of WTLS certificate file
+ *
+ * @param[in] data        WTLS certificate data
+ *
+ * @post if successful the contents of the WTLS certificate are written to
+ *       the output file.
+ *
+ * @returns if successful function returns #CST_SUCCESS otherwise #CST_FAILURE
+ */
+extern cst_status_t
+write_cert_file(const char *filename, const BIO *wtls_cert);
+
+/** read_certificate
+ *
+ * Read X.509 certificate data from given certificate file
+ *
+ * @param[in] filename    filename of certificate file
+ *
+ * @post if successful the contents of the certificate are extracted to X509
+ * object.
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @post caller is responsible for releasing X.509 certificate memory.
+ *
+ * @returns if successful function returns location of X509 object
+ *   otherwise NULL.
+ */
+extern X509*
+read_certificate(const char* filename);
+
+/** get_der_encoded_certificate_data
+ *
+ * Read X.509 certificate data from given certificate file and calls openssl
+ * to encode X509 to DER format and returns DER formatted data located at
+ * @derder.
+ *
+ * @param[in] filename    filename, function will work with both PEM and DER
+ *                        input certificate files.
+ *
+ * @param[out] der        address to write der data
+ *
+ * @post if successful the contents of the certificate are written at address
+ * @a der.
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @post caller is responsible for releasing memory location returned in @a der
+ *
+ * @returns if successful function returns number of bytes written at address
+ * @a der, 0 otherwise.
+ */
+extern int32_t get_der_encoded_certificate_data(const char* filename,
+                                           uint8_t ** der);
+
+/** read_private_key
+ *
+ * Uses openssl API to read private key from given certificate file
+ *
+ * @param[in] filename    filename of key file
+ *
+ * @param[in] password_cb callback fn to provide password for keyfile
+ *            see openssl's pem.h for callback'e prototype
+ *
+ * @param[in] password    password for keyfile
+ *
+ * @post if successful the contents of the private key are extracted to
+ * EVP_PKEY object.
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @post caller is responsible for releasing the private key memory.
+ *
+ * @returns if successful function returns location of EVP_PKEY object
+ *   otherwise NULL.
+ */
+extern EVP_PKEY*
+read_private_key(const char *filename, pem_password_cb *password_cb,
+                 const char *password);
+
+/** seed_prng
+ *
+ * Calls openssl API to seed prng to given bytes randomness
+ *
+ * @param[in] bytes   bytes to randomize the seed
+ *
+ * @pre  None
+ *
+ * @post None
+ */
+uint32_t seed_prng(uint32_t bytes);
+
+/** gen_random_bytes
+ *
+ * Generates random bytes using openssl RAND_bytes
+ *
+ * @param[out] buf    buf to return the random bytes
+ *
+ * @param[in] bytes   size of the buf in bytes and number of random bytes
+ *                    to generate
+ *
+ * @pre  None
+ *
+ * @post None
+ */
+int32_t gen_random_bytes(uint8_t *buf, size_t bytes);
+
+/** Diplays program license information to stdout
+ *
+ * @pre  None
+ *
+ * @post None
+ */
+extern void
+print_license(void);
+
+/** Diplays program version information to stdout
+ *
+ * @pre  None
+ *
+ * @post None
+ */
+extern void
+print_version(void);
+
+#endif /* __OPENSSL_HELPER_H */
diff --git a/release/code/back_end/hdr/pkey.h b/release/code/back_end/hdr/pkey.h
new file mode 100644
index 0000000..cc6390f
--- /dev/null
+++ b/release/code/back_end/hdr/pkey.h
@@ -0,0 +1,114 @@
+#ifndef PKEY_H
+#define PKEY_H
+/*===========================================================================*/
+/**
+    @file    pkey.h
+
+    @brief   CST private key and password provider API
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011,2012. All rights reserved.
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================
+Revision History:
+
+                 Modification Date  Tracking
+Author             (dd-mmm-yyyy)    Number      Description of Changes
+---------------    -------------   ----------  -----------------------
+Fareed Mohammed     12-Sep-2011                Initial version
+Florent Auger       28-Aug-2012    ENGR162295  Path to key file built from CSF
+
+=============================================================================
+Portability:
+
+These definitions are customised for 32 bit cores of either
+endianness.
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                            INCLUDE FILES
+=============================================================================*/
+
+/*===========================================================================
+                              CONSTANTS
+=============================================================================*/
+
+/*===========================================================================
+                                MACROS
+=============================================================================*/
+
+/*===========================================================================
+                                ENUMS
+=============================================================================*/
+
+/*===========================================================================
+                    STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+
+/*===========================================================================
+                     GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+
+/*===========================================================================
+                         FUNCTION PROTOTYPES
+=============================================================================*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/** get_passcode_to_key_file
+ *
+ * @par Purpose
+ *
+ * Callback to gte password for the encrypted key file. Default behavior
+ * can be overridden by customers by linking with their own implementation
+ * of libpw.a and this function
+ *
+ * @par Operation
+ *
+ * @param[out] buf,  return buffer for the password
+ *
+ * @param[in] size,  size of the buf in bytes
+ *
+ * @param[in] rwflag,  not used
+ *
+ * @param[in] userdata,  filename for a public key used in the CSF
+ *
+ * @retval returns size of password string
+ */
+int get_passcode_to_key_file(char *buf, int size, int rwflag, void *userdata);
+
+/** get_key_file
+ *
+ * @par Purpose
+ *
+ * This API extracts private key filename using cert filename. This API is
+ * moved to libpw to allow customers to change its implementation to better
+ * suit their needs.
+ *
+ * @par Operation
+ *
+ * @param[in] cert_file,  filename for certificate
+ *
+ * @param[out] key_file,  filename for private key for the input certificate
+ *
+ * @retval SUCCESS
+ */
+int32_t get_key_file(const char* cert_file, char* key_file);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* PKEY_H */
diff --git a/release/code/back_end/hdr/ssl_wrapper.h b/release/code/back_end/hdr/ssl_wrapper.h
new file mode 100644
index 0000000..6459334
--- /dev/null
+++ b/release/code/back_end/hdr/ssl_wrapper.h
@@ -0,0 +1,67 @@
+#ifndef SSL_WRAPPER_H
+#define SSL_WRAPPER_H
+/*===========================================================================
+
+    @file    ssl_wrapper.h
+
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011-2015. All rights reserved.
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+===========================================================================*/
+
+/*===========================================================================
+                            INCLUDE FILES
+=============================================================================*/
+#ifndef REMOVE_ENCRYPTION
+#include <openssl/evp.h>
+#endif
+#include <adapt_layer.h>
+/*===========================================================================
+                              CONSTANTS
+=============================================================================*/
+
+/*===========================================================================
+                                MACROS
+=============================================================================*/
+
+/*===========================================================================
+                                ENUMS
+=============================================================================*/
+
+/*===========================================================================
+                    STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+
+/*===========================================================================
+                     GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+
+/*===========================================================================
+                         FUNCTION PROTOTYPES
+=============================================================================*/
+#ifdef __cplusplus
+extern "C" {
+#endif
+void handle_errors(char * str,  int32_t *err_value, char *err_str);
+
+int32_t encryptccm(unsigned char *plaintext, int plaintext_len, unsigned char *aad,
+                   int aad_len, unsigned char *key, int key_len, unsigned char *iv,
+                   int iv_len, const char * out_file, unsigned char *tag, int tag_len,
+                   int32_t *err_value, char *err_str);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* SSL_WRAPPER_H  */
+
+
+
diff --git a/release/code/back_end/hdr/version.h b/release/code/back_end/hdr/version.h
new file mode 100644
index 0000000..4393d39
--- /dev/null
+++ b/release/code/back_end/hdr/version.h
@@ -0,0 +1,27 @@
+#ifndef __VERSION_H
+#define __VERSION_H
+/*===========================================================================*/
+/**
+    @file    version.h
+
+    @brief   Version of the tool to manually set at each release.
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011-2015. All rights reserved.
+        Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================
+@endverbatim */
+
+#define CST_VERSION "3.1.0"
+
+#endif /* __VERSION_H */
diff --git a/release/code/back_end/src/adapt_layer_openssl.c b/release/code/back_end/src/adapt_layer_openssl.c
new file mode 100644
index 0000000..24087f6
--- /dev/null
+++ b/release/code/back_end/src/adapt_layer_openssl.c
@@ -0,0 +1,1072 @@
+/*===========================================================================*/
+/**
+    @file    adapt_layer_openssl.c
+
+    @brief   Implements Code Signing Tool's Adaptation Layer API for the
+             Freescale reference Code Signing Tool.  This file may be
+             replaced in implementations using a Hardware Security Module
+             or a client/server based infrastructure.
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011-2015. All rights reserved.
+        Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                                INCLUDE FILES
+=============================================================================*/
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include "ssl_wrapper.h"
+#include <string.h>
+#include <openssl/bio.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/cms.h>
+#include <openssl/err.h>
+#include <openssl/pem.h>
+#include <openssl/rand.h>
+#include <openssl/crypto.h>
+#include <openssl/rsa.h>
+#include "adapt_layer.h"
+#include "openssl_helper.h"
+#include "pkey.h"
+#if (defined _WIN32 || defined __CYGWIN__) && defined USE_APPLINK
+#include <openssl/applink.c>
+#endif
+/*===========================================================================
+                                 LOCAL MACROS
+=============================================================================*/
+#define MAX_CMS_DATA                4096   /**< Max bytes in CMS_ContentInfo */
+#define MAX_ERR_STR_BYTES           120         /**< Max. error string bytes */
+#define MAX_LINE_CHARS              1024   /**< Max. chars in output line    */
+
+/*===========================================================================
+                  LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
+=============================================================================*/
+
+/*===========================================================================
+                          LOCAL FUNCTION PROTOTYPES
+=============================================================================*/
+
+/** Converts hash_alg to an equivalent NID value for OpenSSL
+ *
+ * @param[in] hash_alg Hash digest algorithm from #hash_alg_t
+ *
+ * @pre hash_alg is a valid value from #hash_alg_t
+ *
+ * @returns Openssl NID value corresponding to a valid value for @a hash_alg,
+ *          NID_undef otherwise.
+ */
+static int32_t
+get_NID(hash_alg_t hash_alg);
+
+/** Generate raw PKCS#1 Signature Data
+ *
+ * Generates a raw PKCS#1 v1.5 signature for the given data file, signer
+ * certificate, and hash algorithm. The signature data is returned in
+ * a buffer provided by caller.
+ *
+ * @param[in] in_file string containing path to file with data to sign
+ *
+ * @param[in] key_file string containing path to signing key
+ *
+ * @param[in] hash_alg hash algorithm from #hash_alg_t
+ *
+ * @param[out] sig_buf signature data buffer
+ *
+ * @param[in,out] sig_buf_bytes On input, contains size of @a sig_buf in bytes,
+ *                              On output, contains size of signature in bytes.
+ *
+ * @pre @a in_file, @a cert_file, @a key_file, @a sig_buf and @a sig_buf_bytes
+ *         must not be NULL.
+ *
+ * @post On success @a sig_buf is updated to hold the resulting signature and
+ *       @a sig_buf_bytes is updates to hold the length of the signature in
+ *       bytes
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_CRYPTO_API_ERROR An Openssl related error has occured
+ */
+static int32_t
+gen_sig_data_raw(const char *in_file,
+                 const char *key_file,
+                 hash_alg_t hash_alg,
+                 uint8_t *sig_buf,
+                 int32_t *sig_buf_bytes);
+
+/** Generate CMS Signature Data
+ *
+ * Generates a CMS signature for the given data file, signer certificate, and
+ * hash algorithm. The signature data is returned in a buffer provided by
+ * caller.  Note that sign_data cannot be used here since that function
+ * requires an input buffer as an argument.  For large files it becomes
+ * unreasonable to allocate a contigous block of memory.
+ *
+ * @param[in] in_file string containing path to file with data to sign
+ *
+ * @param[in] cert_file string constaining path to signer certificate
+ *
+ * @param[in] hash_alg hash algorithm from #hash_alg_t
+ *
+ * @param[out] sig_buf signature data buffer
+ *
+ * @param[in,out] sig_buf_bytes On input, contains size of @a sig_buf in bytes,
+ *                              On output, contains size of signature in bytes.
+ *
+ * @pre @a in_file, @a cert_file, @a key_file, @a sig_buf and @a sig_buf_bytes
+ *         must not be NULL.
+ *
+ * @post On success @a sig_buf is updated to hold the resulting signature and
+ *       @a sig_buf_bytes is updates to hold the length of the signature in
+ *       bytes
+ *
+ * @retval #CAL_SUCCESS API completed its task successfully
+ *
+ * @retval #CAL_INVALID_ARGUMENT One of the input arguments is invalid
+ *
+ * @retval #CAL_CRYPTO_API_ERROR An Openssl related error has occured
+ */
+static int32_t
+gen_sig_data_cms(const char *in_file,
+                 const char *cert_file,
+                 const char *key_file,
+                 hash_alg_t hash_alg,
+                 uint8_t *sig_buf,
+                 size_t *sig_buf_bytes);
+
+/** Copies CMS Content Info with encrypted or signature data to buffer
+ *
+ * @param[in] cms CMS Content Info
+ *
+ * @param[in] bio_in input bio
+ *
+ * @param[out] data_buffer address to data buffer
+ *
+ * @param[in] data_buffer_size max size, [out] return size
+ *
+ * @param[in] flags CMS Flags
+ *
+ * @returns CAL_SUCCESS upon success
+ *
+ * @returns CAL_CRYPTO_API_ERROR when openssl BIO API fail
+ */
+int32_t cms_to_buf(CMS_ContentInfo *cms, BIO * bio_in, uint8_t * data_buffer,
+                            size_t * data_buffer_size, int32_t flags);
+
+/** generate_dek_key
+ *
+ * Uses openssl API to generate a random 128 bit AES key
+ *
+ * @param[out] key buffer to store the key data
+ *
+ * @param[in] len length of the key to generate
+ *
+ * @post if successful the random bytes are placed into output buffer
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @returns if successful function returns location CAL_SUCCESS.
+ */
+int32_t generate_dek_key(uint8_t * key, int32_t len);
+
+/**  write_plaintext_dek_key
+ *
+ * Writes the provide DEK to the give path. It will be encrypted
+ * under the certificate file if provided.
+ *
+ * @param[in] key input key data
+ *
+ * @param[in] key_bytes length of the input key
+ *
+ * @param[in] cert_file  certificate to encrypt the DEK
+ *
+ * @param[in] enc_file  destination file
+ *
+ * @post if successful the dek is written to the file
+ *
+ * @returns if successful function returns location CAL_SUCCESS.
+ */
+int32_t write_plaintext_dek_key(uint8_t * key, size_t key_bytes,
+                        const char * cert_file, const char * enc_file);
+
+/** encrypt_dek_key
+ *
+ * Uses openssl API to encrypt the key. Saves the encrypted structure to a file
+ *
+ * @param[in] key input key data
+ *
+ * @param[in] key_bytes length of the input key
+ *
+ * @param[in] cert filename of the RSA certificate, dek will be encrypted with
+ *
+ * @param[in] file encrypted data saved in the file
+ *
+ * @post if successful the file is created with the encrypted data
+ *
+ * @pre  #openssl_initialize has been called previously
+ *
+ * @returns if successful function returns location CAL_SUCCESS.
+ */
+int32_t encrypt_dek_key(uint8_t * key, size_t key_bytes,
+                const char * cert_file, const char * enc_file);
+
+/** Display error message
+ *
+ * Displays error message to STDERR
+ *
+ * @param[in] err Error string to display
+ *
+ * @pre  @a err is not NULL
+ *
+ * @post None
+ */
+static void
+display_error(const char *err);
+
+/*===========================================================================
+                               GLOBAL VARIABLES
+=============================================================================*/
+
+/*===========================================================================
+                               LOCAL FUNCTIONS
+=============================================================================*/
+
+/*--------------------------
+  get_NID
+---------------------------*/
+int32_t
+get_NID(hash_alg_t hash_alg)
+{
+    return OBJ_txt2nid(get_digest_name(hash_alg));
+}
+
+/*--------------------------
+  gen_sig_data_raw
+---------------------------*/
+int32_t
+gen_sig_data_raw(const char *in_file,
+                 const char *key_file,
+                 hash_alg_t hash_alg,
+                 uint8_t *sig_buf,
+                 int32_t *sig_buf_bytes)
+{
+    EVP_PKEY *key = NULL; /**< Ptr to read key data */
+    RSA *rsa = NULL; /**< Ptr to rsa of key data */
+    uint8_t *rsa_in = NULL; /**< Mem ptr for hash data of in_file */
+    uint8_t *rsa_out = NULL; /**< Mem ptr for encrypted data */
+    int32_t rsa_inbytes; /**< Holds the length of rsa_in buf */
+    int32_t rsa_outbytes = 0; /**< Holds the length of rsa_out buf */
+    int32_t key_bytes; /**< Size of key data */
+    int32_t hash_nid; /**< hash id needed for RSA_sign() */
+    /** Array to hold error string */
+    char err_str[MAX_ERR_STR_BYTES];
+    /**< Holds the return error value */
+    int32_t err_value = CAL_CRYPTO_API_ERROR;
+
+    do
+    {
+        /* Read key */
+        key = read_private_key(key_file,
+                           (pem_password_cb *)get_passcode_to_key_file,
+                           key_file);
+        if (!key) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Cannot open key file %s", key_file);
+            display_error(err_str);
+            break;
+        }
+
+        rsa = EVP_PKEY_get1_RSA(key);
+        EVP_PKEY_free(key);
+
+        if (!rsa) {
+            display_error("Unable to extract RSA key for RAW PKCS#1 signature");
+            break;
+        }
+
+        rsa_inbytes = HASH_BYTES_MAX;
+        rsa_in = OPENSSL_malloc(HASH_BYTES_MAX);
+        key_bytes = RSA_size(rsa);
+        rsa_out = OPENSSL_malloc(key_bytes);
+
+        /* Generate hash data of data from in_file */
+        err_value = calculate_hash(in_file, hash_alg, rsa_in, &rsa_inbytes);
+        if (err_value != CAL_SUCCESS) {
+            break;
+        }
+
+        /* Compute signature.  Note: RSA_sign() adds the appropriate DER
+         * encoded prefix internally.
+         */
+        hash_nid = get_NID(hash_alg);
+        if (!RSA_sign(hash_nid, rsa_in,
+                      rsa_inbytes, rsa_out,
+                      (unsigned int *)&rsa_outbytes, rsa)) {
+            err_value = CAL_CRYPTO_API_ERROR;
+            display_error("Unable to generate signature");
+            break;
+        }
+        else {
+            err_value = CAL_SUCCESS;
+        }
+
+        /* Copy signature to sig_buf and update sig_buf_bytes */
+        *sig_buf_bytes = rsa_outbytes;
+        memcpy(sig_buf, rsa_out, rsa_outbytes);
+    } while(0);
+
+    if (err_value != CAL_SUCCESS) {
+        ERR_print_errors_fp(stderr);
+    }
+
+    if (rsa) RSA_free(rsa);
+    if (rsa_in) OPENSSL_free(rsa_in);
+    if (rsa_out) OPENSSL_free(rsa_out);
+    return err_value;
+}
+
+/*--------------------------
+  cms_to_buf
+---------------------------*/
+int32_t cms_to_buf(CMS_ContentInfo *cms, BIO * bio_in, uint8_t * data_buffer,
+                            size_t * data_buffer_size, int32_t flags)
+{
+    int32_t err_value = CAL_SUCCESS;
+    BIO * bio_out = NULL;
+    BUF_MEM buffer_memory;            /**< Used with BIO functions */
+
+    buffer_memory.length = 0;
+    buffer_memory.data = (char*)data_buffer;
+    buffer_memory.max = *data_buffer_size;
+
+    do {
+        if (!(bio_out = BIO_new(BIO_s_mem()))) {
+            display_error("Unable to allocate CMS signature result memory");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        BIO_set_mem_buf(bio_out, &buffer_memory, BIO_NOCLOSE);
+
+        /* Convert cms to der format */
+        if (!i2d_CMS_bio_stream(bio_out, cms, bio_in, flags)) {
+            display_error("Unable to convert CMS signature to DER format");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Get the size of bio out in data_buffer_size */
+        *data_buffer_size = BIO_ctrl_pending(bio_out);
+    }while(0);
+
+    if (bio_out)
+        BIO_free(bio_out);
+    return err_value;
+}
+
+/*--------------------------
+  gen_sig_data_cms
+---------------------------*/
+int32_t
+gen_sig_data_cms(const char *in_file,
+                 const char *cert_file,
+                 const char *key_file,
+                 hash_alg_t hash_alg,
+                 uint8_t *sig_buf,
+                 size_t *sig_buf_bytes)
+{
+    BIO             *bio_in = NULL;   /**< BIO for in_file data */
+    X509            *cert = NULL;     /**< Ptr to X509 certificate read data */
+    EVP_PKEY        *key = NULL;      /**< Ptr to key read data */
+    CMS_ContentInfo *cms = NULL;      /**< Ptr used with openssl API */
+    const EVP_MD    *sign_md = NULL;  /**< Ptr to digest name */
+    int32_t err_value = CAL_SUCCESS;  /**< Used for return value */
+    /** Array to hold error string */
+    char err_str[MAX_ERR_STR_BYTES];
+    /* flags set to match Openssl command line options for generating
+     *  signatures
+     */
+    int32_t         flags = CMS_DETACHED | CMS_NOCERTS |
+                            CMS_NOSMIMECAP | CMS_BINARY;
+
+    /* Set signature message digest alg */
+    sign_md = EVP_get_digestbyname(get_digest_name(hash_alg));
+    if (sign_md == NULL) {
+        display_error("Invalid hash digest algorithm");
+        return CAL_INVALID_ARGUMENT;
+    }
+
+    do
+    {
+        cert = read_certificate(cert_file);
+        if (!cert) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Cannot open certificate file %s", cert_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Read key */
+        key = read_private_key(key_file,
+                           (pem_password_cb *)get_passcode_to_key_file,
+                           key_file);
+        if (!key) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Cannot open key file %s", key_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Read Data to be signed */
+        if (!(bio_in = BIO_new_file(in_file, "rb"))) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Cannot open data file %s", in_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Generate CMS Signature - can only use CMS_sign if default
+         * MD is used which is SHA1 */
+        flags |= CMS_PARTIAL;
+
+        cms = CMS_sign(NULL, NULL, NULL, bio_in, flags);
+        if (!cms) {
+            display_error("Failed to initialize CMS signature");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        if (!CMS_add1_signer(cms, cert, key, sign_md, flags)) {
+            display_error("Failed to generate CMS signature");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Finalize the signature */
+        if (!CMS_final(cms, bio_in, NULL, flags)) {
+            display_error("Failed to finalize CMS signature");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Write CMS signature to output buffer - DER format */
+        err_value = cms_to_buf(cms, bio_in, sig_buf, sig_buf_bytes, flags);
+    } while(0);
+
+    /* Print any Openssl errors */
+    if (err_value != CAL_SUCCESS) {
+        ERR_print_errors_fp(stderr);
+    }
+
+    /* Close everything down */
+    if (cms)      CMS_ContentInfo_free(cms);
+    if (cert)     X509_free(cert);
+    if (key)      EVP_PKEY_free(key);
+    if (bio_in)   BIO_free(bio_in);
+
+    return err_value;
+}
+
+/*--------------------------
+  gen_sig_data_ecdsa
+---------------------------*/
+int32_t
+gen_sig_data_ecdsa(const char *in_file,
+                   const char *key_file,
+                   hash_alg_t hash_alg,
+                   uint8_t    *sig_buf,
+                   size_t     *sig_buf_bytes)
+{
+    BIO          *bio_in    = NULL;          /**< BIO for in_file data    */
+    EVP_PKEY     *key       = NULL;          /**< Private key data        */
+    uint32_t     key_size   = 0;             /**< n of bytes of key param */
+    const EVP_MD *sign_md   = NULL;          /**< Digest name             */
+    uint8_t      *hash      = NULL;          /**< Hash data of in_file    */
+    int32_t      hash_bytes = 0;             /**< Length of hash buffer   */
+    uint8_t      *sign      = NULL;          /**< Signature data in DER   */
+    uint32_t     sign_bytes = 0;             /**< Length of DER signature */
+    uint8_t      *r = NULL, *s = NULL;       /**< Raw signature data R&S  */
+    size_t       bn_bytes = 0;               /**< Length of R,S big num   */
+    ECDSA_SIG    *sign_dec  = NULL;          /**< Raw signature data R|S  */
+    int32_t      err_value  = CAL_SUCCESS;   /**< Return value            */
+    char         err_str[MAX_ERR_STR_BYTES]; /**< Error string            */
+    const BIGNUM *sig_r, *sig_s;             /**< signature numbers defined as OpenSSL BIGNUM */
+
+    /* Set signature message digest alg */
+    sign_md = EVP_get_digestbyname(get_digest_name(hash_alg));
+    if (sign_md == NULL) {
+        display_error("Invalid hash digest algorithm");
+        return CAL_INVALID_ARGUMENT;
+    }
+
+    do
+    {
+        /* Read key */
+        key = read_private_key(key_file,
+                               (pem_password_cb *)get_passcode_to_key_file,
+                               key_file);
+        if (!key) {
+            snprintf(err_str, MAX_ERR_STR_BYTES,
+                     "Cannot open key file %s", key_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Read Data to be signed */
+        if (!(bio_in = BIO_new_file(in_file, "rb"))) {
+            snprintf(err_str, MAX_ERR_STR_BYTES,
+                     "Cannot open data file %s", in_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Generate hash of data from in_file */
+        hash_bytes = HASH_BYTES_MAX;
+        hash = OPENSSL_malloc(HASH_BYTES_MAX);
+
+        err_value = calculate_hash(in_file, hash_alg, hash, &hash_bytes);
+        if (err_value != CAL_SUCCESS) {
+            break;
+        }
+
+        /* Generate ECDSA signature with DER encoding */
+        sign_bytes = ECDSA_size(EVP_PKEY_get0_EC_KEY(key));
+        sign = OPENSSL_malloc(sign_bytes);
+
+        if (0 == ECDSA_sign(0 /* ignored */, hash, hash_bytes, sign, &sign_bytes, EVP_PKEY_get0_EC_KEY(key))) {
+            display_error("Failed to generate ECDSA signature");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        sign_dec = d2i_ECDSA_SIG(NULL, (const uint8_t **) &sign, sign_bytes);
+        if (NULL == sign_dec) {
+            display_error("Failed to decode ECDSA signature");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Copy R|S to sig_buf */
+        memset(sig_buf, 0, *sig_buf_bytes);
+
+        key_size = EVP_PKEY_bits(key) >> 3;
+        if (EVP_PKEY_bits(key) & 0x7) key_size += 1; /* Valid for P-521 */
+
+        if ((key_size * 2) > *sig_buf_bytes){
+            display_error("Signature buffer too small");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        *sig_buf_bytes = key_size * 2;
+
+        ECDSA_SIG_get0(sign_dec, &sig_r, &sig_s);
+
+        r = get_bn(sig_r, &bn_bytes);
+        memcpy(sig_buf + (key_size - bn_bytes),
+               r,
+               bn_bytes);
+        free(r);
+
+        s = get_bn(sig_s, &bn_bytes);
+        memcpy(sig_buf + key_size + (key_size - bn_bytes),
+               s,
+               bn_bytes);
+        free(s);
+    } while(0);
+
+    /* Print any Openssl errors */
+    if (err_value != CAL_SUCCESS) {
+        ERR_print_errors_fp(stderr);
+    }
+
+    /* Close everything down */
+    if (key)    EVP_PKEY_free(key);
+    if (bio_in) BIO_free(bio_in);
+
+    return err_value;
+}
+
+/*--------------------------
+  error
+---------------------------*/
+void
+display_error(const char *err)
+{
+    fprintf(stderr, "Error: %s
", err);
+}
+
+/*--------------------------
+  export_signature_request
+---------------------------*/
+int32_t export_signature_request(const char *in_file,
+                                 const char *cert_file)
+{
+    #define WRITE_LINE()                                              \
+        if (strlen(line) != fwrite(line, 1, strlen(line), sig_req)) { \
+            snprintf(err_str, MAX_ERR_STR_BYTES,                      \
+                     "Unable to write to file %s", SIG_REQ_FILENAME); \
+            display_error(err_str);                                   \
+            return CAL_CRYPTO_API_ERROR;                              \
+        }
+
+    char err_str[MAX_ERR_STR_BYTES]; /**< Used in preparing error message  */
+    FILE *sig_req = NULL;            /**< Output signing request           */
+    char line[MAX_LINE_CHARS];       /**< Used in preparing output message */
+
+    sig_req = fopen(SIG_REQ_FILENAME, "a");
+    if (NULL ==  sig_req) {
+        snprintf(err_str, MAX_ERR_STR_BYTES,
+                 "Unable to create file %s", SIG_REQ_FILENAME);
+        display_error(err_str);
+        return CAL_CRYPTO_API_ERROR;
+    }
+
+    snprintf(line, MAX_LINE_CHARS,
+             "[Signing request]
");
+    WRITE_LINE();
+    snprintf(line, MAX_LINE_CHARS,
+             "Signing certificate = %s
", cert_file);
+    WRITE_LINE();
+    snprintf(line, MAX_LINE_CHARS,
+             "Data to be signed   = %s

", in_file);
+    WRITE_LINE();
+
+    fclose(sig_req);
+
+    return CAL_SUCCESS;
+}
+
+/*===========================================================================
+                              GLOBAL FUNCTIONS
+=============================================================================*/
+
+/*--------------------------
+  gen_sig_data
+---------------------------*/
+int32_t gen_sig_data(const char* in_file,
+                     const char* cert_file,
+                     hash_alg_t hash_alg,
+                     sig_fmt_t sig_fmt,
+                     uint8_t* sig_buf,
+                     size_t *sig_buf_bytes,
+                     func_mode_t mode)
+{
+    int32_t err = CAL_SUCCESS; /**< Used for return value */
+    char *key_file;            /**< Mem ptr for key filename */
+
+    /* Check for valid arguments */
+    if ((!in_file) || (!cert_file) || (!sig_buf) || (!sig_buf_bytes)) {
+        return CAL_INVALID_ARGUMENT;
+    }
+
+    if (MODE_HSM == mode)
+    {
+        return export_signature_request(in_file, cert_file);
+    }
+
+    /* Determine private key filename from given certificate filename */
+    key_file = malloc(strlen(cert_file)+1);
+
+    err = get_key_file(cert_file, key_file);
+    if ( err != CAL_SUCCESS) {
+        free(key_file);
+        return CAL_FILE_NOT_FOUND;
+    }
+
+    if (SIG_FMT_PKCS1 == sig_fmt) {
+        err = gen_sig_data_raw(in_file, key_file,
+                               hash_alg, sig_buf, (int32_t *)sig_buf_bytes);
+    }
+    else if (SIG_FMT_CMS == sig_fmt) {
+        err = gen_sig_data_cms(in_file, cert_file, key_file,
+                               hash_alg, sig_buf, sig_buf_bytes);
+    }
+    else if (SIG_FMT_ECDSA == sig_fmt) {
+        err = gen_sig_data_ecdsa(in_file, key_file,
+                                 hash_alg, sig_buf, sig_buf_bytes);
+    }
+    else {
+        free(key_file);
+        display_error("Invalid signature format");
+        return CAL_INVALID_ARGUMENT;
+    }
+
+    free(key_file);
+    return err;
+}
+
+/*--------------------------
+  generate_dek_key
+---------------------------*/
+int32_t generate_dek_key(uint8_t * key, int32_t len)
+{
+    if (gen_random_bytes(key, len) != CAL_SUCCESS) {
+        return CAL_CRYPTO_API_ERROR;
+    }
+
+    return CAL_SUCCESS;
+}
+
+/*--------------------------
+  write_plaintext_dek_key
+---------------------------*/
+int32_t write_plaintext_dek_key(uint8_t * key, size_t key_bytes,
+                const char * cert_file, const char * enc_file)
+{
+    int32_t err_value = CAL_SUCCESS;  /**< Return value */
+    char err_str[MAX_ERR_STR_BYTES];  /**< Used in preparing error message */
+    FILE *fh = NULL;                  /**< File handle used with file api */
+#ifdef DEBUG
+    int32_t i = 0;                    /**< Used in for loops */
+#endif
+
+    UNUSED(cert_file);
+
+    do {
+        /* Save the buffer into enc_file */
+        if ((fh = fopen(enc_file, "wb")) == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Unable to create binary file %s", enc_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        if (fwrite(key, 1, key_bytes, fh) !=
+            key_bytes) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Unable to write to binary file %s", enc_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        fclose (fh);
+   } while(0);
+
+    return err_value;
+}
+
+
+/*--------------------------
+  encrypt_dek_key
+---------------------------*/
+int32_t encrypt_dek_key(uint8_t * key, size_t key_bytes,
+                const char * cert_file, const char * enc_file)
+{
+    X509            *cert = NULL;     /**< Ptr to X509 certificate read data */
+    STACK_OF(X509) *recips = NULL;    /**< Ptr to X509 stack */
+    CMS_ContentInfo *cms = NULL;      /**< Ptr to cms structure */
+    const EVP_CIPHER *cipher = NULL;  /**< Ptr to EVP_CIPHER */
+    int32_t err_value = CAL_SUCCESS;  /**< Return value */
+    char err_str[MAX_ERR_STR_BYTES];  /**< Used in preparing error message */
+    BIO *bio_key = NULL;              /**< Bio for the key data to encrypt */
+    uint8_t * enc_buf = NULL;         /**< Ptr for encoded key data */
+    FILE *fh = NULL;                  /**< File handle used with file api */
+    size_t cms_info_size = MAX_CMS_DATA; /**< Size of cms content info*/
+#ifdef DEBUG
+    int32_t i = 0;                    /**< Used in for loops */
+#endif
+
+    do {
+        /* Read the certificate from cert_file */
+        cert = read_certificate(cert_file);
+        if (!cert) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Cannot open certificate file %s", cert_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Create recipient STACK and add recipient cert to it */
+        recips = sk_X509_new_null();
+
+        if (!recips || !sk_X509_push(recips, cert)) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Cannot instantiate object STACK_OF(%s)", cert_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /*
+         * sk_X509_pop_free will free up recipient STACK and its contents
+         * so set cert to NULL so it isn't freed up twice.
+         */
+        cert = NULL;
+
+        /* Instantiate correct cipher */
+        if (key_bytes == (AES_KEY_LEN_128 / BYTE_SIZE_BITS))
+            cipher = EVP_aes_128_cbc();
+        else if (key_bytes == (AES_KEY_LEN_192 / BYTE_SIZE_BITS))
+            cipher = EVP_aes_192_cbc();
+        else if (key_bytes == (AES_KEY_LEN_256 / BYTE_SIZE_BITS))
+            cipher = EVP_aes_256_cbc();
+        if (cipher == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Invalid cipher used for encrypting key %s", enc_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Allocate memory buffer BIO for input key */
+        bio_key = BIO_new_mem_buf(key, key_bytes);
+        if (!bio_key) {
+            display_error("Unable to allocate BIO memory");
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Encrypt content of the key with certificate */
+        cms = CMS_encrypt(recips, bio_key, cipher, CMS_BINARY|CMS_STREAM);
+        if (cms == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Failed to encrypt key data");
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Finalize the CMS content info structure */
+        if (!CMS_final(cms, bio_key, NULL,  CMS_BINARY|CMS_STREAM)) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Failed to finalize cms data");
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Alloc mem to convert cms to binary and save it into enc_file */
+        enc_buf = malloc(MAX_CMS_DATA);
+        if (enc_buf == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Failed to allocate memory");
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+
+        /* Copy cms info into enc_buf */
+        err_value = cms_to_buf(cms, bio_key, enc_buf, &cms_info_size,
+            CMS_BINARY);
+
+        /* Save the buffer into enc_file */
+        if ((fh = fopen(enc_file, "wb")) == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Unable to create binary file %s", enc_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        if (fwrite(enc_buf, 1, cms_info_size, fh) !=
+            cms_info_size) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Unable to write to binary file %s", enc_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        fclose (fh);
+#ifdef DEBUG
+        printf("Encoded key ;");
+        for(i=0; i<key_bytes; i++) {
+            printf("%02x ", enc_buf[i]);
+        }
+        printf("
");
+#endif
+    } while(0);
+
+    if (cms)
+        CMS_ContentInfo_free(cms);
+    if (cert)
+        X509_free(cert);
+    if (recips)
+        sk_X509_pop_free(recips, X509_free);
+    if (bio_key)
+        BIO_free(bio_key);
+    return err_value;
+}
+
+/*--------------------------
+  gen_auth_encrypted_data
+---------------------------*/
+int32_t gen_auth_encrypted_data(const char* in_file,
+                     const char* out_file,
+                     aead_alg_t aead_alg,
+                     uint8_t *aad,
+                     size_t aad_bytes,
+                     uint8_t *nonce,
+                     size_t nonce_bytes,
+                     uint8_t *mac,
+                     size_t mac_bytes,
+                     size_t key_bytes,
+                     const char* cert_file,
+                     const char* key_file,
+                     int reuse_dek)
+{
+    int32_t err_value = CAL_SUCCESS;         /**< status of function calls */
+    char err_str[MAX_ERR_STR_BYTES];         /**< Array to hold error string */
+    uint8_t key[MAX_AES_KEY_LENGTH];         /**< Buffer for random key */
+    FILE *fh = NULL;                         /**< Used with files */
+    size_t file_size;                        /**< Size of in_file */
+    unsigned char *plaintext = NULL;                /**< Array to read file data */
+    int32_t bytes_read;
+#ifdef DEBUG
+    int32_t i;                                        /**< used in for loops */
+#endif
+
+    UNUSED(aead_alg);
+
+    do {
+        /* Generate Nonce */
+        err_value = gen_random_bytes((uint8_t*)nonce, nonce_bytes);
+        if (err_value != CAL_SUCCESS) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                         "Failed to get nonce");
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+#ifdef DEBUG
+        printf("nonce bytes: ");
+        for(i=0; i<nonce_bytes; i++) {
+            printf("%02x ", nonce[i]);
+        }
+        printf("
");
+#endif
+        if (reuse_dek) {
+            fh = fopen(key_file, "rb");
+            if (fh == NULL) {
+                snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                    "Unable to open dek file %s", key_file);
+                display_error(err_str);
+                err_value = CAL_FILE_NOT_FOUND;
+                break;
+            }
+            /* Read encrypted data into input_buffer */
+            bytes_read = fread(key, 1, key_bytes, fh);
+            if (bytes_read == 0) {
+                snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                    "Cannot read file %s", key_file);
+                display_error(err_str);
+                err_value = CAL_FILE_NOT_FOUND;
+                fclose(fh);
+                break;
+            }
+            fclose(fh);
+        }
+        else {
+            /* Generate random aes key to use it for encrypting data */
+            err_value = generate_dek_key(key, key_bytes);
+            if (err_value) {
+                snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                             "Failed to generate random key");
+                display_error(err_str);
+                err_value = CAL_CRYPTO_API_ERROR;
+                break;
+            }
+        }
+
+#ifdef DEBUG
+        printf("random key : ");
+        for (i=0; i<key_bytes; i++) {
+            printf("%02x ", key[i]);
+        }
+        printf("
");
+#endif
+        if (cert_file!=NULL) {
+            /* Encrypt key using cert file and save it in the key_file */
+            err_value = encrypt_dek_key(key, key_bytes, cert_file, key_file);
+            if (err_value) {
+                snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                         "Failed to encrypt and save key");
+                display_error(err_str);
+                err_value = CAL_CRYPTO_API_ERROR;
+                break;
+            }
+        } else {
+            /* Save key in the key_file */
+            err_value = write_plaintext_dek_key(key, key_bytes, cert_file, key_file);
+            if (err_value) {
+                snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                         "Failed to save key");
+                display_error(err_str);
+                err_value = CAL_CRYPTO_API_ERROR;
+                break;
+            }
+        }
+        /* Get the size of in_file */
+        fh = fopen(in_file, "rb");
+        if (fh == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                     "Unable to open binary file %s", in_file);
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        fseek(fh, 0, SEEK_END);
+        file_size = ftell(fh);
+        plaintext = (unsigned char*)malloc(file_size);;
+        if (plaintext == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                         "Not enough allocated memory" );
+            display_error(err_str);
+            err_value = CAL_CRYPTO_API_ERROR;
+            break;
+        }
+        fclose(fh);
+
+        fh = fopen(in_file, "rb");
+        if (fh == NULL) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                         "Cannot open file %s", in_file);
+            display_error(err_str);
+            err_value = CAL_FILE_NOT_FOUND;
+            break;
+        }
+
+        /* Read encrypted data into input_buffer */
+        bytes_read = fread(plaintext, 1, file_size, fh);
+        /* Reached EOF? */
+        if (bytes_read == 0) {
+            snprintf(err_str, MAX_ERR_STR_BYTES-1,
+                         "Cannot read file %s", out_file);
+            display_error(err_str);
+            err_value = CAL_FILE_NOT_FOUND;
+           break;
+        }
+
+        err_value = encryptccm(plaintext, file_size, aad, aad_bytes,
+                               key, key_bytes, nonce, nonce_bytes, out_file,
+                               mac, mac_bytes, &err_value, err_str);
+        if (err_value == CAL_NO_CRYPTO_API_ERROR) {
+            printf("Encryption not enabled
");
+            break;
+        }
+    } while(0);
+
+    free(plaintext);
+
+    /* Clean up */
+    return err_value;
+}
diff --git a/release/code/back_end/src/openssl_helper.c b/release/code/back_end/src/openssl_helper.c
new file mode 100644
index 0000000..3a54ac7
--- /dev/null
+++ b/release/code/back_end/src/openssl_helper.c
@@ -0,0 +1,891 @@
+/*===========================================================================*/
+/**
+    @file    openssl_helper.c
+
+    @brief   Provide helper functions to ease openssl tasks. Mainly to
+                provide common code for several tools.
+
+@verbatim
+=============================================================================
+
+              NXP Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011, 2012. All rights reserved.
+        Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+NXP that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from NXP.
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                                INCLUDE FILES
+=============================================================================*/
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <strings.h>
+#include <openssl/bio.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/pem.h>
+#include <openssl/err.h>
+#include "openssl_helper.h"
+#include "version.h"
+#include <openssl/rand.h>
+#include <openssl/rsa.h>
+
+/*===========================================================================
+                               LOCAL CONSTANTS
+=============================================================================*/
+
+/*===========================================================================
+                                 LOCAL MACROS
+=============================================================================*/
+
+/*===========================================================================
+                  LOCAL TYPEDEFS (STRUCTURES, UNIONS, ENUMS)
+=============================================================================*/
+
+/*===========================================================================
+                               OPENSSL 1.0.2 SUPPORT
+=============================================================================*/
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+
+static void *
+OPENSSL_zalloc(size_t num)
+{
+    void *ret = OPENSSL_malloc(num);
+
+    if (ret != NULL) {
+        memset(ret, 0, num);
+    }
+    return ret;
+}
+
+void
+ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps)
+{
+    if (pr != NULL) {
+        *pr = sig->r;
+    }
+    if (ps != NULL) {
+        *ps = sig->s;
+    }
+}
+
+int
+ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s)
+{
+    if (r == NULL || s == NULL) {
+        return 0;
+    }
+    BN_clear_free(sig->r);
+    BN_clear_free(sig->s);
+    sig->r = r;
+    sig->s = s;
+    return 1;
+}
+
+void
+EVP_MD_CTX_free(EVP_MD_CTX *ctx)
+{
+    EVP_MD_CTX_cleanup(ctx);
+    OPENSSL_free(ctx);
+}
+
+EVP_MD_CTX *
+EVP_MD_CTX_new(void)
+{
+    return OPENSSL_zalloc(sizeof(EVP_MD_CTX));
+}
+
+EC_KEY *
+EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey)
+{
+    return (pkey->pkey.ec);
+}
+
+RSA *
+EVP_PKEY_get0_RSA(EVP_PKEY *pkey)
+{
+    if (pkey->type != EVP_PKEY_RSA) {
+        return NULL;
+    }
+    return pkey->pkey.rsa;
+}
+
+void
+RSA_get0_key(const RSA *r, const BIGNUM **n, const BIGNUM **e, const BIGNUM **d)
+{
+    if (n != NULL) {
+        *n = r->n;
+    }
+    if (e != NULL) {
+        *e = r->e;
+    }
+    if (d != NULL) {
+       *d = r->d;
+    }
+}
+
+#endif
+
+/*===========================================================================
+                          LOCAL FUNCTION PROTOTYPES
+=============================================================================*/
+
+/*===========================================================================
+                               LOCAL FUNCTIONS
+=============================================================================*/
+
+/*===========================================================================
+                               GLOBAL FUNCTIONS
+=============================================================================*/
+
+/*--------------------------
+  openssl_initialize
+---------------------------*/
+
+void
+openssl_initialize(void)
+{
+#if defined _WIN32 || defined __CYGWIN__
+    /* Required to avoid OpenSSL runtime errors on Win32 platforms */
+    /* See: https://www.openssl.org/docs/faq.html#PROG3 */
+    OPENSSL_malloc_init();
+#endif
+
+#if (OPENSSL_VERSION_NUMBER < 0x10100000L)
+    ERR_load_crypto_strings();
+    OpenSSL_add_all_algorithms();
+#endif
+}
+
+
+/*--------------------------
+  generate_hash
+---------------------------*/
+
+uint8_t *
+generate_hash(const uint8_t *buf, size_t msg_bytes, const char *hash_alg,
+              size_t *hash_bytes)
+{
+    const EVP_MD *type;                /**< Mesage digest type*/
+    EVP_MD_CTX   *ctx = EVP_MD_CTX_new(); /**< Message digest context */
+    uint8_t      *hash_mem_ptr = NULL; /**< location of result buffer */
+    unsigned int  tmp;
+
+    if (!(type = EVP_get_digestbyname(hash_alg)))
+    {
+        return NULL;
+    }
+
+    if (!(hash_mem_ptr = (uint8_t *)malloc(EVP_MAX_MD_SIZE)))
+    {
+        return NULL;
+    }
+
+
+    EVP_DigestInit(ctx, type);
+    EVP_DigestUpdate(ctx, buf, msg_bytes);
+    EVP_DigestFinal(ctx, hash_mem_ptr, &tmp);
+
+    *hash_bytes = tmp;
+
+    return hash_mem_ptr;
+}
+
+/*--------------------------
+  get_bn
+---------------------------*/
+
+uint8_t*
+get_bn(const BIGNUM *a, size_t *bytes)
+{
+    uint8_t *byte_array = NULL; /**< Resulting big number byte array */
+    uint32_t a_num_bytes = BN_num_bytes(a);
+
+    byte_array = malloc(a_num_bytes);
+    if (byte_array == NULL)
+    {
+        return NULL;
+    }
+
+    BN_bn2bin(a, byte_array);
+
+    *bytes = a_num_bytes;
+    return byte_array;
+}
+
+
+/*--------------------------
+  unix_time
+---------------------------*/
+
+uint32_t
+unix_time(const char* x509_time)
+{
+    uint32_t year = 0;       /**< year */
+    uint32_t month = 0;      /**< month */
+    uint32_t day = 0;        /**< day */
+    uint32_t hour = 0;       /**< hour */
+    uint32_t minute = 0;     /**< minute */
+    uint32_t second = 0;     /**< second */
+    uint32_t unix_time = 0;  /**< resulting unix time */
+    char     temp[5];        /**< temp array for char conversion */
+    uint32_t idx = 0;        /**< index into X509_time string */
+
+    if (x509_time)
+    {
+        /* String from X.509 certificate must have one of the following
+         * formats: YYMMDDHHMMSSZ or YYYYMMDDHHMMSSZ
+         */
+        if (strlen(x509_time) == X509_UTCTIME_STRING_BYTES)
+        {
+            temp[0] = x509_time[idx++];
+            temp[1] = x509_time[idx++];
+            temp[2] = ' ';
+            temp[3] = ' ';
+            year = atoi(temp);
+            if (year < 50)
+            {
+                year = year + 2000;
+            }
+            else
+            {
+                year = year + 1900;
+            }
+        }
+        else if (strlen(x509_time) == X509_GENTIME_STRING_BYTES)
+        {
+            temp[0] = x509_time[idx++];
+            temp[1] = x509_time[idx++];
+            temp[2] = x509_time[idx++];
+            temp[3] = x509_time[idx++];
+            temp[4] = ' ';
+            year = atoi(temp);
+        }
+        /* Invalid time string length */
+        else
+        {
+            return unix_time;
+        }
+
+        temp[0] = x509_time[idx++];
+        temp[1] = x509_time[idx++];
+        temp[2] = 0;
+        temp[3] = 0;
+        month = atoi(temp);
+
+        temp[0] = x509_time[idx++];
+        temp[1] = x509_time[idx++];
+        day = atoi(temp);
+
+        temp[0] = x509_time[idx++];
+        temp[1] = x509_time[idx++];
+        hour = atoi(temp);
+
+        temp[0] = x509_time[idx++];
+        temp[1] = x509_time[idx++];
+        minute = atoi(temp);
+
+        temp[0] = x509_time[idx++];
+        temp[1] = x509_time[idx++];
+        second = atoi(temp);
+
+        /* Convert to unix time */
+        year -= month < 3;
+        month += month < 3 ? 10 : -2;
+        unix_time = year/400 - year/100 + year/4
+            + year*365 + month*367/12 + day
+            - 719499;
+        unix_time = unix_time * 86400
+            + hour * 3600
+            + minute * 60
+            + second;
+    }
+
+    return unix_time;
+}
+
+/*--------------------------
+  sign_data
+---------------------------*/
+
+uint8_t*
+sign_data(const EVP_PKEY *skey, const BUF_MEM *bptr, hash_alg_t hash_alg,
+          size_t *sig_bytes)
+{
+    EVP_MD_CTX   *ctx = EVP_MD_CTX_create(); /**< Signature context */
+    uint8_t      *sig_buf = NULL;            /**< Location of sig. array */
+    const EVP_MD *hash_type = NULL;          /**< Hash digest algorithm type */
+    unsigned int  tmp_sig_bytes;
+#ifdef DEBUG
+    uint32_t i;                              /**< Loop index */
+#endif
+
+    if (ctx)
+    {
+        tmp_sig_bytes = EVP_PKEY_size((EVP_PKEY *)skey);
+        sig_buf = malloc(tmp_sig_bytes);
+
+        /* Determine OpenSSL hash digest type */
+        if (hash_alg == SHA_1)
+        {
+            hash_type = EVP_sha1();
+        }
+        else if (hash_alg == SHA_256)
+        {
+            hash_type = EVP_sha256();
+        }
+        else
+        {
+            EVP_MD_CTX_destroy(ctx);
+            return NULL;
+        }
+
+        if ((sig_buf != NULL) &&
+            ( (EVP_SignInit_ex(ctx, hash_type, NULL) != CST_SUCCESS) ||
+              (EVP_SignUpdate(ctx, bptr->data, bptr->length) != CST_SUCCESS) ||
+              (EVP_SignFinal(ctx, sig_buf, &tmp_sig_bytes, (EVP_PKEY *)skey)
+               != CST_SUCCESS) ))
+        {
+            *sig_bytes = tmp_sig_bytes;
+            EVP_MD_CTX_destroy(ctx);
+            return NULL;
+        }
+
+        *sig_bytes = tmp_sig_bytes;
+
+#ifdef DEBUG
+        printf("Signature bytes = %d
", tmp_sig_bytes);
+        if (sig_buf)
+        {
+            for (i = 0; i < tmp_sig_bytes; i++)
+            {
+                printf("%d) 0x%02x
", i, sig_buf[i]);
+            }
+        }
+#endif
+
+        EVP_MD_CTX_destroy(ctx);
+    }
+    return sig_buf;
+}
+
+/*--------------------------
+  write_cert_file
+---------------------------*/
+cst_status_t
+write_cert_file(const char *filename, const BIO *data)
+{
+    BIO *wtls_file = NULL;   /**< Resulting output file */
+    BUF_MEM *bptr;           /**< OpenSSL BIO memory buffer ptr */
+
+    wtls_file = BIO_new_file(filename, "wb");
+    if (wtls_file == NULL)
+    {
+        return CST_FAILURE;;
+    }
+
+    BIO_get_mem_ptr((BIO *)data, &bptr);
+
+    if (bptr == NULL)
+    {
+        BIO_free(wtls_file);
+        return CST_FAILURE;
+    }
+
+    BIO_write(wtls_file, bptr->data, bptr->length);
+    BIO_free(wtls_file);
+    return CST_SUCCESS;
+}
+
+/*--------------------------
+  read_certificate
+---------------------------*/
+X509*
+read_certificate(const char* filename)
+{
+    BIO  *bio_cert = NULL; /**< OpenSSL BIO ptr */
+    X509 *cert = NULL;     /**< X.509 certificate data structure */
+    FILE *fp = NULL;       /**< File pointer for DER encoded file */
+    /** Points to expected location of ".pem" filename extension */
+    const char *temp = filename + strlen(filename) -
+                       PEM_FILE_EXTENSION_BYTES;
+
+    bio_cert = BIO_new(BIO_s_file());
+    if (bio_cert == NULL)
+    {
+        return NULL;
+    }
+
+    /* PEM encoded */
+    if (!strncasecmp(temp, PEM_FILE_EXTENSION, PEM_FILE_EXTENSION_BYTES))
+    {
+        if (BIO_read_filename(bio_cert, filename) <= 0)
+        {
+            BIO_free(bio_cert);
+            return NULL;
+        }
+
+        cert = PEM_read_bio_X509(bio_cert, NULL, 0, NULL);
+    }
+    /* DER encoded */
+    else
+    {
+        /* Open the DER file and load it into a X509 object */
+        fp = fopen(filename, "rb");
+        if (NULL == fp) return NULL;
+        cert = d2i_X509_fp(fp, NULL);
+        fclose(fp);
+    }
+
+    BIO_free(bio_cert);
+    return cert;
+}
+
+/*--------------------------------
+  get_der_encoded_certificate_data
+----------------------------------*/
+int32_t get_der_encoded_certificate_data(const char* filename,
+                                         uint8_t ** der)
+{
+    /** Used for returning either size of der data or 0 to indicate an error */
+    int32_t ret_val = 0;
+
+    /* Read X509 certificate data from cert file */
+    X509 *cert = read_certificate(filename);
+
+    if (cert != NULL)
+    {
+        /* i2d_X509() allocates memory for der data, converts the X509
+         * cert structure to binary der formatted data.  It then
+         * returns the address of the memory allocated for the der data
+         */
+        ret_val = i2d_X509(cert, der);
+
+        /* On error return 0 */
+        if (ret_val < 0)
+        {
+            ret_val = 0;
+        }
+        X509_free(cert);
+    }
+    return ret_val;
+}
+
+/*--------------------------
+  read_private_key
+---------------------------*/
+EVP_PKEY*
+read_private_key(const char *filename, pem_password_cb *password_cb,
+                 const char *password)
+{
+    BIO      *private_key = NULL; /**< OpenSSL BIO ptr */
+    EVP_PKEY *pkey;               /**< Private Key data structure */
+    /** Points to expected location of ".pem" filename extension */
+    const char *temp = filename + strlen(filename) -
+                       PEM_FILE_EXTENSION_BYTES;
+
+    /* Read Private key */
+    private_key = BIO_new(BIO_s_file( ));
+    if (!private_key)
+    {
+        return NULL;
+    }
+
+    /* Set BIO to read from the given filename */
+    if (BIO_read_filename(private_key, filename) <= 0)
+    {
+        BIO_free(private_key);
+        return NULL;
+    }
+
+    if (!strncasecmp(temp, PEM_FILE_EXTENSION, PEM_FILE_EXTENSION_BYTES))
+    {
+        /* Read Private key - from PEM encoded file */
+        pkey = PEM_read_bio_PrivateKey(private_key, NULL, password_cb,
+                                       (char *)password);
+        if (!pkey)
+        {
+            BIO_free(private_key);
+            return NULL;
+        }
+    }
+    else
+    {
+        pkey = d2i_PKCS8PrivateKey_bio (private_key, NULL, password_cb,
+                                        (char *)password );
+        if (!pkey)
+        {
+            BIO_free(private_key);
+            return NULL;
+        }
+    }
+    return pkey;
+}
+
+/*--------------------------
+  print_version
+---------------------------*/
+
+void print_version(void)
+{
+    printf("Code Signing Tool release version %s
",CST_VERSION);
+}
+
+/*--------------------------
+  seed_prng
+---------------------------*/
+uint32_t seed_prng(uint32_t bytes)
+{
+    return RAND_load_file("/dev/random", bytes);
+}
+
+
+/*--------------------------
+  gen_random_bytes
+---------------------------*/
+int32_t gen_random_bytes(uint8_t *buf, size_t bytes)
+{
+    if (!RAND_bytes(buf, bytes))
+    {
+        return CAL_RAND_API_ERROR;
+    }
+
+    return CAL_SUCCESS;
+}
+
+/*--------------------------
+  get_digest_name
+---------------------------*/
+char*
+get_digest_name(hash_alg_t hash_alg)
+{
+    char *hash_name = NULL;    /**< Ptr to return address of string macro */
+    switch(hash_alg) {
+        case SHA_1:
+            hash_name = HASH_ALG_SHA1;
+            break;
+        case SHA_256:
+            hash_name = HASH_ALG_SHA256;
+            break;
+        case SHA_384:
+            hash_name = HASH_ALG_SHA384;
+            break;
+        case SHA_512:
+            hash_name = HASH_ALG_SHA512;
+            break;
+        default:
+            hash_name = HASH_ALG_INVALID;
+            break;
+    }
+    return hash_name;
+}
+
+/*--------------------------
+  calculate_hash
+---------------------------*/
+int32_t
+calculate_hash(const char *in_file,
+               hash_alg_t hash_alg,
+               uint8_t *buf,
+               int32_t *pbuf_bytes)
+{
+    const EVP_MD *sign_md; /**< Ptr to digest name */
+    int32_t bio_bytes; /**< Length of bio data */
+    BIO *in = NULL; /**< Ptr to BIO for reading data from in_file */
+    BIO *bmd = NULL; /**< Ptr to BIO with hash bytes */
+    BIO *inp; /**< Ptr to BIO for appending in with bmd */
+    /** Status initialized to API error */
+    int32_t err_value =  CAL_CRYPTO_API_ERROR;
+
+    sign_md = EVP_get_digestbyname(get_digest_name(hash_alg));
+    if (sign_md == NULL) {
+        return CAL_INVALID_ARGUMENT;
+    }
+
+    /* Read data to generate hash */
+    do {
+
+        /* Create necessary bios */
+        in = BIO_new(BIO_s_file());
+        bmd = BIO_new(BIO_f_md());
+        if (in == NULL || bmd == NULL) {
+            break;
+        }
+
+        /* Set BIO to read filename in_file */
+        if (BIO_read_filename(in, in_file) <= 0) {
+            break;
+        }
+
+        /* Set BIO md to given hash */
+        if (!BIO_set_md(bmd, sign_md)) {
+            break;
+        }
+
+        /* Appends BIO in to bmd */
+        inp = BIO_push(bmd, in);
+
+        /* Read data from file BIO */
+        do
+        {
+            bio_bytes = BIO_read(inp, (uint8_t *)buf, *pbuf_bytes);
+        } while (bio_bytes > 0);
+
+        /* Check for read error */
+        if (bio_bytes < 0) {
+            break;
+        }
+
+        /* Get the hash */
+        bio_bytes = BIO_gets(inp, (char *)buf, *pbuf_bytes);
+        if (bio_bytes <= 0) {
+            break;
+        }
+
+        /* Send the output bytes in pbuf_bytes */
+        *pbuf_bytes = bio_bytes;
+        err_value =  CAL_SUCCESS;
+    } while(0);
+
+    if (in != NULL) BIO_free(in);
+    if (bmd != NULL) BIO_free(bmd);
+
+    return err_value;
+}
+
+/*--------------------------
+  ver_sig_data
+---------------------------*/
+int32_t ver_sig_data(const char *in_file,
+                     const char *cert_file,
+                     hash_alg_t hash_alg,
+                     sig_fmt_t  sig_fmt,
+                     uint8_t    *sig_buf,
+                     size_t     sig_buf_bytes)
+{
+    EVP_PKEY *pkey                = X509_get_pubkey(read_certificate(cert_file));
+    const EVP_MD   *hash_type     = EVP_get_digestbyname(get_digest_name(hash_alg));
+    int32_t        hash_bytes     = HASH_BYTES_MAX;
+    uint8_t        *hash          = OPENSSL_malloc(HASH_BYTES_MAX);
+    ECDSA_SIG      *ecdsa_sig     = NULL;
+    uint8_t        *ecdsa_der     = NULL;
+    uint32_t       ecdsa_der_size = 0;
+
+    if (NULL == in_file)       return CAL_INVALID_ARGUMENT;
+    if (NULL == pkey)          return CAL_INVALID_ARGUMENT;
+    if (NULL == hash_type)     return CAL_INVALID_ARGUMENT;
+    if (NULL == sig_buf)       return CAL_INVALID_ARGUMENT;
+    if (0    == sig_buf_bytes) return CAL_INVALID_ARGUMENT;
+    if (NULL == hash)          return CAL_CRYPTO_API_ERROR;
+
+    if (CAL_SUCCESS != calculate_hash(in_file, hash_alg, hash, &hash_bytes))
+        return CAL_CRYPTO_API_ERROR;
+
+    switch (sig_fmt)
+    {
+        case SIG_FMT_PKCS1:
+            if (1 != RSA_verify(EVP_MD_type(hash_type), hash, hash_bytes,
+                                sig_buf, sig_buf_bytes, EVP_PKEY_get0_RSA(pkey)))
+            {
+                return CAL_INVALID_SIGNATURE;
+            }
+            break;
+
+        case SIG_FMT_ECDSA:
+            ecdsa_sig = ECDSA_SIG_new();
+            if (NULL == ecdsa_sig)   return CAL_CRYPTO_API_ERROR;
+            ECDSA_SIG_set0(ecdsa_sig,
+                BN_bin2bn(sig_buf, sig_buf_bytes/2, NULL),
+                BN_bin2bn(sig_buf + sig_buf_bytes/2, sig_buf_bytes/2, NULL));
+            ecdsa_der_size = i2d_ECDSA_SIG(ecdsa_sig, &ecdsa_der);
+            if (0 == ecdsa_der_size) return CAL_CRYPTO_API_ERROR;
+            if (1 != ECDSA_verify(0 /* ignored */, hash, hash_bytes,
+                                  ecdsa_der, ecdsa_der_size, EVP_PKEY_get0_EC_KEY(pkey)))
+            {
+                return CAL_INVALID_SIGNATURE;
+            }
+            break;
+
+        default:
+            return CAL_INVALID_ARGUMENT;
+    }
+
+    return CAL_SUCCESS;
+}
+
+/*--------------------------
+  print_license
+---------------------------*/
+
+void print_license(void)
+{
+    printf("

NXP License Information:
");
+    printf("----------------------------------
");
+    printf("Copyright (c) Freescale Semiconductor, Inc. 2011, 2012. All rights reserved.
");
+    printf("Copyright 2018 NXP

");
+    printf("This software is under license from NXP
");
+    printf("By using this software you agree to the license terms provided
");
+    printf("at the time this release was downloaded from www.nxp.com
");
+    printf("
Openssl/SSLeay License Information:
");
+    printf("---------------------------------------
");
+    printf("This product includes software developed by the OpenSSL Project
");
+    printf("for use in the OpenSSL Toolkit (http://www.openssl.org/)

");
+    printf("This product includes cryptographic software written by
");
+    printf("Eric Young (eay@cryptsoft.com)
");
+    printf("This product includes cryptographic software written by
");
+    printf("Brian Gladman, Worcester, UK
");
+    printf("
The following is the full license text for OpenSSL, SSLeay
");
+    printf("and Brian Gladman:

");
+    printf("OpenSSL License
");
+    printf("---------------

");
+    printf("/* ====================================================================
");
+    printf(" * Copyright (c) 1998-2018 The OpenSSL Project.  All rights reserved.
");
+    printf(" *
");
+    printf(" * Redistribution and use in source and binary forms, with or without
");
+    printf(" * modification, are permitted provided that the following conditions
");
+    printf(" * are met:
");
+    printf(" *
");
+    printf(" * 1. Redistributions of source code must retain the above copyright
");
+    printf(" *    notice, this list of conditions and the following disclaimer.
");
+    printf(" *
");
+    printf(" * 2. Redistributions in binary form must reproduce the above copyright
");
+    printf(" *    notice, this list of conditions and the following disclaimer in
");
+    printf(" *    the documentation and/or other materials provided with the
");
+    printf(" *    distribution.
");
+    printf(" *
");
+    printf(" * 3. All advertising materials mentioning features or use of this
");
+    printf(" *    software must display the following acknowledgment:
");
+    printf(" *    \"This product includes software developed by the OpenSSL Project
");
+    printf(" *    for use in the OpenSSL Toolkit. (http://www.openssl.org/)\"
");
+    printf(" *
");
+    printf(" * 4. The names \"OpenSSL Toolkit\" and \"OpenSSL Project\" must not be used to
");
+    printf(" *    endorse or promote products derived from this software without
");
+    printf(" *    prior written permission. For written permission, please contact
");
+    printf(" *    openssl-core@openssl.org.
");
+    printf(" *
");
+    printf(" * 5. Products derived from this software may not be called \"OpenSSL\"
");
+    printf(" *    nor may \"OpenSSL\" appear in their names without prior written
");
+    printf(" *    permission of the OpenSSL Project.
");
+    printf(" *
");
+    printf(" * 6. Redistributions of any form whatsoever must retain the following
");
+    printf(" *    acknowledgment:
");
+    printf(" *    \"This product includes software developed by the OpenSSL Project
");
+    printf(" *    for use in the OpenSSL Toolkit (http://www.openssl.org/)\"
");
+    printf(" *
");
+    printf(" * THIS SOFTWARE IS PROVIDED BY THE OpenSSL PROJECT ``AS IS'' AND ANY
");
+    printf(" * EXPRESSED OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
");
+    printf(" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
");
+    printf(" * PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE OpenSSL PROJECT OR
");
+    printf(" * ITS CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
");
+    printf(" * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
");
+    printf(" * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
");
+    printf(" * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
");
+    printf(" * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
");
+    printf(" * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
");
+    printf(" * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED
");
+    printf(" * OF THE POSSIBILITY OF SUCH DAMAGE.
");
+    printf(" * ====================================================================
");
+    printf(" *
");
+    printf(" * This product includes cryptographic software written by Eric Young
");
+    printf(" * (eay@cryptsoft.com).  This product includes software written by Tim
");
+    printf(" * Hudson (tjh@cryptsoft.com).
");
+    printf(" *
");
+    printf(" */

");
+    printf("Original SSLeay License
");
+    printf("-----------------------

");
+    printf("/* Copyright (C) 1995-1998 Eric Young (eay@cryptsoft.com)
");
+    printf(" * All rights reserved.
");
+    printf(" *
");
+    printf(" * This package is an SSL implementation written
");
+    printf(" * by Eric Young (eay@cryptsoft.com).
");
+    printf(" * The implementation was written so as to conform with Netscapes SSL.
");
+    printf(" *
");
+    printf(" * This library is free for commercial and non-commercial use as long as
");
+    printf(" * the following conditions are aheared to.  The following conditions
");
+    printf(" * apply to all code found in this distribution, be it the RC4, RSA,
");
+    printf(" * lhash, DES, etc., code; not just the SSL code.  The SSL documentation
");
+    printf(" * included with this distribution is covered by the same copyright terms
");
+    printf(" * except that the holder is Tim Hudson (tjh@cryptsoft.com).
");
+    printf(" *
");
+    printf(" * Copyright remains Eric Young's, and as such any Copyright notices in
");
+    printf(" * the code are not to be removed.
");
+    printf(" * If this package is used in a product, Eric Young should be given attribution
");
+    printf(" * as the author of the parts of the library used.
");
+    printf(" * This can be in the form of a textual message at program startup or
");
+    printf(" * in documentation (online or textual) provided with the package.
");
+    printf(" *
");
+    printf(" * Redistribution and use in source and binary forms, with or without
");
+    printf(" * modification, are permitted provided that the following conditions
");
+    printf(" * are met:
");
+    printf(" * 1. Redistributions of source code must retain the copyright
");
+    printf(" *    notice, this list of conditions and the following disclaimer.
");
+    printf(" * 2. Redistributions in binary form must reproduce the above copyright
");
+    printf(" *    notice, this list of conditions and the following disclaimer in the
");
+    printf(" *    documentation and/or other materials provided with the distribution.
");
+    printf(" * 3. All advertising materials mentioning features or use of this software
");
+    printf(" *    must display the following acknowledgement:
");
+    printf(" *    \"This product includes cryptographic software written by
");
+    printf(" *     Eric Young (eay@cryptsoft.com)\"
");
+    printf(" *    The word 'cryptographic' can be left out if the rouines from the library
");
+    printf(" *    being used are not cryptographic related :-).
");
+    printf(" * 4. If you include any Windows specific code (or a derivative thereof) from
");
+    printf(" *    the apps directory (application code) you must include an acknowledgement:
");
+    printf(" *    \"This product includes software written by Tim Hudson (tjh@cryptsoft.com)\"
");
+    printf(" *
");
+    printf(" * THIS SOFTWARE IS PROVIDED BY ERIC YOUNG ``AS IS'' AND
");
+    printf(" * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
");
+    printf(" * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
");
+    printf(" * ARE DISCLAIMED.  IN NO EVENT SHALL THE AUTHOR OR CONTRIBUTORS BE LIABLE
");
+    printf(" * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
");
+    printf(" * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
");
+    printf(" * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
");
+    printf(" * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
");
+    printf(" * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
");
+    printf(" * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
");
+    printf(" * SUCH DAMAGE.
");
+    printf(" *
");
+    printf(" * The licence and distribution terms for any publically available version or
");
+    printf(" * derivative of this code cannot be changed.  i.e. this code cannot simply be
");
+    printf(" * copied and put under another distribution licence
");
+    printf(" * [including the GNU Public Licence.]
");
+    printf(" */

");
+    printf("Original Brian Gladman License
");
+    printf("------------------------------

");
+    printf("  /*
");
+    printf("  ---------------------------------------------------------------------------
");
+    printf("  Copyright (c) 1998-2008, Brian Gladman, Worcester, UK. All rights reserved.
");
+    printf(" 
");
+    printf("  LICENSE TERMS
");
+    printf(" 
");
+    printf("  The redistribution and use of this software (with or without changes)
");
+    printf("  is allowed without the payment of fees or royalties provided that:
");
+    printf(" 
");
+    printf("   1. source code distributions include the above copyright notice, this
");
+    printf("      list of conditions and the following disclaimer;
");
+    printf(" 
");
+    printf("   2. binary distributions include the above copyright notice, this list
");
+    printf("      of conditions and the following disclaimer in their documentation;
");
+    printf(" 
");
+    printf("   3. the name of the copyright holder is not used to endorse products
");
+    printf("      built using this software without specific written permission.
");
+    printf(" 
");
+    printf("  DISCLAIMER
");
+    printf(" 
");
+    printf("  This software is provided 'as is' with no explicit or implied warranties
");
+    printf("  in respect of its properties, including, but not limited to, correctness
");
+    printf("  and/or fitness for purpose.
");
+    printf("  ---------------------------------------------------------------------------
");
+    printf("  Issue Date: 20/12/2007
");
+    printf(" */

");
+}
diff --git a/release/code/back_end/src/pkey.c b/release/code/back_end/src/pkey.c
new file mode 100644
index 0000000..9ee5049
--- /dev/null
+++ b/release/code/back_end/src/pkey.c
@@ -0,0 +1,165 @@
+/*===========================================================================*/
+/**
+    @file    pkey.c
+
+    @brief   Implements private key access API. This is part of libpkey.a
+    library. The functionality of these API can be customized by linking to
+    customer version of libpkey.a owned by customer.
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011, 2012. All rights reserved.
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================
+Revision History:
+
+                 Modification Date  Tracking
+Author             (dd-mmm-yyyy)    Number      Description of Changes
+---------------    -------------   ----------  -----------------------
+Fareed Mohammed     12-Sep-2011                Initial version
+Florent Auger       28-Aug-2012    ENGR162295  Path to key file built from CSF
+
+=============================================================================
+Portability:
+
+These definitions are customised for 32 bit cores of either endianness.
+
+=============================================================================
+@endverbatim */
+
+/*===========================================================================
+                                INCLUDE FILES
+=============================================================================*/
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <openssl/bio.h>
+#include <openssl/x509.h>
+#include <openssl/x509v3.h>
+#include <openssl/cms.h>
+#include <openssl/err.h>
+#include <openssl/pem.h>
+#include <openssl_helper.h>
+#include <adapt_layer.h>
+
+/*===========================================================================
+                          LOCAL FUNCTION PROTOTYPES
+=============================================================================*/
+/** Chomp - removes newline from character string
+ *
+ * @param[in] s    input string
+ *
+ * @pre None
+ *
+ * @post s is modified removing new line characters
+ */
+static void
+chomp(char *s);
+
+/*===========================================================================
+                               LOCAL FUNCTIONS
+=============================================================================*/
+/*--------------------------
+  chomp
+---------------------------*/
+void
+chomp(char *s)
+{
+    while(*s && *s != '
' && *s != '') s++;
+    *s = 0;
+}
+
+/*--------------------------
+  get_passcode_to_key_file
+---------------------------*/
+int get_passcode_to_key_file(char *buf, int size, int rwflag, void *userdata)
+{
+    FILE * password_fp;
+    char * ptr_to_last_slash;
+    char key_file_path[255];
+    char *key_file = (char *)userdata;
+
+    UNUSED(rwflag);
+
+    /* Initialize the temporary path */
+    memset(key_file_path,0,255);
+
+    /*
+     * Get the folder where the password file is present.
+     * The file is located in the same folder than the keys used for signature.
+     * Start by searching for the last occurance of '/' in the path of
+     * a key installed by a CSF command and passed through *userdata.
+     */
+    ptr_to_last_slash = strrchr(key_file, '/');
+
+    /* Copy from beginning to ptr_to_last_slash into key_file_path */
+    if(ptr_to_last_slash != NULL)
+    {
+        strncpy(key_file_path, key_file, (ptr_to_last_slash -
+                               key_file + 1));
+    }
+
+    /* Concatenate with key_pass.txt to form the complete path */
+    strcat(key_file_path, "key_pass.txt");
+
+    /*
+     * This particular implementation assumes file key_file.txt to be present
+     * in keys folder with password string.
+     */
+    password_fp = fopen(key_file_path, "r");
+    if (password_fp == NULL)
+    {
+        /* Cannot open password file, it could be that keys are not encrypted
+         * return 0 for password size */
+        return 0;
+    }
+
+    fgets(buf, size, password_fp);
+    chomp(buf);
+
+    return strlen(buf);
+}
+
+/*--------------------------
+  get_key_file
+---------------------------*/
+int32_t get_key_file(const char* cert_file, char* key_file)
+{
+    /* Algorithm to locate key file from given cert file  */
+    /* for now just assume the key to present in the      */
+    /* same folder as cert file. The crt in the name will */
+    /* will be replaced with key */
+    char * folder;
+    int32_t i = strlen(cert_file);  /**< Index into key filename, initialized
+                                         to filename length */
+
+    strcpy(key_file, cert_file);
+    key_file[i] = 0;
+
+    key_file[i-5] = 'y';
+    key_file[i-6] = 'e';
+    key_file[i-7] = 'k';
+
+    /* Search for folder name "certs" in the file and replace it with "keys" */
+    /* Keys are found in "keys" folder and certs are in "certs" folder       */
+
+    folder = strstr(key_file, "crts");
+    if(folder)
+    {
+        folder[0] = 'k';
+        folder[1] = 'e';
+        folder[2] = 'y';
+        folder[3] = 's';
+    }
+    return CAL_SUCCESS;
+}
diff --git a/release/code/back_end/src/ssl_wrapper.c b/release/code/back_end/src/ssl_wrapper.c
new file mode 100644
index 0000000..6cd69b2
--- /dev/null
+++ b/release/code/back_end/src/ssl_wrapper.c
@@ -0,0 +1,176 @@
+/*===========================================================================*/
+/**
+    @file    ssl_wrapper.c
+
+    @brief   Implements Code Signing Tool's SSL Wrapper API for the
+             Freescale reference Code Signing Tool.  .
+
+@verbatim
+=============================================================================
+
+              Freescale Semiconductor Confidential Proprietary
+        (c) Freescale Semiconductor, Inc. 2011-2015. All rights reserved.
+        Copyright 2018 NXP
+
+Presence of a copyright notice is not an acknowledgement of
+publication. This software file listing contains information of
+Freescale Semiconductor, Inc. that is of a confidential and
+proprietary nature and any viewing or use of this file is prohibited
+without specific written permission from Freescale Semiconductor, Inc.
+
+=============================================================================*/
+#include <assert.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include "ssl_wrapper.h"
+
+/*===========================================================================
+                                 LOCAL MACROS
+=============================================================================*/
+#define MAX_ERR_STR_BYTES           120         /**< Max. error string bytes */
+
+void handle_errors(char * str,  int32_t *err_value, char *err_str) {
+    snprintf(err_str, MAX_ERR_STR_BYTES-1, "%s", str);
+    *err_value = CAL_CRYPTO_API_ERROR;
+}
+
+int32_t encryptccm(unsigned char *plaintext, int plaintext_len, unsigned char *aad,
+    int aad_len, unsigned char *key, int key_len, unsigned char *iv, int iv_len,
+    const char * out_file, unsigned char *tag, int tag_len, int32_t *err_value,
+    char *err_str) {
+
+#ifdef REMOVE_ENCRYPTION
+    UNUSED(plaintext);
+    UNUSED(plaintext_len);
+    UNUSED(aad);
+    UNUSED(aad_len);
+    UNUSED(key);
+    UNUSED(key_len);
+    UNUSED(iv);
+    UNUSED(iv_len);
+    UNUSED(out_file);
+    UNUSED(tag);
+    UNUSED(tag_len);
+    UNUSED(err_value);
+    UNUSED(err_str);
+
+    return CAL_NO_CRYPTO_API_ERROR;
+#else
+    EVP_CIPHER_CTX *ctx;
+
+    int len;
+    int ciphertext_len;
+
+    unsigned char ciphertext[plaintext_len + EVP_MAX_BLOCK_LENGTH] ;
+
+    FILE *fho = NULL;
+    int err = 0;
+    do{
+        /* Create and initialise the context */
+        if (!(ctx = EVP_CIPHER_CTX_new())) {
+            handle_errors("Failed to allocate ccm context structure",
+                          err_value, err_str);
+            break;
+        }
+
+        /* Initialise the encryption operation. */
+        switch(key_len) {
+            case 16:
+                err = EVP_EncryptInit_ex(ctx, EVP_aes_128_ccm(), NULL, NULL, NULL);
+                break;
+            case 24:
+                err = EVP_EncryptInit_ex(ctx, EVP_aes_192_ccm(), NULL, NULL, NULL);
+                break;
+            case 32:
+                err = EVP_EncryptInit_ex(ctx, EVP_aes_256_ccm(), NULL, NULL, NULL);
+                break;
+            default:
+                handle_errors("Failed to allocate ccm context structure",
+                              err_value, err_str);
+                return *err_value;
+        }
+
+        if (err != 1) {
+            handle_errors("Failed to initialize ccm context structure",
+                          err_value, err_str);
+            break;
+        }
+
+        /*
+         * Setting IV len to 7. Not strictly necessary as this is the default
+         * but shown here for the purposes of this example
+         */
+        if (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_IVLEN, iv_len, NULL)) {
+            handle_errors("Failed to initialize IV", err_value, err_str);
+            break;
+        }
+
+        /* Set tag length */
+        EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_SET_TAG, tag_len, NULL);
+
+        /* Initialise key and IV */
+        if (1 != EVP_EncryptInit_ex(ctx, NULL, NULL, key, iv)) {
+            handle_errors("Failed to intialize key", err_value, err_str);
+            break;
+        }
+
+        /* Provide the total plaintext length */
+        if (1 != EVP_EncryptUpdate(ctx, NULL, &len, NULL, plaintext_len)) {
+            handle_errors("Failed to initialize length parameter", err_value, err_str);
+            break;
+        }
+
+        /*
+         * Provide the message to be encrypted, and obtain the encrypted output.
+         * EVP_EncryptUpdate can only be called once for this
+         */
+        if (1 != EVP_EncryptUpdate(ctx, ciphertext, &len, plaintext, plaintext_len)) {
+            handle_errors("Failed to encrypt", err_value, err_str);
+            break;
+        }
+        ciphertext_len = len;
+
+        /* Open out_file for writing */
+        fho = fopen(out_file, "wb");
+        if (fho == NULL) {
+            handle_errors("Cannot open file", err_value, err_str);
+            break;
+        }
+
+        /* Write encrypted data to out file */
+        if (fwrite(ciphertext, 1, ciphertext_len, fho) != ciphertext_len) {
+            handle_errors("Cannot write file", err_value, err_str);
+            break;
+        }
+
+        /*
+         * Finalise the encryption. Normally ciphertext bytes may be written at
+         * this stage, but this does not occur in CCM mode
+         */
+        if (1 != EVP_EncryptFinal_ex(ctx, ciphertext + len, &len)) {
+            handle_errors("Failed to finalize", err_value, err_str);
+            break;
+        }
+        ciphertext_len += len;
+
+        /* Get the tag */
+        if (1 != EVP_CIPHER_CTX_ctrl(ctx, EVP_CTRL_CCM_GET_TAG, 16, tag)) {
+            handle_errors("Failed to get tag", err_value, err_str);
+            break;
+        }
+
+    } while(0);
+
+    /* Clean up */
+    EVP_CIPHER_CTX_free(ctx);
+
+    if (fho) {
+        fclose(fho);
+    }
+
+    return *err_value;
+#endif
+}
+
diff --git a/release/code/hab3/hdr/hab_super_root.h b/release/code/hab3/hdr/hab_super_root.h
new file mode 100644
index 0000000..ffe526a
--- /dev/null
+++ b/release/code/hab3/hdr/hab_super_root.h
@@ -0,0 +1,40 @@
+#ifndef HAB_SUPER_ROOT_H
+#define HAB_SUPER_ROOT_H
+/*===========================================================================
+
+     File:  hab_super_root.h
+
+     General Description:  This file contains the definition for the HAB
+                           Super Root public key.  This file is required
+                           only for HAB version 3.
+
+=============================================================================*/
+
+/*===========================================================================
+                              CONSTANTS
+=============================================================================*/
+
+#define TRUE 1
+#define HAB_MAX_EXPONENT_BYTES 4
+
+/*===========================================================================
+                    STRUCTURES AND OTHER TYPEDEFS
+=============================================================================*/
+
+/* Structure containing RSA Super Root Key data required for HAB version 3 */
+typedef struct
+{
+    /* RSA public exponent */
+    unsigned char rsa_exponent[HAB_MAX_EXPONENT_BYTES];
+    unsigned char *rsa_modulus;              /* RSA modulus pointer */
+    unsigned short int exponent_bytes;       /* Exponent size in bytes */
+    unsigned short int modulus_bytes;        /* Modulus size in bytes */
+    unsigned char init_flag;                 /* Indicates if key initialized */
+} hab_rsa_public_key;
+
+/*===========================================================================
+                     GLOBAL VARIABLE DECLARATIONS
+=============================================================================*/
+extern const hab_rsa_public_key hab_super_root_key;
+
+#endif /* HAB_SUPER_ROOT_H */
diff --git a/release/code/hab_csf_parser/Makefile b/release/code/hab_csf_parser/Makefile
new file mode 100644
index 0000000..61c363a
--- /dev/null
+++ b/release/code/hab_csf_parser/Makefile
@@ -0,0 +1,37 @@
+#==============================================================================
+#
+#    File Name:  Makefile
+#
+#    General Description: Makefile for CSF parser
+#
+#==============================================================================
+#
+#    Copyright 2018 NXP
+#
+# Presence of a copyright notice is not an acknowledgement of publication.
+# This software file listing contains information of NXP that is of a
+# confidential and proprietary nature and any viewing or use of this file is
+# prohibited without specific written permission from NXP
+#
+#==============================================================================
+
+CC = gcc
+
+COPTS = -g -Wall -Werror
+CFLAGS = -I.
+
+DEPS = csf_parser.h extract_csf.h
+SRCS = csf_parser.c extract_csf.c
+
+.PHONY: all clean
+
+all: csf_parser
+
+%.o: %.c $(DEPS)
+	$(CC) -c -o $@ $< $(CFLAGS)
+
+csf_parser: csf_parser.c
+	$(CC) $(COPTS) $(CFLAGS) -o $@ $(SRCS)
+
+clean:
+	rm -rvf output csf_parser
diff --git a/release/code/hab_csf_parser/README b/release/code/hab_csf_parser/README
new file mode 100644
index 0000000..e87d64c
--- /dev/null
+++ b/release/code/hab_csf_parser/README
@@ -0,0 +1,27 @@
+CSF Parser:
+This tool is developed to assist users in parsing the CSF binary either from a Signed image or a stand-alone CSF binary and output debug data. The parsed CSF also extracts the certificates, signatures and SRK table.
+
+
+Build:
+	make
+
+Clean:
+	make clean
+
+Usage:
+	csf_parser [-d] [[-s <signed_image>] | [-c <csf_binary>]]
+	options:
+		-d|--enable-debug     -->	Enable Debug information
+	        -s|--signed-image     -->	Input signed image
+	        -c|--csf-binary       -->	Input CSF binary
+
+	Note: Only one image can be parsed at once.
+
+Contents:
+csf_parser.c  - Program to parse CSF binary in the boot image
+csf_parser.h  - Header file for csf_parser.c file
+extract_csf.c - Program to extract CSF binary from a signed image
+extract_csf.h - Header file for extract_csf.c file
+Makefile      - Makefile for csf_parser
+README        - This file
+README.md     - Markdown format README
diff --git a/release/code/hab_csf_parser/csf_parser.c b/release/code/hab_csf_parser/csf_parser.c
new file mode 100644
index 0000000..08a9fec
--- /dev/null
+++ b/release/code/hab_csf_parser/csf_parser.c
@@ -0,0 +1,1342 @@
+/*
+ * Copyright 2017-2018 NXP
+ */
+
+#include "csf_parser.h"
+#include "extract_csf.h"
+
+/* @Function    : parse_mac_sec
+ * @Description : This function parses the MAC Section in CSF
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *
+ * @Outputs     : return length of MAC
+ *
+ */
+int parse_mac_sec(const uint8_t *csf_hdr, int csf_len, int offset)
+{
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        csf_sec_mac_t *mac_sec_temp = (csf_sec_mac_t *)csf_hdr;
+
+        int i, mac_sec_len;
+
+        if (debug_log) {
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(mac_sec_temp) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(mac_sec_temp->tag == HAB_TAG_MAC, "tag");
+        validate((mac_sec_temp->version == HAB_VER_40 || \
+                  mac_sec_temp->version == HAB_VER_41 || \
+                  mac_sec_temp->version == HAB_VER_42 ), "hab version");
+        validate((offset + HAB_HDR_LEN(mac_sec_temp)) <= csf_len, "length OOB");
+        validate((HAB_HDR_LEN(mac_sec_temp) == (mac_sec_temp->nonce_bytes + \
+                                                mac_sec_temp->mac_bytes + \
+                                                sizeof(hab_hdr_t) + sizeof(hab_hdr_t))), \
+                                                "MAC Nonce length");
+
+        csf_sec_mac_t *mac_sec = malloc(HAB_HDR_LEN(mac_sec_temp));
+        if (memcpy(mac_sec, csf_hdr, HAB_HDR_LEN(mac_sec_temp)) == NULL) {
+                puts("Error: Memcopy to copy mac section contents failed.
");
+                free(mac_sec);
+                return FAIL;
+        }
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_TAG_MAC		MAC and Nonce

", mac_sec->tag);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes		Length of MAC and Nonce

", HAB_HDR_LEN(mac_sec), HAB_HDR_LEN(mac_sec));
+
+        w2f_hdr("VER");
+        fprintf(fp_output, "   	0x%X		HAB_MAJOR.HAB_MINOR	HAB VERSION

", mac_sec->version);
+
+        fprintf(fp_output, "NONCE	NONCE_LEN	VALUE
");
+        fprintf(fp_output, "----------------------------------------------------------------------
");
+        fprintf(fp_output, "   	0x%X		", mac_sec->nonce_bytes);
+        for (i = 0; i < mac_sec->nonce_bytes; i++)
+                fprintf(fp_output, "%02X", mac_sec->nonce_mac[i]);
+        fprintf(fp_output, "

");
+
+        fprintf(fp_output, "MAC	MAC_LEN		VALUE
");
+        fprintf(fp_output, "----------------------------------------------------------------------
");
+        fprintf(fp_output, "   	0x%X		", mac_sec->mac_bytes);
+        for (i=0; i < mac_sec->mac_bytes ; i++)
+                fprintf(fp_output, "%02X", mac_sec->nonce_mac[mac_sec->nonce_bytes + i]);
+        fprintf(fp_output, "

");
+
+        mac_sec_len = HAB_HDR_LEN(mac_sec);
+        free(mac_sec);
+
+        return mac_sec_len;
+}
+
+/* @Function    : parse_sig_sec
+ * @Description : This function parses the Signature Section in CSF
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *                sig_num - Signature number
+ *
+ * @Outputs     : return length of signature
+ *
+ */
+int parse_sig_sec(const uint8_t *csf_hdr, int csf_len, int offset, int *sig_num)
+{
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        csf_sec_sig_t *sig_sec_temp = (csf_sec_sig_t *)csf_hdr;
+
+        int sig_sec_len;
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(sig_sec_temp) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(sig_sec_temp->tag == HAB_TAG_SIG, "tag");
+        validate((sig_sec_temp->version == HAB_VER_40 || \
+                  sig_sec_temp->version == HAB_VER_41 || \
+                  sig_sec_temp->version == HAB_VER_42 ), "hab version");
+        validate((offset + HAB_HDR_LEN(sig_sec_temp)) <= csf_len, "length OOB");
+
+        csf_sec_sig_t *sig_sec = malloc(HAB_HDR_LEN(sig_sec_temp));
+        if (memcpy(sig_sec, csf_hdr, HAB_HDR_LEN(sig_sec_temp)) == NULL) {
+                puts("Error: Memcopy to copy mac section contents failed.
");
+                free(sig_sec);
+                return FAIL;
+        }
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_TAG_SIG		Signature

", sig_sec->tag);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes		Length of Signature

", HAB_HDR_LEN(sig_sec), HAB_HDR_LEN(sig_sec));
+
+        w2f_hdr("VER");
+        fprintf(fp_output, "   	0x%X		HAB_MAJOR.HAB_MINOR	HAB VERSION

", sig_sec->version);
+
+        w2f_hdr("SIG");
+        fprintf(fp_output, "   	0x%X		Signature Offset	Relative to start of CSF

", offset + HAB_HDR_SIZE);
+
+        if (getAbs(sig_sec))
+                sig_sec_len = HAB_HDR_LEN(sig_sec) + (HAB_HDR_SIZE - getAbs(sig_sec));
+        else
+                sig_sec_len = HAB_HDR_LEN(sig_sec);
+
+        /* Create Signature files */
+        char sig_fn[16];
+        snprintf(sig_fn, sizeof(sig_fn), "output/sig%d.bin", *sig_num);
+        FILE *fp_sig = fopen(sig_fn, "w");
+        if (fp_sig) {
+                fwrite(sig_sec->sig, (HAB_HDR_LEN(sig_sec) - HAB_HDR_SIZE),  1, fp_sig);
+                puts("Signature file created
");
+                (*sig_num)++;
+        } else
+                puts("Error: Unable to create Signature file
");
+
+        fclose(fp_sig);
+
+        free(sig_sec);
+
+        return sig_sec_len;
+}
+
+/* @Function    : parse_cert_sec
+ * @Description : This function parses the Certificate Section in CSF
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *
+ * @Outputs     : return length of certificate
+ *
+ */
+int parse_cert_sec(const uint8_t *csf_hdr, int csf_len, int offset)
+{
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        csf_sec_cert_t *cert_sec = (csf_sec_cert_t *)csf_hdr;
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(cert_sec) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(cert_sec->tag == HAB_TAG_CRT, "tag");
+        validate((cert_sec->version == HAB_VER_40 || \
+                  cert_sec->version == HAB_VER_41 || \
+                  cert_sec->version == HAB_VER_42), "hab version");
+        validate((offset + HAB_HDR_LEN(cert_sec)) <= csf_len, "length OOB");
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_TAG_CSF		Certificate

", cert_sec->tag);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes		Length of Certificate

", HAB_HDR_LEN(cert_sec), HAB_HDR_LEN(cert_sec));
+
+        w2f_hdr("VER");
+        fprintf(fp_output, "   	0x%X		HAB_MAJOR.HAB_MINOR	HAB VERSION

", cert_sec->version);
+
+        w2f_hdr("CERT");
+        fprintf(fp_output, "   	0x%X		Certificate Offset	Relative to start of CSF

", (offset + HAB_HDR_SIZE));
+
+        if (getAbs(cert_sec))
+                return HAB_HDR_LEN(cert_sec) + (HAB_HDR_SIZE - getAbs(cert_sec));
+        else
+                return HAB_HDR_LEN(cert_sec);
+}
+
+/* @Function    : parse_set_cmd
+ * @Description : This function parses the Set command in CSF
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *
+ * @Outputs     : return length of Set command
+ *
+ */
+
+int parse_set_cmd(const uint8_t *csf_hdr, int csf_len, int offset)
+{
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        char *def = NULL;
+        char *des = NULL;
+        csf_cmd_set_t *set_cmd = (csf_cmd_set_t *)csf_hdr;
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(set_cmd) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(set_cmd->cmd == HAB_CMD_SET, "tag");
+        validate(set_cmd->cfg_itm == HAB_VAR_CFG_ITM_ENG, "config item");
+        validate(set_cmd->alg == HAB_ALG_SHA1 || \
+                 set_cmd->alg == HAB_ALG_SHA256 || \
+                 set_cmd->alg == HAB_ALG_SHA512, "algorithm");
+        validate(set_cmd->engine == HAB_ENG_ANY || \
+                 set_cmd->engine == HAB_ENG_CAAM || \
+                 set_cmd->engine == HAB_ENG_DCP || \
+                 set_cmd->engine == HAB_ENG_SAHARA || \
+                 set_cmd->engine == HAB_ENG_RTIC || \
+                 set_cmd->engine == HAB_ENG_SW, "engine");
+        validate((offset + HAB_HDR_LEN(set_cmd)) <= csf_len, "length OOB");
+        validate(!(set_cmd->eng_cfg & (uint8_t)~HAB_ENG_CONF_MASK), "engine configuration");
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_CMD_SET		Set Command

",  set_cmd->cmd);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes			Length of Set Command

", HAB_HDR_LEN(set_cmd), HAB_HDR_LEN(set_cmd));
+
+        w2f_hdr("CFG_ITM");
+        if (set_cmd->cfg_itm == HAB_VAR_CFG_ITM_ENG)
+                { def = "HAB_VAR_CFG_ITM_ENG"; des = "Set Engine command"; }
+        else { puts("Error: Invalid configuration item.
"); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s	%s

", set_cmd->cfg_itm, def, des);
+
+        w2f_hdr("ALG");
+        if (set_cmd->alg == HAB_ALG_SHA1)
+                { def = "HAB_ALG_SHA1";
+                  des = "SHA1 Algorithm"; }
+        else if (set_cmd->alg == HAB_ALG_SHA256)
+                { def = "HAB_ALG_SHA256";
+                  des = "SHA256 Algorithm"; }
+        else if (set_cmd->alg == HAB_ALG_SHA512)
+                { def = "HAB_ALG_SHA512";
+                  des = "SHA512 Algorithm"; }
+        else { puts("Error: Invalid Algorithm.
"); return FAIL; }
+        fprintf(fp_output, "   	0x%X		%s		%s

", set_cmd->alg, def, des);
+
+        w2f_hdr("ENG");
+        if (set_cmd->engine == HAB_ENG_ANY)
+                { def = "HAB_ENG_ANY";
+                  des = "Any ‚Äì HAB will chose the most appropriate engine"; }
+        else if (set_cmd->engine == HAB_ENG_CAAM)
+                { def = "HAB_ENG_CAAM"; des = "CAAM"; }
+        else if (set_cmd->engine == HAB_ENG_DCP)
+                { def = "HAB_ENG_DCP"; des = "DCP"; }
+        else if (set_cmd->engine == HAB_ENG_SAHARA)
+                { def = "HAB_ENG_SAHARA"; des = "SAHARA"; }
+        else if (set_cmd->engine == HAB_ENG_RTIC)
+                { def = "HAB_ENG_RTIC"; des = "RTIC"; }
+        else if (set_cmd->engine == HAB_ENG_SW)
+                { def = "HAB_ENG_SW"; des = "Software Engine"; }
+        else { puts("Error: Invalid Engine.
"); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s		%s

", set_cmd->engine, def, des);
+
+        w2f_hdr("ENG_CFG");
+        fprintf(fp_output, "   	0x%X		BITWISE OR   		Bitwise OR of Engine confs as below

", set_cmd->eng_cfg);
+
+        if (set_cmd->engine == HAB_ENG_ANY && set_cmd->eng_cfg == HAB_ANY_CONF_DEFAULT) {
+                def = "HAB_ANY_CONF_DEFAULT"; des = "Engine Configuration ANY Default";
+                fprintf(fp_output, "   	0x%X		%s		%s

", HAB_ANY_CONF_DEFAULT, def, des);
+        } else if (set_cmd->engine == HAB_ENG_CAAM) {
+                if (set_cmd->eng_cfg == HAB_CAAM_DEFAULT) {
+                        def = "HAB_CAAM_DEFAULT";
+                        des = "Engine Configuration CAAM Default";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_DEFAULT, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_CAAM_IN_SWAP8)) {
+                        def = "HAB_CAAM_IN_SWAP8";
+                        des = "Engine Configuration CAAM IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_IN_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_CAAM_IN_SWAP16)) {
+                        def = "HAB_CAAM_IN_SWAP16";
+                        des = "Engine Configuration CAAM IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_IN_SWAP16, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_CAAM_OUT_SWAP8)) {
+                        def = "HAB_CAAM_OUT_SWAP8";
+                        des = "Engine Configuration CAAM OUT SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_OUT_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_CAAM_OUT_SWAP16)) {
+                        def = "HAB_CAAM_OUT_SWAP16";
+                        des = "Engine Configuration CAAM OUT SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_OUT_SWAP16,def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_CAAM_DSC_SWAP8)) {
+                        def = "HAB_CAAM_DSC_SWAP8";
+                        des = "Engine Configuration CAAM DSC SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_DSC_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_CAAM_DSC_SWAP16)) {
+                        def = "HAB_CAAM_DSC_SWAP16";
+                        des = "Engine Configuration CAAM DSC SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_DSC_SWAP16,def, des);
+                }
+        }
+        else if (set_cmd->engine == HAB_ENG_DCP) {
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_DCP_DEFAULT)) {
+                        def = "HAB_DCP_DEFAULT";
+                        des = "Engine Configuration DCP default";
+                        fprintf(fp_output, "   	0x%X		%s		%s

", HAB_DCP_DEFAULT, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_DCP_IN_SWAP8)) {
+                        def = "HAB_DCP_IN_SWAP8";
+                        des = "Engine Configuration DCP IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_IN_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_DCP_IN_SWAP32)) {
+                        def = "HAB_DCP_IN_SWAP32";
+                        des = "Engine Configuration DCP IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_IN_SWAP32, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_DCP_OUT_SWAP8)) {
+                        def = "HAB_DCP_OUT_SWAP8";
+                        des = "Engine Configuration DCP OUT SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_OUT_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_DCP_OUT_SWAP32)) {
+                        def = "HAB_DCP_OUT_SWAP32";
+                        des = "Engine Configuration DCP OUT SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_OUT_SWAP32, def, des);
+                }
+        }
+        else if (set_cmd->engine == HAB_ENG_SAHARA) {
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_SAHARA_DEFAULT)) {
+                        def = "HAB_SAHARA_DEFAULT";
+                        des = "Engine Configuration SAHARA default";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_DEFAULT,def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_SAHARA_IN_SWAP8)) {
+                        def = "HAB_SAHARA_IN_SWAP8";
+                        des = "Engine Configuration SAHARA IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_IN_SWAP8,def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_SAHARA_IN_SWAP16)) {
+                        def = "HAB_SAHARA_IN_SWAP16";
+                        des = "Engine Configuration SAHARA IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_IN_SWAP16,def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_SAHARA_DSC_BE8_16)) {
+                        def = "HAB_SAHARA_DSC_BE8_16";
+                        des = "Engine Configuration SAHARA DSC BE8 16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_DSC_BE8_16,def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_SAHARA_DSC_BE8_32)) {
+                        def = "HAB_SAHARA_DSC_BE8_32";
+                        des = "Engine Configuration SAHARA DSC BE8 32";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_DSC_BE8_32, def, des);
+                }
+        }
+        else if (set_cmd->engine == HAB_ENG_RTIC) {
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_RTIC_DEFAULT)) {
+                        def = "HAB_RTIC_DEFAULT";
+                        des = "Engine Configuration RTIC default";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_RTIC_DEFAULT, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_RTIC_IN_SWAP8)) {
+                        def = "HAB_RTIC_IN_SWAP8";
+                        des = "Engine Configuration RTIC IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_RTIC_IN_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_RTIC_IN_SWAP16)) {
+                        def = "HAB_RTIC_IN_SWAP16";
+                        des = "Engine Configuration RTIC IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_RTIC_IN_SWAP16,def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_RTIC_OUT_SWAP8)) {
+                        def = "HAB_RTIC_OUT_SWAP8";
+                        des = "Engine Configuration RTIC OUT SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_RTIC_OUT_SWAP8, def, des);
+                }
+                if (CHECK_BIT(set_cmd->eng_cfg, HAB_RTIC_KEEP)) {
+                        def = "HAB_RTIC_KEEP";
+                        des = "Engine Configuration RTIC KEEP";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_RTIC_KEEP, def, des);
+                }
+        }
+        else if (set_cmd->engine == HAB_ENG_SW && \
+                set_cmd->eng_cfg == HAB_SW_CONF_DEFAULT) {
+                def = "HAB_SW_CONF_DEFAULT";
+                des = "Engine Configuration SW Default";
+                fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SW_CONF_DEFAULT, def, des);
+        }
+        else { puts("Error: Invalid Engine configuration found
"); return FAIL; }
+
+        return HAB_HDR_LEN(set_cmd);
+}
+
+/* @Function    : parse_unlock_cmd
+ * @Description : This function parses the Unlock command in CSF
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *
+ * @Outputs     : return length of Unlock command
+ *
+ */
+
+int parse_unlock_cmd(const uint8_t *csf_hdr, int csf_len, int offset)
+{
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        char *def = NULL;
+        char *des = NULL;
+        uint32_t ulck_features;
+        csf_cmd_unlock_t *unlock_cmd = (csf_cmd_unlock_t *)csf_hdr;
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(unlock_cmd) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate((unlock_cmd->cmd == HAB_CMD_UNLK ||\
+                  unlock_cmd->cmd == HAB_CMD_INIT), "tag");
+        validate(unlock_cmd->engine == HAB_ENG_CAAM || \
+                 unlock_cmd->engine == HAB_ENG_SNVS || \
+                 unlock_cmd->engine == HAB_ENG_OCOTP, "engine");
+        validate((offset + HAB_HDR_LEN(unlock_cmd)) <= csf_len, "length OOB");
+        ulck_features = from_be32(unlock_cmd->features);
+        validate(!(ulck_features & (uint32_t)~HAB_UNLK_FEAT_MASK), "unlock features");
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        if (unlock_cmd->cmd == HAB_CMD_UNLK)
+                fprintf(fp_output, "   	0x%X		HAB_CMD_UNLK		Unlock Command

", unlock_cmd->cmd);
+        else
+                fprintf(fp_output, "   	0x%X		HAB_CMD_INIT		Init Command

", unlock_cmd->cmd);
+
+        w2f_hdr("LEN");
+        if (unlock_cmd->cmd == HAB_CMD_UNLK)
+                fprintf(fp_output, "   	0x%X		%d bytes  		Length of Unlock Command

", HAB_HDR_LEN(unlock_cmd), HAB_HDR_LEN(unlock_cmd));
+        else
+                fprintf(fp_output, "   	0x%X		%d bytes  		Length of Init Command

", HAB_HDR_LEN(unlock_cmd), HAB_HDR_LEN(unlock_cmd));
+
+        w2f_hdr("ENG");
+        if (unlock_cmd->engine == HAB_ENG_CAAM)
+                { def = "HAB_ENG_CAAM"; des = "CAAM"; }
+        else if (unlock_cmd->engine == HAB_ENG_SNVS)
+                { def = "HAB_ENG_SNVS"; des = "Secure Non-Volatile Storage"; }
+        else if (unlock_cmd->engine == HAB_ENG_OCOTP)
+                { def = "HAB_ENG_OCOTP"; des = "On Chip OTP memory"; }
+        else { puts("Error: Invalid Engine.
"); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s		%s

", unlock_cmd->engine, def, des);
+
+        w2f_hdr("FEATURE");
+        fprintf(fp_output, "   	0x%X		BITWISE OR 		Bitwise OR of features below 

", (ulck_features));
+
+        if (unlock_cmd->engine == HAB_ENG_CAAM) {
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_CAAM_MID)) {
+                        def = "UNLOCK_CAAM_MID"; des = "Unlock CAAM MID feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s 	%s

", HAB_CMD_UNLOCK_CAAM_MID, def, des);
+                }
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_CAAM_RNG)) {
+                        if (unlock_cmd->cmd == HAB_CMD_UNLK) {
+                                def = "UNLOCK_CAAM_RNG"; des = "Unlock CAAM RNG feature enabled";
+                        } else {
+                                def = "INIT_CAAM_RNG"; des = "Init CAAM RNG feature enabled";
+                        }
+                        fprintf(fp_output, "   	0x%X		%s		%s

", HAB_CMD_UNLOCK_CAAM_RNG, def, des);
+                }
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_CAAM_MFG)) {
+                        def = "UNLOCK_CAAM_MFG"; des = "Unlock CAAM MFG feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s		%s

", HAB_CMD_UNLOCK_CAAM_MFG, def, des);
+                }
+        } else if (unlock_cmd->engine == HAB_ENG_SNVS) {
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_SNVS_LP_SWR)) {
+                        def = "UNLOCK_SNVS_LP_SWR";
+                        des = "Unlock SNVS LP SWR feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CMD_UNLOCK_SNVS_LP_SWR, def, des);
+                }
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_SNVS_ZMK_WRITE)) {
+                        def = "UNLOCK_SNVS_ZMK_WRITE";
+                        des = "Unlock SNVS ZMK WRITE feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CMD_UNLOCK_SNVS_ZMK_WRITE, def, des);
+                }
+        } else if (unlock_cmd->engine == HAB_ENG_OCOTP) {
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_OCOTP_FLD_RTN)) {
+                        def = "UNLOCK_OCOTP_FLD_RTN";
+                        des = "Unlock OCOTP Field Return feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CMD_UNLOCK_OCOTP_FLD_RTN, def, des);
+                }
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_OCOTP_SRK_RVK)) {
+                        def = "UNLOCK_OCOTP_SRK_RVK";
+                        des = "Unlock OCOTP SRK Revoke feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CMD_UNLOCK_OCOTP_SRK_RVK, def, des);
+                }
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_OCOTP_SCS)) {
+                        def = "UNLOCK_OCOTP_SCS";
+                        des = "Unlock OCOTP SCS feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CMD_UNLOCK_OCOTP_SCS, def, des);
+                }
+                if (CHECK_BIT(ulck_features, HAB_CMD_UNLOCK_OCOTP_JTAG)) {
+                        def = "UNLOCK_OCOTP_JTAG";
+                        des = "Unlock OCOTP JTAG feature enabled";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CMD_UNLOCK_OCOTP_JTAG, def, des);
+                }
+        } else { puts("Error: Invalid Engine configuration found
"); return FAIL; }
+
+        if (unlock_cmd->cmd == HAB_CMD_UNLK && \
+            unlock_cmd->engine == HAB_ENG_OCOTP && \
+            HAB_HDR_LEN(unlock_cmd) > MIN_UNLK_CMD_LEN) {
+                fprintf(fp_output, "UID	VALUE					DESCRIPTION
");
+                fprintf(fp_output, "----------------------------------------------------------------------
");
+                fprintf(fp_output, "   	0x%08X%08X			Unique Identifier

", \
+                                        (uint32_t)from_be32(unlock_cmd->uid), \
+                                        (uint32_t)from_be32((unlock_cmd->uid >> 32)));
+        }
+
+        return HAB_HDR_LEN(unlock_cmd);
+}
+
+/* @Function    : parse_aut_dat_cmd
+ * @Description : This function parses the Authenticate Data command in CSF 
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *
+ * @Outputs     : return Success or Fail
+ *
+ */
+
+int parse_aut_dat_cmd(const uint8_t *csf_hdr, int csf_len, int offset)
+{
+
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        char *def = NULL;
+        char *des = NULL;
+        csf_cmd_aut_dat_t *aut_dat_cmd_temp = (csf_cmd_aut_dat_t *)csf_hdr;
+        int nregions = 0;
+        int aut_dat_len;
+
+        if (HAB_HDR_LEN(aut_dat_cmd_temp) > MIN_AUT_DAT_CMD_LEN) {
+                nregions = (HAB_HDR_LEN(aut_dat_cmd_temp) - sizeof(csf_cmd_aut_dat_t)) / sizeof(region_t);
+
+                if (aut_dat_cmd_temp->engine == HAB_ENG_CAAM) {
+                        validate(nregions < HAB_CAAM_BLOCK_MAX && nregions > 0, "blocks");
+                } else if (aut_dat_cmd_temp->engine == HAB_ENG_DCP) {
+                        validate(nregions < HAB_DCP_BLOCK_MAX && nregions > 0, "blocks");
+                } else if (aut_dat_cmd_temp->engine == HAB_ENG_SAHARA) {
+                        validate(nregions < HAB_SAHARA_BLOCK_MAX && nregions > 0, "blocks");
+                }
+        }
+
+        csf_cmd_aut_dat_t *aut_dat_cmd = malloc(sizeof(csf_cmd_aut_dat_t) + (nregions * sizeof(region_t)));
+
+        if (memcpy(aut_dat_cmd, csf_hdr, HAB_HDR_LEN(aut_dat_cmd_temp)) == NULL) {
+                puts("Error: Memcopy to copy aut dat cmd contents failed.
");
+                free(aut_dat_cmd);
+                return FAIL;
+        }
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(aut_dat_cmd) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(aut_dat_cmd->cmd == HAB_CMD_AUT_DAT, "tag");
+        validate(aut_dat_cmd->flags == HAB_CMD_AUT_DAT_NO_FLAG || aut_dat_cmd->flags == HAB_CMD_AUT_DAT_ABS, "flags");
+        validate((offset + HAB_HDR_LEN(aut_dat_cmd)) <= csf_len, "length OOB");
+        /* Normal Authentication Verification Index = 1 for CSF
+         * Normal Authentication Verification Index = 2 - 4 for IMG
+         * Fast Authentication Verification Index : 0
+         */
+        validate(aut_dat_cmd->key >= 0 && aut_dat_cmd->key < 5 , "key");
+        validate(aut_dat_cmd->sig_fmt == HAB_CMD_AUT_DAT_PCL_CMS || \
+                 aut_dat_cmd->sig_fmt == HAB_CMD_AUT_DAT_PCL_AEAD, "signature format");
+        validate(aut_dat_cmd->engine == HAB_ENG_ANY || \
+                 aut_dat_cmd->engine == HAB_ENG_CAAM || \
+                 aut_dat_cmd->engine == HAB_ENG_DCP || \
+                 aut_dat_cmd->engine == HAB_ENG_SAHARA || \
+                 aut_dat_cmd->engine == HAB_ENG_SW, "engine");
+/* aut_dat_cmd->engine == HAB_ENG_SNVS || \
+   aut_dat_cmd->engine == HAB_ENG_OCOTP || \ */
+        validate(!(aut_dat_cmd->eng_cfg & (uint8_t)~HAB_ENG_CONF_MASK), "engine configuration");
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_CMD_AUT_DAT		Authenticate Data Command

", aut_dat_cmd->cmd);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes		Length of Authenticate Data Command

", HAB_HDR_LEN(aut_dat_cmd), HAB_HDR_LEN(aut_dat_cmd));
+
+        w2f_hdr("FLG");
+
+        if (aut_dat_cmd->flags == HAB_CMD_AUT_DAT_NO_FLAG)
+                { def = "HAB_CMD_AUT_DAT_NO_FLAG"; des = "No Flags set"; }
+        else if (aut_dat_cmd->flags == HAB_CMD_AUT_DAT_ABS)
+                { def = "HAB_CMD_AUT_DAT_ABS";
+                  des = "Use absolute address for the key"; }
+        else { puts("Error: Invalid Authenticate data flag.
"); free(aut_dat_cmd); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s	%s

", aut_dat_cmd->flags, def, des);
+    
+        w2f_hdr("KEY");
+        fprintf(fp_output, "   	0x%X		Verification Key Idx %d	Public Key Store Index

", aut_dat_cmd->key, aut_dat_cmd->key);
+
+        w2f_hdr("PCL");
+        fprintf(fp_output, "   	0x%X		HAB_PCL_CMS		CMS/PKCS#7 Signature Format

", aut_dat_cmd->sig_fmt);
+    
+        w2f_hdr("ENG");
+        if (aut_dat_cmd->engine == HAB_ENG_ANY)
+                { def = "HAB_ENG_ANY";
+                  des = "Any ‚Äì HAB will chose the most appropriate engine"; }
+        else if (aut_dat_cmd->engine == HAB_ENG_CAAM)
+                { def = "HAB_ENG_CAAM"; des = "CAAM"; }
+        else if (aut_dat_cmd->engine == HAB_ENG_DCP)
+                { def = "HAB_ENG_DCP"; des = "DCP"; }
+        else if (aut_dat_cmd->engine == HAB_ENG_SAHARA)
+                { def = "HAB_ENG_SAHARA"; des = "SAHARA"; }
+/*    else if (aut_dat_cmd->engine == HAB_ENG_SNVS) { def = "HAB_ENG_SNVS"; des = "Secure Non-Volatile Storage"; }
+    else if (aut_dat_cmd->engine == HAB_ENG_OCOTP) { def = "HAB_ENG_OCOTP"; des = "On Chip OTP memory"; } */
+        else if (aut_dat_cmd->engine == HAB_ENG_SW)
+                { def = "HAB_ENG_SW"; des = "Software Engine"; }
+        else { puts("Error: Invalid Engine.
"); free(aut_dat_cmd); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s		%s

", aut_dat_cmd->engine, def, des);
+
+        w2f_hdr("ENG_CFG");
+        fprintf(fp_output, "   	0x%X		BITWISE OR   		Bitwise OR of Engine confs as below

", aut_dat_cmd->eng_cfg);
+
+        if (aut_dat_cmd->engine == HAB_ENG_ANY && aut_dat_cmd->eng_cfg == HAB_ANY_CONF_DEFAULT) {
+                def = "HAB_ANY_CONF_DEFAULT"; des = "Engine Configuration ANY Default";
+                fprintf(fp_output, "   	0x%X		%s	%s

", HAB_ANY_CONF_DEFAULT, def, des);
+        } else if (aut_dat_cmd->engine == HAB_ENG_CAAM) {
+                if (aut_dat_cmd->eng_cfg == HAB_CAAM_DEFAULT) {
+                        def = "HAB_CAAM_DEFAULT";
+                        des = "Engine Configuration CAAM Default";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_DEFAULT, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_CAAM_IN_SWAP8)) {
+                        def = "HAB_CAAM_IN_SWAP8";
+                        des = "Engine Configuration CAAM IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_IN_SWAP8, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_CAAM_IN_SWAP16)) {
+                        def = "HAB_CAAM_IN_SWAP16";
+                        des = "Engine Configuration CAAM IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_IN_SWAP16, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_CAAM_OUT_SWAP8)) {
+                        def = "HAB_CAAM_OUT_SWAP8";
+                        des = "Engine Configuration CAAM OUT SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_OUT_SWAP8, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_CAAM_OUT_SWAP16)) {
+                        def = "HAB_CAAM_OUT_SWAP16";
+                        des = "Engine Configuration CAAM OUT SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_OUT_SWAP16, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_CAAM_DSC_SWAP8)) {
+                        def = "HAB_CAAM_DSC_SWAP8";
+                        des = "Engine Configuration CAAM DSC SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_DSC_SWAP8, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_CAAM_DSC_SWAP16)) {
+                        def = "HAB_CAAM_DSC_SWAP16";
+                        des = "Engine Configuration CAAM DSC SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_CAAM_DSC_SWAP16, def, des);
+                }
+        }
+        else if (aut_dat_cmd->engine == HAB_ENG_DCP) {
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_DCP_DEFAULT)) {
+                        def = "HAB_DCP_DEFAULT";
+                        des = "Engine Configuration DCP default";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_DEFAULT, def,  des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_DCP_IN_SWAP8)) {
+                        def = "HAB_DCP_IN_SWAP8";
+                        des = "Engine Configuration DCP IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_IN_SWAP8, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_DCP_IN_SWAP32)) {
+                        def = "HAB_DCP_IN_SWAP32";
+                        des = "Engine Configuration DCP IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_IN_SWAP32, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_DCP_OUT_SWAP8)) {
+                        def = "HAB_DCP_OUT_SWAP8";
+                        des = "Engine Configuration DCP OUT SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_OUT_SWAP8, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_DCP_OUT_SWAP32)) {
+                        def = "HAB_DCP_OUT_SWAP32";
+                        des = "Engine Configuration DCP OUT SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_DCP_OUT_SWAP32, def, des);
+                }
+        }
+        else if (aut_dat_cmd->engine == HAB_ENG_SAHARA) {
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_SAHARA_DEFAULT)) {
+                        def = "HAB_SAHARA_DEFAULT";
+                        des = "Engine Configuration SAHARA default";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_DEFAULT,    def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_SAHARA_IN_SWAP8)) {
+                        def = "HAB_SAHARA_IN_SWAP8";
+                        des = "Engine Configuration SAHARA IN SWAP8";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_IN_SWAP8, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_SAHARA_IN_SWAP16)) {
+                        def = "HAB_SAHARA_IN_SWAP16";
+                        des = "Engine Configuration SAHARA IN SWAP16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_IN_SWAP16, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_SAHARA_DSC_BE8_16)) {
+                        def = "HAB_SAHARA_DSC_BE8_16";
+                        des = "Engine Configuration SAHARA DSC BE8 16";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_DSC_BE8_16, def, des);
+                }
+                if (CHECK_BIT(aut_dat_cmd->eng_cfg, HAB_SAHARA_DSC_BE8_32)) {
+                        def = "HAB_SAHARA_DSC_BE8_32";
+                        des = "Engine Configuration SAHARA DSC BE8 32";
+                        fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SAHARA_DSC_BE8_32, def, des);
+                }
+        }
+        else if (aut_dat_cmd->engine == HAB_ENG_SW && \
+                aut_dat_cmd->eng_cfg == HAB_SW_CONF_DEFAULT) {
+                def = "HAB_SW_CONF_DEFAULT";
+                des = "Engine Configuration SW Default";
+                fprintf(fp_output, "   	0x%X		%s	%s

", HAB_SW_CONF_DEFAULT, def, des);
+        }
+        else { puts("Error: Invalid Engine configuration found
"); free(aut_dat_cmd); return FAIL; }
+
+        w2f_hdr("SIG_LOC");
+        fprintf(fp_output, "   	0x%X		Authentication Data	Relative to start of CSF

", (uint32_t)from_be32(aut_dat_cmd->sig_loc));
+
+        if (HAB_HDR_LEN(aut_dat_cmd) > MIN_AUT_DAT_CMD_LEN && nregions > 0 && nregions < HAB_CAAM_BLOCK_MAX) {
+                int j;
+                for (j = 0; j < nregions; j++) {
+                        if (debug_log) {
+                                fprintf(fp_debug, "Region %d: address: 0x%X, size: 0x%X
", j,
+                                from_be32(aut_dat_cmd->region[j].address), from_be32(aut_dat_cmd->region[j].size));
+                        }
+                        w2f_hdr("BLK_SRT");
+                        fprintf(fp_output, "   	0x%X	Address of Region %d	Address of Region %d \
+to verify

", (uint32_t)from_be32(aut_dat_cmd->region[j].address), j, j);
+                        w2f_hdr("BLK_LEN");
+                        fprintf(fp_output, "   	0x%X		Size of Region %d	Size of Region %d \
+to verify

", (uint32_t)from_be32(aut_dat_cmd->region[j].size), j, j);
+                }
+        }
+
+        aut_dat_len = HAB_HDR_LEN(aut_dat_cmd);
+        free(aut_dat_cmd);
+        return aut_dat_len;
+}
+
+/* @Function    : parse_ins_key_cmd
+ * @Description : This function parses the Insert key command in CSF 
+ *                and prints the parsed content
+ *
+ * @Inputs      : csf_hdr  - Pointer to the start of CSF
+ *                csf_len  - Length of CSF
+ *                offset   - Offset from beginning of CSF
+ 8                cert_num - Certificate Number
+ *
+ * @Outputs     : return Success or Fail
+ *
+ */
+int parse_ins_key_cmd(const uint8_t *csf_hdr, int csf_len, int offset, int *cert_num)
+{
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        char *def = NULL;
+        char *des = NULL;
+        csf_cmd_ins_key_t *ins_key_cmd = (csf_cmd_ins_key_t *)csf_hdr;
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < HAB_HDR_LEN(ins_key_cmd) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(ins_key_cmd->cmd == HAB_CMD_INS_KEY, "tag");
+        validate(ins_key_cmd->flags == HAB_CMD_INS_KEY_NO_FLAG || \
+                 ins_key_cmd->flags == HAB_CMD_INS_KEY_ABS || \
+                 ins_key_cmd->flags == HAB_CMD_INS_KEY_CSF, "flags");
+        validate((offset + HAB_HDR_LEN(ins_key_cmd)) <= csf_len, "length OOB");
+        validate(ins_key_cmd->cert_fmt == HAB_PCL_SRK || \
+                 ins_key_cmd->cert_fmt == HAB_PCL_X509 || \
+                 ins_key_cmd->cert_fmt == HAB_PCL_BLOB, "cert format");
+        validate(ins_key_cmd->hash_alg == HAB_ALG_NO_ALG || \
+                 ins_key_cmd->hash_alg == HAB_ALG_SHA256, "hash algorithm");
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_SRK) {
+                /* Key Index of SRK1 - 4 */
+                validate(ins_key_cmd->src_index >= 0 && ins_key_cmd->src_index < 4, "source index");
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB) {
+                /* Master KEK index */
+                validate(ins_key_cmd->src_index >= 0 && ins_key_cmd->src_index < 4, "Master KEK index");
+        } else {
+                /* Verification Index */
+                validate(ins_key_cmd->src_index == 0 || \
+                        (ins_key_cmd->src_index > 1 && \
+                         ins_key_cmd->src_index < 6 ), "verification index");
+        }
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_SRK) {
+                validate(ins_key_cmd->tgt_index == 0, "target index");
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB) {
+                validate(ins_key_cmd->tgt_index >= 0 && ins_key_cmd->tgt_index < 4, "target index");
+        } else {
+                validate(ins_key_cmd->tgt_index > 0 && \
+                         ins_key_cmd->tgt_index < 6 , "target index");
+        }
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_CMD_INS_KEY		Install Key Command

", ins_key_cmd->cmd);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes		Length of Insert Key Command

", HAB_HDR_LEN(ins_key_cmd), HAB_HDR_LEN(ins_key_cmd));
+
+        w2f_hdr("FLG");
+        if (ins_key_cmd->flags == HAB_CMD_INS_KEY_NO_FLAG)
+                { def = "HAB_CMD_INS_KEY_NO_FLAG";
+                  des = "No Flags set"; }
+        else if (ins_key_cmd->flags == HAB_CMD_INS_KEY_ABS)
+                { def = "HAB_CMD_INS_KEY_ABS";
+                  des = "Use absolute address for the key"; }
+        else if (ins_key_cmd->flags == HAB_CMD_INS_KEY_CSF)
+                { def = "HAB_CMD_INS_KEY_CSF";
+                  des = "Install CSF Key"; }
+        else { puts("Error: Invalid Insert Key Flag.
"); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s	%s

", ins_key_cmd->flags, def, des);
+
+        w2f_hdr("PCL");
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_SRK) {
+                def = "HAB_PCL_SRK";
+                des = "SRK Format";
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_X509) {
+                def = "HAB_PCL_X509";
+                des = "X.509v3 Cert Format";
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB) {
+                def = "HAB_PCL_BLOB";
+                des = "SHW-specific wrapped key format";
+        } else { puts("Error: Invalid Certificate format.
"); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s		%s

", ins_key_cmd->cert_fmt, def, des);
+        w2f_hdr("ALG");
+
+        if (ins_key_cmd->hash_alg == HAB_ALG_NO_ALG)
+                { def = "HAB_ALG_NO_ALG";
+                  des = "No Hash Alg."; }
+        else if (ins_key_cmd->hash_alg == HAB_ALG_SHA256)
+                { def = "HAB_ALG_SHA256";
+                  des = "SHA-256 Alg."; }
+        else { puts("Error: Invalid hash algorithm.
"); return FAIL; }
+
+        fprintf(fp_output, "   	0x%X		%s		%s

", ins_key_cmd->hash_alg, def, des);
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_SRK) {
+                w2f_hdr("SRC");
+                fprintf(fp_output, "   	0x%X		SRK Index %d		Source Key Index of SRK

", ins_key_cmd->src_index, ins_key_cmd->src_index);
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_X509) {
+                w2f_hdr("VRF");
+                fprintf(fp_output, "   	0x%X		Verification Index %d	SRK Verification Key Index

", ins_key_cmd->src_index, ins_key_cmd->src_index);
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB) {
+                w2f_hdr("VRF");
+                switch (ins_key_cmd->src_index) {
+                case 0:
+                case 1:
+                        fprintf(fp_output, "   	0x%X		Master KEK Index %d	OTPMK:Master Key

", ins_key_cmd->src_index, ins_key_cmd->src_index);
+                        break;
+                case 2:
+                        fprintf(fp_output, "   	0x%X		Master KEK Index %d	OTPMK:Master Key

", ins_key_cmd->src_index, ins_key_cmd->src_index);
+                        break;
+                case 3:
+                        fprintf(fp_output, "   	0x%X		Master KEK Index %d	OTPMK:Master Key

", ins_key_cmd->src_index, ins_key_cmd->src_index);
+                        break;
+                default:
+                        puts("Error: Invalid Master KEK Index.
");
+                        return FAIL;
+                }
+        } else { puts("Error: Invalid Certificate format.
"); return FAIL; }
+
+
+        w2f_hdr("TGT");
+        if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB)
+                fprintf(fp_output, "   	0x%X		Key Index %d		Secret Key Store Index

", ins_key_cmd->tgt_index, ins_key_cmd->tgt_index);
+        else
+                fprintf(fp_output, "   	0x%X		Key Index %d		Public Key Store Index

", ins_key_cmd->tgt_index, ins_key_cmd->tgt_index);
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_SRK)
+                def = "Start of SRK Table";
+        else if (ins_key_cmd->cert_fmt == HAB_PCL_X509)
+                def = "Certificate Data";
+        else if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB)
+                def = "Blob Address";
+        else {  puts("Error: Invalid Certificate format.
"); return FAIL; }
+
+        w2f_hdr("KEY_DAT");
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_BLOB)
+                fprintf(fp_output, "   	0x%X	%s		Absolute memory address of blob

", (uint32_t)from_be32(ins_key_cmd->key_loc), def);
+        else
+                fprintf(fp_output, "   	0x%X		%s	Relative to start of CSF

", (uint32_t)from_be32(ins_key_cmd->key_loc), def);
+
+        if (ins_key_cmd->cert_fmt == HAB_PCL_SRK) {
+                /* Create SRK Table file out of Image file */
+                FILE *fp_srkTable = fopen("output/SRKTable.bin", "w");
+                if (fp_srkTable) {
+                        int srktable_offset = from_be32(ins_key_cmd->key_loc) - offset;
+                        csf_sec_cert_t *cert_sec = (csf_sec_cert_t *)&csf_hdr[srktable_offset];
+                        fwrite(&csf_hdr[srktable_offset], HAB_HDR_LEN(cert_sec), 1, fp_srkTable);
+                        puts("SRK Table file created
");
+                } else
+                        puts("Error: Unable to create SRK Table file
");
+
+                fclose(fp_srkTable);
+        } else if (ins_key_cmd->cert_fmt == HAB_PCL_X509) {
+                char cert_fn[17];
+                snprintf(cert_fn, sizeof(cert_fn), "output/cert%d.der", *cert_num);
+                FILE *fp_cert = fopen(cert_fn, "w");
+                if (fp_cert) {
+                        int cert_offset = from_be32(ins_key_cmd->key_loc) - offset;
+                        csf_sec_cert_t *cert_sec = (csf_sec_cert_t *)&csf_hdr[cert_offset];
+                        fwrite(&csf_hdr[cert_offset + HAB_HDR_SIZE], (HAB_HDR_LEN(cert_sec) - HAB_HDR_SIZE), 1, fp_cert);
+                        puts("Certificate file created
");
+                        (*cert_num)++;
+                } else
+                        puts("Error: Unable to create Certificate file
");
+
+                fclose(fp_cert);
+        }
+
+        return HAB_HDR_LEN(ins_key_cmd);
+}
+
+/* @Function    : parse_csf_hdr
+ * @Description : This function parses the CSF header and prints
+ *                the parsed content
+ *
+ * @Inputs      : csf_hdr - Pointer to the start of CSF
+ *                csf_len - Length of CSF
+ *                offset  - Offset from beginning of CSF
+ *
+ * @outputs     : return Success or Fail
+ *
+ */
+
+int parse_csf_hdr(const uint8_t *csf_hdr, int csf_len, int offset)
+{
+
+        assert(csf_hdr != NULL);
+
+        validate(csf_len != 0, "csf length");
+
+        csf_hdr_t *csf_header = (csf_hdr_t *)csf_hdr;
+
+        if (debug_log) {
+                int i = 0;
+                fprintf(fp_debug, "Parsing following values
");
+                for (i=0; i < sizeof(csf_hdr_t) ; i++)
+                        fprintf(fp_debug, "0x%02X ", csf_hdr[i]);
+                fprintf(fp_debug, "
");
+        }
+
+        validate(csf_header->tag == HAB_TAG_CSF, "tag");
+        validate((csf_header->version == HAB_VER_40 || \
+                  csf_header->version == HAB_VER_41 || \
+                  csf_header->version == HAB_VER_42 ), "hab version");
+        validate((offset + HAB_HDR_LEN(csf_header)) <= csf_len, "length OOB");
+
+        fprintf(fp_output, "

");
+        w2f_hdr("TAG");
+        fprintf(fp_output, "   	0x%X		HAB_TAG_CSF		Command Sequence File header

", csf_header->tag);
+
+        w2f_hdr("LEN");
+        fprintf(fp_output, "   	0x%X		%d bytes		Length of Command Sequence File

", HAB_HDR_LEN(csf_header), HAB_HDR_LEN(csf_header));
+
+        w2f_hdr("VER");
+        fprintf(fp_output, "   	0x%X		HAB_MAJOR.HAB_MINOR	HAB VERSION

", csf_header->version);
+
+        return sizeof(csf_hdr_t);
+}
+
+/*
+ * Description : This function initiates the call to different parsing
+ *               functions from offset of start of CSF
+ *
+ * @Inputs  : csf     - Pointer to the start of CSF
+ *           csf_len - Length of CSF
+ *
+ * @Outputs : return Success or Fail
+ *
+ */
+int parse_csf(const uint8_t *csf, int csf_len)
+{
+        assert(csf != NULL);
+
+        validate(csf_len != 0, "csf length");
+        if (debug_log) {
+                fprintf(fp_debug, "CSF TAG = 0x%X and Total size = 0x%X
", (const uint8_t)csf[0], csf_len);
+        }
+
+        int offset = 0;
+        int hdr_len = 0;
+        int cert_count = 0;
+        int sig_count = 0;
+
+        do {
+                if (debug_log) {
+                        fprintf(fp_debug, "
CSF TAG: 0x%X
",csf[offset]);
+                }
+
+                switch (csf[offset]) {
+                case (HAB_TAG_CSF):
+                        hdr_len = parse_csf_hdr(&csf[offset], csf_len, offset);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse CSF Header
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_CMD_INS_KEY):
+                        hdr_len = parse_ins_key_cmd(&csf[offset], csf_len, offset, &cert_count);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse Insert Key Command
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_CMD_AUT_DAT):
+                        hdr_len = parse_aut_dat_cmd(&csf[offset], csf_len, offset);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse Authenticate Data Command
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_CMD_INIT):
+                case (HAB_CMD_UNLK):
+                        hdr_len = parse_unlock_cmd(&csf[offset], csf_len, offset);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse Unlock Command
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_CMD_SET):
+                        hdr_len = parse_set_cmd(&csf[offset], csf_len, offset);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse Set Command
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_TAG_CRT):
+                        hdr_len = parse_cert_sec(&csf[offset], csf_len, offset);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse Certificate Section
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_TAG_SIG):
+                        hdr_len = parse_sig_sec(&csf[offset], csf_len, offset, &sig_count);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse Signature Section
");
+                                return FAIL;
+                        }
+                        break;
+                case (HAB_TAG_MAC):
+                        hdr_len = parse_mac_sec(&csf[offset], csf_len, offset);
+                        if (!hdr_len) {
+                                puts("Error: Couldn't parse MAC Section
");
+                                return FAIL;
+                        }
+                        break;
+                default :
+                        puts("Error : Unrecognized tag
");
+                        return FAIL;
+                }
+
+                offset +=hdr_len;
+
+        } while(offset < csf_len);
+
+        if (debug_log) {
+                fprintf(fp_debug, "
final offset = 0x%X csf_len = 0x%X
", offset, csf_len);
+        }
+        return PASS;
+}
+
+/*
+ * Description : This function reads the inputs file and returns size
+ *
+ * @Inputs  : fp         - Input file pointer
+ *            input_file - Input file name
+ *
+ * @Outputs : return File size
+ *
+ */
+static int read_file(FILE **fp, char *input_file)
+{
+        int ret = 0;
+
+        /* Open file */
+        *fp = fopen(input_file, "r");
+        if (*fp == NULL) {
+                fprintf(stderr, "Couldn't open file %s; %s
", input_file, strerror(errno));
+                return -1;
+        }
+
+        /* Seek to the end of file to calculate size */
+        if (fseek(*fp , 0 , SEEK_END)) {
+                errno = ENOENT;
+                fprintf(stderr, "Couldn't seek to end of file %s; %s
", input_file, strerror(errno));
+                return -1;
+        }
+
+        /* Get size and go back to start of the file */
+        ret = ftell(*fp);
+        rewind(*fp);
+
+        return ret;
+}
+
+/*
+ * Description : Prints the usage information for running csf_parser
+ *
+ * @Outputs : The usage info will be printed out on console window.
+ */
+static void print_usage(void) {
+        puts("Usage: csf_parser [-d] [[-s <signed_image>] | [-c <csf_binary>]]
"
+		"options:
"
+                "        -d|--enable-debug     -->	Enable Debug information
"
+                "        -s|--signed-image     -->	Input signed image
"
+                "        -c|--csf-binary       -->	Input CSF binary
"
+                "
Note: Only one image can be parsed at once.
");
+}
+
+int main(int argc , char *argv[])
+{
+        FILE *fp;
+        uint8_t *buf = NULL;
+        size_t result;
+        int file_size = 0, csf_len = 0;
+        const uint8_t *csf;
+        const char *output_folder;
+        struct stat sb;
+        int next_opt = 0;
+        int mandatory_opt = 0;
+
+        /* Initialize debug info variable */
+        debug_log = 0;
+
+        /* Check for minimum arguments */
+        if (argc < 2 || argc > 4) {
+                puts("Error: Either -s or -c option required
");
+                print_usage();
+                exit(EXIT_FAILURE);
+        }
+
+        /* Create output folder */
+        output_folder = "output";
+        if (stat(output_folder, &sb) == -1)
+                mkdir("output", 0700);
+
+        /* Create Parsed output file */
+        fp_output = fopen("output/parsed_output.txt", "w");
+        if (fp_output == NULL) {
+                puts("Error: Couldn't create parsed_output file
");
+                exit(EXIT_FAILURE);
+        }
+
+        /* Perform actions according to command-line option */
+        do
+        {
+                next_opt = getopt_long(argc, argv, short_opt, long_opt, NULL);
+                switch (next_opt)
+                {
+                /* Enable Debug */
+                case 'd':
+                        mandatory_opt += 0;
+                        debug_log = 1;
+                        /* Create debug output file */
+                        fp_debug = fopen("output/debug_log.txt", "w");
+                        if (fp_debug == NULL) {
+                                puts("Error: Couldn't create debug output file
");
+                                exit(EXIT_FAILURE);
+                        }
+                        break;
+                /* Get file size of signed image */
+                case 's':
+                /* Get file size of CSF binary */
+                case 'c':
+                        mandatory_opt += 1;
+                        file_size = read_file(&fp, optarg);
+                        if (file_size < 0) {
+                                fprintf(stderr, "File read error; %s
", strerror(errno));
+                                exit(EXIT_FAILURE);
+                        }
+                        break;
+                /* Display usage */
+                case 'h':
+                        print_usage();
+                        exit(EXIT_FAILURE);
+                        break;
+                /* Invalid option */
+                default:
+                        break;
+                }
+        } while (next_opt != -1);
+
+        if (mandatory_opt != 1) {
+                puts("Error: Either -s or -c option required
");
+                print_usage();
+                exit(EXIT_FAILURE);
+        }
+
+        /* Allocate memory to the buffer */
+        buf = malloc(file_size);
+        if (buf == NULL || buf == 0) {
+                fprintf(stderr, "Error allocating memory; %s
", strerror(errno));
+                goto err;
+        }
+
+        /* Copy the file into the buffer */
+        result = fread(buf,1,file_size,fp);
+        if (result != file_size) {
+                fprintf(stderr, "File read error; %s
", strerror(errno));
+                goto err;
+        }
+
+        fclose(fp);
+
+        /* Start from the first command-line option */
+        optind = 0;
+        /* Extract and/or Parse CSF based on command-line option */
+        do
+        {
+                next_opt = getopt_long(argc, argv, short_opt, long_opt, NULL);
+                switch (next_opt)
+                {
+                /* Extract CSF and parse CSF binary */
+                case 's':
+                        /* Extract the CSF */
+                        csf = extract_csf(buf, file_size, &csf_len);
+                        if (csf == NULL) {
+                                /* An issue with extracting CSF occured */
+                                puts("Error: CSF extraction failed.
");
+                                goto err;
+                        }
+
+                        /* Parse CSF binary */
+                        result = parse_csf(csf, csf_len);
+                        if (result == FAIL) {
+                                puts("Error: CSF Parse failed.
");
+                                goto err;
+                        }
+                        break;
+                /* Parse CSF binary */
+                case 'c':
+                        csf = (uint8_t *) buf;
+                        /* Parse CSF binary */
+                        result = parse_csf(csf, file_size);
+                        if (result == FAIL) {
+                                puts("Error: CSF Parse failed.
");
+                                goto err;
+                        }
+                        break;
+                default:
+                        break;
+                }
+        } while (next_opt != -1);
+
+        return EXIT_SUCCESS;
+
+err:
+        if (debug_log) {
+                fclose(fp_debug);
+        }
+        fclose(fp_output);
+        free(buf);
+        return EXIT_FAILURE;
+}
diff --git a/release/code/hab_csf_parser/csf_parser.h b/release/code/hab_csf_parser/csf_parser.h
new file mode 100644
index 0000000..480812b
--- /dev/null
+++ b/release/code/hab_csf_parser/csf_parser.h
@@ -0,0 +1,353 @@
+/*
+ * Copyright 2017-2018 NXP
+ */
+
+#ifndef CSF_PARSER_H
+#define CSF_PARSER_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <sys/stat.h>
+#include <getopt.h>
+
+#define PASS 1
+#define FAIL 0
+
+/* For little endian systems */
+#define from_be32(x) \
+        ((((x) & 0x000000ff) << 24) | \
+        (((x) & 0x0000ff00) << 8 ) | \
+        (((x) & 0x00ff0000) >> 8 ) | \
+        (((x) & 0xff000000) >> 24))
+
+#define assert(x)       if ((x) == 0) { \
+                                printf("ASSERT failed at %s:%d
", __FUNCTION__, __LINE__);    \
+                                exit(2); \
+                        }
+
+#define validate(x,y)   if ((x) == 0) { \
+                                printf("Invalid "y" in function %s
", __FUNCTION__); \
+                                return FAIL; \
+                        }
+
+/* Write to file */
+#define w2f_hdr(x)      do { if(fp_output) { \
+                                fprintf(fp_output, x"	VALUE		DEFINITION		DESCRIPTION
"); \
+                                fprintf(fp_output, "----------------------------------------------------------------------
"); \
+                           } \
+                        } while(0);
+
+
+/*******************************************************************************
+                        MACROS
+*******************************************************************************/
+
+#define IVT_HDR_VAL         0x402000d1
+#define IVT_HDR_MASK        0xf0ffffff
+
+#define HAB_HDR_LEN(h) ((((uint8_t *)&((h)->len))[0] << 8)    \
+                        | (((uint8_t *)&((h)->len))[1]))
+
+#define CHECK_BIT(x,y)  (x & y) == y
+
+#define getAbs(x) (HAB_HDR_LEN(x) & 3)
+
+#define MAX_STRING_LENGTH       30
+#define MIN_AUT_DAT_CMD_LEN     12
+#define MIN_UNLK_CMD_LEN        8
+#define HAB_ENG_CONF_MASK       0xDB
+#define HAB_HDR_SIZE            4
+#define HAB_UNLK_FEAT_MASK      0xF
+
+/************************
+        HAB tags
+************************/
+#define HAB_TAG_IVT      0xD1 /* Image Vector Table HAB_TAG_IVT */
+#define HAB_TAG_DCD      0xD2 /* Device Configuration Data HAB_TAG_DCD */
+#define HAB_TAG_CSF      0xD4 /* Command Sequence File HAB_TAG_CSF */
+#define HAB_TAG_CRT      0xD7 /* Certificate HAB_TAG_CRT */
+#define HAB_TAG_SIG      0xD8 /* Signature HAB_TAG_SIG */
+#define HAB_TAG_MAC      0xAC /* Message Authentication Code */
+
+#define HAB_CMD_INS_KEY  0xBE /* Insert key command HAB_CMD_INS_KEY */
+#define HAB_CMD_AUT_DAT  0xCA /* Authenticate Data command HAB_CMD_AUT_DAT */
+#define HAB_CMD_SET      0xB1 /* Set command HAB_CMD_SET */
+#define HAB_CMD_WRT_DAT  0xCC /* Write Data command HAB_CMD_WRT_DAT */
+//#define HAB_CMD_CHK_DAT  0xCF /* Check Data HAB_CMD_CHK_DAT */
+//#define HAB_CMD_NOP      0xC0 /* No Operation command HAB_CMD_NOP */
+#define HAB_CMD_INIT     0xB4 /* Initialize command HAB_CMD_INIT */
+#define HAB_CMD_UNLK     0xB2 /* Unlock command HAB_CMD_UNLK */
+
+#define HAB_KEY_PUBLIC   0xE1 /* Public Key HAB_KEY_PUBLIC */
+#define HAB_KEY_SECRET   0xE2 /* Secret Key HAB_KEY_SECRET */
+#define HAB_KEY_MASTER   0xED /* Master Key Encryption Key HAB_KEY_MASTER */
+#define HAB_KEY_HASH     0xEE /* Hash HAB_KEY_HASH */
+
+/************************
+        HAB version flags
+************************/
+
+#define HAB_VER_40      0x40 /* HAB 4.0: 0x40 */
+#define HAB_VER_41      0x41 /* HAB 4.1: 0x41 */
+#define HAB_VER_42      0x42 /* HAB 4.2: 0x42 */
+
+/************************
+        HAB engines
+************************/
+
+#define HAB_ENG_ANY      0x00 /* Any HAB will chose the most appropriate engine */
+#define HAB_ENG_CAAM     0x1D /* CAAM HAB_ENG_CAAM */
+#define HAB_ENG_SNVS     0x1E /* Secure Non-Volatile Storage HAB_ENG_SNVS */
+#define HAB_ENG_OCOTP    0x21 /* On Chip OTP memory HAB_ENG_OCOTP */
+#define HAB_ENG_SW       0xFF /* Software Engine HAB_ENG_SW */
+#define HAB_ENG_SAHARA   0x06 /* Crypto accelerator */
+#define HAB_ENG_SCC      0x03 /* Security controller */
+#define HAB_ENG_DCP      0x1b /* Data Co-Processor */
+#define HAB_ENG_RTIC     0x05 /* Run-time integrity checker */
+
+/************************
+        HAB engine configurations
+************************/
+
+#define HAB_ANY_CONF_DEFAULT  0x00 /* ANY 0x00 */
+#define HAB_CAAM_DEFAULT      0x00 /* Default: 0x00 */
+#define HAB_CAAM_IN_SWAP8     0x01 /* IN SWAP8: 0x01 */
+#define HAB_CAAM_IN_SWAP16    0x02 /* IN SWAP16: 0x02 */
+#define HAB_CAAM_OUT_SWAP8    0x08 /* OUT SWAP8: 0x08 */
+#define HAB_CAAM_OUT_SWAP16   0x10 /* OUT SWAP16: 0x10 */
+#define HAB_CAAM_DSC_SWAP8    0x40 /* DSC SWAP8: 0x40 */
+#define HAB_CAAM_DSC_SWAP16   0x80 /* DSC SWAP16: 0x80 */
+#define HAB_SW_CONF_DEFAULT   0x00 /* SW 0x00 */
+#define HAB_SAHARA_DEFAULT    0x00 /* Default: 0x00 */
+#define HAB_SAHARA_IN_SWAP8   0x01 /* Set MESS BYTE SWAP bit (reverse message
+                                        bytes within word on input to
+                                        SAHARA) */
+#define HAB_SAHARA_IN_SWAP16  0x02 /* Set MESS HALF WORD SWAP bit (reverse
+                                        message half-words within word on
+                                        input to SAHARA)  */
+#define HAB_SAHARA_DSC_BE8_16 0x10/**< Interpret descriptors and links as for
+                                        BE-8 16-bit memory. */
+#define HAB_SAHARA_DSC_BE8_32 0x20 /**< Interpret descriptors and links as for
+                                        BE-8 32-bit memory. */
+#define HAB_DCP_DEFAULT       0x00 /* Default: 0x00 */
+#define HAB_DCP_IN_SWAP8      0x01 /* Set INPUT BYTE SWAP bit (reverse bytes
+                                         within words on input to DCP) */
+#define HAB_DCP_IN_SWAP32     0x04 /* Set INPUT WORD SWAP bit (ignored for
+                                        hashing)  */
+#define HAB_DCP_OUT_SWAP8     0x08 /* Set OUPUT BYTE SWAP bit (reverse bytes
+                                        within words on output from DCP) */
+#define HAB_DCP_OUT_SWAP32    0x20 /* Set OUTPUT WORD SWAP bit (ignored for
+                                        hashing)  */
+#define HAB_RTIC_DEFAULT      0x00 /* Default: 0x0 */
+#define HAB_RTIC_IN_SWAP8     0x01 /* Set BYTE SWAP bit (reverse bytes within
+                                        word on input to RTIC) */
+#define HAB_RTIC_IN_SWAP16    0x02 /* Set HALF WORD SWAP bit (reverse
+                                        half-words within word on input to
+                                        RTIC)  */
+#define HAB_RTIC_OUT_SWAP8    0x08 /* Set HASH RESULT BYTE SWAP bit (reverse
+                                        bytes within word on output from RTIC) */
+#define HAB_RTIC_KEEP         0x80 /* Retain reference hash value for later
+                                        monitoring */
+
+/************************
+        HAB Insert key flags
+************************/
+
+#define HAB_CMD_INS_KEY_NO_FLAG 0x00 /* No flags */
+#define HAB_CMD_INS_KEY_ABS     0x01 /* Use absolute address for the key */
+#define HAB_CMD_INS_KEY_CSF     0x02 /* Install CSF Key */
+
+/************************
+        HAB Insert key certificate format
+************************/
+
+#define HAB_PCL_SRK     0x03 /* SRK format HAB_PCL_SRK */
+#define HAB_PCL_X509    0x09 /* X509 format HAB_PCL_X509 */
+// #define HAB_PCL_CMS     0xc5 /* CMS/PKCS#7 signature format */
+#define HAB_PCL_BLOB    0xbb /* SHW-specific wrapped key format */
+// #define HAB_PCL_AEAD    0xa3 /* Proprietary AEAD MAC format */
+
+/************************
+        HAB Insert key hash algorithm
+************************/
+
+#define HAB_ALG_NO_ALG  0x00 /* No hash algorithm */
+#define HAB_ALG_SHA1    0x11 /* SHA-1 algorithm ID */
+#define HAB_ALG_SHA256  0x17 /* SHA-256 algorithm ID */
+#define HAB_ALG_SHA512  0x1b /* SHA-512 algorithm ID */
+
+/************************
+        HAB Authenticate data flags
+************************/
+
+#define HAB_CMD_AUT_DAT_NO_FLAG         0x00 /* No flags */
+#define HAB_CMD_AUT_DAT_ABS             0x01 /* Use absolute address for the key */
+
+/************************
+        HAB Authenticate data Signature format
+************************/
+
+#define HAB_CMD_AUT_DAT_PCL_CMS         0xC5
+#define HAB_CMD_AUT_DAT_PCL_AEAD        0xA3 /* Proprietary AEAD MAC format */
+
+/************************
+        HAB Unlock command flags
+************************/
+
+#define HAB_CMD_UNLOCK_CAAM_MID       0x01 /* CAAM MID No Leave Job Ring and
+                                              DECO master ID registers unlocked. */
+#define HAB_CMD_UNLOCK_CAAM_RNG       0x02 /* RNG No Leave RNG uninstantiated */
+#define HAB_CMD_UNLOCK_CAAM_MFG       0x04 /* MFG Manufacturing Protection unlocked */
+
+#define HAB_CMD_UNLOCK_SNVS_LP_SWR    0x01 /* SNVS LP SWR Leave LP SW reset
+                                              unlocked. 0x01 */
+#define HAB_CMD_UNLOCK_SNVS_ZMK_WRITE 0x02 /* ZMK WRITE Leave Zeroisable Master
+                                              Key write unlocked. 0x02 */
+#define HAB_CMD_UNLOCK_OCOTP_FLD_RTN  0x01 /* OCOTP Field Return Leave Field
+                                              Return activation unlocked. 0x01 */
+#define HAB_CMD_UNLOCK_OCOTP_SRK_RVK  0x02 /* SRK Revoke Leave SRK revocation
+                                              unlocked. 0x02 */
+#define HAB_CMD_UNLOCK_OCOTP_SCS      0x04 /* SCS No Leave SCS register unlocked */
+#define HAB_CMD_UNLOCK_OCOTP_JTAG     0x08 /* JTAG No Unlock JTAG using SCS
+                                              HAB_JDE bit. 0x08 */
+
+#define HAB_DCP_BLOCK_MAX    6  /* Maximum on non-contiguous memory blocks
+                                   supported for DCP operations */
+#define HAB_SAHARA_BLOCK_MAX 12 /* Maximum on non-contiguous memory blocks
+                                   supported for SAHARA operations */
+#define HAB_CAAM_BLOCK_MAX   8  /* Maximum on non-contiguous memory blocks
+                                   supported for CAAM operations */
+
+/* HAB Engine variable configuration */
+#define HAB_VAR_CFG_ITM_ENG 0x03 /**< Preferred engine for a given algorithm */
+
+/************************
+        Command line arguments
+************************/
+/* Valid short command line option letters. */
+const char* const short_opt = "hds:c:";
+
+/* Valid long command line options. */
+const struct option long_opt[] =
+{
+        {"enable-debug", no_argument, 0, 'd'},
+        {"signed-image", required_argument,  0, 's'},
+        {"csf-binary", required_argument,  0, 'c'},
+        {"help", no_argument, 0, 'h'},
+        {NULL, 0, NULL, 0}
+};
+
+typedef struct __attribute__((packed)) {
+        uint32_t header;
+        uint32_t start;
+        uint32_t res1;
+        uint32_t dcd;
+        uint32_t boot_data;
+        uint32_t self;
+        uint32_t csf;
+        uint32_t res2;
+} ivt_t;
+
+/************************
+        HAB STRUCTURES
+************************/
+typedef struct __attribute__((packed)) {
+        uint8_t  tag;
+        uint16_t len;
+        uint8_t  version;
+} csf_hdr_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t tag;
+        uint16_t len;
+        uint8_t flags;
+} hab_hdr_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t cmd;
+        uint16_t len;
+        uint8_t flags;
+
+        uint8_t cert_fmt;
+        uint8_t hash_alg;
+        uint8_t src_index;
+        uint8_t tgt_index;
+
+        uint32_t key_loc;
+} csf_cmd_ins_key_t;
+
+typedef struct __attribute__((packed)) {
+        uint32_t address;
+        uint32_t size;
+} region_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t cmd;
+        uint16_t len;
+        uint8_t flags;
+
+        uint8_t key;
+        uint8_t sig_fmt;
+        uint8_t engine;
+        uint8_t eng_cfg;
+
+        uint32_t sig_loc;
+
+        region_t region[0];
+} csf_cmd_aut_dat_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t cmd;
+        uint16_t len;
+        uint8_t engine;
+        uint32_t features;
+        uint64_t uid;
+} csf_cmd_unlock_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t cmd;
+        uint16_t len;
+        uint8_t cfg_itm;
+        uint8_t res;
+        uint8_t alg;
+        uint8_t engine;
+        uint8_t eng_cfg;
+} csf_cmd_set_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t tag;
+        uint16_t len;
+        uint8_t version;
+
+        uint8_t cert[];
+} csf_sec_cert_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t tag;
+        uint16_t len;
+        uint8_t version;
+
+        uint8_t sig[];
+} csf_sec_sig_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t tag;
+        uint16_t len;
+        uint8_t version;
+
+        uint8_t res1;
+        uint8_t nonce_bytes;
+        uint8_t res2;
+        uint8_t mac_bytes;
+
+        uint8_t nonce_mac[];
+} csf_sec_mac_t;
+
+FILE *fp_output;
+extern FILE *fp_debug;
+extern int debug_log;
+
+#endif /* CSF_PARSER_H */
diff --git a/release/code/hab_csf_parser/extract_csf.c b/release/code/hab_csf_parser/extract_csf.c
new file mode 100644
index 0000000..54f8d96
--- /dev/null
+++ b/release/code/hab_csf_parser/extract_csf.c
@@ -0,0 +1,89 @@
+/*
+ * Copyright 2017-2018 NXP
+ */
+
+#include "extract_csf.h"
+
+/* @Function    : extract_csf
+ * @Description : This function parses the input image and
+ *                finds the location of csf
+ *
+ * @inputs      : buf      - Pointer to the start of image
+ *                buf_size - Length of image
+ *
+ * @Outputs     : csf_len  - Length of the CSF binary
+ *                Return location CSF or NULL if error
+ *
+ */
+const uint8_t *extract_csf(const uint8_t *buf, int buf_size, int *csf_len)
+{
+        assert(buf != NULL);
+
+        int pos = 0;
+        const ivt_t *ivt = (const ivt_t *)buf;
+        long csf_pos;
+        hab_hdr_t *hdr;
+        int csf_hdr_len;
+
+        /* Find the header of the IVT - must be on a 32 bit alignment */
+        while((ivt->header & IVT_HDR_MASK) != IVT_HDR_VAL) {
+                pos += 4;
+                if (pos > (buf_size - sizeof(ivt_t))) {
+                        puts("Reached end of file. CSF not found.
");
+                        return NULL;
+                }
+
+                ivt = (const ivt_t *)&buf[pos];
+        }
+
+        if (debug_log) {
+                fprintf(fp_debug, "
IVT : HEADER    = 0x%08X
",ivt->header);
+                fprintf(fp_debug, "      START     = 0x%08X
",ivt->start);
+                fprintf(fp_debug, "      RES1      = 0x%08X
",ivt->res1);
+                fprintf(fp_debug, "      DCD       = 0x%08X
",ivt->dcd);
+                fprintf(fp_debug, "      BOOT DATA = 0x%08X
",ivt->boot_data);
+                fprintf(fp_debug, "      SELF      = 0x%08X
",ivt->self);
+                fprintf(fp_debug, "      CSF       = 0x%08X
",ivt->csf);
+                fprintf(fp_debug, "      RES2      = 0x%08X

",ivt->res2);
+                fprintf(fp_debug, "IVT found at offset = 0x%08X
", pos);
+                fprintf(fp_debug, "
");
+        }
+
+        csf_pos = pos + (ivt->csf - ivt->self);
+        if (ivt->csf != 0 && csf_pos > (buf_size - sizeof(hab_hdr_t))) {
+                /* CSF is out of bounds */
+                puts("CSF out of bounds or non existent.
");
+                return NULL;
+        }
+
+        if (debug_log) {
+                fprintf(fp_debug, "CSF found at offset = 0x%08X
", (int)csf_pos);
+        }
+
+        hdr = (hab_hdr_t *)&buf[csf_pos];
+
+        if (hdr->tag != HAB_TAG_CSF) {
+                /* Not a CSF */
+                puts("Not a CSF.
");
+                return NULL;
+        }
+
+        csf_hdr_len = HAB_HDR_LEN(hdr);
+
+        if ((csf_pos + csf_hdr_len) < buf_size) {
+                *csf_len = buf_size - csf_pos;
+                /* Create CSF file out of Image file */
+                FILE *fp_csf = fopen("output/csf.bin", "w");
+                if (fp_csf) {
+                        fwrite(&buf[csf_pos], *csf_len, 1, fp_csf);
+                        puts("CSF file created
");
+                }
+                else
+                        puts("Unable to create CSF file
");
+
+                fclose(fp_csf);
+                return &buf[csf_pos];
+        } else {
+                return NULL;
+        }
+}
diff --git a/release/code/hab_csf_parser/extract_csf.h b/release/code/hab_csf_parser/extract_csf.h
new file mode 100644
index 0000000..463803c
--- /dev/null
+++ b/release/code/hab_csf_parser/extract_csf.h
@@ -0,0 +1,48 @@
+/*
+ * Copyright 2017-2018 NXP
+ */
+
+#ifndef CSF_PARSER_H
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+
+#define IVT_HDR_VAL         0x402000d1
+#define IVT_HDR_MASK        0xf0ffffff
+
+#define assert(x)       if ((x) == 0) { \
+                                printf("ASSERT failed at %s:%d
", __FUNCTION__, __LINE__);    \
+                                exit(2); \
+                        }
+
+#define HAB_HDR_LEN(h) ((((uint8_t *)&((h)->len))[0] << 8)    \
+                        | (((uint8_t *)&((h)->len))[1]))
+
+#define HAB_TAG_CSF      0xD4 /* Command Sequence File HAB_TAG_CSF */
+
+typedef struct __attribute__((packed)) {
+        uint32_t header;
+        uint32_t start;
+        uint32_t res1;
+        uint32_t dcd;
+        uint32_t boot_data;
+        uint32_t self;
+        uint32_t csf;
+        uint32_t res2;
+} ivt_t;
+
+typedef struct __attribute__((packed)) {
+        uint8_t tag;
+        uint16_t len;
+        uint8_t flags;
+} hab_hdr_t;
+
+int debug_log;
+FILE *fp_debug;
+
+#endif /* CSF_PARSER_H */
+
+const uint8_t *extract_csf(const uint8_t *buf, int buf_size, int *csf_len);
diff --git a/release/code/hab_srktool_scripts/README b/release/code/hab_srktool_scripts/README
new file mode 100644
index 0000000..168d274
--- /dev/null
+++ b/release/code/hab_srktool_scripts/README
@@ -0,0 +1,30 @@
+Shell scripts to create SRK fuses from SRK table and create SRK table from SRK certificates.
+
+##########################################################################
+#
+# SCRIPT:  	createSRKFuses
+#
+# DESCRIPTION:	Create SRK fuses from SRK table generated by SRKTOOL or 
+# 		createSrkTable script. This script shows steps to compute
+#		SRK fuses and can be verified against the fuses generated
+#		by SRKTOOL or createSRKTable script.
+#
+##########################################################################
+
+Usage:
+./createSRKFuses <SRK table> <Number of SRKs> <SRK key length>
+Number of SRK : 1 - 4
+SRK Key Length : 1024, 2048, 3072, 4096
+
+##########################################################################
+#
+# SCRIPT:  	createSRKTable
+#
+# DESCRIPTION: 	This script creats SRK table with input SRK certificates.
+#		Similar to what srktool does.
+#
+##########################################################################
+
+Usage:
+./createSRKTable <No. of SRKs> <SRK pub key 1> .. <SRK pub key 4>
+Number of SRK : 1 - 4
diff --git a/release/code/hab_srktool_scripts/createSRKFuses b/release/code/hab_srktool_scripts/createSRKFuses
new file mode 100755
index 0000000..d8cbe65
--- /dev/null
+++ b/release/code/hab_srktool_scripts/createSRKFuses
@@ -0,0 +1,129 @@
+#
+# Copyright 2017-2018 NXP
+#
+##########################################################################
+#!/bin/bash
+#
+# SCRIPT:  	createSRKFuses
+#
+# DESCRIPTION:	Create SRK fuses from SRK table generated by SRKTOOL or 
+# 		createSrkTable script. This script shows steps to compute
+#		SRK fuses and can be verified against the fuses generated
+#		by SRKTOOL or createSRKTable script.
+#
+##########################################################################
+
+
+#Debug
+DEBUG=0
+
+# Help
+if [[ "$1" = "-h" || "$1" = "--help" || "$1" = "" ]] ; then
+	echo
+	echo "./createSRKFuses [-h|--help] for help"
+	echo "Usage: ./createSRKFuses <SRK table> <Number of SRKs> <SRK key length>"
+	echo "Number of SRK : 1 - 4"
+	echo "SRK Key Length : 1024, 2048, 3072, 4096"
+	exit 1
+fi
+
+# Input SRK Table file
+SRKtablefile="$1"
+if [[ -n "$SRKtablefile" &&  -f "$SRKtablefile" ]] ; then
+	echo "SRK table file is $1"
+else
+	echo "File $1 doesnt exist or is empty"
+	echo
+	echo "./createSRKFuses [-h|--help] for help"
+	echo "Usage: ./createSRKFuses <SRK table> <Number of SRKs> <SRK key length>"
+	echo "Number of SRK : 1 - 4"
+	echo "SRK Key Length : 1024, 2048, 3072, 4096"
+	exit 1
+fi
+
+# Number of SRK certs
+if [[ $2 > 0 && $2 < 5 ]] ; then
+	nSRK=$2
+	echo "Number of SRKs are $nSRK"
+else
+	echo "Number of SRKs need to be between 1 and 4"
+	echo
+	echo "./createSRKFuses [-h|--help] for help"
+	echo "Usage: ./createSRKFuses <SRK table> <Number of SRKs> <SRK key length>"
+	echo "Number of SRK : 1 - 4"
+	echo "SRK Key Length : 1024, 2048, 3072, 4096"
+	exit 1
+fi
+
+# SRK key length
+lSRK=$3
+if [[ $lSRK = 1024 || $lSRK = 2048 || $lSRK = 3072 || $lSRK = 4096 ]] ; then
+	echo "SRK Key length is $lSRK"
+else
+	echo "SRK key length needs to be 1024, 2048, 3072 or 4096 bits"
+	echo
+	echo "./createSRKFuses [-h|--help] for help"
+	echo "Usage: ./createSRKFuses <SRK table> <Number of SRKs> <SRK key length>"
+	echo "Number of SRK : 1 - 4"
+	echo "SRK Key Length : 1024, 2048, 3072, 4096"
+	exit 1
+fi
+
+# Decide size of cert w.r.t SRK Key Length
+if [ $lSRK = 1024 ] ; then
+	countSize=143;
+elif [ $lSRK = 2048 ] ; then
+	countSize=271;
+elif [ $lSRK = 3072 ] ; then
+	countSize=399;
+elif [ $lSRK = 4096 ] ; then
+	countSize=527;
+fi
+
+
+# Divide SRK certificates into individual file
+i=$nSRK
+for nSRK in {1..4} ; do
+	dd if=$1 of=SRKCert$nSRK bs=1 skip=$((4+($countSize*($nSRK-1)))) count=$countSize
+	echo "File SRKCert$nSRK created"
+	if [ $nSRK = $i ] ; then
+		break
+	fi
+done
+
+#SRK certs being hashed once
+i=1
+for fSRK in SRKCert[1234] ; do
+	sha256sum $fSRK | \
+		awk '{print $1}' | \
+			perl -e 'print pack "H*", <STDIN>' | \
+				dd of=$fSRK.bin bs=1 count=32
+	echo "File $fSRK.bin created"
+	if [ $nSRK = $i ] ; then
+		break
+	fi
+	i=$((i+1))
+done
+
+#SRK certs hashed again
+cat SRKCert[1234].bin | \
+	sha256sum | awk '{print $1}' | \
+		perl -e 'print pack "H*", <STDIN>' | \
+			dd of=SRK_fuses.bin bs=1 count=32
+
+#remove all temp files
+if [ $DEBUG = 0 ]; then
+	rm -v SRKCert*
+fi
+
+if [ $DEBUG != 0 ]; then
+#hexdiff if available
+#	hexdiff SRK_fuses.bin SRK_1_2_3_4_fuse.bin
+	
+	echo "Created Hash SRK_fuses.bin"
+	hexdump SRK_fuses.bin
+	echo -n "Enter the SRK fuse filename created by SRKTOOL/createSRKTable script > "
+	read SRKfuse
+	echo "Existing Hash from SRK tool in $SRKfuse file"
+	hexdump $SRKfuse
+fi
diff --git a/release/code/hab_srktool_scripts/createSRKTable b/release/code/hab_srktool_scripts/createSRKTable
new file mode 100755
index 0000000..f3d098b
--- /dev/null
+++ b/release/code/hab_srktool_scripts/createSRKTable
@@ -0,0 +1,172 @@
+#
+# Copyright 2017-2018 NXP
+#
+##########################################################################
+#!/bin/bash
+#
+# SCRIPT:  	createSRKTable
+#
+# DESCRIPTION: 	This script creats SRK table with input SRK certificates.
+#		Similar to what srktool does.
+#
+##########################################################################
+
+
+#Debug
+DEBUG=0
+
+#remove all temp files
+if [ $DEBUG = 0 ]; then
+	rm -v temp* SRK_table.bin
+fi
+
+# Help
+if [[ "$1" = "-h" || "$1" = "--help" || "$1" = "" ]] ; then
+	echo 
+	echo "./createSRKTable [-h|--help] for help"
+	echo "Usage: createSRKTable <No. of SRKs> <SRK pub key 1> .. <SRK pub key 4>"
+	echo "Number of SRK : 1 - 4"
+	exit 1
+fi
+
+# Number of SRK certs
+if [[ $1 > 0 && $1 < 5 ]] ; then
+	nSRK=$1
+	echo "Number of SRKs are $nSRK"
+else
+	echo "Number of SRKs need to be between 1 and 4"
+	echo
+	echo "./createSRKTable [-h|--help] for help"
+	echo "Usage: createSRKTable <No. of SRKs> <SRK pub key 1> .. <SRK pub key 4>"
+	echo "Number of SRK : 1 - 4"
+	exit 1
+fi
+
+if [[ $nSRK = 1 && -n "$2" && -f "$2" && -z "$3" ]]; then
+	true
+elif [[ $nSRK = 2 && -n "$2" && -f "$2" \
+				  && -n "$3" && -f "$3" \
+				  && -z "$4" ]]; then
+	true
+elif [[ $nSRK = 3 && -n "$2" && -f "$2" \
+				  && -n "$3" && -f "$3" \
+				  && -n "$4" && -f "$4" \
+				  && -z "$5" ]]; then
+	true
+elif [[ $nSRK = 4 && -n "$2" && -f "$2" \
+				  && -n "$3" && -f "$3" \
+				  && -n "$4" && -f "$4" \
+				  && -n "$5" && -f "$5" ]]; then
+	true
+else
+	echo "Number of SRK certs entered are not equal to <No. of SRKs> argument"
+	echo
+	echo "./createSRKTable [-h|--help] for help"
+	echo "Usage: createSRKTable <No. of SRKs> <SRK pub key 1> .. <SRK pub key 4>"
+	echo "Number of SRK : 1 - 4"
+	exit 1
+fi
+
+###### DO NOT CHANGE #######
+#Macros for SRK table header
+SRKTableTag=D7
+#Macros for SRK key header and body
+SRKKeyHdrTag=E1
+SRKKeyAlg=21
+
+ExponentLength=0003
+Exponent=010001
+ModLength=0000
+
+Length=0000
+Reserved=000000
+############################
+
+# HAB Version 
+# HAB4.0 : 40
+# HAB4.1 : 41
+# HAB4.2 : 42
+SRKTableHABVer=40
+#SRK Flag---None 	: 00
+#	'---CA Flag	: 80
+SRKFlagCA=80
+
+#Prepare SRK Table header
+perl -e 'print pack "H*", '"$SRKTableTag$Length$SRKTableHABVer" > SRK_table.bin
+
+#Process each SRK Key to append in SRK table
+append_srk_key ()
+{
+	openssl x509 -modulus -noout -in $1 > temp.bin
+	modSize=`stat -c "%s" temp.bin`
+	dd if=temp.bin of=tempModSRK.bin bs=1 skip=8 count=$((modSize-8-1)) && sync
+	rm temp.bin
+	n=$2
+
+#Prepare SRK key header with Exponent header
+	printf "%s" "$SRKKeyHdrTag$Length$SRKKeyAlg$Reserved$SRKFlagCA" | \
+		perl -e 'print pack "H*", <STDIN>' > tempSRK$n.hex
+	printf "%s" "$ModLength$ExponentLength" | \
+		perl -e 'print pack "H*", <STDIN>' >> tempSRK$n.hex
+
+#Append modulus
+	cat tempModSRK.bin | perl -e 'print pack "H*", <STDIN>' >> tempSRK$n.hex
+
+#Add modulus size
+	modSize=$(printf "%x" $(($(stat -c %s "tempSRK$n.hex") - 12)))
+	printf "%04s" "$modSize" | \
+		perl -e 'print pack "H*", <STDIN>' | \
+			dd of=tempSRK$n.hex bs=1 seek=8 conv=notrunc
+
+#Append Exponent
+	printf "%04s" "$Exponent" | \
+		perl -e 'print pack "H*", <STDIN>' >> tempSRK$n.hex
+
+#Add SRK key size
+	SRKKeySize=$(printf "%x" $(stat -c %s "tempSRK$n.hex"))
+	printf "%04s" $SRKKeySize | \
+		perl -e 'print pack "H*", <STDIN>' | \
+			dd of=tempSRK$n.hex bs=1 seek=1 conv=notrunc
+	dd if=tempSRK$n.hex of=SRK_table.bin bs=1 oflag=append conv=notrunc
+
+	if [ $DEBUG = 0 ]; then
+		rm -v temp*
+	fi
+
+}
+
+#Input SRK keys
+if [[ -n "$2" && -f "$2" ]] ; then
+	append_srk_key "$2" "1"
+ if [[ -n "$3" && -f "$3" ]] ; then
+	 append_srk_key "$3" "2"
+  if [[ -n "$4" && -f "$4" ]] ; then
+	  append_srk_key "$4" "3"
+   if [[ -n "$5" && -f "$5" ]] ; then
+	   append_srk_key "$5" "4"
+   fi
+  fi
+ fi
+elif [[ "$2" = "" ]] ; then
+	echo "SRK certs $2 doesnt exist or is empty"
+	echo
+	echo "./createSRKTable [-h|--help] for help"
+	echo "Usage: createSRKTable <No. of SRKs> <SRK pub key 1> .. <SRK pub key 4>"
+	echo "Number of SRK : 1 - 4"
+	exit 1
+fi
+
+# Add SRK table size
+SRKTableSize=$(printf "%x" $(stat -c %s "SRK_table.bin"))
+printf "%04s" $SRKTableSize | \
+		perl -e 'print pack "H*", <STDIN>' | \
+			dd of=SRK_table.bin bs=1 seek=1 conv=notrunc
+
+
+if [ $DEBUG = 0 ]; then
+
+#If hexdiff utility is installed you can compare SRK table generated
+#with SRK table from SRKTOOL as follows
+
+#hexdiff SRK_table.bin SRK_1_2_3_4_table.bin
+fi
diff --git a/release/docs/CST_UG.pdf b/release/docs/CST_UG.pdf
new file mode 100755
index 0000000..26dce52
Binary files /dev/null and b/release/docs/CST_UG.pdf differ
diff --git a/release/docs/HAB4_API.pdf b/release/docs/HAB4_API.pdf
new file mode 100644
index 0000000..bd70544
Binary files /dev/null and b/release/docs/HAB4_API.pdf differ
diff --git a/release/docs/README.hab_log_parser b/release/docs/README.hab_log_parser
new file mode 100644
index 0000000..ac1c0d3
--- /dev/null
+++ b/release/docs/README.hab_log_parser
@@ -0,0 +1,105 @@
+hab_log_parser tool:
+
+********************************************************************************
+
+Introduction:
+
+ROM/HAB allocates certain memory region in Internal RAM (OCRAM) for HAB logs. This space is marked as reserved in Internal RAM memory map and must not be edited. This memory region is called HAB persistent memory. It contains certs, events and other HAB process related information.
+
+********************************************************************************
+
+Description:
+
+HAB persistent memory is used by HAB to store audit logs i.e. logs of various events and status results generated from HAB library functions. HAB uses this memory region to search through existing events to report when requested through API call. HAB stores certificate information of the keys installed as reported in the CSF file.
+
+|-------------------------------|-------------------------------|-------|
+|          Chipset              | HAB Persistent Memory Address | Size  |
+|-------------------------------|-------------------------------|-------|
+| i.MX6 S/DL/D/Q/DP/QP/         |       0x904000                | 0xB80 |
+|      UL/ULL/SL/SLL/SX	        |                               |       |
+|-------------------------------|-------------------------------|-------|
+| i.MX7 S/D                     |       0x9049C0                | 0xB80 |
+|-------------------------------|-------------------------------|-------|
+| i.MX7 ULP1 A7 B0              |       0x2F006840              | 0xB80 |
+| i.MX7 ULP1 M4 B0              |       0x20008040              | 0xB80 |
+|-------------------------------|-------------------------------|-------|
+| MSCALE 850D B0                |       0x9061C0                | 0xB80 |
+|-------------------------------|-------------------------------|-------|
+
+********************************************************************************
+
+Required packages:
+
+	libudev-dev
+	libusb-1.0-0-dev
+
+Build:
+	make
+
+********************************************************************************
+
+Clean:
+	make clean
+
+********************************************************************************
+
+Usage:
+        hab_log_parser [input] [output]
+Input:
+        -s|--sdp <device_name>: SDP mode selected with Device name required
+                 <device_name>:
+                        '-----imx6s
+                        '-----imx6dl
+                        '-----imx6q
+                        '-----imx6d
+                        '-----imx6qp
+                        '-----imx6dp
+                        '-----imx6sl
+                        '-----imx6sll
+                        '-----imx6sx
+                        '-----imx6ul
+                        '-----imx6ull
+                        '-----imx7s
+                        '-----imx7d
+                        '-----imx7ulpa7
+                        '-----imx7ulpm4
+                        '-----imx8mq
+        -b|--input-bin <input file>: Binary file containing a dump of HAB4 persistent memory contents
+        -a|--input-ascii <input file>: Binary file containing a dump of HAB4 persistent memory contents
+Output (Optional):
+        -o|--output <output>: File of the parsed HAB4 persistent memory region
+                            : If output not provided output is sent to stdout
+
+Examples:
+SDP:
+        ./hab_log_parser -s imx6s -o hab_log_parsed.txt
+Binary Input file:
+        ./hab_log_parser -b hab4_pers.bin -o hab_log_parsed.txt
+ASCII Input file:
+        ./hab_log_parser -a hab4_pers.ascii -o hab_log_parsed.txt
+
+********************************************************************************
+
+Extracting debug information:
+
+Via JTAG:
+
+Trace32 (Lauterbach):
+
+    DATA.SAVE.BINARY <filename> <hab persistent memory address>--<hab persistent memory address + size>
+
+DSTREAM (DS5):
+
+    dump binary memory <filename> <hab persistent memory address> <hab persistent memory address + size>
+
+U-Boot:
+    1- Dump persistent memory region with U-Boot md command:
+        //for imx7ulp B0 A7 (u-boot)
+        u-boot=> md.b 0x2f006840 0xb80
+
+        //for imx7ulp B0 M4 (u-boot)
+        u-boot=> md.b 0x20008040 0xb80
+
+    2- Copy the log and save in uboot_dump.txt file
+    3- Adapt U-Boot log to ASCII format
+        $ cat uboot_dump.txt | cut -c 11- | cut -c -48 > uboot_persistent_ascii.txt
diff --git a/release/keys/add_key.bat b/release/keys/add_key.bat
new file mode 100755
index 0000000..e591b22
--- /dev/null
+++ b/release/keys/add_key.bat
@@ -0,0 +1,213 @@
+@echo off
+
+::-----------------------------------------------------------------------------
+::
+:: File: add_key.bat
+::
+:: Description: This script adds a key to an existing HAB PKI tree to be used
+::              with the HAB code signing feature.  Both the private key and
+::              corresponding certificate are generated.  This script can
+::              generate new SRKs, CSF keys and Images keys for HAB3 or HAB4.
+::              This script is not intended for generating CA root keys.
+::
+::            (c) Freescale Semiconductor, Inc. 2011. All rights reserved.
+::            Copyright 2018 NXP
+::
+:: Presence of a copyright notice is not an acknowledgement of publication.
+:: This software file listing contains information of NXP that is of a
+:: confidential and proprietary nature and any viewing or use of this file is
+:: prohibited without specific written permission from NXP
+::
+::-----------------------------------------------------------------------------
+
+set /P ver="Which version of HAB do you want to generate the key for (3 = HAB3 / 4 = HAB4 / a = AHAB)?: "
+if %ver%==3 goto VALID_ver
+if %ver%==4 goto VALID_ver
+if %ver%==a goto VALID_ver
+echo Error - HAB version selected must be either 3, 4 or a
+exit /B
+:VALID_ver
+
+set /P key_name="Enter new key name (e.g. SRK5): "
+
+:: Key type
+if %ver%==3 goto KEY_TYPE_DEFAULT
+:: AHAB or HAB4
+set /P kt="Enter new key type (ecc / rsa): "
+:: Confirm that a valid key type has been entered
+if %kt%==ecc goto KEY_TYPE_DONE
+if %kt%==rsa goto KEY_TYPE_DONE
+echo Invalid key type. Supported key types: rsa, ecc
+exit /B
+:: HAB3
+:KEY_TYPE_DEFAULT
+set kt=rsa
+:KEY_TYPE_DONE
+
+:: Key length
+if not %kt%==rsa goto KEY_LENGTH_ECC
+:: RSA
+set /P kl="Enter new key length in bits: "
+:: Confirm that a valid key length has been entered
+if %kl%==2048 goto VALID_KEY_LENGTH
+if %kl%==3072 goto VALID_KEY_LENGTH
+if %kl%==4096 goto VALID_KEY_LENGTH
+echo Invalid key length. Supported key lengths: 2048, 3072, 4096
+exit /B
+:KEY_LENGTH_ECC
+:: ECC
+set /P kl="Enter new key length (p256 / p384 / p521): "
+:: Confirm that a valid key length has been entered
+if %kl%==p256 set "cn=prime256v1" & goto VALID_KEY_LENGTH
+if %kl%==p384 set "cn=secp384r1"  & goto VALID_KEY_LENGTH
+if %kl%==p521 set "cn=secp521r1"  & goto VALID_KEY_LENGTH
+echo Invalid key length. Supported key lengths: 256, 384, 521
+exit /B
+:VALID_KEY_LENGTH
+
+:: Message digest
+if not %ver%==a goto MD_DEFAULT
+:: AHAB
+set /P md="Enter new message digest (sha256, sha384, sha512): "
+:: Confirm that a valid message digest has been entered
+if %md%==sha256 goto MD_DONE
+if %md%==sha384 goto MD_DONE
+if %md%==sha512 goto MD_DONE
+echo Invalid message digest. Supported message digests: sha256, sha384, sha512
+exit /B
+:: HAB3 or HAB4
+:MD_DEFAULT
+set md=sha256
+:MD_DONE
+
+set /P duration="Enter certificate duration (years): "
+
+:: Compute validity period
+set /A val_period=%duration%*365
+
+:: ---------------- Add SRK key and certificate -------------------
+set /P srk="Is this an SRK key? "
+if %srk%==n goto GEN_CSF_IMG_SGK
+
+:: Check if SRKs should be generated as CA certs or user certs
+if %ver%==3 goto CA_DEFAULT
+set /P srk_ca="Do you want the SRK to have the CA flag set (y/n)?: "
+if %srk_ca%==y goto CA_DEFAULT
+set ca=usr
+goto CA_DONE
+:CA_DEFAULT
+set ca=ca
+:CA_DONE
+
+set /P signing_key="Enter CA signing key name: "
+set /P signing_crt="Enter CA signing certificate name: "
+goto GEN_OUTPUTS
+
+:GEN_CSF_IMG_SGK
+if %ver%==a goto GEN_SGK
+
+:: ---------------- Add CSF key and certificate -------------------
+set /P csf="Is this a CSF key?: "
+if %csf%==n goto GEN_IMG
+set /P signing_key="Enter SRK signing key name: "
+set /P signing_crt="Enter SRK signing certificate name: "
+if %ver%==4 set ca=usr
+if %ver%==3 set ca=ca
+goto GEN_OUTPUTS
+
+:GEN_IMG
+:: ---------------- Add IMG key and certificate -------------------
+set ca=usr
+if %ver%==3 goto GEN_IMG_HAB3
+set /P signing_key="Enter SRK signing key name: "
+set /P signing_crt="Enter SRK signing certificate name: "
+goto GEN_OUTPUTS
+:GEN_IMG_HAB3
+set /P signing_key="Enter CSF signing key name: "
+set /P signing_crt="Enter CSF signing certificate name: "
+goto GEN_OUTPUTS
+
+:GEN_SGK
+:: ---------------- Add SGK key and certificate -------------------
+set ca="usr"
+set /P signing_key="Enter SRK signing key name: "
+set /P signing_crt="Enter SRK signing certificate name: "
+goto GEN_OUTPUTS
+
+:GEN_OUTPUTS
+:: ---------------- Generate outputs ------------------------------
+
+:: Generate key
+if %kt%==rsa goto GEN_KEY_RSA
+set key_fullname=%key_name%_%md%_%cn%_v3_%ca%
+:: Generate Elliptic Curve parameters
+openssl ecparam -out .\%key_fullname%_key.pem -name %cn% -genkey
+:: Generate ECC key
+openssl ec -in .\%key_fullname%_key.pem -des3 -passout file:.\key_pass.txt ^
+    -out .\%key_fullname%_key.pem
+goto GEN_KEY_DONE
+:GEN_KEY_RSA
+set key_fullname=%key_name%_%md%_%kl%_65537_v3_%ca%
+set wtls_name=%key_name%_%md%_%kl%_65537_wtls.crt
+:: Generate RSA key
+openssl genrsa -des3 -passout file:.\key_pass.txt -f4 ^
+    -out .\%key_fullname%_key.pem %kl%
+:GEN_KEY_DONE
+
+:: Generate certificate signing request
+openssl req -new -batch -passin file:.\key_pass.txt ^
+    -subj /CN=%key_fullname%/ ^
+    -key .\%key_fullname%_key.pem ^
+    -out .\%key_fullname%_req.pem
+
+:: Generate certificate
+openssl ca -batch -passin file:.\key_pass.txt ^
+    -md %md% -outdir . ^
+    -in .\%key_fullname%_req.pem ^
+    -cert %signing_crt% ^
+    -keyfile %signing_key% ^
+    -extfile ..