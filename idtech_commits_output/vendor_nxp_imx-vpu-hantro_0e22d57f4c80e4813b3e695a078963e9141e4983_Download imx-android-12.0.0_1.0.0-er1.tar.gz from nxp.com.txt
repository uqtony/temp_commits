0e22d57 jenkins 2022-02-18

Download imx-android-12.0.0_1.0.0-er1.tar.gz from nxp.com

Change-Id: Ic467bb1060c3f22fa1e521f50950c730d9e23a70

diff --git a/decoder_sw/software/linux/dwl/dwl_linux.c b/decoder_sw/software/linux/dwl/dwl_linux.c
index 7d5e33b..60757c8 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux.c
@@ -47,15 +47,17 @@
 #ifdef USE_ION
 #include <linux/dma-buf.h>
 #include <linux/version.h>
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0) || defined(ENABLE_DMABUF_HEAP)
 #include <linux/dma-heap.h>
 #else
 #include <linux/ion.h>
 #endif
 #ifdef ANDROID
+#if !defined(ENABLE_DMABUF_HEAP)
 #include <linux/mxc_ion.h>
 #include <ion_4.12.h>
 #endif
+#endif
 #ifdef CFG_SECURE_DATA_PATH
 #include <linux/secure_ion.h>
 #endif
@@ -64,6 +66,10 @@
 #endif  //USE_ION
 #include "sw_util.h"
 
+#ifdef ENABLE_DMABUF_HEAP
+#include <linux/dma-buf-imx.h>
+#endif
+
 #include <assert.h>
 #include <errno.h>
 #include <fcntl.h>
@@ -86,6 +92,7 @@
 #include "internal_test.h"
 #endif
 
+
 #define DWL_PJPEG_E 22    /* 1 bit */
 #define DWL_REF_BUFF_E 20 /* 1 bit */
 
@@ -204,7 +211,7 @@ static void PrintIrqType(u32 core_id, u32 status) {
 }
 #endif
 
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
 u32 *DWLReadRegisters(int mem_dev, unsigned int core_id, unsigned int reg_size)
 {
   const char *io = NULL;
@@ -725,7 +732,7 @@ void DWLReadAsicConfig(DWLHwConfig *hw_cfg,u32 client_type) {
     goto end;
   }
   
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
   io = DWLReadRegisters(fd_dec,core_id, reg_size);
   if (io == NULL) {
     DWL_DEBUG("%s","failed to read registers
");
@@ -745,7 +752,7 @@ void DWLReadAsicConfig(DWLHwConfig *hw_cfg,u32 client_type) {
   ReadCoreConfig(io, hw_cfg);
   asic_cfg_info[idx].cfg = *hw_cfg; /*store the value*/
 
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
   DWLfree(io);
 #else
   DWLUnmapRegisters(io, reg_size);
@@ -806,7 +813,7 @@ void DWLReadMCAsicConfig(DWLHwConfig hw_cfg[MAX_ASIC_CORES]) {
   memset(hw_cfg, 0, MAX_ASIC_CORES * sizeof(*hw_cfg));
 
   for (i = 0; i < n_cores; i++) {
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
     io = DWLReadRegisters(fd_dec,i, reg_size);
     if (io == NULL) {
       DWL_DEBUG("%s","failed to read registers
");
@@ -822,7 +829,7 @@ void DWLReadMCAsicConfig(DWLHwConfig hw_cfg[MAX_ASIC_CORES]) {
 
     ReadCoreConfig(io, hw_cfg + i);
 
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
     DWLfree(io);
 #else
     DWLUnmapRegisters(io, reg_size);
@@ -882,7 +889,7 @@ void DWLReadAsicFuseStatus(struct DWLHwFuseStatus *hw_fuse_sts) {
     goto end;
   }
 
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
   io = DWLReadRegisters(fd_dec,0, reg_size);
   if (io == NULL) {
     DWL_DEBUG("%s","failed to read registers
");
@@ -899,7 +906,7 @@ void DWLReadAsicFuseStatus(struct DWLHwFuseStatus *hw_fuse_sts) {
   /* Decoder fuse configuration */
   ReadCoreFuse(io, hw_fuse_sts);
 
-#ifdef CFG_SECURE_DATA_PATH
+#if defined(CFG_SECURE_DATA_PATH) || defined(CFG_SECURE_IOCTRL_REGS)
   DWLfree(io);
 #else
   DWLUnmapRegisters(io, reg_size);
@@ -1104,7 +1111,7 @@ bail:
 #endif
 }
 
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)) //LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)) && !defined(ENABLE_DMABUF_HEAP) // LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
 i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
   struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
@@ -1258,12 +1265,13 @@ bail:
   return DWL_ERROR;
 }
 
-#else //(LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+#elif (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)) || defined(ENABLE_DMABUF_HEAP) //(LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
 i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
   struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
   struct dma_heap_allocation_data data = { 0 };
   struct dma_buf_phys dma_phys;
   u32 pgsize = getpagesize();
+  int mem_fd = -1;
   int ret;
 
   assert(dec_dwl != NULL);
@@ -1283,20 +1291,71 @@ i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
   data.len = info->size,
   data.fd_flags = O_RDWR | O_CLOEXEC;
   data.heap_flags = 0;
-  ret = ioctl (dec_dwl->fd_memalloc, DMA_HEAP_IOCTL_ALLOC, &data);
+
+  switch(info->mem_type) {
+    case DWL_MEM_TYPE_CPU:
+    case DWL_MEM_TYPE_VPU_WORKING:
+    case DWL_MEM_TYPE_VPU_WORKING_SPECIAL:
+      mem_fd = dec_dwl->fd_memalloc;
+      break;
+    case DWL_MEM_TYPE_DPB:
+    case DWL_MEM_TYPE_VPU_ONLY:
+    case DWL_MEM_TYPE_SLICE:
+      if (dec_dwl->use_secure_mode) {
+        mem_fd = dec_dwl->fd_mem_sec;
+      } else {
+        mem_fd = dec_dwl->fd_memalloc;
+      }
+      break;
+    default:
+      if (dec_dwl->use_secure_mode) {
+        DWL_DEBUG("ERROR! Incorrect memory type
");
+        return DWL_ERROR;
+      } else {
+        mem_fd = dec_dwl->fd_memalloc;
+        break;
+      }
+  }
+
+  ret = ioctl (mem_fd, DMA_HEAP_IOCTL_ALLOC, &data);
   if (ret < 0) {
-    DWL_DEBUG("ion allocate failed. 
");
+    DWL_DEBUG("dma-buf allocate failed. 
");
     return DWL_ERROR;
   }
-  info->ion_fd = data.fd;
 
+  info->ion_fd = data.fd;
   ret = ioctl(info->ion_fd, DMA_BUF_IOCTL_PHYS, &dma_phys);
   if (ret < 0) {
+#ifdef ENABLE_DMABUF_HEAP
+    DWL_DEBUG("ion DMA_BUF_IOCTL_PHYS get phys failed. 
");
+    struct dmabuf_imx_phys_data data;
+    int fd_;
+    fd_ = open("/dev/dmabuf_imx", O_RDONLY | O_CLOEXEC);
+    if (fd_ < 0) {
+        DWL_DEBUG("open /dev/dmabuf_imx failed: %s", strerror(errno));
+        goto bail;
+    }
+
+    data.dmafd = info->ion_fd;
+    if (ioctl(fd_, DMABUF_GET_PHYS, &data) < 0) {
+        DWL_DEBUG("%s ION_GET_PHYS  failed",__func__);
+        close(fd_);
+        goto bail;
+    } else {
+        info->bus_address = data.phys;
+    }
+
+    close(fd_);
+  } else {
+    info->bus_address = dma_phys.phys;
+  }
+#else
     DWL_DEBUG("ion get phys failed. 
");
     goto bail;
   }
 
   info->bus_address = dma_phys.phys;
+#endif
 
   DWL_DEBUG("DWLMallocLinear	 mem_type %d
", info->mem_type);
   DWL_DEBUG("DWLMallocLinear	 physical address: %p
", info->bus_address);
@@ -1305,14 +1364,22 @@ i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
     case DWL_MEM_TYPE_CPU:
     case DWL_MEM_TYPE_VPU_WORKING:
     case DWL_MEM_TYPE_VPU_WORKING_SPECIAL:
+      info->virtual_address =
+      (u32 *)mmap(0, info->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+                  info->ion_fd, 0);
+      break;
 #ifndef CFG_SECURE_DATA_PATH
     case DWL_MEM_TYPE_DPB:
     case DWL_MEM_TYPE_VPU_ONLY:
     case DWL_MEM_TYPE_SLICE:
 #endif
-      info->virtual_address =
-      (u32 *)mmap(0, info->size, PROT_READ | PROT_WRITE, MAP_SHARED,
-                  info->ion_fd, 0);
+      if (dec_dwl->use_secure_mode) {
+        info->virtual_address = NULL;
+      } else {
+        info->virtual_address =
+        (u32 *)mmap(0, info->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+                    info->ion_fd, 0);
+      }
       break;
     default:
       info->virtual_address = NULL;
@@ -1410,32 +1477,11 @@ void DWLFreeLinear(const void *instance, struct DWLLinearMem *info) {
   assert(info != NULL);
 
 #ifdef USE_ION
-  switch(info->mem_type) {
-    case DWL_MEM_TYPE_CPU:
-    case DWL_MEM_TYPE_VPU_WORKING:
-    case DWL_MEM_TYPE_VPU_WORKING_SPECIAL:
-#ifndef CFG_SECURE_DATA_PATH
-    case DWL_MEM_TYPE_DPB:
-    case DWL_MEM_TYPE_VPU_ONLY:
-    case DWL_MEM_TYPE_SLICE:
-#endif // CFG_SECURE_DATA_PATH
-      if (info->virtual_address != NULL) {
-        munmap(info->virtual_address, info->size);
-	info->virtual_address = NULL;
-	info->bus_address = 0;
-      }
-      break;
-#ifdef CFG_SECURE_DATA_PATH
-    case DWL_MEM_TYPE_DPB:
-    case DWL_MEM_TYPE_VPU_ONLY:
-    case DWL_MEM_TYPE_SLICE:
-      break;
-#endif // CFG_SECURE_DATA_PATH
-    default:
-      DWL_DEBUG("ERROR! Incorrect memory type
");
-      return;
+  if (info->virtual_address != NULL) {
+    munmap(info->virtual_address, info->size);
+    info->virtual_address = NULL;
   }
-
+  info->bus_address = 0;
   if (info->ion_fd >= 0)
     close(info->ion_fd);
 #else // USE_ION
diff --git a/decoder_sw/software/linux/dwl/dwl_linux.h b/decoder_sw/software/linux/dwl/dwl_linux.h
index a2e0693..80208cb 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux.h
+++ b/decoder_sw/software/linux/dwl/dwl_linux.h
@@ -78,6 +78,16 @@
 #endif
 #endif
 
+#ifdef ENABLE_DMABUF_HEAP
+#undef MEMALLOC_MODULE_PATH
+#define MEMALLOC_MODULE_PATH "/dev/dma_heap/reserved-uncached"
+#endif
+
+#ifdef ENABLE_SEC_DMABUF_HEAP
+#undef MEMALLOC_SECURE_MODULE_PATH
+#define MEMALLOC_SECURE_MODULE_PATH "/dev/dma_heap/secure"
+#endif
+
 #define HANTRODECPP_REG_START 0x400
 #define HANTRODEC_REG_START 0x4
 
@@ -124,6 +134,7 @@ struct HANTRODWL {
   int fd;          /* decoder device file */
   int fd_mem;      /* /dev/mem for mapping */
   int fd_memalloc; /* linear memory allocator */
+  int fd_mem_sec;  /* linear memory allocator of secure dma-buf */
   u32 num_cores;
   u32 reg_size;         /* IO mem size */
   addr_t free_lin_mem;     /* Start address of free linear memory */
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_hw.c b/decoder_sw/software/linux/dwl/dwl_linux_hw.c
index 63d71c2..8a81220 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_hw.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_hw.c
@@ -72,6 +72,11 @@ const char *dec_dev = DEC_MODULE_PATH;
 /* the memalloc device driver nod */
 const char *mem_dev = MEMALLOC_MODULE_PATH;
 
+#ifdef ENABLE_SEC_DMABUF_HEAP
+/* the secure memalloc device driver nod */
+const char *mem_sec_dev = MEMALLOC_SECURE_MODULE_PATH;
+#endif
+
 /* counters for core usage statistics */
 u32 core_usage_counts[MAX_ASIC_CORES] = {0};
 
@@ -113,6 +118,7 @@ const void *DWLInit(struct DWLInitParam *param) {
   dec_dwl->fd = -1;
   dec_dwl->fd_mem = -1;
   dec_dwl->fd_memalloc = -1;
+  dec_dwl->fd_mem_sec = -1;
 
   /* open the device */
   dec_dwl->fd = open(dec_dev, O_RDWR);
@@ -125,11 +131,17 @@ const void *DWLInit(struct DWLInitParam *param) {
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
     /* open memalloc for linear memory allocation */
     dec_dwl->fd_memalloc = open(mem_dev, O_RDWR | O_SYNC);
-
     if (dec_dwl->fd_memalloc == -1) {
       DWL_DEBUG("failed to open: %s
", mem_dev);
       goto err;
     }
+#ifdef ENABLE_SEC_DMABUF_HEAP
+    dec_dwl->fd_mem_sec = open(mem_sec_dev, O_RDWR | O_SYNC);
+    if (dec_dwl->fd_mem_sec == -1) {
+      DWL_DEBUG("failed to open: %s
", mem_sec_dev);
+      goto err;
+    }
+#endif
   }
 #ifdef USE_VSI_ENV
   dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
@@ -235,6 +247,8 @@ i32 DWLRelease(const void *instance) {
   /* linear memory allocator */
   if (dec_dwl->fd_memalloc != -1) close(dec_dwl->fd_memalloc);
 
+  if (dec_dwl->fd_mem_sec != -1) close(dec_dwl->fd_mem_sec);
+
   /* print core usage stats */
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
     u32 total_usage = 0;
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_mc.c b/decoder_sw/software/linux/dwl/dwl_linux_mc.c
index 3147955..734b4f3 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_mc.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_mc.c
@@ -68,6 +68,11 @@ const char *dec_dev = DEC_MODULE_PATH;
 /* the memalloc device driver nod */
 const char *mem_dev = MEMALLOC_MODULE_PATH;
 
+#ifdef ENABLE_SEC_DMABUF_HEAP
+/* the secure memalloc device driver nod */
+const char *mem_sec_dev = MEMALLOC_SECURE_MODULE_PATH;
+#endif
+
 /* counters for core usage statistics */
 u32 core_usage_counts[MAX_ASIC_CORES] = {0};
 
@@ -198,6 +203,7 @@ const void *DWLInit(struct DWLInitParam * param) {
   dec_dwl->fd = -1;
   dec_dwl->fd_mem = -1;
   dec_dwl->fd_memalloc = -1;
+  dec_dwl->fd_mem_sec = -1;
 
   /* open the device */
   dec_dwl->fd = open(dec_dev, O_RDWR);
@@ -210,11 +216,17 @@ const void *DWLInit(struct DWLInitParam * param) {
   if(dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
     /* open memalloc for linear memory allocation */
     dec_dwl->fd_memalloc = open(mem_dev, O_RDWR | O_SYNC);
-
     if(dec_dwl->fd_memalloc == -1) {
       DWL_DEBUG("failed to open: %s
", mem_dev);
       goto err;
     }
+#ifdef ENABLE_SEC_DMABUF_HEAP
+    dec_dwl->fd_mem_sec = open(mem_sec_dev, O_RDWR | O_SYNC);
+    if (dec_dwl->fd_mem_sec == -1) {
+      DWL_DEBUG("failed to open: %s
", mem_sec_dev);
+      goto err;
+    }
+#endif
   }
 #ifdef USE_VSI_ENV
   dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
@@ -346,6 +358,8 @@ i32 DWLRelease(const void *instance) {
   if(dec_dwl->fd_memalloc != -1)
     close(dec_dwl->fd_memalloc);
 
+  if (dec_dwl->fd_mem_sec != -1)
+    close(dec_dwl->fd_mem_sec);
 
   /* print core usage stats */
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_sc.c b/decoder_sw/software/linux/dwl/dwl_linux_sc.c
index d1811f3..7b64fc3 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_sc.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_sc.c
@@ -65,6 +65,11 @@ const char *dec_dev = DEC_MODULE_PATH;
 /* the memalloc device driver nod */
 const char *mem_dev = MEMALLOC_MODULE_PATH;
 
+#ifdef ENABLE_SEC_DMABUF_HEAP
+/* the secure memalloc device driver nod */
+const char *mem_sec_dev = MEMALLOC_SECURE_MODULE_PATH;
+#endif
+
 /* a mutex protecting the wrapper init */
 static pthread_mutex_t x170_init_mutex = PTHREAD_MUTEX_INITIALIZER;
 
@@ -104,6 +109,7 @@ const void *DWLInit(struct DWLInitParam * param) {
   dec_dwl->fd = -1;
   dec_dwl->fd_mem = -1;
   dec_dwl->fd_memalloc = -1;
+  dec_dwl->fd_mem_sec = -1;
 
   /* open the device */
   dec_dwl->fd = open(dec_dev, O_RDWR);
@@ -114,13 +120,19 @@ const void *DWLInit(struct DWLInitParam * param) {
 
   /* Linear memories not needed in pp */
   if(dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
-	/* open memalloc for linear memory allocation */
-	dec_dwl->fd_memalloc = open(mem_dev, O_RDWR | O_SYNC);
-
-	if(dec_dwl->fd_memalloc == -1) {
-	  DWL_DEBUG("failed to open: %s
", mem_dev);
-	  goto err;
-	}
+    /* open memalloc for linear memory allocation */
+    dec_dwl->fd_memalloc = open(mem_dev, O_RDWR | O_SYNC);
+    if(dec_dwl->fd_memalloc == -1) {
+      DWL_DEBUG("failed to open: %s
", mem_dev);
+      goto err;
+    }
+#ifdef ENABLE_SEC_DMABUF_HEAP
+    dec_dwl->fd_mem_sec = open(mem_sec_dev, O_RDWR | O_SYNC);
+    if (dec_dwl->fd_mem_sec == -1) {
+      DWL_DEBUG("failed to open: %s
", mem_sec_dev);
+      goto err;
+    }
+#endif
   }
 #ifdef USE_VSI_ENV
   dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
@@ -222,6 +234,7 @@ i32 DWLRelease(const void *instance) {
 
   /* linear memory allocator */
   if (dec_dwl->fd_memalloc != -1) close(dec_dwl->fd_memalloc);
+  if (dec_dwl->fd_mem_sec != -1) close(dec_dwl->fd_mem_sec);
 
   /* print core usage stats */
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
diff --git a/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c b/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
index 93136f1..a0adf29 100755
--- a/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
+++ b/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
@@ -193,7 +193,6 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
   /* Variables */
 
   u32 tmp, i, value;
-  u32 invalid_dpb_size = 0;
 
   /* Code */
 
@@ -486,7 +485,6 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
                  p_seq_param_set->num_ref_frames));
     /* set max_dpb_size to 1 if num_ref_frames is zero */
     value = p_seq_param_set->num_ref_frames ? p_seq_param_set->num_ref_frames : 1;
-    invalid_dpb_size = 1;
   }
   p_seq_param_set->max_dpb_size = value;
 
@@ -517,23 +515,6 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
       return(tmp);
     /* check num_reorder_frames and max_dec_frame_buffering */
     if (p_seq_param_set->vui_parameters->bitstream_restriction_flag) {
-      if (p_seq_param_set->vui_parameters->num_reorder_frames >
-          p_seq_param_set->vui_parameters->max_dec_frame_buffering ||
-          p_seq_param_set->vui_parameters->max_dec_frame_buffering <
-          p_seq_param_set->num_ref_frames ||
-          p_seq_param_set->vui_parameters->max_dec_frame_buffering >
-          p_seq_param_set->max_dpb_size) {
-        /* Set pSeqParamSet->maxDpbSize to a valid value */
-        if (p_seq_param_set->vui_parameters->max_dec_frame_buffering >
-            p_seq_param_set->max_dpb_size && invalid_dpb_size)
-            p_seq_param_set->max_dpb_size =
-          p_seq_param_set->vui_parameters->max_dec_frame_buffering;
-        else {
-          ERROR_PRINT("Not valid vui_parameters->bitstream_restriction");
-          return(HANTRO_NOK);
-        }
-      }
-
       /* standard says that "the sequence shall not require a DPB with
        * size of more than max(1, max_dec_frame_buffering) */
       p_seq_param_set->max_dpb_size =
@@ -541,6 +522,9 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
     }
   }
 
+  p_seq_param_set->max_dpb_size = MAX(p_seq_param_set->max_dpb_size, p_seq_param_set->num_ref_frames);
+  p_seq_param_set->max_dpb_size = MIN(p_seq_param_set->max_dpb_size, 16);
+
   if (mvc_flag) {
     if (p_seq_param_set->profile_idc == 118 || p_seq_param_set->profile_idc == 128) {
       /* bit_equal_to_one */
diff --git a/decoder_sw/software/source/hevc/hevc_container.h b/decoder_sw/software/source/hevc/hevc_container.h
index 79ee1c6..7d62d6c 100755
--- a/decoder_sw/software/source/hevc/hevc_container.h
+++ b/decoder_sw/software/source/hevc/hevc_container.h
@@ -201,6 +201,7 @@ struct HevcDecContainer {
   u32 legacy_regs;  /* Legacy registers. */
   u32 secure_mode;
   u32 drop_curr_pic;
+  u32 discard_dpb_num;
 };
 
 #endif /* #ifdef HEVC_CONTAINER_H_ */
diff --git a/decoder_sw/software/source/hevc/hevc_decoder.c b/decoder_sw/software/source/hevc/hevc_decoder.c
index fc6750e..6de19c8 100755
--- a/decoder_sw/software/source/hevc/hevc_decoder.c
+++ b/decoder_sw/software/source/hevc/hevc_decoder.c
@@ -377,7 +377,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
 #ifdef USE_EXTERNAL_BUFFER
           if (nal_unit.nal_unit_type == NAL_CODED_SLICE_CRA &&
               storage->no_rasl_output) {
-            HevcDpbMarkOlderUnused(storage->dpb, 0x7FFFFFFF, 0);
+            dec_cont->discard_dpb_num += HevcDpbMarkOlderUnused(storage->dpb, 0x7FFFFFFF, 0);
           }
 #endif
           return (HEVC_HDRS_RDY);
@@ -417,12 +417,15 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
         //return HEVC_RDY;
       }
 
+    u32 discard_dpb_num = 0;
+
       if(DEC_PARAM_ERROR == HevcSetRefPics(storage->dpb, storage->slice_header,
                                            storage->poc->pic_order_cnt, storage->active_sps,
                                            IS_IDR_NAL_UNIT(&nal_unit),
                                            nal_unit.nal_unit_type == NAL_CODED_SLICE_CRA &&
                                            storage->no_rasl_output, storage->sei_param.bufperiod_present_flag &&
-                                           storage->sei_param.pictiming_present_flag)) {
+                                           storage->sei_param.pictiming_present_flag,
+                                           &discard_dpb_num)) {
         ret = HEVC_RDY;
 #ifndef HEVC_INPUT_MULTI_FRM
         strm.strm_curr_pos = strm.strm_buff_start + strm.strm_data_size;
@@ -434,6 +437,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
 #endif
       }
 
+      dec_cont->discard_dpb_num += discard_dpb_num;
       if (nal_unit.nal_unit_type == NAL_CODED_SLICE_CRA &&
           storage->no_rasl_output)
         storage->no_rasl_output = 0;
diff --git a/decoder_sw/software/source/hevc/hevc_dpb.c b/decoder_sw/software/source/hevc/hevc_dpb.c
index 1d44d2e..96b32a1 100755
--- a/decoder_sw/software/source/hevc/hevc_dpb.c
+++ b/decoder_sw/software/source/hevc/hevc_dpb.c
@@ -688,8 +688,10 @@ u32 HevcSetRefPicPocList(struct DpbStorage *dpb,
   return ret;
 }
 
-void HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_present) {
+u32 HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_present) {
   u32 i;
+  u32 discard_dpb_num = 0;
+
   for (i = 0; i < MAX_DPB_SIZE; i++) {
 
     if (dpb->buffer[i].is_tsa_ref ||
@@ -700,6 +702,7 @@ void HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_p
         dpb->num_out_pics_buffered--;
         dpb->buffer[i].to_be_displayed = 0;
 #ifdef USE_EXTERNAL_BUFFER
+        discard_dpb_num++;
         /* For raster/dscale buffer, return to input buffer queue. */
         if (dpb->storage->raster_buffer_mgr) {
           RbmReturnPpBuffer(dpb->storage->raster_buffer_mgr, dpb->buffer[i].pp_data->bus_address);
@@ -714,13 +717,14 @@ void HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_p
   }
   /* output all pictures */
   while (OutputPicture(dpb) == HANTRO_OK);
+
+  return discard_dpb_num;
 }
 
 /* Determines reference pictures for current and subsequent pictures. */
 u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
                    i32 pic_order_cnt, struct SeqParamSet *sps, u32 is_idr,
-                   u32 is_cra, u32 hrd_present) {
-
+                   u32 is_cra, u32 hrd_present, u32 *discard_dpb) {
   u32 i;
   i32 idx = 0;
   u32 st_count[MAX_DPB_SIZE + 1] = {0};
@@ -734,6 +738,7 @@ u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
     /* if no_output_of_prior_pics_flag was set -> the pictures preceding the
      * IDR picture shall not be output -> set output buffer empty */
     if (slice_header->no_output_of_prior_pics_flag) {
+      *discard_dpb += dpb->num_out;
       RemoveTempOutputAll(dpb->fb_list, dpb);
       dpb->num_out = 0;
       dpb->out_index_w = dpb->out_index_r = 0;
@@ -749,7 +754,7 @@ u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
     dpb->num_poc_st_curr = 0;
     return ret;
   } else if (is_cra) {
-    (void)HevcDpbMarkOlderUnused(dpb, pic_order_cnt, hrd_present);
+    *discard_dpb += HevcDpbMarkOlderUnused(dpb, pic_order_cnt, hrd_present);
     return ret;
   }
 
diff --git a/decoder_sw/software/source/hevc/hevc_dpb.h b/decoder_sw/software/source/hevc/hevc_dpb.h
index b95a885..d0fffeb 100755
--- a/decoder_sw/software/source/hevc/hevc_dpb.h
+++ b/decoder_sw/software/source/hevc/hevc_dpb.h
@@ -190,7 +190,7 @@ u32 HevcResetDpb(const void *dec_inst, struct DpbStorage *dpb,
 
 u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
                    i32 pic_order_cnt, struct SeqParamSet *sps, u32 is_idr,
-                   u32 is_cra, u32 hrd_present);
+                   u32 is_cra, u32 hrd_present, u32 *discard_dpb);
 
 void *HevcAllocateDpbImage(struct DpbStorage *dpb, i32 pic_order_cnt,
                            i32 pic_order_cnt_lsb, u32 is_idr,
@@ -206,7 +206,7 @@ void HevcFreeDpb(const void *dwl, struct DpbStorage *dpb);
 #else
 i32 HevcFreeDpb(const void *inst, struct DpbStorage *dpb);
 i32 HevcFreeDpbExt(const void *dec_inst, struct DpbStorage *dpb);
-void HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_present);
+u32 HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_present);
 void HevcEmptyDpb(const void *dec_inst, struct DpbStorage *dpb);
 #endif
 void HevcDpbUpdateOutputList(struct DpbStorage *dpb);
diff --git a/decoder_sw/software/source/hevc/hevcdecapi.c b/decoder_sw/software/source/hevc/hevcdecapi.c
index 7d6fb8b..228318d 100755
--- a/decoder_sw/software/source/hevc/hevcdecapi.c
+++ b/decoder_sw/software/source/hevc/hevcdecapi.c
@@ -342,6 +342,17 @@ enum DecRet HevcDecGetSpsBitDepth(HevcDecInst dec_inst, u32 *bit_depth) {
   return (DEC_OK);
 }
 
+u32 HevcDecDiscardDpbNums(HevcDecInst dec_inst)
+{
+  u32 discard_dpb_num = 0;
+  struct HevcDecContainer *dec_cont = (struct HevcDecContainer *)dec_inst;
+
+  discard_dpb_num = dec_cont->discard_dpb_num;
+  /* we could reset discard_dpb_num after daemon/APP read it */
+  dec_cont->discard_dpb_num = 0;
+
+  return discard_dpb_num;
+}
 
 /* This function provides read access to decoder information. This
  * function should not be called before HevcDecDecode function has
@@ -530,7 +541,6 @@ enum DecRet HevcDecDecode(HevcDecInst dec_inst,
   if (dec_cont->checksum != dec_cont) {
     return (DEC_NOT_INITIALIZED);
   }
-
 #ifdef USE_EXTERNAL_BUFFER
   if(dec_cont->abort) {
     return (DEC_ABORTED);
@@ -2061,7 +2071,6 @@ static void hevcRemoveDpb(const void *dec_inst, struct DpbStorage *dpb) {
       dpb->buffer[i].data = NULL;
     }
   }
-
   #define FB_OUTPUT 0x04U
 
   for (i = 0; i < MAX_FRAME_BUFFER_NUMBER; i++) {
@@ -2128,7 +2137,6 @@ enum DecRet HevcDecRemoveBuffer(HevcDecInst dec_inst) {
     dec_cont->min_buffer_num = dec_cont->storage.dpb->dpb_size + 2;   /* We need at least (dpb_size+2) output buffers before starting decoding. */
   else
     dec_cont->min_buffer_num = dec_cont->storage.dpb->dpb_size + 1;
-
   dec_cont->buffer_index = 0;
   dec_cont->buf_num = dec_cont->min_buffer_num;
   dec_cont->buffer_num_added = 0;
diff --git a/decoder_sw/software/source/inc/hevcdecapi.h b/decoder_sw/software/source/inc/hevcdecapi.h
index 710acf2..4301e41 100755
--- a/decoder_sw/software/source/inc/hevcdecapi.h
+++ b/decoder_sw/software/source/inc/hevcdecapi.h
@@ -236,6 +236,8 @@ enum DecRet HevcDecSetNoReorder(HevcDecInst dec_inst, u32 no_reorder);
 enum DecRet HevcDecSetInfo(HevcDecInst dec_inst,
                           struct HevcDecConfig *dec_cfg);
 
+u32 HevcDecDiscardDpbNums(HevcDecInst dec_inst);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/h1_encoder/software/inc/ewl.h b/h1_encoder/software/inc/ewl.h
index 0b5169e..640d1c0 100755
--- a/h1_encoder/software/inc/ewl.h
+++ b/h1_encoder/software/inc/ewl.h
@@ -223,6 +223,10 @@ extern u32 (*pollInputLineBufTestFunc)(void);
     void EWLWriteRegAll(const void *inst, const u32 * table, u32 size);
     /* Reading all registers in one call *//*Not in use currently */
     void EWLReadRegAll(const void *inst, u32 * table, u32 size);
+    /* Read values to HW register through ioctl. */
+    int EWLIoctlReadRegs(int fd, u32 offset, u32 size, u32 *val);
+    /* Write values to HW register through ioctl. */
+    int EWLIoctlWriteRegs(int fd, u32 offset, u32 size, u32 *val);
 
 /* HW enable/disable. This will write <val> to register <offset> and by */
 /* this enablig/disabling the hardware. */
diff --git a/h1_encoder/software/linux_reference/ewl/ewl_x280_common.c b/h1_encoder/software/linux_reference/ewl/ewl_x280_common.c
index 312e4cc..f43fe2d 100755
--- a/h1_encoder/software/linux_reference/ewl/ewl_x280_common.c
+++ b/h1_encoder/software/linux_reference/ewl/ewl_x280_common.c
@@ -47,9 +47,8 @@
 #include "ewl_linux_lock.h"
 #include "ewl_x280_common.h"
 
-#include "linux/hx280enc.h"
 #ifdef USE_ION
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0) || defined(ENABLE_DMABUF_HEAP)
 #include <linux/dma-heap.h>
 #else
 #include <linux/ion.h>
@@ -57,13 +56,19 @@
 #include <linux/dma-buf.h>
 #include <linux/version.h>
 #ifdef ANDROID
+#if !defined(ENABLE_DMABUF_HEAP)
 #include <linux/mxc_ion.h>
 #include <ion_4.12.h>
 #endif
+#endif
 #else
 #include "memalloc.h"
 #endif
 
+#ifdef ENABLE_DMABUF_HEAP
+#include <linux/dma-buf-imx.h>
+#endif
+
 #include <sys/syscall.h>
 #include <sys/types.h>
 #include <sys/stat.h>
@@ -181,6 +186,7 @@ int MapAsicRegisters(hx280ewl_t * ewl)
     ioctl(ewl->fd_enc, HX280ENC_IOCGHWOFFSET, &base);
     ioctl(ewl->fd_enc, HX280ENC_IOCGHWIOSIZE, &size);
 
+#ifndef CFG_SECURE_IOCTRL_REGS
     /* map hw registers to user space */
     pRegs =
         (u32 *) mmap(0, size, PROT_READ | PROT_WRITE, MAP_SHARED,
@@ -190,6 +196,9 @@ int MapAsicRegisters(hx280ewl_t * ewl)
         PTRACE("EWLInit: Failed to mmap regs
");
         return -1;
     }
+#else
+    pRegs = MAP_FAILED;
+#endif
 
     ewl->regSize = size;
     ewl->regBase = base;
@@ -499,6 +508,32 @@ i32 EWLRelease(const void *inst)
     return EWL_OK;
 }
 
+/*------------------------------------------------------------------------------
+    Function name   : EWLIoctlWriteRegs
+    Description     : Write values to HW register through ioctl.
+    Return type     : int - return 0 on success, or retrun -1.
+    Argument        : int fd - encoder device fd.
+    Argument        : u32 offset - start write offset of HW register.
+    Argument        : u32 size - write size.
+    Argument        : u32 *val - write data pointer.
+------------------------------------------------------------------------------*/
+int EWLIoctlWriteRegs(int fd, u32 offset, u32 size, u32 *val)
+{
+    struct enc_regs_buffer regs;
+
+    memset(&regs, 0, sizeof(regs));
+    regs.offset = offset;
+    regs.regs = val;
+    regs.size = size;
+    if (ioctl(fd, HX280ENC_IOC_WRITE_REGS, &regs) != 0)
+    {
+        PTRACE("ERROR write enc reg fail, offset:%08x
", offset);
+        return -1;
+    }
+
+    return 0;
+}
+
 /*******************************************************************************
  Function name   : EWLWriteReg
  Description     : Set the content of a hadware register
@@ -511,16 +546,18 @@ void EWLWriteReg(const void *inst, u32 offset, u32 val)
     hx280ewl_t *enc = (hx280ewl_t *) inst;
 
     assert(enc != NULL && offset < enc->regSize);
-
+#ifndef CFG_SECURE_IOCTRL_REGS
     if(offset == 0x04)
     {
         asic_status = val;
     }
 
-    offset = offset / 4;
-    *(enc->pRegBase + offset) = val;
+    *(enc->pRegBase + (offset / 4)) = val;
+#else
+    EWLIoctlWriteRegs(enc->fd_enc, offset, 4, &val);
+#endif
 
-    PTRACE("EWLWriteReg 0x%02x with value %08x
", offset * 4, val);
+    PTRACE("EWLWriteReg 0x%02x with value %08x
", offset, val);
 }
 
 /*------------------------------------------------------------------------------
@@ -533,19 +570,9 @@ void EWLWriteReg(const void *inst, u32 offset, u32 val)
 ------------------------------------------------------------------------------*/
 void EWLEnableHW(const void *inst, u32 offset, u32 val)
 {
-    hx280ewl_t *enc = (hx280ewl_t *) inst;
-
-    assert(enc != NULL && offset < enc->regSize);
-
-    if(offset == 0x04)
-    {
-        asic_status = val;
-    }
+    EWLWriteReg(inst, offset, val);
 
-    offset = offset / 4;
-    *(enc->pRegBase + offset) = val;
-
-    PTRACE("EWLEnableHW 0x%02x with value %08x
", offset * 4, val);
+    PTRACE("EWLEnableHW 0x%02x with value %08x
", offset, val);
 }
 
 /*------------------------------------------------------------------------------
@@ -563,22 +590,46 @@ void EWLDisableHW(const void *inst, u32 offset, u32 val)
 
     assert(enc != NULL && offset < enc->regSize);
 
-    offset = offset / 4;
-
-    if(offset == 0x04)
+    if(offset == 0x10)
     {
-        *(enc->pRegBase + offset) = val;
+        EWLWriteReg(inst, offset, val);
         stats = val;
         asic_status = val;
     }
     else
     {
-        stats = *(enc->pRegBase + offset);
+        stats = EWLReadReg(inst, offset);
         stats = stats & (~1);
-        *(enc->pRegBase + offset) = stats;
+        EWLWriteReg(inst, offset, stats);
+    }
+
+    PTRACE("EWLDisableHW 0x%02x with value %08x
", offset, stats);
+}
+
+/*------------------------------------------------------------------------------
+    Function name   : EWLIoctlReadRegs
+    Description     : Read values to HW register through ioctl.
+    Return type     : int - return 0 on success, or retrun -1.
+    Argument        : int fd - encoder device fd.
+    Argument        : u32 offset - start read offset of HW register.
+    Argument        : u32 size - read size.
+    Argument        : u32 *val - read data pointer.
+------------------------------------------------------------------------------*/
+int EWLIoctlReadRegs(int fd, u32 offset, u32 size, u32 *val)
+{
+    struct enc_regs_buffer regs;
+
+    memset(&regs, 0, sizeof(regs));
+    regs.offset = offset;
+    regs.regs = val;
+    regs.size = size;
+    if (ioctl(fd, HX280ENC_IOC_READ_REGS, &regs) != 0)
+    {
+        PTRACE("ERROR read enc reg fail, offset:%08x
", offset);
+        return -1;
     }
 
-    PTRACE("EWLDisableHW 0x%02x with value %08x
", offset * 4, stats);
+    return 0;
 }
 
 /*******************************************************************************
@@ -596,17 +647,18 @@ u32 EWLReadReg(const void *inst, u32 offset)
     hx280ewl_t *enc = (hx280ewl_t *) inst;
 
     assert(offset < enc->regSize);
-
+#ifndef CFG_SECURE_IOCTRL_REGS
     if(offset == 0x04)
     {
         return asic_status;
     }
 
-    offset = offset / 4;
-    val = *(enc->pRegBase + offset);
-
-    PTRACE("EWLReadReg 0x%02x --> %08x
", offset * 4, val);
+    val = *(enc->pRegBase + (offset / 4));
+#else
+    EWLIoctlReadRegs(enc->fd_enc, offset, 4, &val);
+#endif
 
+    PTRACE("EWLReadReg 0x%02x --> %08x
", offset, val);
     return val;
 }
 
@@ -827,7 +879,7 @@ i32 EWLMallocLinear(const void *instance, u32 size, EWLLinearMem_t * info)
 #endif
 }
 
-#elif (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)) //LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#elif (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0)) && !defined(ENABLE_DMABUF_HEAP) //LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
 i32 EWLMallocLinear(const void *instance, u32 size, EWLLinearMem_t * info)
 {
     hx280ewl_t *enc_ewl = (hx280ewl_t *) instance;
@@ -918,7 +970,7 @@ i32 EWLMallocLinear(const void *instance, u32 size, EWLLinearMem_t * info)
       return EWL_ERROR;
 }
 
-#else  // (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
+#else (LINUX_VERSION_CODE >= KERNEL_VERSION(5, 11, 0)) || defined(ENABLE_DMABUF_HEAP)  // (LINUX_VERSION_CODE < KERNEL_VERSION(5, 11, 0))
 i32 EWLMallocLinear(const void *instance, u32 size, EWLLinearMem_t * info)
 {
     hx280ewl_t *enc_ewl = (hx280ewl_t *) instance;
@@ -950,11 +1002,34 @@ i32 EWLMallocLinear(const void *instance, u32 size, EWLLinearMem_t * info)
 
     ret = ioctl(info->ion_fd, DMA_BUF_IOCTL_PHYS, &dma_phys);
     if (ret < 0) {
-      PTRACE("ion get phys failed. 
");
-      goto bail;
+#ifdef ENABLE_DMABUF_HEAP
+        PTRACE("ion DMA_BUF_IOCTL_PHYS get phys failed. 
");
+        struct dmabuf_imx_phys_data data;
+        int fd_;
+        fd_ = open("/dev/dmabuf_imx", O_RDONLY | O_CLOEXEC);
+        if (fd_ < 0) {
+            PTRACE("open /dev/dambuf_imx failed: %s", strerror(errno));
+            goto bail;
+        }
+        data.dmafd = info->ion_fd;
+        if (ioctl(fd_, DMABUF_GET_PHYS, &data) < 0) {
+            PTRACE("%s ION_GET_PHYS  failed",__func__);
+            close(fd_);
+            goto bail;
+        } else {
+            buff->busAddress = data.phys;
+        }
+        close(fd_);
+    } else {
+        buff->busAddress = dma_phys.phys;
+    }
+#else
+        PTRACE("ion get phys failed. 
");
+        goto bail;
     }
 
     buff->busAddress = dma_phys.phys;
+#endif
 
     PTRACE("physical address: %p
", buff->busAddress);
 
diff --git a/h1_encoder/software/linux_reference/ewl/ewl_x280_common.h b/h1_encoder/software/linux_reference/ewl/ewl_x280_common.h
index f9a94b3..41d4891 100755
--- a/h1_encoder/software/linux_reference/ewl/ewl_x280_common.h
+++ b/h1_encoder/software/linux_reference/ewl/ewl_x280_common.h
@@ -42,6 +42,8 @@
 
 #include <stdio.h>
 #include <signal.h>
+#include <linux/types.h>
+#include "linux/hx280enc.h"
 
 extern FILE *fEwl;
 
@@ -64,6 +66,11 @@ extern FILE *fEwl;
 #endif
 #endif
 
+#ifdef ENABLE_DMABUF_HEAP
+#undef MEMALLOC_MODULE_PATH
+#define MEMALLOC_MODULE_PATH "/dev/dma_heap/reserved-uncached"
+#endif
+
 /* the encoder device driver nod */
 #ifndef MEMALLOC_MODULE_PATH
 #define MEMALLOC_MODULE_PATH        "/tmp/dev/memalloc"
@@ -98,6 +105,24 @@ typedef struct
 #endif
 } hx280ewl_t;
 
+#ifndef HX280ENC_IOC_WRITE_REGS
+struct enc_regs_buffer
+{
+  u32 core_id;
+  u32 *regs;
+  u32 offset;
+  u32 size;
+  u32 *reserved;
+};
+#endif
+
+#ifndef HX280ENC_IOC_WRITE_REGS
+#define HX280ENC_IOC_WRITE_REGS     _IOW(HX280ENC_IOC_MAGIC, 14, struct enc_regs_buffer *)
+#endif
+#ifndef HX280ENC_IOC_READ_REGS
+#define HX280ENC_IOC_READ_REGS      _IOR(HX280ENC_IOC_MAGIC, 15, struct enc_regs_buffer *)
+#endif
+
 void HandleSIGIO(hx280ewl_t * enc);
 
 #endif /* __EWLX280_COMMON_H__ */
diff --git a/h1_encoder/software/linux_reference/ewl/ewl_x280_irq.c b/h1_encoder/software/linux_reference/ewl/ewl_x280_irq.c
index 4f5bbfe..1831d65 100755
--- a/h1_encoder/software/linux_reference/ewl/ewl_x280_irq.c
+++ b/h1_encoder/software/linux_reference/ewl/ewl_x280_irq.c
@@ -44,7 +44,6 @@
 
 #include "basetype.h"
 #include "ewl.h"
-#include "linux/hx280enc.h"   /* This EWL uses the kernel module */
 #include "ewl_x280_common.h"
 #include "ewl_linux_lock.h"
 
diff --git a/h1_encoder/software/linux_reference/ewl/ewl_x280_polling.c b/h1_encoder/software/linux_reference/ewl/ewl_x280_polling.c
index a194870..44f1867 100755
--- a/h1_encoder/software/linux_reference/ewl/ewl_x280_polling.c
+++ b/h1_encoder/software/linux_reference/ewl/ewl_x280_polling.c
@@ -48,8 +48,6 @@
 #include "ewl_x280_common.h"
 #include "encswhwregisters.h"
 
-#include "linux/hx280enc.h"
-
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
@@ -107,19 +105,19 @@ i32 EWLWaitHwRdy(const void *inst, u32 *slicesReady)
     {
         /* Get the number of completed slices from ASIC registers. */
         if (slicesReady)
-            *slicesReady = (enc->pRegBase[21] >> 16) & 0xFF;
+            *slicesReady = (EWLReadReg(enc, 21 * 4) >> 16) & 0xFF;
 
-        #ifdef PCIE_FPGA_VERIFICATION
+#ifdef PCIE_FPGA_VERIFICATION
         /* Only for verification purpose, to test input line buffer in hw-handshake mode or sw-irq is disabled. */
         if (pollInputLineBufTestFunc) pollInputLineBufTestFunc();
        #endif
 
-        irq_stats = enc->pRegBase[1];
+        irq_stats = EWLReadReg(enc, 1 * 4);
 
         PTRACE("EWLWaitHw: IRQ stat = %08x
", irq_stats);
 
         /* ignore the irq status of input line buffer in hw handshake mode */
-        if ((irq_stats == ASIC_STATUS_LINE_BUFFER_DONE) && (enc->pRegBase[BASE_HEncInstantInput/4] & (1<<29)))
+        if ((irq_stats == ASIC_STATUS_LINE_BUFFER_DONE) && (EWLReadReg(enc, BASE_HEncInstantInput) & (1<<29)))
             continue;
 
         if((irq_stats & ASIC_STATUS_ALL))
diff --git a/imx_vpu_hantro.go b/imx_vpu_hantro.go
index 84f50df..db55d7d 100755
--- a/imx_vpu_hantro.go
+++ b/imx_vpu_hantro.go
@@ -66,6 +66,15 @@ func IMX_VPU_DEC_Defaults(ctx android.LoadHookContext) {
     if ctx.Config().VendorConfig("IMXPLUGIN").String("CFG_SECURE_DATA_PATH") == "y" {
         Cflags = append(Cflags, "-DCFG_SECURE_DATA_PATH")
     }
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("ENABLE_DMABUF_HEAP") {
+        Cflags = append(Cflags, "-DENABLE_DMABUF_HEAP")
+    }
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("ENABLE_SEC_DMABUF_HEAP") {
+        Cflags = append(Cflags, "-DENABLE_SEC_DMABUF_HEAP")
+    }
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("CFG_SECURE_IOCTRL_REGS") {
+        Cflags = append(Cflags, "-DCFG_SECURE_IOCTRL_REGS")
+    }
     p.Target.Android.Cflags = Cflags
     p.Target.Android.Include_dirs = Include_dirs
     ctx.AppendProperties(p)
@@ -113,6 +122,9 @@ func IMX_VPU_ENC_Defaults(ctx android.LoadHookContext) {
     if ctx.Config().VendorConfig("IMXPLUGIN").String("CFG_SECURE_DATA_PATH") == "y" {
         Cflags = append(Cflags, "-DCFG_SECURE_DATA_PATH")
     }
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("ENABLE_DMABUF_HEAP") {
+        Cflags = append(Cflags, "-DENABLE_DMABUF_HEAP")
+    }
     p.Target.Android.Cflags = Cflags
     p.Target.Android.Include_dirs = Include_dirs
     ctx.AppendProperties(p)
