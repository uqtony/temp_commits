8338200 jenkins 2021-07-19

Download imx-android-11.0.0_2.2.0.tar.gz from nxp.com


diff --git a/Android.bp b/Android.bp
new file mode 100644
index 0000000..e5f07da
--- /dev/null
+++ b/Android.bp
@@ -0,0 +1,67 @@
+IMX_VPU_HANTRO_DAEMON_DEFAULTS {
+    name: "IMX_VPU_HANTRO_DAEMON_DEFAULT",
+
+    include_dirs: [
+        "vendor/nxp-opensource/kernel_imx/drivers/mxc/hantro_v4l2",
+        "vendor/nxp/imx-vpu-hantro/decoder_sw/software/source/inc",
+    ],
+
+    cflags: [
+        "-fPIC",
+        "-Wall",
+        "-Wno-pointer-sign",
+        "-Wno-unused-function",
+        "-O2",
+        "-DUSE_EXTERNAL_BUFFER",
+        "-DUSE_OUTPUT_RELEASE",
+        "-DUSE_HW",
+        "-DUSE_G1",
+        "-DUSE_G2",
+    ],
+
+    srcs: [
+        "v4l2_vsi_daemon/src/buffer_list.c",
+        "v4l2_vsi_daemon/src/command_defines.c",
+        "v4l2_vsi_daemon/src/dec_dpb_buff.c",
+        "v4l2_vsi_daemon/src/dec_ts.c",
+        "v4l2_vsi_daemon/src/fifo.c",
+        "v4l2_vsi_daemon/src/hash_table.c",
+        "v4l2_vsi_daemon/src/object_heap.c",
+        "v4l2_vsi_daemon/src/vsi_dec.c",
+        "v4l2_vsi_daemon/src/vsi_main.c",
+    ],
+
+    shared_libs: [
+        "libhantro",
+        "libg1",
+    ],
+
+    vendor: true,
+}
+
+
+bootstrap_go_package {
+    name: "soong-imx-vpu-hantro-daemon",
+    pkgPath: "android/soong/vendor/nxp/imx-vpu-hantro-daemon",
+    deps: [
+        "blueprint",
+        "blueprint-pathtools",
+        "soong",
+        "soong-android",
+        "soong-cc",
+        "soong-genrule",
+    ],
+    srcs: [
+        "imx_vpu_hantro_daemon.go",
+    ],
+    pluginFor: ["soong_build"],
+}
+
+cc_binary {
+    name: "vsidaemon",
+
+    defaults: [
+        "IMX_VPU_HANTRO_DAEMON_DEFAULT",
+    ],
+
+}
diff --git a/LICENSE.txt b/LICENSE.txt
new file mode 100644
index 0000000..f786bc3
--- /dev/null
+++ b/LICENSE.txt
@@ -0,0 +1,23 @@
+
+MIT License
+
+Copyright (c) 2021 VeriSilicon Inc.
+
+Permission is hereby granted, free of charge, to any person obtaining a copy
+of this software and associated documentation files (the "Software"), to deal
+in the Software without restriction, including without limitation the rights
+to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
+copies of the Software, and to permit persons to whom the Software is
+furnished to do so, subject to the following conditions:
+
+The above copyright notice and this permission notice shall be included in
+all copies or substantial portions of the Software.
+
+THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
+AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
+THE SOFTWARE.
+
diff --git a/Makefile b/Makefile
new file mode 100755
index 0000000..9a775b0
--- /dev/null
+++ b/Makefile
@@ -0,0 +1,64 @@
+
+CC = $(CROSS_COMPILE)gcc --sysroot=$(SDKTARGETSYSROOT)
+AR = $(CROSS_COMPILE)ar
+STRIP = $(CROSS_COMPILE)strip 
+
+#CFLAGS ?= -O2 -Wall
+
+DEST_DIR = ./bin
+RELEASE_DIR = ./bin
+HANTRO_G1G2_LIB_DIR = ../../imx-vpu-hantro
+HANTRO_VC8000E_LIB_DIR = ../../imx-vpu-hantro-vc
+HANTRO_H1_LIB_DIR = ../../imx-vpu-hantro
+CTRLSW_HDRPATH = ../inc
+
+DAEMON_DIR = ./v4l2_vsi_daemon
+#KERNEL_DIR = ../../linux-2.6-testbuild
+#MXC_UNIT_TEST_DIR = ./v4l2_vsi_daemon/test/mxc
+#MXC_UNIT_TEST = mxc_v4l2_vpu_enc.out
+
+OUT_FILE = vsidaemon
+
+DEC = nxp_enc_hw
+ENC = nxp_dec_hw
+LIBFILES = 
+LD_FLAGS = -lpthread -lm
+
+PLATFORM ?= IMX8MP
+
+ifeq ($(PLATFORM), IMX8MP)
+TARGET=865
+LD_FLAGS += -L$(HANTRO_G1G2_LIB_DIR) -lhantro -lg1 -L$(HANTRO_VC8000E_LIB_DIR) -lhantro_vc8000e
+else ifeq ($(PLATFORM), IMX8MM)
+TARGET=845
+LD_FLAGS += -L$(HANTRO_G1G2_LIB_DIR) -lhantro -lg1 -L$(HANTRO_H1_LIB_DIR) -lhantro_h1
+else ifeq ($(PLATFORM), IMX8MQ)
+TARGET=850
+LD_FLAGS += -L$(HANTRO_G1G2_LIB_DIR) -lhantro -lg1
+else
+TARGET=865
+LD_FLAGS += -L$(HANTRO_G1G2_LIB_DIR) -lhantro -lg1 -L$(HANTRO_VC8000E_LIB_DIR) -lhantro_vc8000e
+endif
+
+
+all:
+	@mkdir -p $(RELEASE_DIR)
+	make -C $(DAEMON_DIR) CC="$(CC)" OUT_FILE=$(OUT_FILE) target=$(TARGET) enc=$(ENC) dec=$(DEC) LIBFILES="$(LIBFILES)" LD_FLAGS="$(LD_FLAGS)" CTRLSW_HDRPATH="$(CTRLSW_HDRPATH)"
+	cp $(DAEMON_DIR)/$(OUT_FILE) $(RELEASE_DIR)/$(OUT_FILE)
+
+install:
+	@mkdir -p $(DEST_DIR)/usr/bin
+	cp $(RELEASE_DIR)/$(OUT_FILE) $(DEST_DIR)/usr/bin/
+
+#test:
+#	@mkdir -p $(RELEASE_DIR)
+#	make -C $(MXC_UNIT_TEST_DIR) CC="$(CC)" STRIP=$(STRIP) debug=0 VSIPARSE=y
+#	cp $(MXC_UNIT_TEST_DIR)/$(MXC_UNIT_TEST) $(RELEASE_DIR)/$(MXC_UNIT_TEST)
+
+.PHONY: clean
+clean:
+	make -C $(DAEMON_DIR) CC="$(CC)" OUT_FILE=$(OUT_FILE) target=$(TARGET) enc=$(ENC) dec=$(DEC) LIBFILES="$(LIBFILES)" LD_FLAGS="$(LD_FLAGS)" CTRLSW_HDRPATH="$(CTRLSW_HDRPATH)" clean
+	#make -C $(MXC_UNIT_TEST_DIR) CC="$(CC)" STRIP=$(STRIP) debug=0 VSIPARSE=y clean
+	rm -f $(RELEASE_DIR)/$(OUT_FILE)
+	#rm -f $(RELEASE_DIR)/$(MXC_UNIT_TEST)
+
diff --git a/doc/readme_NXP865.txt b/doc/readme_NXP865.txt
new file mode 100755
index 0000000..fb165ff
--- /dev/null
+++ b/doc/readme_NXP865.txt
@@ -0,0 +1,138 @@
+1. Environment setup
+	
+	1.1 system requirement
+		On NXP865 board We're running with Linux kernel version 5.4.3.
+		There're some incompatible issues with older version of kernel (<4.18).
+	
+	1.2 kernel configuration
+		In building linux kernel there're several configurations that will affect 
+	VSI V4L2 system, they are:
+		1.2.1 
+		VIDEO_V4L2	='y'
+		several related definitions: V4L2_FWNODE, V4L2_M2MDEV, VIDEOBUF2_V4L2 should
+		be 'm' or 'y'. In NXP's kernel package they're all 'y'.
+		1.2.2
+		CMA	='y'.
+		To enable CMA support in linux.
+
+	1.3 supporting modules
+		N.A.
+	
+	1.4 CMA(contiguous memory area) size
+		CMA size could affect memory usage of your V4L2. On NXP865 board default CMA
+	is about 1GB. This could support up to 8K single stream encoding.
+		
+2. Building VSI V4L2 modules
+	VSI V4L2 is composed of two modules: kernel driver and daemon. VSI daemon uses
+	VC8000E and VC8000D's control software library as supporting library. Pre-built
+	libraries are located in /libs4daemon directory.
+	
+	2.1 VSI V4L2 kernel driver provides standard v4l2 interfaces to user space application.
+	It's located in /vsi_v4l2_driver.
+		To build VSI V4L2 driver:
+			"make clean"
+			"make -f Makefie.arm"
+		A file named "vsiv4l2.ko" will be created.
+		Note that in Makefile.arm "KDIR" should be target board's kernel directory for building.
+	
+	2.2 Build VC8000E libraries
+		2.2.1 build h264 encoder lib:
+		vc8000e/system$ make clean libclean h264 DEBUG=n TRACE=n target=TBH V4L2=y CROSS_COMPILE=aarch64-linux-gnu- USE_SAFESTRIG=n
+		
+		2.2.2 copy the h264 c-model and control SW lib:
+		vc8000e$ cp system/models/ench2_asic_model.a $libs4daemon/ench2_asic_model_h264_aarch64.a
+		vc8000e$ cp software/linux_reference/libh2enc.a $libs4daemon/libh2enc_aarch64.a
+		
+		2.2.3 build hevc encoder lib:
+		vc8000e/system$ make clean libclean hevc DEBUG=n TRACE=n target=TBH V4L2=y CROSS_COMPILE=aarch64-linux-gnu- USE_SAFESTRIG=n
+		
+		2.2.4 copy the hevc encoder c-model and control SW lib:
+		vc8000e$ cp system/models/ench2_asic_model.a $libs4daemon/ench2_asic_model_hevc_aarch64.a
+		vc8000e$ cp software/linux_reference/libh2enc.a $libs4daemon/libh2enc_aarch64.a
+	2.3 Build VC8000D libraries
+	This script will automatically generate libs, and copy to related path
+		2.3.1 build g1 decoder libs:
+		./genlib.sh h264high arm_pclinux 
+		./genlib.sh h264high versatile 
+		./genlib.sh mpeg2 arm_pclinux 
+		./genlib.sh mpeg2 versatile 
+
+		2.3.2 build g2 decoder libs:
+		./genlib.sh g2dec arm_pclinux 
+		./genlib.sh g2dec arm_linux 
+
+	2.4 VSI V4L2 daemon is a daemon process in user space. It's located in /vsi_v4l2_daemon.
+		To build VSI V4L2 daemon:
+			"make clean"
+			"make DECTARGET=xxx ENCTARGET=xxx"
+			 DECTARGET is one of nxp_g1dec_hw/nxp_g2dec_hw.
+			 ENCTARGET is nxp_h26x_hw.
+		A file named "vsidaemon" will be created.
+		Please note there're two decoder target formats. The former supports H264, the latter for HEVC.
+		All binaries use hardware for codec.
+		By default DECTARGET is nxp_g1dec_hw, and ENCTARGET is nxp_h26x_hw.
+		
+3. Starting up VSI V4L2 system
+	3.1 Bring up hardware device file
+		mknod /dev/hx280 c 235 0
+		mknod /dev/hantrodec c 236 0
+	
+	3.2 Enable VSI V4L2 driver
+		Using these command to enable VSI V4L2 kernel driver in system:
+			"insmod vsiv4l2.ko"
+			On success it'll create two "/dev/video*" files and "/dev/vsi_daemon_ctrl".
+			Formers are	for two V4L2 interface file. On NXP865 board they are
+		/dev/video0 and /dev/video1.
+			The latter is device handle for communication between VSI V4L2 driver
+		and VSI V4L2 daemon.
+
+	3.3 Starting up daemon:
+		Just run "vsidaemon"
+		On success it won't report any error and blocked wait there.
+	
+4. Building ffmpeg
+		Configure for arm64 platform:
+		"./configure --target-os=linux --cross-prefix=aarch64-linux-gnu- --arch=arm64 --pkg-config=pkg-config"
+		"make clean all"
+		
+5. Test examples with ffmpeg
+	5.1	Simple encoding:
+	$(your_arm64_ffmpeg) -s 352x288 -i foreman_cif.yuv -s 352x288 -vcodec h264_v4l2m2m foreman.h264
+	$(your_arm64_ffmpeg) -s 352x288 -i foreman_cif.yuv -s 352x288 -vcodec hevc_v4l2m2m foreman.hevc
+	
+	5.2	Simple decoding:
+	$(your_arm64_ffmpeg) -vcodec h264_v4l2m2m -i foreman.h264 foreman_cif.yuv	(building with DECTARGET=nxp_g1dec_hw)
+	$(your_arm64_ffmpeg) -vcodec hevc_v4l2m2m -i foreman.hevc foreman_cif.yuv	(building with DECTARGET=nxp_g2dec_hw)
+
+	5.3 Transcoding:
+	$(your_arm64_ffmpeg) -vcodec h264 -i stream.h264 -pix_fmt nv12 -vcodec h264_v4l2m2m -f h264 transcoded.h264
+	
+	5.4 Multi encoding output:
+	$(your_arm64_ffmpeg) -s 352x288 -i foreman_cif.yuv -s 352x288 -vcodec h264_v4l2m2m foreman.h264 -s 176x144 -vcodec h264_v4l2m2m foreman2.h264
+	
+	5.5 Multi decoding output:
+	$(your_arm64_ffmpeg) -vcodec hevc_v4l2m2m -i stream422.h264 -s 1280x720 transcoded.yuv -s 720x480 transcoded2.yuv
+		
+6. Supported features
+	6.1 Supported Codec format as encoder's output and decoder's input
+		HEVC and H264.
+		
+	6.2 Supported Raw format as encoder's input and decoder's output
+		YUV420, NV12 and NV21.
+		
+7. Known issues
+	7.1 Memory usage
+		Currently all daemon internal memory allocation and mapping goes through /dev/ion on NXP865 board.
+		All hardware register mapping goes through corresponding hardware driver.
+		Due to /dev/ion's limit, when vsidaemon maps buffers of V4L2 driver, it uses /dev/vsi_daemon_ctrl.
+		
+	7.2 ffmpeg encoding
+		Since ffmpeg does not support B frame in encoding, we haven't tested B-frame encoding with ffmpeg.
+		We did test it by our own test code. We'll try to find other public tools which may supports
+		B-frame in encoding.
+		
+	7.3 ffmpeg decoding
+		Due to some problem in ffmpeg, there might be a few redundant frames at tail of decoding.
+		
+	7.4 Decoding output order
+		VSI V4L2 decoded stream are in codec order, not display order. Application should be able to handle this.
\ No newline at end of file
diff --git a/doc/vsi-v4l2-structure.txt b/doc/vsi-v4l2-structure.txt
new file mode 100755
index 0000000..6f90352
--- /dev/null
+++ b/doc/vsi-v4l2-structure.txt
@@ -0,0 +1,171 @@
+vsi v4l2 system structure definition
+
+1. Standard v4l2 skeleton
+
+										|- video device 0
+										|
+										|- video device 1
+                    |
+		v4l2-device	---	|...
+			              |
+										|- video device n
+
+	1.1 v4l2 device
+		v4l2 device is initialized by v4l2_device_register(). It has a 
+	parent struct device *dev which is created from platform_device_register().
+		Commonly v4l2 device is embedded in a larger structure as global control.
+	We can refer to struct vsi_v4l2_device for example.
+	
+	1.2 video device
+		Each video device is created by video_device_alloc() and registered to system
+	by video_register_device().
+		It is connected to v4l2 device as its parent device. Each video device has a 
+	file in	/dev/ according to its capability. E.g. for video device it is
+	/dev/video*. So each video device has open/close/read/write/ioctl/mmap/poll
+	interfaces as standard files do.
+	
+	1.3 ioctls
+		Each video device's ioctl will go through v4l2's kernel standard ioctl
+	API. They will finally call video device's ioctl_ops callbacks. Ioctl callbacks
+	are set through struct v4l2_ioctl_ops as a member	of video device. 
+	vsi_v4l2_ioctl is our realization of it. Most of our member functions use
+	default value since it's easier to comply to v4l2 standard this way.
+	
+	1.4 controls
+		v4l2's controls is used to configure video device operation parameters. There
+	are	three kinds of controls: standard, standard menu (where there's a range of
+	choice) and custom defined control. Each custom control has a standard structure
+	to define its content. Each control must have a structure v4l2_ctrl_ops	for
+	v4l2 callback to set/get. I write vsi_setup_ctrls() as example, it sets up one
+	control	for each kind of control.
+	
+	1.5 v4l2 file handle
+	For each open operation of v4l2 video device which go through open API, v4l2 will
+	register it with v4l2_fh_init() and v4l2_fh_add(). We just use it to store some
+	private data now. Currently we create context for each opened file handle.
+	
+	1.6 v4l2 subdev
+	Another important part of v4l2 is subdev. We don't use it in current stage and
+	will update its information later.
+	
+	1.7 v4l2 queue management: vb2_queue and vb2_buffer
+	The critical functionality of v4l2 is buffer control, which is realized through
+	v4l2 queue management. Each video device manages one or more structure vb2_queue.
+	Each vb2_queue manages a number of struct vb2_buffer as their content. 
+	vb2_buffer has internal structure to represent a buffer, who may have over one
+	planes. How to organize and use these buffers are determined by system
+	requirement and driver realization. In most cases we've saw they are link as a list.
+	
+	struct vb2_queue_init has rich parameters. It is initialized by vb2_queue_init().
+	There're two groups of important callbacks: ops and mem_ops. Another group of
+	callbacks is vb2_buf_ops, which is rarely used and whose meaning is not clear.
+	
+	1.7.1 mem_ops callbacks of vb2_queue
+	mem_ops is used as alloc, free, mmap, ref/unref, transfer logic address, 
+	attach/detach dmabuf, etc. These callbacks are used internally by v4l2 kernel,
+	thus they won't be called explicitly. Kernel provides two well defined
+	realization: vb2_dma_contig_memops and vb2_vmalloc_memops. Almost all
+	v4l2 drivers use either of them. We use vb2_dma_contig_memops since we're
+	familiar with DMA_BUF operation.
+	
+	1.7.2 ops callbacks of vb2_queue
+	ops is used as callbacks when v4l2 kernel need do something on buffer in
+	certain operation. Most of these callbacks don't have default value. How to
+	realize these callbacks depends on v4l2's requirement of them and how
+	our v4l2 driver manages buffers. This is critical.
+	There're three kind of buffer, which is transferred as parameter in
+	VIDIOC_REQBUFS: V4L2_MEMORY_DMABUF, V4L2_MEMORY_MMAP, V4L2_MEMORY_USERPTR.
+	Actually there's fourth kind: V4L2_MEMORY_OVERLAY, which is very rarely
+	used. V4L2_MEMORY_DMABUF means all buffers are DMA_BUF allocated by
+	caller app and shared through DMA_BUF's file handle. V4L2_MEMORY_USERPTR
+	means input buffer are allocated by user app and shared by mem mapping
+	user pointer. V4L2_MEMORY_MMAP means v4l2 driver should allocate buffer
+	by itself and returned them to user space app. We'll support only
+	V4L2_MEMORY_MMAP according to our hardware's limit and software
+	flexibility.
+	
+	1.7.3 simple example of queue usage in v4l2 application
+	A simple application using v4l2 to codec looks like this:
+	Through VIDIOC_REQBUFS ioctl, buffer type and number are determined.
+	Then user space app will use VIDIOC_QBUF on each buffer to add them
+	to v4l2 driver's queue. Then VIDIOC_STREAMON is called. Application
+	will wait for VIDIOC_DQBUF for ready buffer returned from v4l2 driver.
+	Note that returned buffer in VIDIOC_DQBUF might not be identical to
+	its input, since which buffer is ready is decided by v4l2 driver.
+	After returned buffer is used up, it can be VIDIOC_QBUF to v4l2
+	driver to use again.
+	
+2. Spec and Test package for v4l2
+
+	v4l2 has spec for user space app, which is attached in wiki as v4l2.pdf.
+	v4l2 kernel driver does not have spec. Currently there're two
+	sets of utils to test single API of kernel driver:
+	v4l-utils: a set of v4l utils. It's a part of apt-get project.
+	linux test project: git https://github.com/linux-test-project/ltp.git.
+		It has a sub directory for v4l2.
+	
+3. VSI v4l2 driver structure
+	
+	Currently VSI v4l2 driver uses stateful method to haste coding
+	and reduce porting problem. Whole system looks like this:
+	
+	
+			v4l2 user space app										VSI v4l2 user space daemon
+			(ffmpeg, gst, etc.)								/
+																			/									|
+					|		|											/										|
+					|		|ioctls							/	msg pipe					VSI middle ware
+					|		|									/		for msg							|
+					|		|								/			exchange						|
+					|		|							/														|
+	
+		VSI v4l2 kernel driver											VSI codec kernel driver
+	
+	3.1 v4l2 user space app
+	v4l2 user space app is conformant to v4l2 user space spec. It needs
+	only communicate with VSI v4l2 kernel driver by ioctls and other
+	standard file operations. It can't see VSI v4l2 user space daemon,
+	nor VSI middle ware, nor VSI codec kernel driver.
+	
+	3.2 VSI v4l2 kernel driver
+	VSI v4l2 kernel driver should be conformant to v4l2 kernel driver
+	definition.	It has three main functionalities.
+	3.2.1
+		Link v4l2 user space app with VSI v4l2 daemon. It receives command from
+		v4l2 user space app by ioctl, reformat it, write it to VSI v4l2
+		daemon through message pipe, receives return value from VSI daemon
+		through message pipe and returns it to v4l2 user space app. Currently
+		message pipe is realized through standard file read/write API.
+	3.2.2
+		Manage buffers, including buffer allocation, buffer sharing and queue
+		control.
+	3.2.3
+		Internal state maintaining. This is used to reduce message exchange
+		with VSI v4l2 daemon.
+	
+	3.3 VSI v4l2 kernel driver device files
+		To realize functionality in 3.2 VSI v4l2 driver creates two device files:
+		/dev/video*, file for v4l2 user space app to use.
+		/dev/v4l2,   file for message exchange with VSI v4l2 daemon.
+		
+	3.4 VSI v4l2 user space daemon
+		This daemon has two aspects: it exchange command and state with v4l2
+		kernel driver through message pipe; it controls VSI codec through
+		middle ware.
+		
+4. VSI v4l2 Code organization	(may change in future)
+	<project.v4l2>
+        +-- develop (developing branch)
+                  +-- doc
+                  +-- v4l2_vsi_daemon (user space)
+                  |     
+                  +-- v4l2_vsi_driver
+                  |        +-- vsi_v4l2.c				v4l2 kernel driver skeleton
+                  |        +-- v4l2-daemon.c		message pipe management
+                  |
+                  +-- test
+                           +-- unit (unit test for some function)
+                           +-- ffmpeg (testing the integrate to ffmpeg)
+                           +-- gst (testing the integrate to ffmpeg)
+                           +-- comform (conformance testing)
+                           
\ No newline at end of file
diff --git a/imx_vpu_hantro_daemon.go b/imx_vpu_hantro_daemon.go
new file mode 100755
index 0000000..e7793f8
--- /dev/null
+++ b/imx_vpu_hantro_daemon.go
@@ -0,0 +1,106 @@
+// Copyright 2021 NXP
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//      http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+package imx_vpu_hantro_daemon
+
+import (
+        "android/soong/android"
+        "android/soong/cc"
+        "strings"
+        "github.com/google/blueprint/proptools"
+)
+
+func init() {
+    android.RegisterModuleType("IMX_VPU_HANTRO_DAEMON_DEFAULTS", IMX_VPU_HANTRO_DAEMON_DefaultsFactory)
+}
+
+func IMX_VPU_HANTRO_DAEMON_DefaultsFactory() (android.Module) {
+    module := cc.DefaultsFactory()
+    android.AddLoadHook(module, Hantro_Daemon_Defaults)
+    return module
+}
+
+func Hantro_Daemon_Defaults(ctx android.LoadHookContext) {
+    var Cflags []string
+    var Srcs []string
+    var Shared_libs []string
+    var Include_dirs []string
+    type props struct {
+        Target struct {
+                Android struct {
+                        Enabled *bool
+                        Cflags []string
+                        Srcs []string
+                        Shared_libs []string
+                        Include_dirs []string
+                }
+        }
+    }
+    p := &props{}
+    var vpu_type string = ctx.Config().VendorConfig("IMXPLUGIN").String("BOARD_VPU_TYPE")
+    if strings.Contains(vpu_type, "hantro") {
+        p.Target.Android.Enabled = proptools.BoolPtr(true)
+    } else {
+        p.Target.Android.Enabled = proptools.BoolPtr(false)
+    }
+
+    var board string = ctx.Config().VendorConfig("IMXPLUGIN").String("BOARD_SOC_TYPE")
+    if strings.Contains(board, "IMX8MP") {
+        Cflags = append(Cflags, "-DNXP")
+        Cflags = append(Cflags, "-DHAS_VSI_ENC")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_hevc.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_h264.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vp9.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vp8.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_enc_img_h2.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_enc.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_enc_video_h2.c")
+        Shared_libs = append(Shared_libs, "libhantro_vc8000e")
+        Include_dirs = append(Include_dirs, "vendor/nxp/fsl-codec/ghdr/hantro_VC8000E_enc")
+    } else if strings.Contains(board, "IMX8MM") {
+        Cflags = append(Cflags, "-DUSE_H1")
+        Cflags = append(Cflags, "-DNXP")
+        Cflags = append(Cflags, "-DHAS_VSI_ENC")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_hevc.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_h264.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vp8.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vp9.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_enc_img_h1.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_enc.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_enc_video_h1.c")
+        Shared_libs = append(Shared_libs, "libhantro_h1")
+        Include_dirs = append(Include_dirs, "vendor/nxp/imx-vpu-hantro/h1_encoder/software/inc")
+    } else if strings.Contains(board, "IMX8MQ") {
+        Cflags = append(Cflags, "-DHAS_FULL_DECFMT")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_hevc.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_h264.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_mpeg2.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vp8.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vp9.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_mpeg4.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_vc1.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_jpeg.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_rv.c")
+        Srcs = append(Srcs, "v4l2_vsi_daemon/src/vsi_dec_avs.c")
+    }
+
+    p.Target.Android.Cflags = Cflags
+    p.Target.Android.Srcs = Srcs
+    p.Target.Android.Shared_libs = Shared_libs
+    p.Target.Android.Include_dirs = Include_dirs
+    ctx.AppendProperties(p)
+}
+
+
+
diff --git a/v4l2_vsi_daemon/Makefile b/v4l2_vsi_daemon/Makefile
new file mode 100755
index 0000000..ce7bcdc
--- /dev/null
+++ b/v4l2_vsi_daemon/Makefile
@@ -0,0 +1,76 @@
+#-------------------------------------------------------------------------
+# Makefile
+#
+# Copyright (c) VeriSilicon Beijing
+# All rights reserved.
+#-------------------------------------------------------------------------
+ 
+#Building Target
+#target: 845, 850, ,865
+
+ifeq ($(strip $(target)),)
+target=865
+endif
+
+CC = $(CROSS_COMPILE)gcc --sysroot=$(SDKTARGETSYSROOT)
+C++ = $(CROSS_COMPILE)g++ --sysroot=$(SDKTARGETSYSROOT)
+AR = $(CROSS_COMPILE)ar
+RM=rm -rf
+
+CFLAGS = -fPIC -Wall -Wno-pointer-sign -Wno-unused-function -DUSE_EXTERNAL_BUFFER -DUSE_OUTPUT_RELEASE
+LD_FLAGS = -lpthread -lm
+ifeq ($(debug),1)
+CFLAGS += -g -DDEBUG -O0
+else ifeq ($(debug),2)
+CFLAGS += -g -DDEBUG -O0 -DDEC_COPY_INPUT 
+else
+CFLAGS += -O2
+endif
+
+# OBJECT FILES
+OUT_FILE = vsidaemon
+SRC_OBJECTS = dec_dpb_buff.o buffer_list.o command_defines.o fifo.o hash_table.o object_heap.o	\
+              vsi_dec.o vsi_main.o dec_ts.o
+
+ifeq ($(target),865)
+SRC_OBJECTS += vsi_dec_hevc.o vsi_dec_vp9.o vsi_dec_h264.o vsi_dec_vp8.o vsi_enc_img_h2.o vsi_enc.o vsi_enc_video_h2.o
+CFLAGS += -I$(CTRLSW_HDRPATH)/hantro_dec -I$(CTRLSW_HDRPATH)/hantro_VC8000E_enc -DUSE_G2 -DUSE_G1 -DUSE_HW -DNXP -DHAS_VSI_ENC
+LD_FLAGS += -L. -lhantro -lg1 -lhantro_vc8000e
+
+else ifeq ($(target),845)
+SRC_OBJECTS += vsi_dec_hevc.o vsi_dec_vp9.o  vsi_dec_h264.o vsi_dec_vp8.o vsi_enc_img_h1.o vsi_enc.o vsi_enc_video_h1.o
+CFLAGS += -I$(CTRLSW_HDRPATH)/hantro_dec -I$(CTRLSW_HDRPATH)/hantro_enc -DUSE_G2 -DUSE_G1 -DUSE_HW -DUSE_H1 -DNXP -DHAS_VSI_ENC
+LD_FLAGS += -L. -lhantro -lg1 -lhantro_h1
+
+else ifeq ($(target),850)
+SRC_OBJECTS += vsi_dec_hevc.o vsi_dec_vp9.o vsi_dec_h264.o vsi_dec_mpeg2.o vsi_dec_vp8.o vsi_dec_mpeg4.o vsi_dec_vc1.o vsi_dec_jpeg.o vsi_dec_rv.o vsi_dec_avs.o
+CFLAGS += -I$(CTRLSW_HDRPATH)/hantro_dec -DUSE_G2 -DUSE_G1 -DUSE_HW -DHAS_FULL_DECFMT
+LD_FLAGS += -L. -lhantro -lg1
+
+else
+#echo "invalid building target"
+endif
+
+SRC_DIR = src
+OBJ_DIR = obj
+	
+OBJECTS = $(addprefix $(OBJ_DIR)/, $(SRC_OBJECTS))
+
+.PHONY : all
+
+all : $(OUT_FILE)
+	
+clean:
+	$(RM) $(OBJ_DIR)/*.o 
+	$(RM) $(OUT_FILE)
+
+$(OUT_FILE) : $(OBJECTS)
+	$(CC) -o $(OUT_FILE) $(OBJECTS) $(LD_FLAGS)
+	
+$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
+	mkdir -p $(OBJ_DIR)
+	$(CC) $(CFLAGS) -o $@ -c $(patsubst %.o,%.c , $(patsubst $(OBJ_DIR)/%,$(SRC_DIR)/%,$@))
+
+$(OBJ_DIR)/%.o: $(SRC_DIR)/%.cpp
+	mkdir -p $(OBJ_DIR)
+	$(C++) $(CFLAGS) -o $@ -c $(patsubst %.o,%.cpp , $(patsubst $(OBJ_DIR)/%,$(SRC_DIR)/%,$@))
diff --git a/v4l2_vsi_daemon/src/buffer_list.c b/v4l2_vsi_daemon/src/buffer_list.c
new file mode 100755
index 0000000..4f92c17
--- /dev/null
+++ b/v4l2_vsi_daemon/src/buffer_list.c
@@ -0,0 +1,215 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#include "buffer_list.h"
+#include "stdlib.h"
+#include "vsi_daemon_debug.h"
+/**
+ * @brief bufferlist_init(), initial a buffer list with specified slot num.
+ * @param BUFFERLIST* list: list handle.
+ * @param uint32_t size: slot num.
+ * @return int, 0: succeed; Other value: failed.
+ */
+int bufferlist_init(BUFFERLIST* list, uint32_t size) {
+  ASSERT(list);
+  list->list = (BUFFER**)malloc(sizeof(BUFFER*) * size);
+  if (!list->list) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Error insufficient resources./n");
+    return -1;
+  }
+
+  memset(list->list, 0, sizeof(BUFFER*) * size);
+  list->size = 0;
+  list->capacity = size;
+  return 0;
+}
+
+/**
+ * @brief bufferlist_destroy(), destroy a buffer list.
+ * @param BUFFERLIST* list: list handle.
+ * @return none.
+ */
+void bufferlist_destroy(BUFFERLIST* list) {
+  ASSERT(list);
+  if (list->list) free(list->list);
+  memset(list, 0, sizeof(BUFFERLIST));
+}
+
+/**
+ * @brief bufferlist_get_size(), get available slot num.
+ * @param BUFFERLIST* list: list handle.
+ * @return uint32_t, available slot num.
+ */
+uint32_t bufferlist_get_size(BUFFERLIST* list) {
+  ASSERT(list);
+  return list->size;
+}
+
+/**
+ * @brief bufferlist_get_size(), get total slot num.
+ * @param BUFFERLIST* list: list handle.
+ * @return uint32_t, total slot num.
+ */
+uint32_t bufferlist_get_capacity(BUFFERLIST* list) {
+  ASSERT(list);
+  return list->capacity;
+}
+
+/**
+ * @brief bufferlist_at(), get buffer from list with specified slot id.
+ * @param BUFFERLIST* list: list handle.
+ * @param uint32_t i: the specified slot id.
+ * @return BUFFER*, handle of got buffer.
+ */
+BUFFER** bufferlist_at(BUFFERLIST* list, uint32_t i) {
+  ASSERT(list);
+  ASSERT(i < list->size);
+  return &list->list[i];
+}
+
+/**
+ * @brief bufferlist_find_buffer(), find & get buffer from list with specified
+ * pic_id.
+ * @param BUFFERLIST* list: list handle.
+ * @param uint32_t next_pic_id: the specified pic_id.
+ * @param uint32_t* num: slot id of got buffer.
+ * @return BUFFER*, handle of got buffer.
+ */
+BUFFER* bufferlist_find_buffer(BUFFERLIST* list, uint32_t next_pic_id,
+                               uint32_t* num) {
+  uint32_t size = bufferlist_get_size(list);
+  if (size == 0) return NULL;
+
+  uint32_t i = 0;
+  for (i = 0; i < size; ++i) {
+    BUFFER* buff = *bufferlist_at(list, i);
+    if (buff->frame_display_id == next_pic_id) {
+      *num = i;
+      return buff;
+    }
+  }
+  return NULL;
+}
+
+/**
+ * @brief bufferlist_push_buffer(), push a buffer to list.
+ * @param BUFFERLIST* list: list handle.
+ * @param BUFFER* buff: handle of buffer to push.
+ * @return int, 0: succeed; Other value: failed.
+ */
+int bufferlist_push_buffer(BUFFERLIST* list, BUFFER* buff) {
+  ASSERT(list);
+  if (list->size == list->capacity) return -1;
+  list->list[list->size++] = buff;
+  return 0;
+}
+
+/**
+ * @brief bufferlist_remove(), remove a buffer from list with specified slot id.
+ * @param BUFFERLIST* list: list handle.
+ * @param uint32_t i: the specified slot id.
+ * @return none.
+ */
+void bufferlist_remove(BUFFERLIST* list, uint32_t i) {
+  ASSERT(list);
+  ASSERT(i < list->size);
+  memmove(list->list + i, list->list + i + 1,
+          (list->size - i - 1) * sizeof(BUFFER*));
+  --list->size;
+}
+
+/**
+ * @brief bufferlist_get_buffer(), get the first buffer from list.
+ * @param BUFFERLIST* list: list handle.
+ * @return BUFFER*: handle of got buffer.
+ */
+BUFFER* bufferlist_get_buffer(BUFFERLIST* list) {
+  ASSERT(list);
+  if (list->size == 0) {
+    return NULL;
+  }
+
+  return *bufferlist_at(list, 0);
+}
+
+/**
+ * @brief bufferlist_pop_buffer(), pop(remove) the first buffer from list.
+ * @param BUFFERLIST* list: list handle.
+ * @return int, 0: succeed; Other value: failed.
+ */
+int bufferlist_pop_buffer(BUFFERLIST* list) {
+  ASSERT(list);
+  if (list->size == 0) {
+    return -1;
+  }
+
+  bufferlist_remove(list, 0);
+  return 0;
+}
+
+/**
+ * @brief bufferlist_get_tail(), get the last buffer from list.
+ * @param BUFFERLIST* list: list handle.
+ * @return BUFFER*: handle of got buffer.
+ */
+BUFFER* bufferlist_get_tail(BUFFERLIST* list) {
+  ASSERT(list);
+  if (list->size == 0) {
+    return NULL;
+  }
+
+  return *bufferlist_at(list, list->size - 1);
+}
+
+/**
+ * @brief bufferlist_get_head(), get the last buffer from list.
+ * @param BUFFERLIST* list: list handle.
+ * @return BUFFER*: handle of got buffer.
+ */
+BUFFER* bufferlist_get_head(BUFFERLIST* list) {
+  ASSERT(list);
+  if (list->size == 0) {
+    return NULL;
+  }
+
+  return *bufferlist_at(list, 0);
+}
+
+/**
+ * @brief bufferlist_flush(), flush buffer list.
+ * @param BUFFERLIST *list: buffer list.
+ * @return void.
+ */
+void bufferlist_flush(BUFFERLIST* list) {
+  BUFFER* p = NULL;
+
+  do {
+    p = bufferlist_get_buffer(list);
+    if (p) {
+      free(p);
+      bufferlist_pop_buffer(list);
+    }
+  } while (p);
+}
diff --git a/v4l2_vsi_daemon/src/buffer_list.h b/v4l2_vsi_daemon/src/buffer_list.h
new file mode 100755
index 0000000..81e236a
--- /dev/null
+++ b/v4l2_vsi_daemon/src/buffer_list.h
@@ -0,0 +1,63 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef BUFFER_LIST_H
+#define BUFFER_LIST_H
+#include <string.h>
+#include "command_defines.h"
+#define MAX_BUFFER_SIZE 32
+
+typedef struct BUFFER {
+  union {
+    v4l2_daemon_enc_params enc_cmd;
+    v4l2_daemon_dec_params dec_cmd;
+  };
+  uint32_t frame_display_id;
+} BUFFER;
+
+typedef struct BUFFERLIST {
+  BUFFER** list;
+  uint32_t size;  // list size
+  uint32_t capacity;
+} BUFFERLIST;
+
+int bufferlist_init(BUFFERLIST* list, uint32_t size);
+void bufferlist_destroy(BUFFERLIST* list);
+uint32_t bufferlist_get_size(BUFFERLIST* list);
+uint32_t bufferlist_get_capacity(BUFFERLIST* list);
+BUFFER** bufferlist_at(BUFFERLIST* list, uint32_t i);
+BUFFER* bufferlist_find_buffer(BUFFERLIST* list, uint32_t next_pic_id,
+                               uint32_t* num);
+int bufferlist_push_buffer(BUFFERLIST* list, BUFFER* buff);
+void bufferlist_remove(BUFFERLIST* list, uint32_t i);
+void bufferlist_clear(BUFFERLIST* list);
+BUFFER* bufferlist_get_buffer(BUFFERLIST* list);
+int bufferlist_pop_buffer(BUFFERLIST* list);
+BUFFER* bufferlist_get_tail(BUFFERLIST* list);
+BUFFER* bufferlist_get_head(BUFFERLIST* list);
+void bufferlist_flush(BUFFERLIST* list);
+
+#endif
diff --git a/v4l2_vsi_daemon/src/command_defines.c b/v4l2_vsi_daemon/src/command_defines.c
new file mode 100755
index 0000000..c3d53bf
--- /dev/null
+++ b/v4l2_vsi_daemon/src/command_defines.c
@@ -0,0 +1,479 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#include <sys/mman.h>
+#include <unistd.h>
+
+#include "daemon_instance.h"
+#include "vsi_daemon_debug.h"
+/**
+ * @file command_defines.c
+ * @brief Interface between daemon and v4l2.
+ */
+
+int32_t pipe_fd = 0;  // open /dev/vsi_daemon_ctrl
+int32_t mmap_fd = 0;  // open /dev/mem
+
+/**
+ * @brief open_v4l2_device(), open v4l2 device for communication between daemon
+ * and driver.
+ * @param none.
+ * @return int32_t: file handle.
+ */
+int32_t open_v4l2_device() {
+  int32_t fd = open(PIPE_DEVICE, O_RDWR);
+  if (fd == -1) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed to open: %s
", PIPE_DEVICE);
+    output_log(LOG_DEBUG, 0, "failed to open /dev/v4l2");
+    ASSERT(0);
+  }
+  output_log(LOG_DEBUG, 0, "open device: /dev/v4l2");
+  return fd;
+}
+
+/**
+ * @brief receive_from_v4l2(), receive msg from v4l2 device, block if no msg.
+ * @param int32_t pipe_fd, device fd.
+ * @param struct vsi_v4l2_msg* msg, pointer of buffer for receiving message.
+ * @param int32_t size, size to receive.
+ * @return void.
+ */
+int receive_from_v4l2(int32_t pipe_fd, struct vsi_v4l2_msg *msg, int32_t size) {
+  int err = read(pipe_fd, msg, size);
+  if (err < 0) return -errno;
+
+  return err;
+}
+
+/**
+ * @brief send_ack_to_v4l2(), after receive msg from v4l2 device, send an
+ * acknowledge immediately.
+ * @param int32_t pipe_fd, device fd.
+ * @param struct vsi_v4l2_msg *msg, pointer of buffer for sending message.
+ * @param int32_t size, size to send.
+ * @return void.
+ */
+void send_ack_to_v4l2(int32_t pipe_fd, struct vsi_v4l2_msg *msg, int32_t size) {
+  int32_t wsize = size;
+  if (write(pipe_fd, msg, wsize) != size) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed to write to: %s
", PIPE_DEVICE);
+    ASSERT(0);
+  }
+}
+
+/**
+ * @brief send_notif_to_v4l2(), send notification to v4l2.
+ * @param int32_t pipe_fd, device fd.
+ * @param struct vsi_v4l2_msg *msg, pointer of buffer for sending message.
+ * @param int32_t size, size to send.
+ * @return void.
+ */
+void send_notif_to_v4l2(int32_t pipe_fd, struct vsi_v4l2_msg *msg,
+                        int32_t size) {
+  send_ack_to_v4l2(pipe_fd, msg, size);
+}
+
+/**
+ * @brief send_enc_orphan_msg(), send BUF_RDY event for encoder.
+ * @param vsi_v4l2_msg* v4l2_msg, pointer of buffer for current message.
+ * @param int32_t inbuf_idx, inbuf idx.
+ * @param int32_t outbuf_idx, outbuf idx.
+ * @param int32_t out_buf_size, stream size.
+ * @param int32_t ret_value, return value.
+ * @return void.
+ */
+void send_enc_orphan_msg(vsi_v4l2_msg *v4l2_msg, int32_t inbuf_idx,
+                         int32_t outbuf_idx, int32_t out_buf_size,
+                         int32_t ret_value) {
+  vsi_v4l2_msg msg = {
+      0,
+  };
+
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+  msg.params.enc_params.io_buffer.inbufidx = inbuf_idx;
+  msg.params.enc_params.io_buffer.outbufidx = -1;
+  msg.params.enc_params.io_buffer.bytesused = 0;
+  msg.error = ret_value;
+  msg.inst_id = v4l2_msg->inst_id;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  msg.param_type = v4l2_msg->param_type;
+  msg.size = sizeof(struct v4l2_daemon_enc_buffers);
+  msg.params.enc_params.io_buffer.timestamp = v4l2_msg->params.enc_params.io_buffer.timestamp;
+  send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr) + msg.size);
+
+  if(outbuf_idx == -1) {//when -1, encoder may be overflow and will not return buffers.
+      msg.cmd_id = V4L2_DAEMON_VIDIOC_PICCONSUMED;
+  }
+
+  msg.params.enc_params.io_buffer.inbufidx = -1;
+  msg.params.enc_params.io_buffer.outbufidx = outbuf_idx;
+  msg.params.enc_params.io_buffer.bytesused = out_buf_size;
+  send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr) + msg.size);
+}
+
+/**
+ * @brief send_enc_outputbuf_orphan_msg(), send BUF_RDY event for encoder.
+ * @param vsi_v4l2_msg* v4l2_msg, pointer of buffer for current message.
+ * @param int32_t outbuf_idx, outbuf idx.
+ * @param int32_t out_buf_size, stream size.
+ * @param int32_t flag, last buffer or not for now.
+ * @return void.
+ */
+void send_enc_outputbuf_orphan_msg(vsi_v4l2_msg *v4l2_msg, int32_t outbuf_idx,
+                                   int32_t out_buf_size, int32_t flag) {
+  vsi_v4l2_msg msg = {
+      0,
+  };
+
+  msg.inst_id = v4l2_msg->inst_id;
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+  msg.param_type |= flag;
+  msg.params.enc_params.io_buffer.inbufidx = -1;
+  msg.params.enc_params.io_buffer.outbufidx = outbuf_idx;
+  msg.params.enc_params.io_buffer.bytesused = out_buf_size;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  msg.size = sizeof(struct v4l2_daemon_enc_buffers);
+  send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr) + msg.size);
+}
+
+#define VSI_DEC_GOT_OUTPUT_DATA 0
+#define VSI_DEC_EMPTY_OUTPUT_DATA 1
+
+/**
+ * @brief send_dec_inputbuf_orphan_msg(), send BUF_RDY of src queue for dec.
+ * @param vsi_v4l2_msg* v4l2_msg, pointer of buffer for current message.
+ * @param int32_t inbuf_idx, input buffer index.
+ * @return void.
+ */
+void send_dec_inputbuf_orphan_msg(v4l2_daemon_inst *h, vsi_v4l2_msg *v4l2_msg,
+                                  int32_t inbuf_idx) {
+  vsi_v4l2_msg msg = {
+      0,
+  };
+
+  msg.inst_id = h->instance_id;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+  msg.error = 0;
+  msg.size = sizeof(struct v4l2_daemon_dec_buffers);
+  msg.params.dec_params.io_buffer.inbufidx = inbuf_idx;
+  msg.params.dec_params.io_buffer.outbufidx = INVALID_IOBUFF_IDX;
+
+  if (pipe_fd >= 0)
+    send_notif_to_v4l2(pipe_fd, &msg,
+                       sizeof(struct vsi_v4l2_msg_hdr) + msg.size);
+}
+
+/**
+ * @brief send_fatalerror_orphan_msg(), send error notification to driver.
+ * @param unsigned long inst_id, current instance id.
+ * @param int32_t error, error id.
+ * @return void.
+ */
+void send_fatalerror_orphan_msg(unsigned long inst_id, int32_t error) {
+  vsi_v4l2_msg msg = {0};
+
+  msg.inst_id = inst_id;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  //    msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+  msg.error = error;
+  msg.size = 0;
+
+  if (pipe_fd >= 0)
+    send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr));
+}
+
+/**
+ * @brief send_warning_orphan_msg(), send warning notification to driver.
+ * @param unsigned long inst_id, current instance id.
+ * @param int32_t warn_id, warning id.
+ * @return void.
+ */
+void send_warning_orphan_msg(unsigned long inst_id, int32_t warn_id)
+{
+  vsi_v4l2_msg msg = {0};
+
+  if (pipe_fd >= 0) {
+    msg.inst_id = inst_id;
+    msg.seq_id = NO_RESPONSE_SEQID;
+    msg.cmd_id = V4L2_DAEMON_VIDIOC_WARNONOPTION;
+    msg.error = warn_id;
+    msg.size = 0;
+    send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr));
+  }
+}
+
+/**
+ * @brief send_cmd_orphan_msg(), send specified cmd message to driver.
+ * @param unsigned long inst_id, current instance id.
+ * @param int32_t cmd_id, message id.
+ * @return void.
+ */
+void send_cmd_orphan_msg(unsigned long inst_id, int32_t cmd_id)
+{
+  vsi_v4l2_msg msg = {0};
+
+  if (pipe_fd >= 0) {
+    msg.inst_id = inst_id;
+    msg.seq_id = NO_RESPONSE_SEQID;
+    msg.cmd_id = cmd_id;
+    send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr));
+  }
+}
+
+#if 0
+void send_dec_outputbuf_orphan_msg(v4l2_daemon_inst* h,
+                                      vsi_v4l2_msg* v4l2_msg,
+                                      int32_t outbuf_idx,
+                                      int32_t out_buff_size, int32_t ret_value)
+{
+    vsi_v4l2_msg msg = {0};
+
+    memcpy(&msg, v4l2_msg, sizeof(vsi_v4l2_msg));
+    msg.inst_id = h->instance_id;
+    msg.seq_id = NO_RESPONSE_SEQID;
+    msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+    msg.error = 0;
+    msg.size = sizeof(struct v4l2_daemon_dec_buffers);
+    msg.params.dec_params.io_buffer.inbufidx = INVALID_IOBUFF_IDX;
+    msg.params.dec_params.io_buffer.outbufidx = outbuf_idx;
+    msg.params.dec_params.io_buffer.OutBufSize = out_buff_size;
+    msg.params.dec_params.io_buffer.bytesused = (ret == VSI_DEC_EMPTY_OUTPUT_DATA) ? 0 : out_buff_size;
+
+    if(pipe_fd >= 0)
+    {
+        send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr) + msg.size);
+    }
+}
+/**
+* @brief send_dec_orphan_msg(), initiatively send deccoder's state to v4l2
+* @param v4l2_daemon_inst* h, daemon instance.
+* @param vsi_v4l2_msg* v4l2_msg, pointer of buffer for sending message.
+* @param int32_t inbuf_idx, inbuf idx.
+* @param int32_t outbuf_idx, outbuf idx.
+* @param int32_t out_buff_size, destination buffer size.
+* @param int32_t ret_value, error number.
+* @return void.
+*/
+void send_dec_orphan_msg(v4l2_daemon_inst* h,
+                             vsi_v4l2_msg* v4l2_msg,
+                             int32_t inbuf_idx,
+                             int32_t outbuf_idx, int32_t out_buff_size,
+                             int32_t ret_value)
+{
+    if(inbuf_idx != INVALID_IOBUFF_IDX)
+        send_dec_inputbuf_orphan_msg(h, v4l2_msg, inbuf_idx);
+    if(outbuf_idx != INVALID_IOBUFF_IDX)
+        send_dec_outputbuf_orphan_msg(h, v4l2_msg, outbuf_idx, out_buff_size, ret_value);
+}
+#endif
+
+/**
+ * @brief open_mmap_device_daemon(), open mmap device for map address.
+ * @param none.
+ * @return int32_t file handle.
+ */
+int32_t open_mmap_device_daemon() {
+  int32_t fd = open(MMAP_DEVICE, O_RDWR);
+  if (fd == -1) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed to open: %s
", MMAP_DEVICE);
+    ASSERT(0);
+  }
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "open device: %s
", MMAP_DEVICE);
+  return fd;
+}
+
+/**
+ * @brief mmap_phy_addr_daemon(), map address using mmap device.
+ * @param int32_t fd: file handle.
+ * @param uint32_t phy_addr: physical address.
+ * @param int32_t size: size of the buffer to map.
+ * @return uint32_t *, pointer of address that mapped.
+ */
+uint32_t *mmap_phy_addr_daemon(int32_t fd, vpu_addr_t phy_addr, int32_t size) {
+  void *v_addr; /* virtual addr */
+  vpu_addr_t aligned_phy_addr = phy_addr & (~(MEM_PAGE_SIZE - 1));
+  uint32_t offset = phy_addr - aligned_phy_addr;
+
+  if (offset & 0x3) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "phy address 0x%llx unmappable
", phy_addr);
+    return NULL;
+  }
+  v_addr = mmap(0, size + offset, PROT_READ | PROT_WRITE, MAP_SHARED, fd,
+                aligned_phy_addr);
+  if (v_addr == MAP_FAILED) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "mmap_phy_addr: Failed to mmap phy Address! mmap size %d, phy "
+               "address 0x%llx
",
+               size, phy_addr);
+    return NULL;
+  }
+  return (uint32_t *)(v_addr + offset);
+}
+
+/**
+ * @brief unmap_phy_addr_daemon(), unmap memory.
+ * @param uint32_t *v_addr: virtual address.
+ * @param int32_t size: size of the buffer to unmap.
+ * @return
+ */
+void unmap_phy_addr_daemon(uint32_t *v_addr, int32_t size) {
+  int ret;
+  void *p_aligned = (void *)(((uint64_t)v_addr) & (~(MEM_PAGE_SIZE - 1)));
+
+  ret = munmap(p_aligned, size + ((void *)v_addr - p_aligned));
+  ASSERT(0 == ret);
+  (void)ret;
+}
+
+/**
+ * @brief open_log(), open log tools for debug daemon.
+ * @param int8_t * log_name: log name.
+ * @return none.
+ */
+void open_log(char *log_name) {
+#ifdef LOG_OUTPUT
+  int32_t log_fd;
+  remove(log_name);
+  if ((log_fd = open(log_name, O_CREAT | O_RDWR | O_APPEND, 0644)) < 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "log_fd open faild.
");
+    return;
+  }
+  close(STDERR_FILENO);
+  dup2(log_fd, STDERR_FILENO);
+  close(log_fd);
+  openlog(NULL, LOG_PERROR, LOG_DAEMON);  // open log service
+#endif
+}
+
+/**
+ * @brief send_cmd_to_worker(), send command to worker, and ack to v4l2 driver.
+ * @param[in] h: The daemon instance.
+ * @param[in] msg: The msg being sent to worker.
+ * @return void.
+ */
+void send_cmd_to_worker(v4l2_daemon_inst *h, vsi_v4l2_msg *msg) {
+  ASSERT(h != NULL);
+  int32_t cmd_ID;
+  struct vsi_v4l2_cmd *command;
+  cmd_ID = object_heap_allocate(&h->cmds);
+  command = (struct vsi_v4l2_cmd *)object_heap_lookup(&h->cmds, cmd_ID);
+  if (command == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "object_heap_lookup error.
");
+    return;
+  }
+  memcpy(&command->msg, msg, sizeof(struct vsi_v4l2_msg));
+  FifoPush(h->fifo_inst, command, FIFO_EXCEPTION_DISABLE);
+  msg->size = 0;
+  send_ack_to_v4l2(pipe_fd, msg, sizeof(struct vsi_v4l2_msg_hdr));  // ack an
+                                                                    // ok;
+}
+
+/**
+ * @brief send_fake_cmd(), send fake command avoid blocking.
+ * @param v4l2_daemon_inst* h: daemon instance.
+ * @return void.
+ */
+void send_fake_cmd(v4l2_daemon_inst *h) {
+  ASSERT(h != NULL);
+  int32_t cmd_ID;
+  struct vsi_v4l2_cmd *command;
+
+  cmd_ID = object_heap_allocate(&h->cmds);
+  command = (struct vsi_v4l2_cmd *)object_heap_lookup(&h->cmds, cmd_ID);
+  if (command == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "object_heap_lookup error.
");
+    return;
+  }
+
+  memset(&command->msg, 0, sizeof(vsi_v4l2_msg));
+  command->msg.cmd_id = V4L2_DAEMON_VIDIOC_FAKE;
+  command->msg.inst_id = h->instance_id;
+
+  FifoPush(h->fifo_inst, command, FIFO_EXCEPTION_DISABLE);
+}
+/**
+ * @brief output_log(), output log for debug daemon, max 4 parameters.
+ * @param int32_t priority: log priority.
+ * @param int32_t num: parameter numbers.
+ * @param const int8_t* format: variable parameter.
+ * @return none.
+ */
+void output_log(int32_t priority, int32_t num, const char *format, ...) {
+#ifdef LOG_OUTPUT
+#ifndef MAX_NUM
+#define MAX_NUM 4
+#endif
+  if ((num >= 4) || (num < 0)) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "output_log(): parameter error. num=%d
",
+               num);
+    return;
+  }
+
+  int32_t m_int[MAX_NUM], t_int = 0;
+  va_list valist;
+  float t1;
+  get_time(&t1);
+
+  int8_t format_time[100] = "Time:[%f]    ";
+  strcat(format_time, format);
+
+  va_start(valist, format);
+  for (int32_t i = 0; i < num; i++) {
+    m_int[t_int++] = va_arg(valist, int);
+  }
+  switch (num) {
+    case 0:
+      syslog(priority, format_time, t1);
+      break;
+    case 1:
+      syslog(priority, format_time, t1, m_int[0]);
+      break;
+    case 2:
+      syslog(priority, format_time, t1, m_int[0], m_int[1]);
+      break;
+    case 3:
+      syslog(priority, format_time, t1, m_int[0], m_int[1], m_int[2]);
+      break;
+    case 4:
+      syslog(priority, format_time, t1, m_int[0], m_int[1], m_int[2], m_int[3]);
+      break;
+  }
+  va_end(valist);
+#endif
+}
+
+/**
+ * @brief get_time(), get time for test performance.
+ * @param float *sec: point to a float that for second of now.
+ * @return none.
+ */
+void get_time(float *sec) {
+  struct timeval tv1;
+  gettimeofday(&tv1, NULL);
+  tv1.tv_sec &= 0xffff;
+  *sec = (float)tv1.tv_sec + (float)(tv1.tv_usec) / 1000000;
+}
diff --git a/v4l2_vsi_daemon/src/command_defines.h b/v4l2_vsi_daemon/src/command_defines.h
new file mode 100755
index 0000000..6f3e7c2
--- /dev/null
+++ b/v4l2_vsi_daemon/src/command_defines.h
@@ -0,0 +1,660 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef COMMAND_DEFINES_H
+#define COMMAND_DEFINES_H
+
+#include "object_heap.h"
+#include "v4l2_base_type.h"
+
+#define MAX_STREAMS 100
+#define MAX_GOP_SIZE 8
+#define MAX_INTRA_PIC_RATE 0x7fffffff
+#define NO_RESPONSE_SEQID 0xFFFFFFFE
+#define SEQID_UPLIMT 0x7FFFFFFE
+
+#define OUTF_BASE 0x3ffff000L
+
+#define VSI_DAEMON_DEVMAJOR 100
+
+#define VSI_DAEMON_FNAME "vsi_daemon_ctrl"
+#define VSI_DAEMON_PATH "/usr/bin/vsidaemon"
+#define PIPE_DEVICE "/dev/vsi_daemon_ctrl"
+#define MMAP_DEVICE "/dev/vsi_daemon_ctrl"
+
+#define MEM_PAGE_SIZE (4096)
+
+/* some common defines between driver and daemon */
+#define DEFAULTLEVEL 0
+
+#define FRAMETYPE_I (1 << 1)
+#define FRAMETYPE_P (1 << 2)
+#define FRAMETYPE_B (1 << 3)
+#define LAST_BUFFER_FLAG (1 << 4)
+#define FORCE_IDR (1 << 5)
+#define UPDATE_INFO (1 << 6)
+
+#define VSI_V4L2_MAX_ROI_REGIONS 8
+#define VSI_V4L2_MAX_ROI_REGIONS_H1 2
+#define VSI_V4L2_MAX_IPCM_REGIONS 2
+
+#define INVALID_IOBUFF_IDX (-1)
+
+/*-----------------------------------------------------------
+        communication with v4l2 driver.
+-----------------------------------------------------------*/
+
+struct vsi_v4l2_dev_info {
+  int dec_corenum;
+  int enc_corenum;
+  int enc_isH1;
+  unsigned int max_dec_resolution;
+  unsigned long decformat;  // hw_dec_formats
+  unsigned long encformat;  // hw_enc_formats
+};
+
+/* daemon ioctl id definitions */
+#define VSIV4L2_IOCTL_BASE 'd'
+#define VSI_IOCTL_CMD_BASE _IO(VSIV4L2_IOCTL_BASE, 0x44)
+
+/* user space daemno should use this ioctl to initial HW info to v4l2 driver */
+#define VSI_IOCTL_CMD_INITDEV \
+  _IOW(VSIV4L2_IOCTL_BASE, 45, struct vsi_v4l2_dev_info)
+/* end of daemon ioctl id definitions */
+
+/*these two enum have same sequence, identical to the table vsi_coded_fmt[] in
+ * vsi-v4l2-config.c */
+enum hw_enc_formats {
+  ENC_HAS_HEVC = 0,
+  ENC_HAS_H264,
+  ENC_HAS_JPEG,
+  ENC_HAS_VP8,
+  ENC_HAS_VP9,
+  ENC_HAS_AV1,
+  ENC_FORMATS_MAX,
+};
+
+enum hw_dec_formats {
+  DEC_HAS_HEVC = 0,
+  DEC_HAS_H264,
+  DEC_HAS_JPEG,
+  DEC_HAS_VP8,
+  DEC_HAS_VP9,
+  DEC_HAS_AV1,
+
+  DEC_HAS_MPEG2,
+  DEC_HAS_MPEG4,
+  DEC_HAS_H263,
+  DEC_HAS_VC1_G,
+  DEC_HAS_VC1_L,
+  DEC_HAS_RV,
+  DEC_HAS_AVS2,
+  DEC_HAS_XVID,
+  DEC_HAS_CSC,
+  DEC_FORMATS_MAX
+};
+/*above two enum have same sequence, identical to the table vsi_coded_fmt[] in
+ * vsi-v4l2-config.c */
+
+typedef enum {
+  /*  every command should mark which kind of parameters is valid.
+   *      For example, V4L2_DAEMON_VIDIOC_BUF_RDY can contains input or output
+   * buffers.
+   *          also it can contains other parameters.  */
+  V4L2_DAEMON_VIDIOC_STREAMON = 0,  // for streamon and start
+  V4L2_DAEMON_VIDIOC_BUF_RDY,
+  V4L2_DAEMON_VIDIOC_CMD_STOP,   // this is for flush.
+  V4L2_DAEMON_VIDIOC_STREAMOFF,   //enc destroy
+  V4L2_DAEMON_VIDIOC_ENC_RESET,   //enc reset, as in spec
+  //above are enc cmds
+
+  V4L2_DAEMON_VIDIOC_FAKE,  // fake command.
+
+  /*Below is for decoder*/
+  V4L2_DAEMON_VIDIOC_S_EXT_CTRLS,
+  V4L2_DAEMON_VIDIOC_RESET_BITRATE,
+  V4L2_DAEMON_VIDIOC_CHANGE_RES,
+  V4L2_DAEMON_VIDIOC_G_FMT,
+  V4L2_DAEMON_VIDIOC_S_SELECTION,
+  V4L2_DAEMON_VIDIOC_S_FMT,
+  V4L2_DAEMON_VIDIOC_PACKET,            // tell daemon a frame is ready.
+  V4L2_DAEMON_VIDIOC_STREAMON_CAPTURE,  // for streamon and start
+  V4L2_DAEMON_VIDIOC_STREAMON_OUTPUT,
+  V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE,
+  V4L2_DAEMON_VIDIOC_STREAMOFF_OUTPUT,
+  V4L2_DAEMON_VIDIOC_CMD_START,
+  V4L2_DAEMON_VIDIOC_FRAME,
+  V4L2_DAEMON_VIDIOC_DESTROY_DEC,
+
+  V4L2_DAEMON_VIDIOC_EXIT,  // daemon should exit itself
+  V4L2_DAEMON_VIDIOC_PICCONSUMED,
+  V4L2_DAEMON_VIDIOC_CROPCHANGE,
+  V4L2_DAEMON_VIDIOC_WARNONOPTION,
+  V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE_DONE,
+  V4L2_DAEMON_VIDIOC_TOTAL_AMOUNT,
+} v4l2_daemon_cmd_id;
+
+typedef enum {
+  /*enc format, identical to VCEncVideoCodecFormat except name*/
+  V4L2_DAEMON_CODEC_ENC_HEVC = 0,
+  V4L2_DAEMON_CODEC_ENC_H264,
+  V4L2_DAEMON_CODEC_ENC_AV1,
+  V4L2_DAEMON_CODEC_ENC_VP8,
+  V4L2_DAEMON_CODEC_ENC_VP9,
+  V4L2_DAEMON_CODEC_ENC_MPEG2,
+  V4L2_DAEMON_CODEC_ENC_JPEG,
+
+  /*dec format*/
+  V4L2_DAEMON_CODEC_DEC_HEVC,
+  V4L2_DAEMON_CODEC_DEC_H264,
+  V4L2_DAEMON_CODEC_DEC_JPEG,
+  V4L2_DAEMON_CODEC_DEC_VP9,
+  V4L2_DAEMON_CODEC_DEC_MPEG2,
+  V4L2_DAEMON_CODEC_DEC_MPEG4,
+  V4L2_DAEMON_CODEC_DEC_VP8,
+  V4L2_DAEMON_CODEC_DEC_H263,
+  V4L2_DAEMON_CODEC_DEC_VC1_G,
+  V4L2_DAEMON_CODEC_DEC_VC1_L,
+  V4L2_DAEMON_CODEC_DEC_RV,
+  V4L2_DAEMON_CODEC_DEC_AVS2,
+  V4L2_DAEMON_CODEC_DEC_XVID,
+  V4L2_DAEMON_CODEC_UNKNOW_TYPE,
+} v4l2_daemon_codec_fmt;
+
+typedef enum {
+  VSI_V4L2_DECOUT_DEFAULT,
+  VSI_V4L2_DEC_PIX_FMT_NV12,
+  VSI_V4L2_DEC_PIX_FMT_400,
+  VSI_V4L2_DEC_PIX_FMT_411SP,
+  VSI_V4L2_DEC_PIX_FMT_422SP,
+  VSI_V4L2_DEC_PIX_FMT_444SP,
+  
+  VSI_V4L2_DECOUT_DTRC,
+  VSI_V4L2_DECOUT_P010,
+  VSI_V4L2_DECOUT_NV12_10BIT,
+  VSI_V4L2_DECOUT_DTRC_10BIT,
+  VSI_V4L2_DECOUT_RFC,
+  VSI_V4L2_DECOUT_RFC_10BIT,
+} vsi_v4l2dec_pixfmt;
+
+typedef enum {
+  DAEMON_OK = 0,                   // no error.
+  DAEMON_ENC_FRAME_READY = 1,      // frame encoded
+  DAEMON_ENC_FRAME_ENQUEUE = 2,    // frame enqueued
+
+  DAEMON_ERR_INST_CREATE = -1,       // inst_init() failed.
+  DAEMON_ERR_SIGNAL_CONFIG = -2,     // sigsetjmp() failed.
+  DAEMON_ERR_DAEMON_MISSING = -3,     // daemon is not alive.
+  DAEMON_ERR_NO_MEM = -4,     		// no mem, used also by driver.
+	
+  DAEMON_ERR_ENC_PARA = -100,        // Parameters Error.
+  DAEMON_ERR_ENC_NOT_SUPPORT = -101, // Not Support Error.
+  DAEMON_ERR_ENC_INTERNAL = -102,    // Ctrlsw reported Error.
+  DAEMON_ERR_ENC_BUF_MISSED = -103,  // No desired input buffer.
+  DAEMON_ERR_ENC_FATAL_ERROR = -104,  // Fatal error.
+
+  DAEMON_ERR_DEC_FATAL_ERROR = -200, // Fatal error.
+  DAEMON_ERR_DEC_METADATA_ONLY = -201,  // CMD_STOP after metadata-only.
+}vsi_v4l2daemon_err;
+
+//warn type attached in V4L2_DAEMON_VIDIOC_WARNONOPTION message. Stored in msg.error member
+enum {
+	UNKONW_WARNTYPE = -1,		//not known warning type
+	WARN_ROIREGION,			//(part of)roi region can not work with media setting and be ignored by enc
+	WARN_IPCMREGION,			//(part of)ipcm region can not work with media setting and be ignored by enc
+	WARN_LEVEL,				//current level cant't work with media setting and be updated by enc
+};
+
+typedef struct v4l2_daemon_enc_buffers {
+  /*IO*/
+  int32_t inbufidx;   // from v4l2 driver, don't modify it
+  int32_t outbufidx;  //-1:invalid, other:valid.
+
+  vpu_addr_t busLuma;
+  int32_t busLumaSize;
+  vpu_addr_t busChromaU;
+  int32_t busChromaUSize;
+  vpu_addr_t busChromaV;
+  int32_t busChromaVSize;
+
+  vpu_addr_t busLumaOrig;
+  vpu_addr_t busChromaUOrig;
+  vpu_addr_t busChromaVOrig;
+
+  vpu_addr_t busOutBuf;
+  uint32_t outBufSize;
+
+  uint32_t bytesused;  // valid bytes in buffer from user app.
+  int64_t timestamp;
+} v4l2_daemon_enc_buffers;
+
+typedef struct v4l2_daemon_enc_general_cmd {
+  int32_t valid;  // 0:invalid, 1:valid.
+
+  /*frame property*/
+  int32_t outputRateNumer; /* Output frame rate numerator */
+  int32_t outputRateDenom; /* Output frame rate denominator */
+  int32_t inputRateNumer;  /* Input frame rate numerator */
+  int32_t inputRateDenom;  /* Input frame rate denominator */
+
+  int32_t firstPic;
+  int32_t lastPic;
+
+  int32_t width;         // encode width
+  int32_t height;        // encode height
+  int32_t lumWidthSrc;   // input width
+  int32_t lumHeightSrc;  // input height
+
+  int32_t inputFormat;  // input format
+  int32_t bitPerSecond;
+
+  int32_t rotation;  // prep
+  int32_t mirror;
+  int32_t horOffsetSrc;
+  int32_t verOffsetSrc;
+  int32_t colorConversion;
+  int32_t scaledWidth;
+  int32_t scaledHeight;
+  int32_t scaledOutputFormat;
+
+  int32_t codecFormat;
+} v4l2_daemon_enc_general_cmd;
+
+typedef struct v4l2_daemon_enc_h26x_cmd {
+  int32_t valid;       // 0:invalid, 1:valid.
+  int32_t byteStream;  // byteStream
+
+  int32_t enableCabac;    /* [0,1] H.264 entropy coding mode, 0 for CAVLC, 1 for
+                             CABAC */
+  int32_t cabacInitFlag;  // cabacInitFlag
+
+  int32_t profile;   /*main profile or main still picture profile*/
+  int32_t tier;      /*main tier or high tier*/
+  int32_t avclevel;  /*h264 main profile level*/
+  int32_t hevclevel; /*hevc main profile level*/
+
+  uint32_t strong_intra_smoothing_enabled_flag;  // intra setup
+
+  int32_t cirStart;  // cir
+  int32_t cirInterval;
+
+  int32_t intraAreaEnable;  // intra area
+  int32_t intraAreaTop;
+  int32_t intraAreaLeft;
+  int32_t intraAreaBottom;
+  int32_t intraAreaRight;
+
+  int32_t pcm_loop_filter_disabled_flag;
+
+  int32_t ipcmAreaEnable[VSI_V4L2_MAX_IPCM_REGIONS];
+  int32_t ipcmAreaTop[VSI_V4L2_MAX_IPCM_REGIONS];  // ipcm area 1, 2
+  int32_t ipcmAreaLeft[VSI_V4L2_MAX_IPCM_REGIONS];
+  int32_t ipcmAreaBottom[VSI_V4L2_MAX_IPCM_REGIONS];
+  int32_t ipcmAreaRight[VSI_V4L2_MAX_IPCM_REGIONS];
+
+  int32_t ipcmMapEnable;  // ipcm map
+  uint8_t *ipcmMapBuf;
+
+  int32_t skipMapEnable;  // skip map
+  int32_t skipMapBlockUnit;
+  uint8_t *skipMapBuf;
+
+  int32_t roiAreaEnable[VSI_V4L2_MAX_ROI_REGIONS];  // 8 roi for H2, 2 roi for
+                                                    // H1
+  int32_t roiAreaTop[VSI_V4L2_MAX_ROI_REGIONS];
+  int32_t roiAreaLeft[VSI_V4L2_MAX_ROI_REGIONS];
+  int32_t roiAreaBottom[VSI_V4L2_MAX_ROI_REGIONS];
+  int32_t roiAreaRight[VSI_V4L2_MAX_ROI_REGIONS];
+  int32_t roiDeltaQp[VSI_V4L2_MAX_ROI_REGIONS];  // roiQp has higher priority
+                                                 // than roiDeltaQp
+  int32_t roiQp[VSI_V4L2_MAX_ROI_REGIONS];  // only H2 use it
+
+  uint32_t roiMapDeltaQpBlockUnit;  // roimap cuctrl
+  uint32_t roiMapDeltaQpEnable;
+  uint32_t RoiCuCtrlVer;
+  uint32_t RoiQpDeltaVer;
+  uint8_t *roiMapDeltaQpBuf;
+  uint8_t *cuCtrlInfoBuf;
+
+  /* Rate control parameters */
+  int32_t hrdConformance;
+  int32_t cpbSize;
+  int32_t intraPicRate; /* IDR interval */
+  int32_t vbr;          /* Variable Bit Rate Control by qpMin */
+  int32_t qpHdr;
+  int32_t qpHdrI_h26x;  // for 264/5 I frame QP
+  int32_t qpHdrP_h26x;  // for 264/5 P frame PQ
+  int32_t qpMin_h26x;
+  int32_t qpMax_h26x;
+  int32_t qpHdrI_vpx;  // for vpx I frame QP
+  int32_t qpHdrP_vpx;  // for vpx P frame PQ
+  int32_t qpMin_vpx;
+  int32_t qpMax_vpx;
+  int32_t qpMinI;
+  int32_t qpMaxI;
+  int32_t bitVarRangeI;
+  int32_t bitVarRangeP;
+  int32_t bitVarRangeB;
+  uint32_t u32StaticSceneIbitPercent;
+  int32_t tolMovingBitRate; /*tolerance of max Moving bit rate */
+  int32_t monitorFrames;    /*monitor frame length for moving bit rate*/
+  int32_t picRc;
+  int32_t ctbRc;
+  int32_t blockRCSize;
+  uint32_t rcQpDeltaRange;
+  uint32_t rcBaseMBComplexity;
+  int32_t picSkip;
+  int32_t picQpDeltaMin;
+  int32_t picQpDeltaMax;
+  int32_t ctbRcRowQpStep;
+  int32_t tolCtbRcInter;
+  int32_t tolCtbRcIntra;
+  int32_t bitrateWindow;
+  int32_t intraQpDelta;
+  int32_t fixedIntraQp;
+  int32_t bFrameQpDelta;
+  int32_t disableDeblocking;
+  int32_t enableSao;
+  int32_t tc_Offset;
+  int32_t beta_Offset;
+  int32_t chromaQpOffset;
+
+  int32_t smoothPsnrInGOP;  // smooth psnr
+  int32_t sliceSize;        // multi slice
+
+  int32_t enableDeblockOverride;  // deblock
+  int32_t deblockOverride;
+
+  int32_t enableScalingList;  // scale list
+
+  uint32_t compressor;  // rfc
+
+  int32_t interlacedFrame;  // pregress/interlace
+  int32_t fieldOrder;       // field order
+  int32_t ssim;
+
+  int32_t sei;  // sei
+  int8_t *userData;
+
+  uint32_t gopSize;  // gop
+  int8_t *gopCfg;
+  uint32_t gopLowdelay;
+  int32_t outReconFrame;
+
+  uint32_t longTermGap;  // longterm
+  uint32_t longTermGapOffset;
+  uint32_t ltrInterval;
+  int32_t longTermQpDelta;
+
+  int32_t gdrDuration;  // gdr
+
+  int32_t bitDepthLuma;  // 10 bit
+  int32_t bitDepthChroma;
+
+  uint32_t enableOutputCuInfo;  // cu info
+
+  uint32_t rdoLevel;  // rdo
+
+  int32_t constChromaEn; /* constant chroma control */
+  uint32_t constCb;
+  uint32_t constCr;
+
+  int32_t skip_frame_enabled_flag; /*for skip frame encoding ctr*/
+  int32_t skip_frame_poc;
+
+  /* HDR10 */
+  uint32_t hdr10_display_enable;
+  uint32_t hdr10_dx0;
+  uint32_t hdr10_dy0;
+  uint32_t hdr10_dx1;
+  uint32_t hdr10_dy1;
+  uint32_t hdr10_dx2;
+  uint32_t hdr10_dy2;
+  uint32_t hdr10_wx;
+  uint32_t hdr10_wy;
+  uint32_t hdr10_maxluma;
+  uint32_t hdr10_minluma;
+
+  uint32_t hdr10_lightlevel_enable;
+  uint32_t hdr10_maxlight;
+  uint32_t hdr10_avglight;
+
+  uint32_t hdr10_color_enable;
+  uint32_t hdr10_primary;
+  uint32_t hdr10_transfer;
+  uint32_t hdr10_matrix;
+
+  uint32_t RpsInSliceHeader;
+  uint32_t P010RefEnable;
+  uint32_t vui_timing_info_enable;
+
+  uint32_t picOrderCntType;
+  uint32_t log2MaxPicOrderCntLsb;
+  uint32_t log2MaxFrameNum;
+
+  uint32_t lookaheadDepth;
+  uint32_t halfDsInput;
+  uint32_t cuInfoVersion;
+  uint32_t parallelCoreNum;
+
+  uint32_t force_idr;
+
+  uint32_t vuiVideoSignalTypePresentFlag;  // 1
+  uint32_t vuiVideoFormat;                 // default 5
+  int32_t videoRange;
+  uint32_t vuiColorDescripPresentFlag;  // 1 if elems below exist
+  uint32_t vuiColorPrimaries;
+  uint32_t vuiTransferCharacteristics;
+  uint32_t vuiMatrixCoefficients;
+} v4l2_daemon_enc_h26x_cmd;
+
+typedef struct v4l2_daemon_enc_jpeg_cmd {
+  int32_t valid;  // 0:invalid, 1:valid.
+  int32_t restartInterval;
+  int32_t frameType;
+  int32_t partialCoding;
+  int32_t codingMode;
+  int32_t markerType;
+  int32_t qLevel;
+  int32_t unitsType;
+  int32_t xdensity;
+  int32_t ydensity;
+  int32_t thumbnail;
+  int32_t widthThumb;
+  int32_t heightThumb;
+  int32_t lumWidthSrcThumb;
+  int32_t lumHeightSrcThumb;
+  int32_t horOffsetSrcThumb;
+  int32_t verOffsetSrcThumb;
+  int32_t write;
+  int32_t comLength;
+  int32_t mirror;
+  int32_t formatCustomizedType;
+  int32_t constChromaEn;
+  uint32_t constCb;
+  uint32_t constCr;
+  int32_t losslessEnable;
+  int32_t predictMode;
+  int32_t ptransValue;
+  uint32_t bitPerSecond;
+  uint32_t mjpeg;
+  int32_t rcMode;
+  int32_t picQpDeltaMin;
+  int32_t picQpDeltaMax;
+  uint32_t qpmin;
+  uint32_t qpmax;
+  int32_t fixedQP;
+  uint32_t exp_of_input_alignment;
+  uint32_t streamBufChain;
+  uint32_t streamMultiSegmentMode;
+  uint32_t streamMultiSegmentAmount;
+} v4l2_daemon_enc_jpeg_cmd;
+
+typedef struct v4l2_daemon_enc_params {
+  v4l2_daemon_enc_buffers io_buffer;
+  v4l2_daemon_enc_general_cmd general;
+  union {
+    v4l2_daemon_enc_h26x_cmd enc_h26x_cmd;
+    v4l2_daemon_enc_jpeg_cmd enc_jpeg_cmd;
+  } specific;
+} v4l2_daemon_enc_params;
+
+typedef struct v4l2_daemon_dec_buffers {
+  /*IO*/
+  int32_t inbufidx;   // from v4l2 driver, don't modify it
+  int32_t outbufidx;  //-1:invalid, other:valid.
+
+  vpu_addr_t busInBuf;
+  uint32_t inBufSize;
+  int32_t inputFormat;  // input format
+  int32_t srcwidth;     // encode width
+  int32_t srcheight;    // encode height
+  // infer output
+  vpu_addr_t busOutBuf;  // for Y or YUV
+  int32_t OutBufSize;
+  vpu_addr_t busOutBufUV;
+  int32_t OutUVBufSize;
+  int32_t outBufFormat;
+  int32_t output_width;
+  int32_t output_height;
+  int32_t output_wstride;
+  int32_t output_hstride;
+  int32_t outputPixelDepth;
+
+  vpu_addr_t rfc_luma_offset;
+  vpu_addr_t rfc_chroma_offset;
+
+  uint32_t bytesused;  // valid bytes in buffer from user app.
+  int64_t timestamp;
+
+  int32_t no_reordering_decoding;
+  int32_t securemode_on;
+} v4l2_daemon_dec_buffers;
+
+// stub struct
+typedef struct v4l2_daemon_dec_pp_cfg {
+  uint32_t x;
+  uint32_t y;
+  uint32_t width;
+  uint32_t height;
+} v4l2_daemon_dec_pp_cfg;
+
+typedef struct v4l2_vpu_hdr10_meta {
+  unsigned int hasHdr10Meta;
+  unsigned int redPrimary[2];
+  unsigned int greenPrimary[2];
+  unsigned int bluePrimary[2];
+  unsigned int whitePoint[2];
+  unsigned int maxMasteringLuminance;
+  unsigned int minMasteringLuminance;
+  unsigned int maxContentLightLevel;
+  unsigned int maxFrameAverageLightLevel;
+} v4l2_vpu_hdr10_meta;
+
+typedef struct v4l2_daemon_dec_info {
+  uint32_t frame_width;
+  uint32_t frame_height;
+  uint32_t bit_depth;
+  struct {
+    uint32_t left;
+    uint32_t top;
+    uint32_t width;
+    uint32_t height;
+  } visible_rect;
+  uint32_t needed_dpb_nums;
+  uint32_t dpb_buffer_size;
+  uint32_t pic_wstride;
+  v4l2_daemon_dec_pp_cfg pp_params;
+  uint32_t colour_description_present_flag;
+  uint32_t matrix_coefficients;
+  uint32_t colour_primaries;
+  uint32_t transfer_characteristics;
+  uint32_t video_range;
+  vsi_v4l2dec_pixfmt src_pix_fmt;
+  v4l2_vpu_hdr10_meta vpu_hdr10_meta;
+} v4l2_daemon_dec_info;
+
+typedef struct v4l2_daemon_pic_info {
+  uint32_t width;
+  uint32_t height;
+  uint32_t crop_left;
+  uint32_t crop_top;
+  uint32_t crop_width;
+  uint32_t crop_height;
+  uint32_t pic_wstride;
+} v4l2_daemon_pic_info;
+
+struct v4l2_daemon_dec_resochange_params {
+  v4l2_daemon_dec_buffers io_buffer;
+  v4l2_daemon_dec_info dec_info;
+};
+
+struct v4l2_daemon_dec_pictureinfo_params {
+  // v4l2_daemon_dec_buffers io_buffer;
+  v4l2_daemon_pic_info pic_info;
+};
+
+typedef struct v4l2_daemon_dec_params {
+  union {
+    v4l2_daemon_dec_buffers io_buffer;
+    struct v4l2_daemon_dec_resochange_params dec_info;
+    struct v4l2_daemon_dec_pictureinfo_params pic_info;
+  };
+  //	struct TBCfg general;
+} v4l2_daemon_dec_params;
+
+typedef struct vsi_v4l2_msg_hdr {
+  int32_t size;
+  int32_t error;
+  unsigned long seq_id;
+  unsigned long inst_id;
+  v4l2_daemon_cmd_id cmd_id;
+  v4l2_daemon_codec_fmt codec_fmt;
+  int32_t param_type;  // for save memory. 0:no parameters. 1:enc_params.
+} vsi_v4l2_msg_hdr;
+
+typedef struct vsi_v4l2_msg {
+  int32_t size;
+  int32_t error;
+  unsigned long seq_id;
+  unsigned long inst_id;
+  v4l2_daemon_cmd_id cmd_id;
+  v4l2_daemon_codec_fmt codec_fmt;
+  uint32_t param_type;
+  // above part must be identical to vsi_v4l2_msg_hdr
+
+  union {
+    v4l2_daemon_enc_params enc_params;
+    v4l2_daemon_dec_params dec_params;
+  } params;
+} vsi_v4l2_msg;
+
+typedef struct vsi_v4l2_cmd {
+  struct object_base base;
+  vsi_v4l2_msg msg;
+} vsi_v4l2_cmd;
+
+#endif  //#ifndef COMMAND_DEFINES_H
diff --git a/v4l2_vsi_daemon/src/daemon_instance.h b/v4l2_vsi_daemon/src/daemon_instance.h
new file mode 100755
index 0000000..9109a13
--- /dev/null
+++ b/v4l2_vsi_daemon/src/daemon_instance.h
@@ -0,0 +1,205 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef DAEMON_INSTNCE_H
+#define DAEMON_INSTNCE_H
+
+#include <errno.h>
+#include <fcntl.h>
+#include <pthread.h>
+#include <semaphore.h>
+#include <setjmp.h>
+#include <signal.h>
+#include <stdarg.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/time.h>
+#include <syslog.h>
+#include <unistd.h>
+
+#include "command_defines.h"
+#include "fifo.h"
+#include "object_heap.h"
+#include "vsi_daemon_debug.h"
+
+typedef struct _v4l2_daemon_inst v4l2_daemon_inst;
+
+//#define LOG_OUTPUT
+typedef enum {
+  DAEMON_MODE_UNKNOWN = 0,
+  DAEMON_MODE_ENCODER,
+  DAEMON_MODE_DECODER
+} v4l2_daemon_mode;
+
+// for instance flag, bit mapped
+typedef enum {
+  INST_CATCH_EXCEPTION,
+  INST_FATAL_ERROR,
+} v4l2_inst_flag;
+
+typedef struct {
+  void *(*create)(v4l2_daemon_inst *h);
+  int32_t (*proc)(void *codec, vsi_v4l2_msg *msg);
+  int32_t (*destroy)(void *codec);
+  int32_t (*in_source_change)(void *codec);
+} vsi_daemon_cb;
+
+struct _v4l2_daemon_inst {
+  unsigned long instance_id;
+  int32_t sequence_id;  // order
+  unsigned long flag;
+
+  pthread_t tid;
+  pthread_attr_t attr;
+  sem_t sem_done;
+
+  jmp_buf sigbuf;
+
+  FifoInst fifo_inst;
+  struct object_heap cmds;
+
+  v4l2_daemon_codec_fmt codec_fmt;
+  v4l2_daemon_mode codec_mode;
+
+  void *codec;
+  vsi_daemon_cb func;
+
+  uint32_t pop_cnt;  // for debug.
+};
+
+/**
+ * @brief vsi_create_encoder(), create encoder inst.
+ * @param v4l2_daemon_inst* h: daemon instance.
+ * @return void *: encoder instance.
+ */
+void *vsi_create_encoder(v4l2_daemon_inst *h);
+
+/**
+ * @brief vsi_create_decoder(), create decoder inst.
+ * @param v4l2_daemon_inst* h: daemon instance.
+ * @return void *: decoder instance.
+ */
+void *vsi_create_decoder(v4l2_daemon_inst *h);
+
+/**
+* @brief vsi_enc_get_codec_format(), get supported codec formats by encoder.
+* @param struct vsi_v4l2_dev_info *hwinfo: output info.
+* @return int32_t, 0 means support at least 1 format, -1 means error.
+*/
+int32_t vsi_enc_get_codec_format(struct vsi_v4l2_dev_info *hwinfo);
+
+/**
+* @brief vsi_dec_get_codec_format(), get supported codec formats by decoder.
+* @param struct vsi_v4l2_dev_info *hwinfo: output info.
+* @return int32_t, 0 means support at least 1 format, -1 means error.
+*/
+int vsi_dec_get_codec_format(struct vsi_v4l2_dev_info *hwinfo);
+
+extern int32_t pipe_fd;
+extern int32_t mmap_fd;
+
+/*  open v4l2 device: /dev/v4l2  */
+int32_t open_v4l2_device(void);
+
+/*   receive msg from v4l2 device  */
+int receive_from_v4l2(int32_t pipe_fd, struct vsi_v4l2_msg *msg, int32_t size);
+
+/*  send an acknowledge immediately  */
+void send_ack_to_v4l2(int32_t pipe_fd, struct vsi_v4l2_msg *msg, int32_t size);
+
+/*  send msg or state to v4l2  */
+void send_notif_to_v4l2(int32_t pipe_fd, struct vsi_v4l2_msg *buffer,
+                        int32_t size);
+
+/* send_enc_orphan_msg(), send BUF_RDY event for encoder. */
+void send_enc_orphan_msg(vsi_v4l2_msg *v4l2_msg, int32_t inbuf_idx,
+                         int32_t outbuf_idx, int32_t out_buf_size,
+                         int32_t ret_value);
+/**
+ * @brief send_enc_outputbuf_orphan_msg(), send BUF_RDY event for encoder.
+ * @param vsi_v4l2_msg* v4l2_msg, pointer of buffer for current message.
+ * @param int32_t outbuf_idx, outbuf idx.
+ * @param int32_t out_buf_size, stream size.
+ * @param int32_t flag, last buffer or not for now.
+ * @return void.
+ */
+void send_enc_outputbuf_orphan_msg(vsi_v4l2_msg *v4l2_msg, int32_t outbuf_idx,
+                                   int32_t out_buf_size, int32_t flag);
+void send_fatalerror_orphan_msg(unsigned long inst_id, int32_t error);
+void send_warning_orphan_msg(unsigned long inst_id, int32_t warn_id);
+void send_cmd_orphan_msg(unsigned long inst_id, int32_t cmd_id);
+
+void send_dec_inputbuf_orphan_msg(v4l2_daemon_inst *h, vsi_v4l2_msg *v4l2_msg,
+                                  int32_t inbuf_idx);
+
+void send_dec_outputbuf_orphan_msg(v4l2_daemon_inst *h, vsi_v4l2_msg *v4l2_msg,
+                                   int32_t outbuf_idx, int32_t out_buff_size,
+                                   int32_t ret_value);
+
+void send_dec_orphan_msg(v4l2_daemon_inst *h, vsi_v4l2_msg *v4l2_msg,
+                         int32_t inbuf_idx, int32_t outbuf_idx,
+                         int32_t out_buff_size, int32_t ret_value);
+
+/* open mmap device for map address  */
+int32_t open_mmap_device_daemon(void);
+
+/*  map address using mmap device  */
+uint32_t *mmap_phy_addr_daemon(int32_t fd, vpu_addr_t phy_addr, int32_t size);
+
+/**
+ * @brief unmap_phy_addr_daemon(), unmap memory.
+ * @param uint32_t *v_addr: virtual address.
+ * @param int32_t size: size of the buffer to unmap.
+ * @return
+ */
+void unmap_phy_addr_daemon(uint32_t *v_addr, int32_t size);
+
+/**
+ * @brief send_cmd_to_worker(), send command to worker, and ack to v4l2 driver.
+ * @param[in] h: The daemon instance.
+ * @param[in] msg: The msg being sent to worker.
+ * @return void.
+ */
+void send_cmd_to_worker(v4l2_daemon_inst *h, vsi_v4l2_msg *msg);
+
+/**
+ * @brief send_fake_cmd(), send fake command avoid blocking.
+ * @param v4l2_daemon_inst* inst: daemon instance.
+ * @return void.
+ */
+void send_fake_cmd(v4l2_daemon_inst *inst);
+
+/*  open log tools  */
+void open_log(char *log_name);
+
+/*  output log to file */
+void output_log(int32_t priority, int32_t num, const char *format, ...);
+
+/*  get time for test performance */
+void get_time(float *sec);
+
+#endif
diff --git a/v4l2_vsi_daemon/src/dec_dpb_buff.c b/v4l2_vsi_daemon/src/dec_dpb_buff.c
new file mode 100755
index 0000000..0d4f421
--- /dev/null
+++ b/v4l2_vsi_daemon/src/dec_dpb_buff.c
@@ -0,0 +1,325 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+void dpb_init(v4l2_dec_inst *h) {
+  memset(h->dpb_buffers, 0, sizeof(h->dpb_buffers));
+  for (int i = 0; i < MAX_BUFFER_SIZE; i++) {
+    h->dpb_buffers[i].buff_idx = INVALID_IOBUFF_IDX;
+    h->dpb_buffers[i].status = DPB_STATUS_INVALID;
+    h->dpb_buffers[i].buff.mem_type = DWL_MEM_TYPE_DPB;
+  }
+  h->existed_dpb_nums = 0;
+}
+
+void dpb_destroy(v4l2_dec_inst *h) {
+  struct v4l2_decoder_dbp *p;
+
+  for (int i = 0; i < MAX_BUFFER_SIZE; i++) {
+    p = &h->dpb_buffers[i];
+    if (p->pic_ctx) {
+      free(p->pic_ctx);
+      p->pic_ctx = NULL;
+    }
+
+    p->buff.bus_address = 0;
+    if (p->buff.virtual_address) {
+      unmap_phy_addr_daemon(p->buff.virtual_address, p->buff.size);
+      p->buff.virtual_address = NULL;
+    }
+
+    p->buff_idx = INVALID_IOBUFF_IDX;
+    p->status = DPB_STATUS_INVALID;
+  }
+
+  if(h->existed_dpb_nums != 0) {
+    vsi_v4l2m2m2_deccodec *dec =
+        (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+    if(dec != NULL && dec->remove_buffer != NULL)
+      dec->remove_buffer(h);
+  }
+
+  h->existed_dpb_nums = 0;
+  h->dpb_buffer_added = 0;
+
+}
+
+static uint32_t dpb_find_free_id(v4l2_dec_inst *h) {
+  int32_t i;
+  for (i = 0; i < MAX_DEC_BUFFERS; i++) {
+    if (h->dpb_buffers[i].buff_idx == INVALID_IOBUFF_IDX) {
+      return i;
+    }
+  }
+  return INVALID_IOBUFF_IDX;
+}
+
+static int32_t dpb_find_idx(v4l2_dec_inst *h, int32_t buf_idx) {
+  int32_t i;
+  for (i = 0; i < h->existed_dpb_nums; i++) {
+    if (h->dpb_buffers[i].buff_idx == buf_idx) {
+      return i;
+    }
+  }
+  return INVALID_IOBUFF_IDX;
+}
+
+static uint32_t dpb_add_buffer_at(v4l2_dec_inst *h, int32_t buf_idx,
+                       v4l2_daemon_dec_buffers *buf) {
+  struct v4l2_decoder_dbp *p;
+  uint32_t id;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+
+  ASSERT(dec);
+
+  id = dpb_find_free_id(h);
+  ASSERT(id < MAX_BUFFER_SIZE);
+
+  p = &h->dpb_buffers[id];
+  ASSERT(p->status == DPB_STATUS_INVALID);
+  ASSERT(p->buff.virtual_address == NULL);
+
+  p->buff_idx = buf_idx;
+  p->buff.virtual_address =
+      mmap_phy_addr_daemon(mmap_fd, buf->busOutBuf, buf->OutBufSize);
+  if (p->buff.virtual_address == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "MMAP dpb Buffer FAILED
");
+    ASSERT(0);
+    return INVALID_IOBUFF_IDX;
+  }
+
+  p->buff.bus_address = buf->busOutBuf;
+#ifdef VSI_CMODEL
+  p->buff.bus_address = (addr_t)p->buff.virtual_address;
+#endif
+  p->buff.size = p->buff.logical_size = buf->OutBufSize;
+
+  if (NULL == p->pic_ctx) {
+    if (dec->pic_ctx_size) {
+      p->pic_ctx = calloc(1, dec->pic_ctx_size);
+    }
+  }
+
+  p->status = DPB_STATUS_EMPTY;
+
+  if (h->dec_add_buffer_allowed && dec->add_buffer) {
+    dec->add_buffer(h, &p->buff);
+    p->status = DPB_STATUS_DECODE;
+  }
+
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG,
+             "add dpb buf[%d], status=%d, bus_addr=0x%lx!
", id, p->status,
+             p->buff.bus_address);
+
+  h->existed_dpb_nums++;
+  return id;
+}
+
+void dpb_refresh_buffer_at(v4l2_dec_inst *h, uint32_t id,
+                           v4l2_daemon_dec_buffers *buf) {
+  struct v4l2_decoder_dbp *p;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+
+  ASSERT(id < MAX_BUFFER_SIZE);
+  ASSERT(buf);
+
+  p = &h->dpb_buffers[id];
+  if (buf)
+    ASSERT(p->status == DPB_STATUS_RENDER ||
+           p->status == DPB_STATUS_PSEUDO_RENDER ||
+           p->status == DPB_STATUS_PSEUDO_DECODE);
+  ASSERT(p->buff.virtual_address);
+
+#ifndef VSI_CMODEL
+  if (buf) ASSERT(p->buff.bus_address == buf->busOutBuf);
+#endif
+  if (buf) ASSERT(p->buff.size == buf->OutBufSize);
+
+  if (h->dec_add_buffer_allowed && dec && dec->release_pic &&
+      p->status == DPB_STATUS_RENDER) {
+    dec->release_pic(h, p->pic_ctx);
+  }
+  p->status = DPB_STATUS_DECODE;
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "pic[%d], status=%d, buf_addr=0x%lx!
", id,
+             p->status, p->buff.bus_address);
+}
+
+void dpb_receive_buffer(v4l2_dec_inst *h, uint32_t buf_idx,
+                        v4l2_daemon_dec_buffers *buf) {
+  int32_t id;
+  id = dpb_find_idx(h, buf_idx);
+  if (id == INVALID_IOBUFF_IDX) {
+    id = dpb_add_buffer_at(h, buf_idx, buf);
+    ASSERT(id != INVALID_IOBUFF_IDX);
+  } else if (h->dpb_buffers[id].status == DPB_STATUS_RENDER ||
+             h->dpb_buffers[id].status == DPB_STATUS_PSEUDO_RENDER ||
+             h->dpb_buffers[id].status == DPB_STATUS_PSEUDO_DECODE) {
+    dpb_refresh_buffer_at(h, id, buf);
+  } else if (h->dpb_buffers[id].status == DPB_STATUS_DECODE) {
+#ifndef VSI_CMODEL
+    ASSERT(h->dpb_buffers[id].buff.bus_address == buf->busOutBuf);
+#endif
+    ASSERT(h->dpb_buffers[id].buff.size == buf->OutBufSize);
+  } else {
+    HANTRO_LOG(HANTRO_LEVEL_WARNING,
+               "Update dpb buffer[%d] in wrong state %d, buf_idx = %d!
", id,
+               h->dpb_buffers[id].status, buf_idx);
+    // TBD        ASSERT(0);
+  }
+
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "receive buffer[%d], status=%d!
", id,
+             h->dpb_buffers[id].status);
+}
+
+int32_t dpb_find_buffer(v4l2_dec_inst *h, addr_t bus_addr) {
+  uint32_t i;
+
+  for (i = 0; i < h->existed_dpb_nums; i++) {
+    if (h->dpb_buffers[i].buff.bus_address == bus_addr) {
+      return i;
+    }
+  }
+
+  HANTRO_LOG(HANTRO_LEVEL_ERROR,
+             "didn't find dbp buffer with bus address %lx
", bus_addr);
+  return INVALID_IOBUFF_IDX;
+}
+
+struct v4l2_decoder_dbp *dpb_list_buffer(v4l2_dec_inst *h, uint32_t id) {
+  struct v4l2_decoder_dbp *p;
+
+  ASSERT(id < MAX_BUFFER_SIZE);
+
+  p = &h->dpb_buffers[id];
+  if (p->status == DPB_STATUS_INVALID) {
+    return NULL;
+  }
+
+  return p;
+}
+
+struct DWLLinearMem *dpb_get_buffer(v4l2_dec_inst *h, uint32_t id) {
+  struct v4l2_decoder_dbp *p;
+
+  ASSERT(id < MAX_BUFFER_SIZE);
+
+  p = &h->dpb_buffers[id];
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "get buf[%d], status=%d!
", id, p->status);
+  if (p->status != DPB_STATUS_EMPTY) {
+    return NULL;
+  }
+
+  ASSERT(p->buff_idx != INVALID_IOBUFF_IDX);
+  p->status = DPB_STATUS_DECODE;
+  return &p->buff;
+}
+
+void dpb_get_buffers(v4l2_dec_inst *h) {
+  struct v4l2_decoder_dbp *p;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+
+  for (int i = 0; i < MAX_BUFFER_SIZE; i++) {
+    p = dpb_list_buffer(h, i);
+    if (p && p->status == DPB_STATUS_EMPTY) {
+      if (h->dec_add_buffer_allowed && dec->add_buffer) {
+        dec->add_buffer(h, &p->buff);
+        p->status = DPB_STATUS_DECODE;
+      }
+    }
+  }
+}
+
+int32_t dpb_render_buffer(v4l2_dec_inst *h, vsi_v4l2_dec_picture *pic) {
+  int32_t id = INVALID_IOBUFF_IDX;
+  int32_t empty_id = INVALID_IOBUFF_IDX;
+  struct v4l2_decoder_dbp *p;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+
+  if (pic == NULL) {
+    for (int i = 0; i < MAX_BUFFER_SIZE; i++) {
+      p = dpb_list_buffer(h, i);
+      if (p && p->status == DPB_STATUS_DECODE) {
+        empty_id = i;
+      }
+      if (0) {  // p && (p->status == DPB_STATUS_RENDER) && dec &&
+                // dec->release_pic) {
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, "release pic[%d], status=%d!
", i,
+                   p->status);
+        dec->release_pic(h, p->pic_ctx);
+        p->status = DPB_STATUS_PSEUDO_DECODE;
+      }
+    }
+    if (empty_id != INVALID_IOBUFF_IDX) {
+      p = dpb_list_buffer(h, empty_id);
+      p->status = DPB_STATUS_PSEUDO_RENDER;
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "render buf[%d], status=%d!
", empty_id,
+                 p->status);
+    }
+    HANTRO_LOG(HANTRO_LEVEL_DEBUG, "render empty buf[%d]
", empty_id);
+    return empty_id;
+  }
+
+  id = dpb_find_buffer(h, pic->output_picture_bus_address);
+
+  ASSERT(id != INVALID_IOBUFF_IDX);
+
+  p = &h->dpb_buffers[id];
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "render buf[%d], status=%d bus address %x
",
+             id, p->status, (unsigned int)pic->output_picture_bus_address);
+  ASSERT(p->status == DPB_STATUS_DECODE ||
+         p->status == DPB_STATUS_PSEUDO_DECODE);
+
+  memcpy(p->pic_ctx, pic->priv_pic_data, dec->pic_ctx_size);
+  p->status = DPB_STATUS_RENDER;
+
+  return id;
+}
+
+void dpb_refresh_all_buffers(v4l2_dec_inst *h) {
+  struct v4l2_decoder_dbp *p = NULL;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+  for (int i = 0; i < MAX_BUFFER_SIZE; i++) {
+    p = dpb_list_buffer(h, i);
+    if (p && (p->status == DPB_STATUS_RENDER) && dec && dec->release_pic) {
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "release pic[%d], status=%d!
", i,
+                 p->status);
+      dec->release_pic(h, p->pic_ctx);
+      p->status = DPB_STATUS_PSEUDO_DECODE;
+    }
+  }
+}
diff --git a/v4l2_vsi_daemon/src/dec_dpb_buff.h b/v4l2_vsi_daemon/src/dec_dpb_buff.h
new file mode 100755
index 0000000..23b021a
--- /dev/null
+++ b/v4l2_vsi_daemon/src/dec_dpb_buff.h
@@ -0,0 +1,43 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef VSI_DEC_DPB_BUFF_H
+#define VSI_DEC_DPB_BUFF_H
+
+#include "vsi_dec.h"
+
+void dpb_init(v4l2_dec_inst* h);
+void dpb_destroy(v4l2_dec_inst* h);
+void dpb_receive_buffer(v4l2_dec_inst* h, uint32_t buf_idx,
+                        v4l2_daemon_dec_buffers* buf);
+int32_t dpb_find_buffer(v4l2_dec_inst* h, addr_t bus_addr);
+struct v4l2_decoder_dbp* dpb_list_buffer(v4l2_dec_inst* h, uint32_t id);
+struct DWLLinearMem* dpb_get_buffer(v4l2_dec_inst* h, uint32_t id);
+void dpb_get_buffers(v4l2_dec_inst* h);
+int32_t dpb_render_buffer(v4l2_dec_inst* h, vsi_v4l2_dec_picture* pic);
+void dpb_refresh_all_buffers(v4l2_dec_inst* h);
+
+#endif  // VSI_DEC_DPB_BUFF_H
diff --git a/v4l2_vsi_daemon/src/dec_ts.c b/v4l2_vsi_daemon/src/dec_ts.c
new file mode 100755
index 0000000..a7bb2f7
--- /dev/null
+++ b/v4l2_vsi_daemon/src/dec_ts.c
@@ -0,0 +1,758 @@
+/****************************************************************************
+*
+*    Copyright (c) 2010-2012, Freescale Semiconductor, Inc. All rights reserved.
+*    Copyright 2020 NXP
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "dec_ts.h"
+#include "vsi_daemon_debug.h"
+
+const char *debug_env = "ME_DEBUG";
+char *debug = NULL;
+int debug_level = 0;
+
+
+enum
+{
+  DEBUG_LEVEL_ERROR = 1,
+  DEBUG_LEVEL_WARNING,
+  DEBUG_LEVEL_LOG,
+  DEBUG_LEVEL_VERBOSE,
+};
+
+
+#define TSM_MESSAGE(level, fmt, ...)\
+  do{\
+    if (debug_level>=(level)){\
+      printf("TSM:"fmt, ##__VA_ARGS__);\
+    }\
+  }while(0)
+
+#define TSM_ERROR(...) TSM_MESSAGE(DEBUG_LEVEL_ERROR, ##__VA_ARGS__)
+#define TSM_WARNING(...) TSM_MESSAGE(DEBUG_LEVEL_WARNING, ##__VA_ARGS__)
+#define TSM_LOG(...) TSM_MESSAGE(DEBUG_LEVEL_LOG, ##__VA_ARGS__)
+#define TSM_VERBOSE(...) TSM_MESSAGE(DEBUG_LEVEL_VERBOSE, ##__VA_ARGS__)
+
+#define TSM_HISTORY_POWER 5
+#define TSM_HISTORY_SIZE (1<<TSM_HISTORY_POWER)
+#define TSM_ADAPTIVE_INTERVAL(tsm) \
+    (tsm->dur_history_total>>TSM_HISTORY_POWER)
+
+#define TSM_SECOND ((TSM_TIMESTAMP)1000000000)
+#define TSM_DEFAULT_INTERVAL (TSM_SECOND/30)
+#define TSM_DEFAULT_TS_BUFFER_SIZE (128)
+
+#define TSM_TS_IS_VALID(ts)	\
+    ((ts) != TSM_TIMESTAMP_NONE)
+
+#define TSM_KEY_IS_VALID(key) \
+    ((key) != TSM_KEY_NONE)
+
+#define TSM_DISTANCE(tsm)\
+    (((tsm->rx)>=(tsm->tx))?((tsm->rx)-(tsm->tx)):(tsm->ts_buf_size-(tsm->tx)+(tsm->rx)))
+
+#define TSM_PLUS_AGE(tsm)\
+    (TSM_DISTANCE(tsm)+tsm->invalid_ts_count+2)
+
+#define TSM_ABS(ts0, ts1)\
+    (((ts0)>(ts1))?((ts0)-(ts1)):((ts1)-(ts0)))
+
+#define TSM_TIME_FORMAT "u:%02u:%02u.%09u"
+
+#define TSM_TIME_ARGS(t) \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) (((TSM_TIMESTAMP)(t)) / (TSM_SECOND * 60 * 60)) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) ((((TSM_TIMESTAMP)(t)) / (TSM_SECOND * 60)) % 60) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) ((((TSM_TIMESTAMP)(t)) / TSM_SECOND) % 60) : 99, \
+        TSM_TS_IS_VALID (t) ? \
+        (unsigned int) (((TSM_TIMESTAMP)(t)) % TSM_SECOND) : 999999999
+
+#define TSM_BUFFER_SET(buf, value, size) \
+    do {\
+        int i;\
+        for (i=0;i<(size);i++){\
+            (buf)[i] = (value);\
+        }\
+    }while(0)
+
+#define TSM_RECEIVED_NUNBER 512
+
+
+typedef struct
+{
+  TSM_TIMESTAMP ts;
+  unsigned long long age;
+  void *key;
+} TSMControl;
+
+typedef struct _TSMReceivedEntry
+{
+  TSM_TIMESTAMP ts;
+  struct _TSMReceivedEntry *next;
+  unsigned int used:1;
+  unsigned int subentry:1;
+  int size;
+} TSMReceivedEntry;
+
+typedef struct _TSMReceivedEntryMemory
+{
+  struct _TSMReceivedEntryMemory *next;
+  TSMReceivedEntry entrys[TSM_RECEIVED_NUNBER];
+} TSMReceivedEntryMemory;
+
+typedef struct
+{
+  TSMReceivedEntry *head;
+  TSMReceivedEntry *tail;
+  TSMReceivedEntry *free;
+  TSMReceivedEntryMemory *memory;
+  int cnt;
+} TSMRecivedCtl;
+
+typedef struct _TSManager
+{
+  int first_tx;
+  int first_rx;
+  int rx;                       //timestamps received
+  int tx;                       //timestamps transfered
+  TSM_TIMESTAMP last_ts_sent;   //last time stamp sent
+  TSM_TIMESTAMP last_ts_received;
+  TSM_TIMESTAMP suspicious_ts;
+
+  TSM_TIMESTAMP discont_threshold;
+
+  unsigned int invalid_ts_count;
+  TSMGR_MODE mode;
+  int ts_buf_size;
+  int dur_history_tx;
+  TSM_TIMESTAMP dur_history_total;
+  TSM_TIMESTAMP dur_history_buf[TSM_HISTORY_SIZE];
+  TSMControl *ts_buf;
+  unsigned long long age;
+  int tx_cnt;
+  int rx_cnt;
+  int cnt;
+  int valid_ts_received:1;
+  int big_cnt;
+
+  TSMRecivedCtl rctl;
+} TSManager;
+
+
+static void
+tsm_free_received_entry (TSMRecivedCtl * rctl, TSMReceivedEntry * entry)
+{
+  entry->next = rctl->free;
+  rctl->free = entry;
+}
+
+
+static TSMReceivedEntry *
+tsm_new_received_entry (TSMRecivedCtl * rctl)
+{
+  TSMReceivedEntry *ret = NULL;
+  if (rctl->free) {
+    ret = rctl->free;
+    rctl->free = ret->next;
+  } else {
+    TSMReceivedEntryMemory *p = malloc (sizeof (TSMReceivedEntryMemory));
+    if (p) {
+      int i;
+      for (i = 1; i < TSM_RECEIVED_NUNBER; i++) {
+        TSMReceivedEntry *e = &p->entrys[i];
+        tsm_free_received_entry (rctl, e);
+      };
+
+      p->next = rctl->memory;
+      rctl->memory = p;
+
+      ret = p->entrys;
+    }
+  }
+  return ret;
+}
+
+
+void
+TSManagerReceive2 (void *handle, TSM_TIMESTAMP timestamp, int size)
+{
+#define CLEAR_TSM_RENTRY(entry)\
+  do { \
+    (entry)->used = 0; \
+    (entry)->subentry = 0; \
+    (entry)->next = NULL; \
+  } while (0)
+  TSManager *tsm = (TSManager *) handle;
+
+  HANTRO_LOG(HANTRO_LEVEL_LOG, "receive2 %" TSM_TIME_FORMAT " size %d
",
+      TSM_TIME_ARGS (timestamp), size);
+
+  if (tsm) {
+    if (size > 0) {
+      TSMRecivedCtl *rctl = &tsm->rctl;
+      TSMReceivedEntry *e = tsm_new_received_entry (rctl);
+      if (e) {
+        CLEAR_TSM_RENTRY (e);
+        if ((rctl->tail) && (rctl->tail->ts == timestamp)) {
+          e->subentry = 1;
+        }
+        e->ts = timestamp;
+        e->size = size;
+        if (rctl->tail) {
+          rctl->tail->next = e;
+          rctl->tail = e;
+        } else {
+          rctl->head = rctl->tail = e;
+        }
+      }
+      rctl->cnt++;
+    } else {
+      TSManagerReceive (handle, timestamp);
+    }
+  }
+}
+
+
+static TSM_TIMESTAMP
+TSManagerGetLastTimeStamp (TSMRecivedCtl * rctl, int size, int use)
+{
+  TSM_TIMESTAMP ts = TSM_TIMESTAMP_NONE;
+  TSMReceivedEntry *e;
+  while ((size > 0) && (e = rctl->head)) {
+    ts = ((e->used) ? (TSM_TIMESTAMP_NONE) : (e->ts));
+
+    HANTRO_LOG(HANTRO_LEVEL_LOG, "ts get: %" TSM_TIME_FORMAT "
",
+        TSM_TIME_ARGS (ts));
+
+    if (use)
+      e->used = 1;
+    if (size >= e->size) {
+      rctl->head = e->next;
+      if (rctl->head == NULL) {
+        rctl->tail = NULL;
+      } else {
+#if 0
+        //removed for rtp/rtsp streaming fix,
+        //this will make same timestamp buffers output timestamp to -1.
+        if (rctl->head->subentry) {
+          rctl->head->used = e->used;
+        }
+#endif
+      }
+      size -= e->size;
+      rctl->cnt--;
+      tsm_free_received_entry (rctl, e);
+    } else {
+      e->size -= size;
+      size = 0;
+    }
+  }
+  return ts;
+}
+
+
+void
+TSManagerFlush2 (void *handle, int size)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSManagerGetLastTimeStamp (&tsm->rctl, size, 0);
+  }
+
+}
+
+
+/*======================================================================================
+FUNCTION:           mfw_gst_receive_ts
+
+DESCRIPTION:        Check timestamp and do frame dropping if enabled
+
+ARGUMENTS PASSED:   pTimeStamp_Object  - TimeStamp Manager to handle related timestamp
+                    timestamp - time stamp of the input buffer which has video data.
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+static void
+_TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp, void *key)
+{
+  TSManager *tsm = (TSManager *) handle;
+
+  if (tsm) {
+    if (TSM_TS_IS_VALID (timestamp) && (tsm->rx_cnt))
+      tsm->valid_ts_received = 1;
+    tsm->rx_cnt++;
+    if (tsm->cnt < tsm->ts_buf_size - 1) {
+      tsm->cnt++;
+      if (tsm->mode == MODE_AI) {
+
+        if (TSM_TS_IS_VALID (timestamp)) {
+          if (tsm->first_rx) {
+            tsm->last_ts_received = timestamp;
+            tsm->first_rx = 0;
+          } else {
+            if (tsm->suspicious_ts) {
+              if (timestamp >= tsm->suspicious_ts) {
+                tsm->last_ts_received = timestamp;
+              }
+              tsm->suspicious_ts = 0;
+            }
+            if ((timestamp > tsm->last_ts_received)
+                && (timestamp - tsm->last_ts_received > tsm->discont_threshold)) {
+              tsm->suspicious_ts = timestamp;
+              timestamp = TSM_TIMESTAMP_NONE;
+            }
+          }
+        }
+
+        if (TSM_TS_IS_VALID (timestamp))        // && (TSM_ABS(timestamp, tsm->last_ts_sent)<TSM_SECOND*10))
+        {
+          tsm->ts_buf[tsm->rx].ts = timestamp;
+          tsm->ts_buf[tsm->rx].age = tsm->age + TSM_PLUS_AGE (tsm);
+          tsm->ts_buf[tsm->rx].key = key;
+          tsm->last_ts_received = timestamp;
+#ifdef DEBUG
+          //printf("age should %lld %lld
", tsm->age, tsm->ts_buf[tsm->rx].age);
+          //printf("++++++ distance = %d  tx=%d, rx=%d, invalid count=%d
", TSM_DISTANCE(tsm), tsm->tx, tsm->rx,tsm->invalid_ts_count);
+#endif
+          tsm->rx = ((tsm->rx + 1) % tsm->ts_buf_size);
+        } else {
+          tsm->invalid_ts_count++;
+        }
+      } else if (tsm->mode == MODE_FIFO) {
+        tsm->ts_buf[tsm->rx].ts = timestamp;
+        tsm->rx = ((tsm->rx + 1) % tsm->ts_buf_size);
+      }
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "++Receive %d:%" TSM_TIME_FORMAT
+          ", invalid:%d, size:%d key %p
", tsm->rx_cnt,
+          TSM_TIME_ARGS (timestamp), tsm->invalid_ts_count, tsm->cnt, key);
+    } else {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Too many timestamps recieved!! (cnt=%d)
", tsm->cnt);
+    }
+  }
+}
+
+
+void
+TSManagerValid2 (void *handle, int size, void *key)
+{
+  TSManager *tsm = (TSManager *) handle;
+
+  HANTRO_LOG(HANTRO_LEVEL_LOG, "valid2 size %d
", size);
+
+  if (tsm) {
+    TSM_TIMESTAMP ts;
+    ts = TSManagerGetLastTimeStamp (&tsm->rctl, size, 1);
+    HANTRO_LOG(HANTRO_LEVEL_LOG, "TSManagerGetLastTimeStamp: %" TSM_TIME_FORMAT "
",
+        TSM_TIME_ARGS (ts));
+    _TSManagerReceive (tsm, ts, key);
+  }
+}
+
+
+void
+TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp)
+{
+  _TSManagerReceive (handle, timestamp, TSM_KEY_NONE);
+}
+
+
+/*======================================================================================
+FUNCTION:           TSManagerSend
+
+DESCRIPTION:        Check timestamp and do frame dropping if enabled
+
+ARGUMENTS PASSED:   pTimeStamp_Object  - TimeStamp Manager to handle related timestamp
+                    ptimestamp - returned timestamp to use at render
+
+RETURN VALUE:       None
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+static TSM_TIMESTAMP
+_TSManagerSend2 (void *handle, void *key, int send)
+{
+  TSManager *tsm = (TSManager *) handle;
+  int i;
+  int index = -1;
+  TSM_TIMESTAMP ts0 = 0, tstmp = TSM_TIMESTAMP_NONE;
+  unsigned long long age = 0;
+  TSM_TIMESTAMP half_interval;
+
+  if (tsm) {
+    i = tsm->tx;
+    half_interval = TSM_ADAPTIVE_INTERVAL (tsm) >> 1;
+    if (send) {
+      tsm->tx_cnt++;
+    } else {
+      tsm->cnt++;
+      tsm->invalid_ts_count++;
+    }
+    if (tsm->cnt > 0) {
+      if (send) {
+        tsm->cnt--;
+      }
+      if (tsm->mode == MODE_AI) {
+
+        if (tsm->first_tx == 0) {
+          tstmp = tsm->last_ts_sent + TSM_ADAPTIVE_INTERVAL (tsm);
+        } else {
+          tstmp = tsm->last_ts_sent;
+        }
+
+        while (i != tsm->rx) {
+          if (index >= 0) {
+            if (tsm->ts_buf[i].ts < ts0) {
+              ts0 = tsm->ts_buf[i].ts;
+              age = tsm->ts_buf[i].age;
+              index = i;
+            }
+          } else {
+            ts0 = tsm->ts_buf[i].ts;
+            age = tsm->ts_buf[i].age;
+            index = i;
+          }
+          if ((TSM_KEY_IS_VALID (key)) && (key == tsm->ts_buf[i].key))
+            break;
+          i = ((i + 1) % tsm->ts_buf_size);
+        }
+        if (index >= 0) {
+          if ((tsm->invalid_ts_count) && (ts0 >= ((tstmp) + half_interval))
+              && (age > tsm->age)) {
+            /* use calculated ts0 */
+            if (send) {
+              tsm->invalid_ts_count--;
+            }
+          } else {
+
+            if (send) {
+              if (index != tsm->tx) {
+                tsm->ts_buf[index] = tsm->ts_buf[tsm->tx];
+              }
+              tsm->tx = ((tsm->tx + 1) % tsm->ts_buf_size);
+
+            }
+#if 0
+            if (ts0 >= ((tstmp) + half_interval))
+              tstmp = tstmp;
+            else
+              tstmp = ts0;
+#else
+            tstmp = ts0;
+#endif
+          }
+
+        } else {
+          if (send) {
+            tsm->invalid_ts_count--;
+          }
+        }
+
+        if (tsm->first_tx == 0) {
+
+          if (tstmp > tsm->last_ts_sent) {
+            ts0 = (tstmp - tsm->last_ts_sent);
+          } else {
+            ts0 = 0;
+            //reset the timestamp to last frame only when new frames's timestamp is earlier than one frame.
+            if (tstmp + TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2 < tsm->last_ts_sent )
+              tstmp = tsm->last_ts_sent;
+          }
+
+          if (ts0 > TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2) {
+            HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Jitter1:%" TSM_TIME_FORMAT " %" TSM_TIME_FORMAT "
",
+                TSM_TIME_ARGS (ts0),
+                TSM_TIME_ARGS (TSM_ADAPTIVE_INTERVAL (tsm) * 3 / 2));
+          } else if (ts0 == 0) {
+            HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Jitter:%" TSM_TIME_FORMAT "
", TSM_TIME_ARGS (ts0));
+          }
+
+          if (send) {
+            if ((ts0 < TSM_ADAPTIVE_INTERVAL (tsm) * 5) || (tsm->big_cnt > 3)) {
+              tsm->big_cnt = 0;
+              tsm->dur_history_total -=
+                  tsm->dur_history_buf[tsm->dur_history_tx];
+              tsm->dur_history_buf[tsm->dur_history_tx] = ts0;
+              tsm->dur_history_tx =
+                  ((tsm->dur_history_tx + 1) % TSM_HISTORY_SIZE);
+              tsm->dur_history_total += ts0;
+            } else {
+              tsm->big_cnt++;
+            }
+          }
+        }
+
+        if (send) {
+          tsm->last_ts_sent = tstmp;
+          tsm->age++;
+          tsm->first_tx = 0;
+        }
+
+      } else if (tsm->mode == MODE_FIFO) {
+        tstmp = tsm->ts_buf[tsm->tx].ts;
+        if (send) {
+          tsm->tx = ((tsm->tx + 1) % tsm->ts_buf_size);
+        }
+        ts0 = tstmp - tsm->last_ts_sent;
+        if (send) {
+          tsm->last_ts_sent = tstmp;
+        }
+      }
+
+      if (send) {
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, "--Send %d:%" TSM_TIME_FORMAT ", int:%" TSM_TIME_FORMAT
+            ", avg:%" TSM_TIME_FORMAT " inkey %p
", tsm->tx_cnt,
+            TSM_TIME_ARGS (tstmp), TSM_TIME_ARGS (ts0),
+            TSM_TIME_ARGS (TSM_ADAPTIVE_INTERVAL (tsm)), key);
+      }
+
+    } else {
+      if (tsm->valid_ts_received == 0) {
+        if (tsm->first_tx) {
+          tstmp = tsm->last_ts_sent;
+        } else {
+          tstmp = tsm->last_ts_sent + TSM_ADAPTIVE_INTERVAL (tsm);
+        }
+        if (send) {
+          tsm->first_tx = 0;
+          tsm->last_ts_sent = tstmp;
+        }
+      }
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Too many timestamps send!!
");
+    }
+
+    if (send == 0) {
+      tsm->cnt--;
+      tsm->invalid_ts_count--;
+    }
+
+  }
+
+  return tstmp;
+}
+
+
+TSM_TIMESTAMP
+TSManagerSend2 (void *handle, void *key)
+{
+  return _TSManagerSend2 (handle, key, 1);
+}
+
+
+TSM_TIMESTAMP
+TSManagerQuery2 (void *handle, void *key)
+{
+  return _TSManagerSend2 (handle, key, 0);
+}
+
+
+TSM_TIMESTAMP
+TSManagerSend (void *handle)
+{
+  return TSManagerSend2 (handle, TSM_KEY_NONE);
+}
+
+
+TSM_TIMESTAMP
+TSManagerQuery (void *handle)
+{
+  return TSManagerQuery2 (handle, TSM_KEY_NONE);
+}
+
+
+void
+resyncTSManager (void *handle, TSM_TIMESTAMP synctime, TSMGR_MODE mode)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSMRecivedCtl *rctl = &tsm->rctl;
+    TSMReceivedEntry *e = rctl->head;
+
+    while ((e = rctl->head)) {
+      rctl->head = e->next;
+      tsm_free_received_entry (rctl, e);
+    };
+    rctl->cnt = 0;
+
+    rctl->tail = NULL;
+
+    tsm->first_tx = 1;
+    tsm->first_rx = 1;
+    tsm->suspicious_ts = 0;
+
+    if (TSM_TS_IS_VALID (synctime))
+      tsm->last_ts_sent = synctime;
+
+    tsm->tx = tsm->rx = 0;
+    tsm->invalid_ts_count = 0;
+    tsm->mode = mode;
+    tsm->age = 0;
+    tsm->rx_cnt = tsm->tx_cnt = tsm->cnt = 0;
+    tsm->valid_ts_received = 0;
+
+    tsm->big_cnt = 0;
+  }
+}
+
+
+/*======================================================================================
+FUNCTION:           mfw_gst_init_ts
+
+DESCRIPTION:        malloc and initialize timestamp strcture
+
+ARGUMENTS PASSED:   ppTimeStamp_Object  - pointer of TimeStamp Manager to handle related timestamp
+
+RETURN VALUE:       TimeStamp structure pointer
+PRE-CONDITIONS:     None
+POST-CONDITIONS:    None
+IMPORTANT NOTES:    None
+=======================================================================================*/
+void *
+createTSManager (int ts_buf_size)
+{
+  TSManager *tsm = (TSManager *) malloc (sizeof (TSManager));
+  debug = getenv (debug_env);
+  if (debug) {
+    debug_level = atoi (debug);
+  }
+  // printf("debug = %s 
 ++++++++++++++++++++++++++++",debug);
+  if (tsm) {
+    memset (tsm, 0, sizeof (TSManager));
+    if (ts_buf_size <= 0) {
+      ts_buf_size = TSM_DEFAULT_TS_BUFFER_SIZE;
+    }
+    tsm->ts_buf_size = ts_buf_size;
+    tsm->ts_buf = malloc (sizeof (TSMControl) * ts_buf_size);
+
+    if (tsm->ts_buf == NULL) {
+      goto fail;
+    }
+
+    resyncTSManager (tsm, (TSM_TIMESTAMP) 0, MODE_AI);
+
+    tsm->dur_history_tx = 0;
+    TSM_BUFFER_SET (tsm->dur_history_buf, TSM_DEFAULT_INTERVAL,
+        TSM_HISTORY_SIZE);
+    tsm->dur_history_total = TSM_DEFAULT_INTERVAL << TSM_HISTORY_POWER;
+
+    tsm->discont_threshold = 10000000000LL;     // 10s
+  }
+  return tsm;
+fail:
+  if (tsm) {
+    if (tsm->ts_buf) {
+      free (tsm->ts_buf);
+    }
+    free (tsm);
+    tsm = NULL;
+  }
+  return tsm;
+}
+
+
+void
+destroyTSManager (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    TSMRecivedCtl *rctl = &tsm->rctl;
+    TSMReceivedEntryMemory *rmem;
+    if (tsm->ts_buf) {
+      free (tsm->ts_buf);
+    }
+
+    while ((rmem = rctl->memory)) {
+      rctl->memory = rmem->next;
+      free (rmem);
+    }
+    free (tsm);
+    tsm = NULL;
+  }
+}
+
+
+void
+setTSManagerFrameRate (void *handle, int fps_n, int fps_d)
+//void setTSManagerFrameRate(void * handle, float framerate)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts;
+  if ((fps_n > 0) && (fps_d > 0) && (fps_n / fps_d <= 80))
+    ts = TSM_SECOND * fps_d / fps_n;
+  else
+    ts = TSM_DEFAULT_INTERVAL;
+  // TSM_TIMESTAMP ts = TSM_SECOND / framerate;
+
+  if (tsm) {
+    TSM_BUFFER_SET (tsm->dur_history_buf, ts, TSM_HISTORY_SIZE);
+    tsm->dur_history_total = (ts << TSM_HISTORY_POWER);
+    if (debug)
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Set frame intrval:%" TSM_TIME_FORMAT "
", TSM_TIME_ARGS (ts));
+  }
+}
+
+
+TSM_TIMESTAMP
+getTSManagerFrameInterval (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts = 0;
+  if (tsm) {
+    ts = TSM_ADAPTIVE_INTERVAL (tsm);
+  }
+  return ts;
+}
+
+
+TSM_TIMESTAMP
+getTSManagerPosition (void *handle)
+{
+  TSManager *tsm = (TSManager *) handle;
+  TSM_TIMESTAMP ts = 0;
+  if (tsm) {
+    ts = tsm->last_ts_sent;
+  }
+  return ts;
+}
+
+
+int
+getTSManagerPreBufferCnt (void *handle)
+{
+  int i = 0;
+  TSManager *tsm = (TSManager *) handle;
+  if (tsm) {
+    i = tsm->rctl.cnt;
+  }
+  return i;
+}
diff --git a/v4l2_vsi_daemon/src/dec_ts.h b/v4l2_vsi_daemon/src/dec_ts.h
new file mode 100755
index 0000000..5403f0d
--- /dev/null
+++ b/v4l2_vsi_daemon/src/dec_ts.h
@@ -0,0 +1,161 @@
+/****************************************************************************
+*
+*    Copyright (c) 2010-2012, Freescale Semiconductor, Inc. All rights reserved.
+*    Copyright 2020 NXP
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef _TIMESTAMP_H_
+#define _TIMESTAMP_H_
+
+
+/**
+ * GST_CLOCK_TIME_NONE:
+ *
+ * Constant to define an undefined clock time.
+ */
+
+typedef long long TSM_TIMESTAMP;
+
+typedef enum
+{
+  MODE_AI,
+  MODE_FIFO,
+} TSMGR_MODE;
+
+#define TSM_TIMESTAMP_NONE ((long long)(-1))
+#define TSM_KEY_NONE ((void *)0)
+
+/**
+ * GST_CLOCK_TIME_IS_VALID:
+ * @time: clock time to validate
+ *
+ * Tests if a given #GstClockTime represents a valid defined time.
+ */
+
+#ifdef __cplusplus
+#define EXTERN
+#else
+#define EXTERN extern
+#endif
+
+#ifdef __cplusplus
+extern "C"
+{
+#endif
+
+/*!
+ * This function receive timestamp into timestamp manager.
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @param	timestamp	timestamp received
+ *
+ * @return	
+ */
+  EXTERN void TSManagerReceive (void *handle, TSM_TIMESTAMP timestamp);
+
+  EXTERN void TSManagerReceive2 (void *handle, TSM_TIMESTAMP timestamp,
+      int size);
+
+  EXTERN void TSManagerFlush2 (void *handle, int size);
+
+  EXTERN void TSManagerValid2 (void *handle, int size, void *key);
+
+/*!
+ * This function send the timestamp for next output frame.
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @return	timestamp for next output frame.
+ */
+  EXTERN TSM_TIMESTAMP TSManagerSend (void *handle);
+
+  EXTERN TSM_TIMESTAMP TSManagerSend2 (void *handle, void *key);
+
+  EXTERN TSM_TIMESTAMP TSManagerQuery2 (void *handle, void *key);
+
+  EXTERN TSM_TIMESTAMP TSManagerQuery (void *handle);
+/*!
+ * This function resync timestamp handler when reset and seek
+ *
+ * @param	handle		handle of timestamp manager.
+ *
+ * @param	synctime    the postion time needed to set, if value invalid, position keeps original
+ * 
+ * @param	mode		playing mode (AI or FIFO)
+ *
+ * @return	
+ */
+  EXTERN void resyncTSManager (void *handle, TSM_TIMESTAMP synctime,
+      TSMGR_MODE mode);
+/*!
+ * This function create and reset timestamp handler
+ *
+ * @param	ts_buf_size	 time stamp queue buffer size 
+ * 
+ * @return	
+ */
+  EXTERN void *createTSManager (int ts_buf_size);
+/*!
+ * This function destory timestamp handler
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN void destroyTSManager (void *handle);
+/*!
+ * This function set  history buffer frame interval by fps_n and fps_d 
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @param	framerate       the framerate to be set
+ * 
+ * @return	
+ */
+  EXTERN void setTSManagerFrameRate (void *handle, int fps_n, int fps_d);
+//EXTERN void setTSManagerFrameRate(void * handle, float framerate);
+/*!
+ * This function set the current calculated Frame Interval
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN TSM_TIMESTAMP getTSManagerFrameInterval (void *handle);
+/*!
+ * This function get  the current time stamp postion
+ *
+ * @param	handle		handle of timestamp manager.
+ * 
+ * @return	
+ */
+  EXTERN TSM_TIMESTAMP getTSManagerPosition (void *handle);
+  EXTERN int getTSManagerPreBufferCnt (void *handle);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /*_TIMESTAMP_H_ */
diff --git a/v4l2_vsi_daemon/src/fifo.c b/v4l2_vsi_daemon/src/fifo.c
new file mode 100755
index 0000000..4a0c9ed
--- /dev/null
+++ b/v4l2_vsi_daemon/src/fifo.c
@@ -0,0 +1,146 @@
+/****************************************************************************
+*
+*    Copyright (c) 2015-2021, VeriSilicon Inc. All rights reserved.
+*    Copyright (c) 2011-2014, Google Inc. All rights reserved.
+*    Copyright (c) 2007-2010, Hantro OY. All rights reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#include "fifo.h"
+
+#include "vsi_daemon_debug.h"
+#include <pthread.h>
+#include <semaphore.h>
+#include <stdlib.h>
+
+/* Container for instance. */
+struct Fifo {
+  sem_t cs_semaphore;    /* Semaphore for critical section. */
+  sem_t read_semaphore;  /* Semaphore for readers. */
+  sem_t write_semaphore; /* Semaphore for writers. */
+  uint32_t num_of_slots;
+  uint32_t num_of_objects;
+  uint32_t tail_index;
+  FifoObject* nodes;
+  uint32_t abort;
+};
+
+enum FifoRet FifoInit(uint32_t num_of_slots, FifoInst* instance) {
+  struct Fifo* inst = calloc(1, sizeof(struct Fifo));
+  if (inst == NULL) return FIFO_ERROR_MEMALLOC;
+  inst->num_of_slots = num_of_slots;
+  /* Allocate memory for the objects. */
+  inst->nodes = calloc(num_of_slots, sizeof(FifoObject));
+  if (inst->nodes == NULL) {
+    free(inst);
+    return FIFO_ERROR_MEMALLOC;
+  }
+  /* Initialize binary critical section semaphore. */
+  sem_init(&inst->cs_semaphore, 0, 1);
+  /* Then initialize the read and write semaphores. */
+  sem_init(&inst->read_semaphore, 0, 0);
+  sem_init(&inst->write_semaphore, 0, num_of_slots);
+  *instance = inst;
+  return FIFO_OK;
+}
+
+enum FifoRet FifoPush(FifoInst inst, FifoObject object, enum FifoException e) {
+  struct Fifo* instance = (struct Fifo*)inst;
+  int32_t value;
+
+  sem_getvalue(&instance->read_semaphore, &value);
+  if ((e == FIFO_EXCEPTION_ENABLE) &&
+      ((uint32_t)value == instance->num_of_slots) &&
+      (instance->num_of_objects == instance->num_of_slots)) {
+    return FIFO_FULL;
+  }
+
+  sem_wait(&instance->write_semaphore);
+  sem_wait(&instance->cs_semaphore);
+  instance->nodes[(instance->tail_index + instance->num_of_objects) %
+                  instance->num_of_slots] = object;
+  instance->num_of_objects++;
+  sem_post(&instance->cs_semaphore);
+  sem_post(&instance->read_semaphore);
+  return FIFO_OK;
+}
+
+enum FifoRet FifoPop(FifoInst inst, FifoObject* object, enum FifoException e) {
+  struct Fifo* instance = (struct Fifo*)inst;
+  int32_t value;
+
+  sem_getvalue(&instance->write_semaphore, &value);
+  if ((e == FIFO_EXCEPTION_ENABLE) &&
+      ((uint32_t)value == instance->num_of_slots) &&
+      (instance->num_of_objects == 0)) {
+    return FIFO_EMPTY;
+  }
+
+  sem_wait(&instance->read_semaphore);
+  sem_wait(&instance->cs_semaphore);
+
+  if (instance->abort) return FIFO_ABORT;
+
+  *object = instance->nodes[instance->tail_index % instance->num_of_slots];
+  instance->tail_index++;
+  instance->num_of_objects--;
+  sem_post(&instance->cs_semaphore);
+  sem_post(&instance->write_semaphore);
+  return FIFO_OK;
+}
+
+uint32_t FifoCount(FifoInst inst) {
+  uint32_t count;
+  struct Fifo* instance = (struct Fifo*)inst;
+  sem_wait(&instance->cs_semaphore);
+  count = instance->num_of_objects;
+  sem_post(&instance->cs_semaphore);
+  return count;
+}
+
+void FifoRelease(FifoInst inst) {
+  struct Fifo* instance = (struct Fifo*)inst;
+#ifdef HEVC_EXT_BUF_SAFE_RELEASE
+  ASSERT(instance->num_of_objects == 0);
+#endif
+  sem_wait(&instance->cs_semaphore);
+  sem_destroy(&instance->cs_semaphore);
+  sem_destroy(&instance->read_semaphore);
+  sem_destroy(&instance->write_semaphore);
+  free(instance->nodes);
+  free(instance);
+}
+
+void FifoSetAbort(FifoInst inst) {
+  struct Fifo* instance = (struct Fifo*)inst;
+  if (instance == NULL) return;
+  instance->abort = 1;
+  sem_post(&instance->cs_semaphore);
+  sem_post(&instance->read_semaphore);
+}
+
+void FifoClearAbort(FifoInst inst) {
+  struct Fifo* instance = (struct Fifo*)inst;
+  if (instance == NULL) return;
+  instance->abort = 0;
+}
diff --git a/v4l2_vsi_daemon/src/fifo.h b/v4l2_vsi_daemon/src/fifo.h
new file mode 100755
index 0000000..388bbad
--- /dev/null
+++ b/v4l2_vsi_daemon/src/fifo.h
@@ -0,0 +1,108 @@
+/****************************************************************************
+*
+*    Copyright (c) 2015-2021, VeriSilicon Inc. All rights reserved.
+*    Copyright (c) 2011-2014, Google Inc. All rights reserved.
+*    Copyright (c) 2007-2010, Hantro OY. All rights reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef __FIFO_H__
+#define __FIFO_H__
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @file fifo.h
+ * @brief Fifo interface.
+ */
+
+#include "v4l2_base_type.h"
+
+#define FIFO_DATATYPE void*
+
+/* FIFO_DATATYPE must be defined to hold specific type of objects. If it is not
+ * defined, we need to report an error. */
+#ifndef FIFO_DATATYPE
+#error "You must define FIFO_DATATYPE to use this module."
+#endif /* FIFO_DATATYPE */
+
+#define MAX_FIFO_CAPACITY 100
+
+typedef FIFO_DATATYPE FifoObject;
+
+/* Possible return values. */
+enum FifoRet {
+  FIFO_OK,             /* Operation was successful. */
+  FIFO_ERROR_MEMALLOC, /* Failed due to memory allocation error. */
+  FIFO_EMPTY,
+  FIFO_FULL,
+  FIFO_NOK,
+  FIFO_ABORT = 0x7FFFFFFF
+};
+
+enum FifoException { FIFO_EXCEPTION_DISABLE, FIFO_EXCEPTION_ENABLE };
+
+typedef void* FifoInst;
+
+/* FifoInit initializes the queue.
+ * |num_of_slots| defines how many slots to reserve at maximum.
+ * |instance| is output parameter holding the instance. */
+enum FifoRet FifoInit(uint32_t num_of_slots, FifoInst* instance);
+
+/* FifoPush pushes an object to the back of the queue. Ownership of the
+ * contained object will be moved from the caller to the queue. Returns OK
+ * if the object is successfully pushed into fifo.
+ *
+ * |inst| is the instance push to.
+ * |object| holds the pointer to the object to push into queue.
+ * |exception_enable| enable FIFO_FULL return value */
+enum FifoRet FifoPush(FifoInst inst, FifoObject object,
+                      enum FifoException exception_enable);
+
+/* FifoPop returns object from the front of the queue. Ownership of the popped
+ * object will be moved from the queue to the caller. Returns OK if the object
+ * is successfully popped from the fifo.
+ *
+ * |inst| is the instance to pop from.
+ * |object| holds the pointer to the object popped from the queue.
+ * |exception_enable| enable FIFO_EMPTY return value */
+enum FifoRet FifoPop(FifoInst inst, FifoObject* object,
+                     enum FifoException exception_enable);
+
+/* Ask how many objects there are in the fifo. */
+uint32_t FifoCount(FifoInst inst);
+
+/* FifoRelease releases and deallocated queue. User needs to make sure the
+ * queue is empty and no threads are waiting in FifoPush or FifoPop.
+ * |inst| is the instance to release. */
+void FifoRelease(FifoInst inst);
+void FifoSetAbort(FifoInst inst);
+void FifoClearAbort(FifoInst inst);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* __FIFO_H__ */
diff --git a/v4l2_vsi_daemon/src/hantro_mutext.h b/v4l2_vsi_daemon/src/hantro_mutext.h
new file mode 100755
index 0000000..a3e79e4
--- /dev/null
+++ b/v4l2_vsi_daemon/src/hantro_mutext.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef _HANTRO_MUTEX_H_
+#define _HANTRO_MUTEX_H_
+
+#include "vsi_compiler.h"
+
+#define PTHREADS
+#if defined PTHREADS
+#include <pthread.h>
+
+typedef pthread_mutex_t _HANTROMutex;
+
+static INLINE void _hantroInitMutex(_HANTROMutex *m) {
+  pthread_mutex_init(m, NULL);
+}
+
+static INLINE void _hantroDestroyMutex(_HANTROMutex *m) {
+  pthread_mutex_destroy(m);
+}
+
+static INLINE void _hantroLockMutex(_HANTROMutex *m) { pthread_mutex_lock(m); }
+
+static INLINE void _hantroUnlockMutex(_HANTROMutex *m) {
+  pthread_mutex_unlock(m);
+}
+
+#define _HANTRO_MUTEX_INITIALIZER PTHREAD_MUTEX_INITIALIZER
+#define _HANTRO_DECLARE_MUTEX(m) _HANTROMutex m = _HANTRO_MUTEX_INITIALIZER
+
+#else
+
+typedef int _HANTROMutex;
+static INLINE void _hantroInitMutex(_HANTROMutex *m) { (void)m; }
+static INLINE void _hantroDestroyMutex(_HANTROMutex *m) { (void)m; }
+static INLINE void _hantroLockMutex(_HANTROMutex *m) { (void)m; }
+static INLINE void _hantroUnlockMutex(_HANTROMutex *m) { (void)m; }
+
+#define _HANTRO_MUTEX_INITIALIZER 0
+#define _HANTRO_DECLARE_MUTEX(m) _HANTROMutex m = _HANTRO_MUTEX_INITIALIZER
+
+#endif
+
+#endif /* _HANTRO_MUTEX_H_ */
diff --git a/v4l2_vsi_daemon/src/hash_table.c b/v4l2_vsi_daemon/src/hash_table.c
new file mode 100755
index 0000000..5520ecd
--- /dev/null
+++ b/v4l2_vsi_daemon/src/hash_table.c
@@ -0,0 +1,155 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#include "hash_table.h"
+#include <string.h>
+#include "vsi_daemon_debug.h"
+
+int32_t hash_func_default(KeyType key) {
+  return (key & 0xffffffff) % HashMaxSize;
+}
+
+void hash_table_init(HashTable* ht) {
+  if (ht == NULL) return;
+  ht->size = 0;
+  ht->hashfunc = hash_func_default;
+  for (size_t i = 0; i < HashMaxSize; i++) {
+    ht->data[i].key = 0;
+    ht->data[i].stat = Empty;
+    ht->data[i].value = NULL;
+  }
+}
+
+int32_t hash_table_insert(HashTable* ht, KeyType key) {
+  if (ht == NULL) return 1;
+  if (ht->size >= HashMaxSize) return 1;
+  int32_t cur = ht->hashfunc(key);
+  if (cur >= HashMaxSize) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "When HashTableInsert, HashMaxSize is reached.!
");
+    return 1;
+  }
+  while (1) {
+    if (ht->data[cur].key == key)  // already exist
+    {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "When HashTableInsert, key already exist!
");
+      return 1;
+    }
+    if (ht->data[cur].stat != Valid) {
+      ht->data[cur].key = key;
+      ht->data[cur].stat = Valid;
+      ht->data[cur].value = (ValueType*)malloc(sizeof(ValueType));
+      if (ht->data[cur].value == NULL) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                   "hash_table_insert: Error when malloc hashtable elem.
");
+        return 1;
+      }
+      ht->size++;
+      return 0;  // insert successful
+    } else {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "When HashTableInsert, state is not EMPTY!
");
+    }
+    cur++;
+    if (cur >= HashMaxSize) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "When HashTableInsert, HashMaxSize is reached.!
");
+      return 1;
+    }
+  }
+}
+
+int32_t hash_table_find(HashTable* ht, KeyType key, ValueType** value) {
+  if (ht == NULL) return 1;
+  int32_t offset = ht->hashfunc(key);
+  if (ht->data[offset].key == key && ht->data[offset].stat == Valid) {
+    *value = ht->data[offset].value;
+    return 0;  // find successful.
+  }
+  return 1;  // find unsuccessful.
+}
+
+int32_t hash_table_find_cur(HashTable* ht, KeyType key,
+                            int32_t* cur)  // find index, for delete.
+{
+  if (ht == NULL) return 0;
+  for (int32_t i = 0; i < HashMaxSize; i++) {
+    if (ht->data[i].key == key && ht->data[i].stat == Valid) {
+      *cur = i;
+      return 1;  // find
+    }
+  }
+  return 0;  // not find
+}
+
+ValueType* hash_table_find_bytid(HashTable* ht, pthread_t tid) {
+  if (ht == NULL) return 0;
+  for (int32_t i = 0; i < HashMaxSize; i++) {
+    if (ht->data[i].value && ht->data[i].stat == Valid &&
+        ht->data[i].value->tid == tid)
+      return ht->data[i].value;
+  }
+  return NULL;  // not find
+}
+
+void hash_table_remove(HashTable* ht, KeyType key, int freeobj) {
+  if (ht == NULL) return;
+  // ValueType value = 0;
+  int32_t cur = 0;
+  int32_t ret = hash_table_find_cur(ht, key, &cur);
+  if (ret == 0)
+    return;
+  else {
+    ht->data[cur].stat = Empty;
+    ht->data[cur].key = 0;
+    if (freeobj)
+      free(ht->data[cur].value);
+    ht->size--;
+  }
+}
+
+int32_t hash_table_empty(HashTable* ht) {
+  if (ht == NULL)
+    return 0;
+  else
+    return ht->size > 0 ? 1 : 0;
+}
+
+int32_t hash_table_size(HashTable* ht) {
+  if (ht == NULL) return 0;
+  return ht->size;
+}
+
+void hash_table_print(HashTable* ht, const int8_t* msg) {
+  if (ht == NULL || ht->size == 0) return;
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "%s
", msg);
+  for (int32_t i = 0; i < HashMaxSize; i++) {
+    // if (ht->data[i].stat != Empty)
+    // printf("[%d]  key=%d  value=%d  stat=%d
", i,
+    // ht->data[i].key,ht->data[i].value, (int32_t)ht->data[i].stat);
+  }
+}
diff --git a/v4l2_vsi_daemon/src/hash_table.h b/v4l2_vsi_daemon/src/hash_table.h
new file mode 100755
index 0000000..576defe
--- /dev/null
+++ b/v4l2_vsi_daemon/src/hash_table.h
@@ -0,0 +1,138 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef HASH_TABLE_H
+#define HASH_TABLE_H
+/**
+ * @file hash_table.h
+ * @brief hash table interface.
+ */
+
+#include <stdint.h>
+#include "daemon_instance.h"
+
+/**
+ * @brief Max size of hash table, this is also the max stream size supported.
+ */
+#define HashMaxSize MAX_STREAMS
+
+/**
+ * @brief key type.
+ */
+typedef uint64_t KeyType;  // inst_id
+
+/**
+ * @brief value type of hash element.
+ */
+typedef v4l2_daemon_inst ValueType;
+
+/**
+ * @brief function pointer for getting current key.
+ */
+typedef int32_t (*HashFunc)(KeyType key);
+
+/**
+ * @brief state of hash element.
+ */
+typedef enum Stat {
+  Empty, /** state: empty.*/
+  Valid  /** state: valid.*/
+} Stat;
+
+/**
+ * @brief hash element.
+ */
+typedef struct HashElem {
+  KeyType key;      /** key */
+  ValueType* value; /** value of hash element */
+  Stat stat;        /** state */
+} HashElem;
+
+/**
+ * @brief hash table.
+ */
+typedef struct HashTable {
+  HashElem data[HashMaxSize]; /** data of hash table */
+  int32_t size;               /** size of hash table */
+  HashFunc hashfunc;          /** function pointer of hash table */
+} HashTable;
+
+/**
+ * @brief Initial a hash table.
+ * @param[in] ht Hash table pointer.
+ * @return void.
+ */
+void hash_table_init(HashTable* ht);
+
+/**
+ * @brief Insert an element to a hash table.
+ * @param[in] ht Hash table pointer.
+ * @param[in] key The key of the element to insert.
+ * @return 0: insert successfully, other: insert unsuccessfully.
+ */
+int32_t hash_table_insert(HashTable* ht, KeyType key);
+
+/**
+ * @brief Search a given key in hash table.
+ * @param[in] ht Hash table pointer.
+ * @param[in] key The key of the element to search.
+ * @param[out] value The element pointer if finded, otherwise NULL.
+ * @return 0: find successfully, other: find unsuccessfully.
+ */
+int32_t hash_table_find(HashTable* ht, KeyType key, ValueType** value);
+
+/**
+ * @brief Remove a given key in hash table.
+ * @param[in] ht Hash table pointer.
+ * @param[in] key The key of the element to search.
+ * @return void.
+ */
+void hash_table_remove(HashTable* ht, KeyType key, int freeobj);
+
+/**
+ * @brief Check if the hash table is empty.
+ * @param[in] ht Hash table pointer.
+ * @return 0: empty, other: not empty.
+ */
+int32_t hash_table_empty(HashTable* ht);
+
+/**
+ * @brief Get size of the hash table.
+ * @param[in] ht Hash table pointer.
+ * @return int Size of the hash table.
+ */
+int32_t hash_table_size(HashTable* ht);
+
+/**
+ * @brief Destory the hash table.
+ * @param[in] ht Hash table pointer.
+ * @return none.
+ */
+void hash_table_destroy(HashTable* ht);
+
+ValueType* hash_table_find_bytid(HashTable* ht, pthread_t tid);
+
+#endif
diff --git a/v4l2_vsi_daemon/src/local_defines.h b/v4l2_vsi_daemon/src/local_defines.h
new file mode 100755
index 0000000..7f934b0
--- /dev/null
+++ b/v4l2_vsi_daemon/src/local_defines.h
@@ -0,0 +1,48 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef LOCAL_DEFINES_H
+#define LOCAL_DEFINES_H
+
+#include "command_defines.h"
+#if 0
+#ifndef HANTRO_TRUE
+#define HANTRO_TRUE (1)
+#endif /* HANTRO_TRUE */
+
+#ifndef HANTRO_FALSE
+#define HANTRO_FALSE (0)
+#endif /* HANTRO_FALSE*/
+
+#ifndef bool
+typedef enum
+{
+  false = HANTRO_FALSE,
+  true  = HANTRO_TRUE
+} bool;
+#endif
+#endif
+#endif  // LOCAL_DEFINES_H
diff --git a/v4l2_vsi_daemon/src/object_heap.c b/v4l2_vsi_daemon/src/object_heap.c
new file mode 100755
index 0000000..afce04b
--- /dev/null
+++ b/v4l2_vsi_daemon/src/object_heap.c
@@ -0,0 +1,252 @@
+/****************************************************************************
+*
+*    Copyright (c) 2017 - 2021 VeriSilicon Inc. All Rights Reserved.
+*    Copyright (c) 2007 - 2016 Intel Corporation. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#include "object_heap.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "vsi_daemon_debug.h"
+
+#define LAST_FREE -1
+#define ALLOCATED -2
+
+/*
+ * Expands the heap
+ * Return 0 on success, -1 on error
+ */
+static int object_heap_expand(object_heap_p heap) {
+  int i;
+  void *new_heap_index;
+  int next_free;
+  int new_heap_size = heap->heap_size + heap->heap_increment;
+  int bucket_index = new_heap_size / heap->heap_increment - 1;
+
+  if (bucket_index >= heap->num_buckets) {
+    int new_num_buckets = heap->num_buckets + 8;
+    void **new_bucket;
+
+    new_bucket = realloc(heap->bucket, new_num_buckets * sizeof(void *));
+    if (NULL == new_bucket) {
+      return -1;
+    }
+
+    heap->num_buckets = new_num_buckets;
+    heap->bucket = new_bucket;
+  }
+
+  if (!heap->bucket) {
+    return -1;
+  }
+
+  new_heap_index = (void *)malloc(heap->heap_increment * heap->object_size);
+  if (NULL == new_heap_index) {
+    return -1; /* Out of memory */
+  }
+
+  heap->bucket[bucket_index] = new_heap_index;
+  next_free = heap->next_free;
+  for (i = new_heap_size; i-- > heap->heap_size;) {
+    object_base_p obj = (object_base_p)(
+        new_heap_index + (i - heap->heap_size) * heap->object_size);
+    obj->id = i + heap->id_offset;
+    obj->next_free = next_free;
+    next_free = i;
+  }
+  heap->next_free = next_free;
+  heap->heap_size = new_heap_size;
+  return 0; /* Success */
+}
+
+/*
+ * Return 0 on success, -1 on error
+ */
+int object_heap_init(object_heap_p heap, int object_size, int id_offset) {
+  heap->object_size = object_size;
+  heap->id_offset = id_offset & OBJECT_HEAP_OFFSET_MASK;
+  heap->heap_size = 0;
+  heap->heap_increment = 16;
+  heap->next_free = LAST_FREE;
+  heap->num_buckets = 0;
+  heap->bucket = NULL;
+
+  if (object_heap_expand(heap) == 0) {
+    ASSERT(heap->heap_size);
+    _hantroInitMutex(&heap->mutex);
+    return 0;
+  } else {
+    ASSERT(!heap->heap_size);
+    ASSERT(!heap->bucket || !heap->bucket[0]);
+
+    free(heap->bucket);
+
+    return -1;
+  }
+}
+
+/*
+ * Allocates an object
+ * Returns the object ID on success, returns -1 on error
+ */
+int object_heap_allocate(object_heap_p heap) {
+  object_base_p obj;
+  int bucket_index, obj_index;
+
+  _hantroLockMutex(&heap->mutex);
+  if (LAST_FREE == heap->next_free) {
+    if (-1 == object_heap_expand(heap)) {
+      _hantroUnlockMutex(&heap->mutex);
+      return -1; /* Out of memory */
+    }
+  }
+  ASSERT(heap->next_free >= 0);
+
+  bucket_index = heap->next_free / heap->heap_increment;
+  obj_index = heap->next_free % heap->heap_increment;
+
+  obj = (object_base_p)(heap->bucket[bucket_index] +
+                        obj_index * heap->object_size);
+  heap->next_free = obj->next_free;
+  _hantroUnlockMutex(&heap->mutex);
+
+  obj->next_free = ALLOCATED;
+  return obj->id;
+}
+
+/*
+ * Lookup an object by object ID
+ * Returns a pointer to the object on success, returns NULL on error
+ */
+object_base_p object_heap_lookup(object_heap_p heap, int id) {
+  object_base_p obj;
+  int bucket_index, obj_index;
+
+  _hantroLockMutex(&heap->mutex);
+  if ((id < heap->id_offset) || (id > (heap->heap_size + heap->id_offset))) {
+    _hantroUnlockMutex(&heap->mutex);
+    return NULL;
+  }
+  id &= OBJECT_HEAP_ID_MASK;
+  bucket_index = id / heap->heap_increment;
+  obj_index = id % heap->heap_increment;
+  obj = (object_base_p)(heap->bucket[bucket_index] +
+                        obj_index * heap->object_size);
+  _hantroUnlockMutex(&heap->mutex);
+
+  /* Check if the object has in fact been allocated */
+  if (obj->next_free != ALLOCATED) {
+    return NULL;
+  }
+  return obj;
+}
+
+/*
+ * Iterate over all objects in the heap.
+ * Returns a pointer to the first object on the heap, returns NULL if heap is
+ * empty.
+ */
+object_base_p object_heap_first(object_heap_p heap,
+                                object_heap_iterator *iter) {
+  *iter = -1;
+  return object_heap_next(heap, iter);
+}
+
+/*
+ * Iterate over all objects in the heap.
+ * Returns a pointer to the next object on the heap, returns NULL if heap is
+ * empty.
+ */
+object_base_p object_heap_next(object_heap_p heap, object_heap_iterator *iter) {
+  object_base_p obj;
+  int i = *iter + 1;
+  int bucket_index, obj_index;
+
+  _hantroLockMutex(&heap->mutex);
+  while (i < heap->heap_size) {
+    bucket_index = i / heap->heap_increment;
+    obj_index = i % heap->heap_increment;
+
+    obj = (object_base_p)(heap->bucket[bucket_index] +
+                          obj_index * heap->object_size);
+    if (obj->next_free == ALLOCATED) {
+      _hantroUnlockMutex(&heap->mutex);
+      *iter = i;
+      return obj;
+    }
+    i++;
+  }
+  _hantroUnlockMutex(&heap->mutex);
+  *iter = i;
+  return NULL;
+}
+
+/*
+ * Frees an object
+ */
+void object_heap_free(object_heap_p heap, object_base_p obj) {
+  /* Don't complain about NULL pointers */
+  if (NULL != obj) {
+    /* Check if the object has in fact been allocated */
+    ASSERT(obj->next_free == ALLOCATED);
+
+    _hantroLockMutex(&heap->mutex);
+    obj->next_free = heap->next_free;
+    heap->next_free = obj->id & OBJECT_HEAP_ID_MASK;
+    _hantroUnlockMutex(&heap->mutex);
+  }
+}
+
+/*
+ * Destroys a heap, the heap must be empty.
+ */
+void object_heap_destroy(object_heap_p heap) {
+  object_base_p obj;
+  int i;
+  int bucket_index, obj_index;
+
+  if (heap->heap_size) {
+    _hantroDestroyMutex(&heap->mutex);
+
+    /* Check if heap is empty */
+    for (i = 0; i < heap->heap_size; i++) {
+      /* Check if object is not still allocated */
+      bucket_index = i / heap->heap_increment;
+      obj_index = i % heap->heap_increment;
+      obj = (object_base_p)(heap->bucket[bucket_index] +
+                            obj_index * heap->object_size);
+      ASSERT(obj->next_free != ALLOCATED);
+    }
+
+    for (i = 0; i < heap->heap_size / heap->heap_increment; i++) {
+      free(heap->bucket[i]);
+    }
+
+    free(heap->bucket);
+  }
+
+  heap->bucket = NULL;
+  heap->heap_size = 0;
+  heap->next_free = LAST_FREE;
+}
diff --git a/v4l2_vsi_daemon/src/object_heap.h b/v4l2_vsi_daemon/src/object_heap.h
new file mode 100755
index 0000000..48d0e89
--- /dev/null
+++ b/v4l2_vsi_daemon/src/object_heap.h
@@ -0,0 +1,118 @@
+/****************************************************************************
+*
+*    Copyright (c) 2017 - 2021 VeriSilicon Inc. All Rights Reserved.
+*    Copyright (c) 2007 - 2016 Intel Corporation. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef _OBJECT_HEAP_H_
+#define _OBJECT_HEAP_H_
+/**
+ * @file object_heap.h
+ * @brief object heap interface.
+ */
+#include "hantro_mutext.h"
+
+#define OBJECT_HEAP_OFFSET_MASK 0x7F000000
+#define OBJECT_HEAP_ID_MASK 0x00FFFFFF
+
+#define CONFIG_ID_OFFSET 0x01000000
+#define CONTEXT_ID_OFFSET 0x02000000
+#define SURFACE_ID_OFFSET 0x04000000
+#define BUFFER_ID_OFFSET 0x08000000
+#define IMAGE_ID_OFFSET 0x0a000000
+#define SUBPIC_ID_OFFSET 0x10000000
+
+#define ENC_HEVC_H264_ID_OFFSET 0x20000000
+#define ENC_HEVC_H264_PRIV_RECON_BUFF_ID_OFFSET 0x20100000
+
+#define ENC_JPEG_ID_OFFSET 0x21000000
+
+#define DEC_HEVC_H264_ID_OFFSET 0x30000000
+#define DEC_JPEG_ID_OFFSET 0x31000000
+#define DEC_VP9_ID_OFFSET 0x32000000
+#define DEC_MPEG2_ID_OFFSET 0x33000000
+
+typedef struct object_base *object_base_p;
+typedef struct object_heap *object_heap_p;
+
+struct object_base {
+  int id;
+  int next_free;
+};
+
+struct object_heap {
+  int object_size;
+  int id_offset;
+  int next_free;
+  int heap_size;
+  int heap_increment;
+  _HANTROMutex mutex;
+  void **bucket;
+  int num_buckets;
+};
+
+typedef int object_heap_iterator;
+
+/*
+ * Return 0 on success, -1 on error
+ */
+int object_heap_init(object_heap_p heap, int object_size, int id_offset);
+
+/*
+ * Allocates an object
+ * Returns the object ID on success, returns -1 on error
+ */
+int object_heap_allocate(object_heap_p heap);
+
+/*
+ * Lookup an allocated object by object ID
+ * Returns a pointer to the object on success, returns NULL on error
+ */
+object_base_p object_heap_lookup(object_heap_p heap, int id);
+
+/*
+ * Iterate over all objects in the heap.
+ * Returns a pointer to the first object on the heap, returns NULL if heap is
+ * empty.
+ */
+object_base_p object_heap_first(object_heap_p heap, object_heap_iterator *iter);
+
+/*
+ * Iterate over all objects in the heap.
+ * Returns a pointer to the next object on the heap, returns NULL if heap is
+ * empty.
+ */
+object_base_p object_heap_next(object_heap_p heap, object_heap_iterator *iter);
+
+/*
+ * Frees an object
+ */
+void object_heap_free(object_heap_p heap, object_base_p obj);
+
+/*
+ * Destroys a heap, the heap must be empty.
+ */
+void object_heap_destroy(object_heap_p heap);
+
+#endif /* _OBJECT_HEAP_H_ */
diff --git a/v4l2_vsi_daemon/src/v4l2_base_type.h b/v4l2_vsi_daemon/src/v4l2_base_type.h
new file mode 100755
index 0000000..2c3f77f
--- /dev/null
+++ b/v4l2_vsi_daemon/src/v4l2_base_type.h
@@ -0,0 +1,77 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef V4L2_BASE_TYPE_H
+#define V4L2_BASE_TYPE_H
+
+#ifndef V4L2_DRIVER
+#include <stdint.h>
+#include <stdio.h>
+#ifndef NDEBUG
+#include <assert.h>
+#endif
+#endif
+
+#if 0
+typedef int8_t    i8;
+typedef uint8_t   u8;
+typedef int16_t   i16;
+typedef uint16_t  u16;
+typedef int32_t   i32;
+typedef uint32_t  u32;
+typedef int64_t   i64;
+typedef uint64_t  u64;
+typedef size_t    ptr_t;
+
+typedef       short               Short;
+typedef       int                 Int;
+typedef       unsigned int        UInt;
+#endif
+
+typedef long long unsigned int vpu_addr_t;  // same as kernel's dma_addr_t
+
+#ifndef INLINE
+#define INLINE inline
+#endif
+
+#ifndef NULL
+#ifdef __cplusplus
+#define NULL 0
+#else /*  */
+#define NULL ((void *)0)
+#endif /*  */
+#endif
+
+/* ASSERT */
+#ifndef ASSERT
+#ifndef NDEBUG
+#define ASSERT(x) assert(x)
+#else
+#define ASSERT(x)
+#endif
+#endif
+
+#endif  // V4L2_BASE_TYPE_H
diff --git a/v4l2_vsi_daemon/src/vsi_compiler.h b/v4l2_vsi_daemon/src/vsi_compiler.h
new file mode 100755
index 0000000..e1d544e
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_compiler.h
@@ -0,0 +1,58 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef _VSI_COMPILER_H_
+#define _VSI_COMPILER_H_
+
+/**
+ * Function inlining
+ */
+#if defined(__GNUC__)
+#ifndef INLINE
+#define INLINE __inline__
+#endif
+#elif (__STDC_VERSION__ >= 199901L) /* C99 */
+#ifndef INLINE
+#define INLINE inline
+#endif
+#else
+#ifndef INLINE
+#define INLINE
+#endif
+#endif
+
+/**
+ * Function visibility
+ */
+#if defined(__GNUC__)
+#define DLL_HIDDEN __attribute__((visibility("hidden")))
+#define DLL_EXPORT __attribute__((visibility("default")))
+#else
+#define DLL_HIDDEN
+#define DLL_EXPORT
+#endif
+
+#endif /* _VSI_COMPILER_H_ */
diff --git a/v4l2_vsi_daemon/src/vsi_daemon_debug.h b/v4l2_vsi_daemon/src/vsi_daemon_debug.h
new file mode 100755
index 0000000..7592a93
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_daemon_debug.h
@@ -0,0 +1,91 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef VSI_DEC_SW_DEBUG_H_
+#define VSI_DEC_SW_DEBUG_H_
+#include <stdio.h>
+#ifndef ASSERT
+#include <assert.h>
+#define ASSERT(expr) assert(expr)
+#endif
+#include "time.h"
+
+#define HANTRO_LEVEL_NONE 0
+#define HANTRO_LEVEL_ERROR 1
+#define HANTRO_LEVEL_WARNING 2
+#define HANTRO_LEVEL_FIXME 3
+#define HANTRO_LEVEL_INFO 4
+#define HANTRO_LEVEL_DEBUG 5
+#define HANTRO_LEVEL_LOG 6
+#define HANTRO_LEVEL_TRACE_REG 7
+#define HANTRO_LEVEL_MEMDUMP 9
+#define HANTRO_LEVEL_COUNT 10
+
+extern int hantro_log_level;
+extern char hantro_level[HANTRO_LEVEL_COUNT][20];
+extern FILE *vsidaemonstdlog;
+#define HANTRO_LOG(level, fmt, args...)                     \
+  if (level < hantro_log_level) {                           \
+    printf(__FILE__ ":%d:%s() %s " fmt, __LINE__, __func__, \
+           hantro_level[level], ##args);                    \
+    if (vsidaemonstdlog) fflush(vsidaemonstdlog);           \
+  }
+
+//#define SW_PERFORMANCE
+
+#ifdef SW_PERFORMANCE
+#define V4L2_START_SW_PERFORMANCE gettimeofday(&dec_start_time, NULL);
+#else
+#define V4L2_START_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define V4L2_END_SW_PERFORMANCE                                       \
+  gettimeofday(&dec_end_time, NULL);                                  \
+  dec_cpu_time +=                                                     \
+      ((double)1000000 * dec_end_time.tv_sec + dec_end_time.tv_usec - \
+       1000000 * dec_start_time.tv_sec - dec_start_time.tv_usec) /    \
+      1000000;
+
+#else
+#define V4L2_END_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define V4L2_FINALIZE_SW_PERFORMANCE \
+  printf("SW_PERFORMANCE %0.5f s
", dec_cpu_time);
+#else
+#define V4L2_FINALIZE_SW_PERFORMANCE
+#endif
+
+#ifdef SW_PERFORMANCE
+#define V4L2_FINALIZE_SW_PERFORMANCE_PP \
+  printf("SW_PERFORMANCE_PP %0.5f
", dec_cpu_time);
+#else
+#define V4L2_FINALIZE_SW_PERFORMANCE_PP
+#endif
+
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_dec.c b/v4l2_vsi_daemon/src/vsi_dec.c
new file mode 100755
index 0000000..b4a75a5
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec.c
@@ -0,0 +1,1960 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include <dlfcn.h>
+#include "sys/mman.h"
+
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+#ifdef NXP_TIMESTAMP_MANAGER
+#include "dec_ts.h"
+#endif
+#ifdef VSI_CMODEL
+#include "tb_cfg.h"
+#endif
+
+v4l2_inst_dec_event vsi_dec_handle_io_buffer(v4l2_dec_inst *h,
+                                             struct vsi_v4l2_msg *v4l2_msg);
+
+char dec_state_name[DAEMON_DEC_STATE_TOTAL][50] = {
+    "DAEMON_DEC_STATE_OPEN",          "DAEMON_DEC_STATE_INIT",
+    "DAEMON_DEC_STATE_CAPTURE_SETUP", "DAEMON_DEC_STATE_DECODE",
+    "DAEMON_DEC_STATE_SOURCE_CHANGE", "DAEMON_DEC_STATE_SEEK",
+    "DAEMON_DEC_STATE_END_OF_STREAM", "DAEMON_DEC_STATE_DRAIN",
+    "DAEMON_DEC_STATE_STOPPED",       "DAEMON_DEC_STATE_DESTROYED",
+};
+
+char dec_event_name[DEC_DECODING_TOTAL_EVENT][50] = {
+    "DEC_EMPTY_EVENT",
+    "DEC_RECEIVE_CAPTUREON_EVENT",
+    "DEC_RECEIVE_CAPTUREOFF_EVENT",
+    "DEC_RECEIVE_OUTPUTON_EVENT",
+    "DEC_RECEIVE_OUTPUTOFF_EVENT",
+    "DEC_RECEIVE_CMDSTOP_EVENT",
+    "DEC_RECEIVE_CMDSTART_EVENT",
+    "DEC_RECEIVE_DESTROY_EVENT",
+    "DEC_BUFFER_EVENT",
+    "DEC_LAST_PIC_EVENT",
+    "DEC_CACHE_IO_BUFFER_EVENT",
+    "DEC_FAKE_EVENT",
+    "DEC_SOURCE_CHANGE_EVENT",
+    "DEC_PIC_DECODED_EVENT",
+    "DEC_DECODING_FAILED_EVENT",
+    "DEC_GOT_EOS_MARK_EVENT",
+    "DEC_NO_DECODING_BUFFER_EVENT",
+    "DEC_WAIT_DECODING_BUFFER_EVENT",
+    "DEC_PENDING_FLUSH_EVENT",
+    "DEC_DECODING_ERROR_EVENT",
+    "DEC_FATAL_ERROR_EVENT",
+};
+char cmd_name[V4L2_DAEMON_VIDIOC_TOTAL_AMOUNT][50] = {
+    "V4L2_DAEMON_VIDIOC_STREAMON",
+    "V4L2_DAEMON_VIDIOC_BUF_RDY",
+    "V4L2_DAEMON_VIDIOC_CMD_STOP",
+    "V4L2_DAEMON_VIDIOC_STREAMOFF",
+    "V4L2_DAEMON_VIDIOC_FAKE",
+    "V4L2_DAEMON_VIDIOC_S_EXT_CTRLS",
+    "V4L2_DAEMON_VIDIOC_RESET_BITRATE",
+    "V4L2_DAEMON_VIDIOC_CHANGE_RES",
+    "V4L2_DAEMON_VIDIOC_G_FMT",
+    "V4L2_DAEMON_VIDIOC_S_SELECTION",
+    "V4L2_DAEMON_VIDIOC_S_FMT",
+    "V4L2_DAEMON_VIDIOC_PACKET",
+    "V4L2_DAEMON_VIDIOC_STREAMON_CAPTURE",
+    "V4L2_DAEMON_VIDIOC_STREAMON_OUTPUT",
+    "V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE",
+    "V4L2_DAEMON_VIDIOC_STREAMOFF_OUTPUT",
+    "V4L2_DAEMON_VIDIOC_CMD_START",
+    "V4L2_DAEMON_VIDIOC_FRAME",
+    "V4L2_DAEMON_VIDIOC_DESTROY_DEC",
+};
+
+char hantro_level[10][20] = {"",      "ERROR", "WARNING",  "",        "INFO",
+                             "DEBUG", "LOG",   "TRACEREG", "MEMDUMP", ""};
+int hantro_log_level;
+#ifdef VSI_CMODEL
+struct TBCfg tb_cfg;
+uint32_t b_frames;
+uint32_t test_case_id;
+#endif
+
+#define INVALIDE_DEC_TABLE_INDEX -1
+#define NEXT_MULTIPLE(value, n) (((value) + (n)-1) & ~((n)-1))
+#define VSI_TS_BUFFER_LENGTH_DEFAULT (1024)
+#define SECURE_MODE_SKIP_LEN (16)
+extern vsi_v4l2m2m2_deccodec vsidaemon_hevc_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_h264_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_vp8_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_vp9_v4l2m2m_decoder;
+#ifdef HAS_FULL_DECFMT
+extern vsi_v4l2m2m2_deccodec vsidaemon_vc1l_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_vc1g_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_jpeg_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_rv_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_avs_v4l2m2m_decoder;
+
+extern vsi_v4l2m2m2_deccodec vsidaemon_mpeg2_v4l2m2m_decoder;
+extern vsi_v4l2m2m2_deccodec vsidaemon_mpeg4_v4l2m2m_decoder;
+#endif  //#ifdef HAS_FULL_DECFMT
+int vsi_dec_find_event_index_in_fsm_table(
+    v4l2_dec_inst *h, v4l2_inst_dec_event dec_receive_event);
+static int vsi_dec_check_crop(v4l2_dec_inst *h, vsi_v4l2_dec_picture *new_pic);
+static v4l2_inst_dec_event vsi_dec_handle_cropchange(v4l2_dec_inst *h);
+
+uint64_t capture_tot_size = 0;
+
+/**
+ * @brief vsi_dec_get_codec_format(), get h supported codec formats.
+ * @param struct vsi_v4l2_dev_info *hwinfo: output info.
+ * @return int, 0 means support at least 1 format, -1 means error.
+ */
+int vsi_dec_get_codec_format(struct vsi_v4l2_dev_info *hwinfo) {
+  int core_num = 0;
+
+#ifdef VSI_CMODEL
+  core_num = 1;
+  hwinfo->dec_corenum = core_num;
+  hwinfo->decformat = 0xFFFFFFFF;
+  hwinfo->max_dec_resolution = 4096;
+#else
+  DWLHwConfig hw_cfg[2] = {0};
+  unsigned long g1_dec_format = 0;
+  unsigned long g2_dec_format = 0;
+
+  DWLReadAsicConfig(&hw_cfg[0], DWL_CLIENT_TYPE_H264_DEC);
+  DWLReadAsicConfig(&hw_cfg[1], DWL_CLIENT_TYPE_HEVC_DEC);
+
+  g1_dec_format = (((hw_cfg[0].h264_support != 0) ? (1 << DEC_HAS_H264) : 0) |
+                   ((hw_cfg[0].vp8_support != 0) ? (1 << DEC_HAS_VP8) : 0));
+
+#ifdef HAS_FULL_DECFMT
+  g1_dec_format |=
+      (((hw_cfg[0].vc1_support == 3) ? (1 << DEC_HAS_VC1_G) : 0) |
+       ((hw_cfg[0].vc1_support != 0) ? (1 << DEC_HAS_VC1_L) : 0) |
+       ((hw_cfg[0].mpeg2_support != 0) ? (1 << DEC_HAS_MPEG2) : 0) |
+       ((hw_cfg[0].mpeg4_support != 0) ? (1 << DEC_HAS_MPEG4) : 0) |
+       ((hw_cfg[0].mpeg4_support != 0) ? (1 << DEC_HAS_H263) : 0) |
+       ((hw_cfg[0].jpeg_support != 0) ? (1 << DEC_HAS_JPEG) : 0) |
+       ((hw_cfg[0].avs_support != 0) ? (1 << DEC_HAS_AVS2) : 0) |
+       ((hw_cfg[0].rv_support != 0) ? (1 << DEC_HAS_RV) : 0) |
+       ((hw_cfg[0].mpeg4_support != 0) ? (1 << DEC_HAS_XVID) : 0));
+#endif
+  g2_dec_format = (((hw_cfg[1].hevc_support != 0) ? (1 << DEC_HAS_HEVC) : 0) |
+                   ((hw_cfg[1].vp9_support != 0) ? (1 << DEC_HAS_VP9) : 0));
+
+  if (g1_dec_format) core_num++;
+  if (g2_dec_format) core_num++;
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "core_num %d, ReadAsicCoreCount %d
", core_num,
+             DWLReadAsicCoreCount());
+  ASSERT(core_num == DWLReadAsicCoreCount());
+  hwinfo->dec_corenum = core_num;
+  hwinfo->decformat = g1_dec_format | g2_dec_format;
+  //is there any better way to determine it?
+  if (g1_dec_format & (1 << DEC_HAS_VC1_G))
+    hwinfo->max_dec_resolution = 4096;
+  else
+    hwinfo->max_dec_resolution = 1920;
+#endif
+  return (core_num != 0) ? 0 : -1;
+}
+
+//#define LOCAL_SAVE_FILE
+#ifdef LOCAL_SAVE_FILE
+uint32_t _dbg_wr_mode = 1; /*0: per frame per file; 1: combined to single file*/
+                           /**
+                            * @brief _dbg_write_input_data_(), write input data packet to file.
+                            * @param v4l2_dec_inst* h: decoder instance.
+                            * @param uint32_t *vaddr: virtual address of input packet.
+                            * @param uint32_t size: size of input packet buffer.
+                            * @param uint32_t payload: bytes number of input packet payload.
+                            * @return none.
+                            */
+void _dbg_write_input_data_(v4l2_dec_inst *h, uint32_t *vaddr, uint32_t size,
+                            uint32_t payload) {
+  FILE *fp = NULL;
+  char name[64];
+  char *p = NULL;
+
+  uint32_t frame_id = 0;
+
+  if (_dbg_wr_mode == 0) {
+    frame_id = h->dec_in_pic_id;
+  }
+
+  switch (h->codec_fmt) {
+    case V4L2_DAEMON_CODEC_DEC_HEVC:
+      sprintf(name, "recived_%lx_%d.hevc", h->instance_id, frame_id);
+      break;
+    case V4L2_DAEMON_CODEC_DEC_H264:
+      sprintf(name, "recived_%lx_%d.h264", h->instance_id, frame_id);
+      break;
+    default:
+      sprintf(name, "recived_%lx_%d.bin", h->instance_id, frame_id);
+      break;
+  }
+
+  if (_dbg_wr_mode == 0) {
+    fp = fopen(name, "wb");
+  } else {
+    fp = fopen(name, "ab+");
+  }
+
+  if (fp) {
+    p = malloc(size);
+    ASSERT(p);
+    memcpy(p, vaddr, size);
+    fwrite(p, 1, payload, fp);
+    free(p);
+    fclose(fp);
+  }
+}
+#endif
+
+/**
+ * @brief vsi_dec_register_fsm_table(), decoder register fsm table.
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @return none.
+ */
+void vsi_dec_register_fsm_table(v4l2_dec_inst *h) {
+  switch (h->codec_fmt) {
+#ifdef USE_G1
+    case V4L2_DAEMON_CODEC_DEC_VP8:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_vp8_v4l2m2m_decoder;
+      break;
+#ifdef HAS_FULL_DECFMT
+    case V4L2_DAEMON_CODEC_DEC_MPEG2:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_mpeg2_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_H263:
+    case V4L2_DAEMON_CODEC_DEC_MPEG4:
+    case V4L2_DAEMON_CODEC_DEC_XVID:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_mpeg4_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_VC1_G:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_vc1g_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_VC1_L:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_vc1l_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_JPEG:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_jpeg_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_AVS2:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_avs_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_RV:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_rv_v4l2m2m_decoder;
+      break;
+
+#endif
+    case V4L2_DAEMON_CODEC_DEC_H264:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_h264_v4l2m2m_decoder;
+      break;
+
+#endif
+
+#ifdef USE_G2
+    case V4L2_DAEMON_CODEC_DEC_HEVC:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_hevc_v4l2m2m_decoder;
+      break;
+    case V4L2_DAEMON_CODEC_DEC_VP9:
+      h->vsi_v4l2m2m_decoder = (void *)&vsidaemon_vp9_v4l2m2m_decoder;
+      break;
+#endif
+    case V4L2_DAEMON_CODEC_UNKNOW_TYPE:
+      HANTRO_LOG(HANTRO_LEVEL_WARNING, "unknown codec fmt 
");
+      break;
+    default:
+      break;
+  }
+}
+/**
+ * @brief vsi_dec_trans_v4l2cmdid_to_eventid(), deduce event ID from
+ * v4l2_msg->cmd_id.
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event, deduced event ID.
+ */
+v4l2_inst_dec_event vsi_dec_trans_v4l2cmdid_to_eventid(
+    v4l2_dec_inst *h, struct vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event dec_event = DEC_EMPTY_EVENT;
+
+  switch (v4l2_msg->cmd_id) {
+    case V4L2_DAEMON_VIDIOC_BUF_RDY:
+      dec_event = DEC_CACHE_IO_BUFFER_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMON_CAPTURE:
+      dec_event = DEC_RECEIVE_CAPTUREON_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE:
+      dec_event = DEC_RECEIVE_CAPTUREOFF_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMON_OUTPUT:
+      dec_event = DEC_RECEIVE_OUTPUTON_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMOFF_OUTPUT:
+      dec_event = DEC_RECEIVE_OUTPUTOFF_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_CMD_START:
+      dec_event = DEC_RECEIVE_CMDSTART_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_CMD_STOP:
+      dec_event = DEC_RECEIVE_CMDSTOP_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_DESTROY_DEC:
+      dec_event = DEC_RECEIVE_DESTROY_EVENT;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_FAKE:
+      if (bufferlist_get_size(h->bufferlist_input)) {
+        dec_event = DEC_FAKE_EVENT;
+      }
+      break;
+    default:
+      HANTRO_LOG(HANTRO_LEVEL_WARNING, "unkonw cmd_id %d
", v4l2_msg->cmd_id);
+      break;
+  }
+  return dec_event;
+}
+
+
+/**
+ * @brief vsi_dec_msg_done(), send msg-done notification to driver
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return
+ */
+void vsi_dec_msg_done(v4l2_dec_inst *h, struct vsi_v4l2_msg *v4l2_msg) {
+  if (v4l2_msg->cmd_id == V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE) {
+    send_cmd_orphan_msg(h->instance_id, V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE_DONE);
+  }
+}
+
+#ifndef NXP_TIMESTAMP_MANAGER
+static void vsi_dec_set_timestamp(v4l2_dec_inst *h, uint64_t ts_value,
+                                  uint32_t index) {
+  h->dec_timestamp_values[index % TIMESTAMP_SLOT_NUM] = ts_value;
+}
+
+static uint64_t vsi_dec_get_timestamp(v4l2_dec_inst *h, uint32_t index) {
+  return h->dec_timestamp_values[index % TIMESTAMP_SLOT_NUM];
+}
+#endif
+
+static v4l2_inst_dec_event vsi_dec_handle_input_buffer(
+    v4l2_dec_inst *h, struct vsi_v4l2_msg *msg) {
+  BUFFER *buf = NULL;
+  int32_t ret = 0;
+
+  if (msg->params.dec_params.io_buffer.inbufidx == INVALID_IOBUFF_IDX) {
+    return DEC_EMPTY_EVENT;
+  }
+
+  buf = (BUFFER *)malloc(sizeof(BUFFER)); //TBD, avoid malloc/free each input.
+  ASSERT(buf);
+  buf->frame_display_id = ++h->input_frame_cnt;
+  memcpy(&buf->dec_cmd, &msg->params.dec_params.io_buffer,
+         sizeof(struct v4l2_daemon_dec_buffers));
+  ret = bufferlist_push_buffer(h->bufferlist_input, buf);
+  ASSERT(ret == 0);
+
+#ifndef NXP_TIMESTAMP_MANAGER
+  vsi_dec_set_timestamp(h, msg->params.dec_params.io_buffer.timestamp,
+                        buf->frame_display_id);
+#endif
+
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG,
+             "Inst[%lx]: received one input buffer: id=%d, payloadSize=%d.
",
+             h->instance_id,
+             msg->params.dec_params.io_buffer.inbufidx,
+             msg->params.dec_params.io_buffer.bytesused);
+
+  return DEC_BUFFER_EVENT;
+}
+
+static v4l2_inst_dec_event vsi_dec_handle_output_buffer(
+    v4l2_dec_inst *h, struct vsi_v4l2_msg *msg) {
+  v4l2_daemon_dec_buffers *buf = &msg->params.dec_params.io_buffer;
+  int32_t index = buf->outbufidx;
+
+  if (index == INVALID_IOBUFF_IDX) {
+    return DEC_EMPTY_EVENT;
+  }
+
+  if (h->dec_cur_state == DAEMON_DEC_STATE_OPEN) {
+    h->dec_info.frame_width = buf->output_width;
+    h->dec_info.frame_height = buf->output_height;
+  }
+
+  dpb_receive_buffer(h, index, buf);
+
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Inst[%lx]: received one output buffer: id=%d.
",
+             h->instance_id,
+             msg->params.dec_params.io_buffer.outbufidx);
+  h->output_frame_cnt++;
+  return DEC_BUFFER_EVENT;
+}
+
+static void vsi_dec_get_dec_ofmt(v4l2_dec_inst *h, struct vsi_v4l2_msg *msg) {
+  if ((msg->params.dec_params.io_buffer.outbufidx == INVALID_IOBUFF_IDX) ||
+      (h->dec_pic_id > 0)) {
+    return;
+  }
+
+  int32_t pixel_depth = msg->params.dec_params.io_buffer.outputPixelDepth;
+
+  // set output format & pixel format
+  switch (msg->params.dec_params.io_buffer.outBufFormat) {
+  case VSI_V4L2_DECOUT_DTRC:
+  case VSI_V4L2_DECOUT_DTRC_10BIT:
+  case VSI_V4L2_DECOUT_RFC:
+  case VSI_V4L2_DECOUT_RFC_10BIT:
+    h->dec_output_fmt = DEC_REF_FRM_TILED_DEFAULT;
+    break;
+  default:
+    h->dec_output_fmt = DEC_REF_FRM_RASTER_SCAN;
+    break;
+  }
+
+  if (pixel_depth == 8) {
+    h->dec_pixel_fmt = DEC_OUT_PIXEL_CUT_8BIT;
+  } else if (pixel_depth == 10) {
+    h->dec_pixel_fmt = DEC_OUT_PIXEL_DEFAULT;
+  } else if (pixel_depth == 16) {
+    h->dec_pixel_fmt = DEC_OUT_PIXEL_P010;
+  }
+  return;
+}
+
+v4l2_inst_dec_event vsi_dec_handle_io_buffer(v4l2_dec_inst *h,
+                                             struct vsi_v4l2_msg *msg) {
+  v4l2_inst_dec_event event_1, event_2;
+  vsi_dec_get_dec_ofmt(h, msg);
+  event_1 = vsi_dec_handle_input_buffer(h, msg);
+  event_2 = vsi_dec_handle_output_buffer(h, msg);
+
+  if (event_1 == DEC_EMPTY_EVENT && event_2 == DEC_EMPTY_EVENT) {
+    return DEC_EMPTY_EVENT;
+  }
+
+  return DEC_BUFFER_EVENT;
+}
+
+void vsi_dec_flush_input_packet(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  BUFFER *p = NULL;
+
+  p = bufferlist_get_buffer(h->bufferlist_input);
+
+  if (p == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: SHOULD GET THE INPUT BUFFER.
",
+               h->instance_id);
+    ASSERT(0);
+  }
+
+#ifdef DEC_INPUT_NO_COPY
+  if (h->dec_cur_input_vaddr) {
+    unmap_phy_addr_daemon(h->dec_cur_input_vaddr, h->stream_in_mem.size);
+    h->stream_in_mem.virtual_address = NULL;
+    h->dec_cur_input_vaddr = NULL;
+  }
+#endif
+
+  send_dec_inputbuf_orphan_msg(h->handler, v4l2_msg,
+                               p->dec_cmd.io_buffer.inbufidx);
+
+  free(p);
+  bufferlist_pop_buffer(h->bufferlist_input);
+}
+
+int32_t vsi_dec_get_input_data(v4l2_dec_inst *h) {
+  BUFFER *p = NULL;
+  v4l2_daemon_dec_buffers *in_buf = NULL;
+
+  if (h->stream_in_mem.logical_size) {
+    return 0;
+  }
+re_get:
+  p = bufferlist_get_buffer(h->bufferlist_input);
+
+  if (p == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: should get one input buffer.
",
+              h->instance_id);
+    return -2;
+  }
+
+  // CHECK: this align for mmap maybe cause overlap
+  in_buf = &p->dec_cmd.io_buffer;
+
+  if (in_buf->bytesused == 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: input payload size is zero!
",
+              h->instance_id);
+    vsi_dec_flush_input_packet(h, NULL);
+    goto re_get;
+  }
+
+  uint32_t map_size = h->secure_mode_on ? (in_buf->bytesused + SECURE_MODE_SKIP_LEN) : in_buf->bytesused;
+
+  uint32_t aligned_map_size = NEXT_MULTIPLE(map_size, 0x1000);
+
+  uint32_t *virtual_address =
+      mmap_phy_addr_daemon(mmap_fd, in_buf->busInBuf, aligned_map_size);
+  if (virtual_address == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: MMAP Input Buffer FAILED
",
+               h->instance_id);
+    ASSERT(0);
+    return -1;
+  }
+
+#ifdef DEC_INPUT_NO_COPY
+  h->stream_in_mem.virtual_address = virtual_address;
+  h->stream_in_mem.bus_address = in_buf->busInBuf;
+  h->stream_in_mem.size = aligned_map_size;  // in_buf->inBufSize; //Using
+                                             // aligned_map_size instead of
+                                             // inBufSize is for umap.
+  h->stream_in_mem.logical_size = in_buf->bytesused;
+  h->stream_in_mem.mem_type = DWL_MEM_TYPE_SLICE;
+
+  h->dec_cur_input_vaddr = virtual_address;
+
+  if (h->secure_mode_on) {
+    //The first 16 bytes store bus address of the secure packet data.
+    h->stream_in_mem.virtual_address += SECURE_MODE_SKIP_LEN/sizeof(uint32_t);
+    h->stream_in_mem.bus_address = *((addr_t *)virtual_address);
+  }
+
+#ifdef LOCAL_SAVE_FILE
+  _dbg_write_input_data_(h, virtual_address, aligned_map_size,
+                         in_buf->bytesused);
+#endif
+
+#else //DEC_INPUT_NO_COPY
+  h->stream_in_mem.logical_size = in_buf->bytesused;
+  ASSERT(h->dec_cur_input_vaddr);
+  h->stream_in_mem.virtual_address = h->dec_cur_input_vaddr;
+
+  memcpy(h->stream_in_mem.virtual_address, virtual_address,
+         aligned_map_size);  // in_buf->bytesused);
+  unmap_phy_addr_daemon(virtual_address, aligned_map_size);
+#endif //DEC_INPUT_NO_COPY
+
+#ifdef VSI_CMODEL
+  h->stream_in_mem.bus_address = (addr_t)h->stream_in_mem.virtual_address;
+#endif
+
+  h->curr_inbuf_idx = in_buf->inbufidx;
+
+#ifdef NXP_TIMESTAMP_MANAGER
+  if (in_buf->timestamp < 0) in_buf->timestamp = TSM_TIMESTAMP_NONE;
+
+  if (h->need_resync_tsm) {
+    resyncTSManager(h->tsm, in_buf->timestamp, MODE_AI);
+    h->need_resync_tsm = 0;
+  }
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: input time stamp: %ld len: %d
",
+             h->instance_id,
+             in_buf->timestamp, in_buf->bytesused);
+  TSManagerReceive2(h->tsm, in_buf->timestamp, in_buf->bytesused);
+#endif
+  h->dec_in_pic_id = p->frame_display_id;
+  h->dec_inpkt_pic_decoded_cnt = h->dec_pic_id;
+  h->dec_in_new_packet = 1;
+  h->dec_inpkt_ignore_picconsumed_event = (in_buf->timestamp < 0) ? 1 : 0;
+  return 0;
+}
+
+static void vsi_dec_handle_inpkt_cnt(v4l2_dec_inst *h) {
+  /* If current input packet doesn't have picture decoded,
+   * send out a specific event out. It is for Android CTS,
+   * which requires input <-> output should match.
+  */
+  if (h->dec_inpkt_pic_decoded_cnt == h->dec_pic_id &&
+      h->dec_inpkt_ignore_picconsumed_event == 0) {
+    BUFFER *p = NULL;
+    i32 inbufidx = INVALID_IOBUFF_IDX;
+
+    p = bufferlist_get_buffer(h->bufferlist_input);
+
+    if (p == NULL) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: SHOULD GET INPUT BUFFER.
",
+                   h->instance_id);
+        ASSERT(0);
+    } else {
+        inbufidx = p->dec_cmd.io_buffer.inbufidx;
+    }
+    vsi_v4l2_msg msg = {0};
+    msg.error = 0;
+    msg.seq_id = NO_RESPONSE_SEQID;
+    msg.size = sizeof(struct v4l2_daemon_dec_buffers);
+    msg.cmd_id = V4L2_DAEMON_VIDIOC_PICCONSUMED;
+    msg.inst_id = h->instance_id;
+    msg.params.dec_params.io_buffer.inbufidx = inbufidx;
+    msg.params.dec_params.io_buffer.outbufidx = INVALID_IOBUFF_IDX;
+    send_notif_to_v4l2(pipe_fd, &msg,
+                       sizeof(struct vsi_v4l2_msg_hdr) +
+                           sizeof(struct v4l2_daemon_dec_buffers));
+  }
+}
+
+void vsi_dec_update_input_data(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  h->dec_in_new_packet = 0;
+
+  if (h->stream_in_mem.logical_size) return;
+  vsi_dec_handle_inpkt_cnt(h);
+  vsi_dec_flush_input_packet(h, v4l2_msg);
+}
+
+/**
+ * @brief vsi_dec_flush_input(), decoder gives back OUTPUT queue buffer to
+ * v4l2-driver.
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @return none.
+ */
+void vsi_dec_flush_input(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  uint32_t avails = bufferlist_get_size(h->bufferlist_input);
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: flush input avails: %d
",
+             h->instance_id, avails);
+  for (int i = 0; i < avails; i++) {
+    vsi_dec_flush_input_packet(h, v4l2_msg);
+  }
+  h->stream_in_mem.logical_size = 0;
+#ifdef NXP_TIMESTAMP_MANAGER
+  h->need_resync_tsm = 1;
+  h->consumed_len = 0;
+#endif
+}
+
+/**
+ * @brief vsi_dec_flush_output(), decoder gives back CAPTURE queue buffer to
+ * v4l2-driver.
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @return none.
+ */
+void vsi_dec_flush_output(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  struct v4l2_decoder_dbp *p;
+
+  for (int i = 0; i < MAX_BUFFER_SIZE; i++) {
+    p = dpb_list_buffer(h, i);
+    if (p && p->status != DPB_STATUS_RENDER) {
+      ;
+      // send_dec_outputbuf_orphan_msg(h->handler, v4l2_msg, p->buff_idx, 0,
+      // VSI_DEC_EMPTY_OUTPUT_DATA);
+    }
+  }
+  dpb_destroy(h);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: currently existed dpb nums %d
",
+             h->instance_id,
+             h->existed_dpb_nums);
+}
+
+/**
+* @brief vsi_dec_get_pic(), try to get output picture, then send to driver.
+* @param v4l2_dec_inst* h: decoder instance.
+* @return int: 0- get & send one picture succeed; others- not pic got.
+*/
+int vsi_dec_dequeue_pic(v4l2_dec_inst *h) {
+  int32_t id = INVALID_IOBUFF_IDX;
+  int ret = 0;
+  vsi_v4l2m2m2_deccodec *dec = (vsi_v4l2m2m2_deccodec *)h->vsi_v4l2m2m_decoder;
+  vsi_v4l2_dec_picture tmp_pic = {0};
+
+  // get picture from decoder
+  ASSERT(dec);
+  ret = dec->get_pic(h, &tmp_pic, h->dec_capture_eos);
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: get pic ret %d
",
+             h->instance_id, ret);
+  if (ret && !h->dec_capture_eos) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Inst[%lx]: didn't have available picture for dequeue.
",
+               h->instance_id);
+    return DEQUEUE_ERR_PIC_NOT_AVAIL;
+  }
+
+  // dpb-buff management - render
+  if (ret != 0) {
+    id = dpb_render_buffer(h, NULL);
+    if (h->dec_drain_tid == 0) {
+      pthread_join(h->dec_drain_thread, NULL);
+      h->dec_drain_tid = -1;
+      HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: joined drain thread.
",
+                 h->instance_id);
+    }
+  } else {
+    if (vsi_dec_check_crop(h, &tmp_pic)) {
+      vsi_dec_handle_cropchange(h);
+    }
+    id = dpb_render_buffer(h, &tmp_pic);
+  }
+
+  if (id == INVALID_IOBUFF_IDX) {
+    return DEQUEUE_ERR_BUF_NOT_AVAIL;
+  }
+
+  // notify kernel for dequeue
+  vsi_v4l2_msg msg = {0};
+  msg.error = 0;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  msg.size = sizeof(v4l2_daemon_dec_buffers);
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+  msg.inst_id = h->instance_id;
+  msg.params.dec_params.io_buffer.inbufidx = INVALID_IOBUFF_IDX;
+  msg.params.dec_params.io_buffer.outbufidx = h->dpb_buffers[id].buff_idx;
+  msg.params.dec_params.io_buffer.OutBufSize = h->dpb_buffers[id].buff.size;
+  h->dec_out_pic_id++;
+
+  if (0 == ret) {
+    uint32_t luma_size = tmp_pic.pic_stride * tmp_pic.pic_height;
+    uint32_t chroma_size = 0;
+    if (tmp_pic.output_picture_chroma_bus_address) {
+      if (!tmp_pic.chroma_size) {
+        chroma_size = tmp_pic.pic_stride * tmp_pic.pic_height / 2;
+      } else {
+        chroma_size = tmp_pic.chroma_size;
+      }
+    }
+    msg.params.dec_params.io_buffer.rfc_luma_offset =
+        tmp_pic.output_rfc_luma_bus_address - tmp_pic.output_picture_bus_address;
+    msg.params.dec_params.io_buffer.rfc_chroma_offset =
+        tmp_pic.output_rfc_chroma_bus_address - tmp_pic.output_picture_bus_address;	
+    msg.params.dec_params.io_buffer.bytesused = luma_size + chroma_size;
+
+#ifdef NXP_TIMESTAMP_MANAGER
+    msg.params.dec_params.io_buffer.timestamp = TSManagerSend2(h->tsm, NULL);
+#else
+    msg.params.dec_params.io_buffer.timestamp =
+        vsi_dec_get_timestamp(h, tmp_pic.pic_id);
+#endif
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Inst[%lx]: output time stamp: %ld buffer[id: %d}: %d
",
+               h->instance_id,
+               msg.params.dec_params.io_buffer.timestamp,
+               id, h->dpb_buffers[id].buff_idx);
+  } else {
+    msg.params.dec_params.io_buffer.bytesused = 0;
+    h->dec_last_pic_sent = 1;
+    h->dec_capture_eos = 0;
+    msg.params.dec_params.io_buffer.timestamp = 0;
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: last pic is sent out.
",
+              h->instance_id);
+  }
+  send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr) +
+                                        sizeof(struct v4l2_daemon_dec_buffers));
+  capture_tot_size += msg.params.dec_params.io_buffer.bytesused;
+  return 0;
+}
+
+/**
+* @brief vsi_dec_dequeue_empty_pic(), send capture buffer (with byteused=0) to
+* driver, for last picture.
+* @param v4l2_dec_inst* h: decoder instance.
+* @return int: 0- succeed; others- no "available" capture buffer got.
+*/
+int vsi_dec_dequeue_empty_pic(v4l2_dec_inst *h) {
+  int32_t id = INVALID_IOBUFF_IDX;
+  vsi_v4l2_msg msg = {0};
+
+  // dpb-buff management - render
+  id = dpb_render_buffer(h, NULL);
+  if (id == INVALID_IOBUFF_IDX) {
+    return DEQUEUE_ERR_BUF_NOT_AVAIL;
+  }
+
+  // notify kernel for dequeue
+  msg.error = 0;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  msg.size = sizeof(v4l2_daemon_dec_buffers);
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_BUF_RDY;
+  msg.inst_id = h->instance_id;
+  msg.params.dec_params.io_buffer.inbufidx = INVALID_IOBUFF_IDX;
+  msg.params.dec_params.io_buffer.outbufidx = h->dpb_buffers[id].buff_idx;
+  msg.params.dec_params.io_buffer.OutBufSize = h->dpb_buffers[id].buff.size;
+  msg.params.dec_params.io_buffer.bytesused = 0;
+  h->dec_out_pic_id++;
+
+  send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg_hdr) +
+                                        sizeof(struct v4l2_daemon_dec_buffers));
+  return 0;
+}
+
+/**
+* @brief vsi_dec_drop_pic(), try to get output buffer idx, then drop it
+* directly.
+* @param v4l2_dec_inst* h: decoder instance.
+* @return none.
+*/
+int vsi_dec_drop_pic(v4l2_dec_inst *h) {
+  int ret = 0;
+  vsi_v4l2m2m2_deccodec *dec = (vsi_v4l2m2m2_deccodec *)h->vsi_v4l2m2m_decoder;
+  vsi_v4l2_dec_picture tmp_pic;
+
+  // get picture from decoder
+  ASSERT(dec);
+  ret = dec->get_pic(h, &tmp_pic, h->dec_capture_eos);
+  if (ret) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Inst[%lx]: didn't have available picture for dequeue.
",
+               h->instance_id);
+    return -1;
+  }
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: release picture: bus_addr=0x%llx
",
+             h->instance_id,
+             tmp_pic.output_picture_bus_address);
+  dec->release_pic(h, tmp_pic.priv_pic_data);
+  return 0;
+}
+
+void *vsi_dec_send_eos(void *arg) {
+  v4l2_dec_inst *h = (v4l2_dec_inst *)arg;
+  ASSERT(h->vsi_v4l2m2m_decoder);
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+  int ret = 0;
+  ret = dec->drain(h);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: END, ret %d
", h->instance_id, ret);
+  return NULL;
+}
+
+v4l2_inst_dec_event vsi_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re = DEC_EMPTY_EVENT;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+  ASSERT(dec);
+#ifdef NXP_TIMESTAMP_MANAGER
+  h->tsm = createTSManager(VSI_TS_BUFFER_LENGTH_DEFAULT);
+  h->need_resync_tsm = 1;
+  h->consumed_len = 0;
+#endif
+
+#ifdef VSI_CMODEL
+  TBSetDefaultCfg(&tb_cfg);
+#endif
+  re = dec->init(h, v4l2_msg);
+  h->priv_pic_data = calloc(1, dec->pic_ctx_size);
+  ASSERT(h->priv_pic_data);
+
+#ifndef DEC_INPUT_NO_COPY
+  h->stream_in_mem.mem_type = DWL_MEM_TYPE_SLICE;
+  DWLMallocLinear(h->dwl_inst, STREAM_INBUFF_SIZE, &h->stream_in_mem);
+  h->dec_cur_input_vaddr = h->stream_in_mem.virtual_address;
+  ASSERT(h->dec_cur_input_vaddr);
+#endif
+  h->stream_in_mem.logical_size = 0;
+  return re;
+}
+
+v4l2_inst_dec_event vsi_dec_destroy(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+  ASSERT(dec);
+
+  dpb_refresh_all_buffers(h);
+  if (h->dec_drain_tid == 0) {
+    pthread_join(h->dec_drain_thread, NULL);
+    h->dec_drain_tid = -1;
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: joined drain thread.
",
+              h->instance_id);
+  }
+
+#ifndef DEC_INPUT_NO_COPY
+  h->stream_in_mem.virtual_address = h->dec_cur_input_vaddr;
+  DWLFreeLinear(h->dwl_inst, &h->stream_in_mem);
+#endif
+  memset(&h->stream_in_mem, 0, sizeof(struct DWLLinearMem));
+  if (h->priv_pic_data) {
+    free(h->priv_pic_data);
+    h->priv_pic_data = NULL;
+  }
+  re = dec->destroy(h, v4l2_msg);
+
+  h->vsi_v4l2m2m_decoder = NULL;
+#ifdef NXP_TIMESTAMP_MANAGER
+  if (h->tsm) {
+    destroyTSManager(h->tsm);
+    h->tsm = NULL;
+  }
+#endif
+  return re;
+}
+
+/**
+ * @brief vsi_dec_find_event_index_in_fsm_table(), decoder search status .
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @param v4l2_inst_dec_event dec_receive_event: message from v4l2 driver.
+ * @return int, status index in fsm table.
+ */
+int vsi_dec_find_event_index_in_fsm_table(
+    v4l2_dec_inst *h, v4l2_inst_dec_event dec_receive_event) {
+  int status_index = INVALIDE_DEC_TABLE_INDEX;
+  int i = 0;
+  for (i = 0; i < vsi_fsm_trans_table_count; i++) {
+    if (dec_receive_event == vsi_v4l2dec_fsm_trans_table[i].dec_event &&
+        h->dec_cur_state == vsi_v4l2dec_fsm_trans_table[i].cur_state) {
+      status_index = i;
+      break;
+    }
+  }
+
+  return status_index;
+}
+
+void dec_capture_act_proc(v4l2_dec_inst *h) {
+  uint32_t act_done = 1;
+
+  if (h->dec_capture_act == DAEMON_QUEUE_ACT_DROP) {
+    while (0 == vsi_dec_drop_pic(h))
+      ;
+  } else if (h->dec_capture_act == DAEMON_QUEUE_ACT_FLUSH) {
+    while (0 == vsi_dec_dequeue_pic(h))
+      ;
+    if (vsi_dec_dequeue_empty_pic(h)) {
+      act_done = 0;
+    }
+  } else if (h->dec_capture_act == DAEMON_QUEUE_ACT_CONSUME) {
+    dpb_refresh_all_buffers(h);
+  }
+
+  if (act_done) h->dec_capture_act = DAEMON_QUEUE_ACT_NONE;
+}
+
+void dec_output_act_proc(v4l2_dec_inst *h) {
+  BUFFER *ibuf = NULL;
+
+  if (h->dec_output_act == DAEMON_QUEUE_ACT_EOS) {
+    // ASSERT(h->dec_output_state == DAEMON_QUEUE_STATE_PEND_OFF);
+
+    h->dec_output_last_inbuf_idx = INVALID_IOBUFF_IDX;
+    ibuf = bufferlist_get_tail(h->bufferlist_input);
+    if (ibuf) {
+      h->dec_output_last_inbuf_idx = ibuf->dec_cmd.io_buffer.inbufidx;
+    }
+    if (h->dec_output_last_inbuf_idx == INVALID_IOBUFF_IDX) {
+      // h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+      h->dec_eos = 1;
+    }
+  }
+  h->dec_output_act = DAEMON_QUEUE_ACT_NONE;
+}
+
+static uint32_t vsi_dec_having_input_data(v4l2_dec_inst *h) {
+  if (h->stream_in_mem.logical_size ||
+      bufferlist_get_size(h->bufferlist_input)) {
+    return 1;
+  }
+  return 0;
+}
+
+v4l2_inst_dec_event vsi_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+  v4l2_inst_dec_event event = DEC_EMPTY_EVENT;
+  int32_t ret;
+
+  ASSERT(dec);
+
+  if (h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP) {
+    if (h->dec_wait_dbp_buf) return DEC_EMPTY_EVENT;
+  }
+
+  if (h->dec_output_state != DAEMON_QUEUE_STATE_PEND_OFF &&
+      h->dec_output_state != DAEMON_QUEUE_STATE_ON) {
+    return DEC_EMPTY_EVENT;
+  }
+
+  ret = vsi_dec_get_input_data(h);
+
+  if (0 == ret) {
+    h->dec_eos = 0;
+    if (h->dec_output_state == DAEMON_QUEUE_STATE_PEND_OFF) {
+      h->dec_eos = (h->curr_inbuf_idx == h->dec_output_last_inbuf_idx);
+    }
+
+    // Make sure dpb buffers are enough to avoid ctrlsw seg-fault
+    if (h->dec_info.needed_dpb_nums &&
+        h->existed_dpb_nums < h->dec_info.needed_dpb_nums) {
+      return DEC_NO_DECODING_BUFFER_EVENT;
+    }
+
+    event = dec->decode(h, v4l2_msg);
+    vsi_dec_update_input_data(h, v4l2_msg);
+  }
+
+#ifdef NXP_TIMESTAMP_MANAGER
+  HANTRO_LOG(HANTRO_LEVEL_INFO,
+             "event: %d consumed len: %d left stream len: %d
", event,
+             h->consumed_len, h->stream_in_mem.logical_size);
+  if (event == DEC_PIC_DECODED_EVENT) {
+    TSManagerValid2(h->tsm, h->consumed_len, NULL);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "consumed len: %d
", h->consumed_len);
+    h->consumed_len = 0;
+  } else if ((event == DEC_DECODING_FAILED_EVENT) &&
+        (h->stream_in_mem.logical_size == 0)) {
+    TSManagerValid2(h->tsm, h->consumed_len, NULL);
+    TSManagerSend2(h->tsm, NULL);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "broken pic consumed len: %d
",
+               h->consumed_len);
+    h->consumed_len = 0;
+  }
+#endif
+
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PEND_OFF) {
+    if (h->dec_eos && h->stream_in_mem.logical_size == 0) {
+      h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+      event = DEC_GOT_EOS_MARK_EVENT;
+    }
+  }
+
+  if ((event == DEC_EMPTY_EVENT || event == DEC_DECODING_FAILED_EVENT || 
+      event == DEC_DECODING_ERROR_EVENT) &&
+      vsi_dec_having_input_data(h)) {
+    send_fake_cmd(h->handler);
+  }
+
+  return event;
+}
+
+static void vsi_dec_set_crop(v4l2_dec_inst *h) {
+  h->pic_info.crop_left = h->dec_info.visible_rect.left;
+  h->pic_info.crop_top = h->dec_info.visible_rect.top;
+  h->pic_info.crop_width = h->dec_info.visible_rect.width;
+  h->pic_info.crop_height = h->dec_info.visible_rect.height;
+  h->pic_info.width = h->dec_info.frame_width;
+  h->pic_info.height = h->dec_info.frame_height;
+  h->pic_info.pic_wstride = h->dec_info.pic_wstride;
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: crop info is updated.
",
+             h->instance_id);
+}
+
+static int vsi_dec_check_crop(v4l2_dec_inst *h, vsi_v4l2_dec_picture *new_pic) {
+  if (new_pic->crop_left == h->pic_info.crop_left &&
+      new_pic->crop_top == h->pic_info.crop_top &&
+      new_pic->crop_width == h->pic_info.crop_width &&
+      new_pic->crop_height == h->pic_info.crop_height &&
+      new_pic->pic_width == h->pic_info.width &&
+      new_pic->pic_height == h->pic_info.height &&
+      new_pic->pic_stride == h->pic_info.pic_wstride) {
+    // crop is not changed
+    return 0;
+  };
+
+  h->pic_info.crop_left = new_pic->crop_left;
+  h->pic_info.crop_top = new_pic->crop_top;
+  h->pic_info.crop_width = new_pic->crop_width;
+  h->pic_info.crop_height = new_pic->crop_height;
+  h->pic_info.width = new_pic->pic_width;
+  h->pic_info.height = new_pic->pic_height;
+  h->pic_info.pic_wstride = new_pic->pic_stride;
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: crop info is different @ frame %d.
",
+             h->instance_id, h->dec_pic_id);
+  return 1;
+}
+
+static v4l2_inst_dec_event vsi_dec_handle_cropchange(v4l2_dec_inst *h) {
+  vsi_v4l2_msg msg = {0};
+  struct v4l2_daemon_dec_pictureinfo_params *pic_info =
+      &msg.params.dec_params.pic_info;
+  msg.error = 0;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  // use same structure with res-change params
+  msg.size = sizeof(struct v4l2_daemon_dec_pictureinfo_params);
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_CROPCHANGE;
+  msg.inst_id = h->instance_id;
+  /*
+      pic_info->io_buffer.inbufidx = INVALID_IOBUFF_IDX;
+      pic_info->io_buffer.outbufidx = INVALID_IOBUFF_IDX;
+      pic_info->io_buffer.srcwidth = h->dec_info.frame_width;
+      pic_info->io_buffer.srcheight = h->dec_info.frame_height;
+      pic_info->io_buffer.output_width = h->dec_info.frame_width;
+      pic_info->io_buffer.output_height = h->dec_info.frame_height;
+      pic_info->io_buffer.OutBufSize = h->dec_info.dpb_buffer_size;
+  */
+  memcpy(&pic_info->pic_info, &h->pic_info, sizeof(v4l2_daemon_pic_info));
+  send_notif_to_v4l2(pipe_fd, &msg,
+                     sizeof(struct vsi_v4l2_msg_hdr) +
+                         sizeof(struct v4l2_daemon_dec_pictureinfo_params));
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: crop change event is sent.
",
+             h->instance_id);
+  return DEC_EMPTY_EVENT;
+}
+
+static v4l2_inst_dec_event vsi_dec_handle_reschange(v4l2_dec_inst *h) {
+  vsi_v4l2_msg msg = {0};
+  msg.error = 0;
+  msg.seq_id = NO_RESPONSE_SEQID;
+  msg.size = sizeof(struct v4l2_daemon_dec_resochange_params);
+  msg.cmd_id = V4L2_DAEMON_VIDIOC_CHANGE_RES;
+  msg.inst_id = h->instance_id;
+  msg.params.dec_params.dec_info.io_buffer.inbufidx = INVALID_IOBUFF_IDX;
+  msg.params.dec_params.dec_info.io_buffer.outbufidx = INVALID_IOBUFF_IDX;
+  msg.params.dec_params.dec_info.io_buffer.srcwidth = h->dec_info.frame_width;
+  msg.params.dec_params.dec_info.io_buffer.srcheight = h->dec_info.frame_height;
+  msg.params.dec_params.dec_info.io_buffer.output_width =
+      h->dec_info.frame_width;
+  msg.params.dec_params.dec_info.io_buffer.output_height =
+      h->dec_info.frame_height;
+  msg.params.dec_params.dec_info.io_buffer.OutBufSize =
+      h->dec_info.dpb_buffer_size;
+  msg.params.dec_params.dec_info.io_buffer.output_wstride =
+      h->dec_info.pic_wstride;
+  memcpy(&msg.params.dec_params.dec_info.dec_info, &h->dec_info,
+         sizeof(v4l2_daemon_dec_info));
+  send_notif_to_v4l2(pipe_fd, &msg,
+                     sizeof(struct vsi_v4l2_msg_hdr) +
+                         sizeof(struct v4l2_daemon_dec_resochange_params));
+
+  vsi_dec_set_crop(h);
+  return DEC_EMPTY_EVENT;
+}
+
+v4l2_inst_dec_event vsi_dec_streaming_output(v4l2_dec_inst *h,
+                                             struct vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event dec_event = DEC_EMPTY_EVENT;
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+
+  dec_output_act_proc(h);
+
+  dec_event = vsi_dec_decode(h, v4l2_msg);
+
+  switch (dec_event) {
+    case DEC_SOURCE_CHANGE_EVENT:
+      vsi_dec_handle_reschange(h);
+      break;
+
+    case DEC_WAIT_DECODING_BUFFER_EVENT:
+      h->dec_wait_dbp_buf = 1;
+      break;
+
+    case DEC_GOT_EOS_MARK_EVENT:
+      h->dec_capture_eos = 1;
+      ASSERT(h->dec_drain_tid == -1);
+      if (dec->attributes & DEC_ATTR_EOS_THREAD)
+        h->dec_drain_tid = pthread_create(
+            &h->dec_drain_thread, &h->handler->attr, &vsi_dec_send_eos, h);
+      else
+        vsi_dec_send_eos(h);
+
+      HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: DecEndOfStream
",
+                 h->instance_id);
+      break;
+
+    case DEC_PENDING_FLUSH_EVENT:
+    case DEC_PIC_DECODED_EVENT:
+      break;
+
+    case DEC_FATAL_ERROR_EVENT:
+      break;
+
+    case DEC_DECODING_FAILED_EVENT:
+    case DEC_DECODING_ERROR_EVENT:
+    case DEC_NO_DECODING_BUFFER_EVENT:
+    default:
+      dec_event = DEC_EMPTY_EVENT;
+      break;
+  }
+  return dec_event;
+}
+
+v4l2_inst_dec_event vsi_dec_streaming_capture(v4l2_dec_inst *h,
+                                              struct vsi_v4l2_msg *v4l2_msg) {
+  int ret = 0;
+  v4l2_inst_dec_event dec_event = DEC_EMPTY_EVENT;
+
+  dec_capture_act_proc(h);
+  if (h->dec_capture_act != DAEMON_QUEUE_ACT_NONE) {
+    return dec_event;
+  }
+
+  if (h->dec_cur_state == DAEMON_DEC_STATE_STOPPED) {
+    ASSERT(h->dec_capture_state != DAEMON_QUEUE_STATE_ON);
+    return dec_event;
+  }
+
+  if (h->dec_capture_state != DAEMON_QUEUE_STATE_ON) {
+    if (h->dec_capture_eos) {
+      if (h->existed_dpb_nums == 0) {
+        h->dec_capture_eos = 0;
+        h->dec_fatal_error = DAEMON_ERR_DEC_METADATA_ONLY;
+        dec_event = DEC_FATAL_ERROR_EVENT;
+      }
+    }
+    return dec_event;
+  }
+
+  ret = vsi_dec_dequeue_pic(h);
+  if (h->dec_eos && h->dec_capture_eos) {
+    if (ret == DEQUEUE_ERR_BUF_NOT_AVAIL) {
+      return dec_event;
+    }
+
+    dec_event = DEC_GOT_EOS_MARK_EVENT;
+/*
+    if (h->existed_dpb_nums == 0) {
+      h->dec_fatal_error = DAEMON_ERR_DEC_METADATA_ONLY;
+      dec_event = DEC_FATAL_ERROR_EVENT;
+    }
+*/
+  }
+
+  if (ret) {
+    if (h->dec_output_state == DAEMON_QUEUE_STATE_PAUSE)
+      dec_event = DEC_PENDING_FLUSH_EVENT;
+    if (h->dec_cur_state == DAEMON_DEC_STATE_SOURCE_CHANGE)
+      dec_event = DEC_LAST_PIC_EVENT;
+  }
+
+  if (h->dec_last_pic_sent) {
+    dec_event = DEC_LAST_PIC_EVENT;
+    h->dec_last_pic_sent = 0;
+  }
+  return dec_event;
+}
+
+/**
+ * @brief vsi_dec_fsm_event_handle(), decoder message processor.
+ * @param v4l2_dec_inst* h: decoder instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return int32_t.
+ */
+int32_t vsi_dec_fsm_event_handle(void *codec, struct vsi_v4l2_msg *v4l2_msg) {
+  v4l2_dec_inst *h = (v4l2_dec_inst *)codec;
+  v4l2_inst_dec_event dec_event = DEC_EMPTY_EVENT;
+
+  dec_event = vsi_dec_trans_v4l2cmdid_to_eventid(h, v4l2_msg);
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Inst[%lx]: receive event [%s]
",
+             h->instance_id,
+             dec_event_name[dec_event]);
+  if (DEC_CACHE_IO_BUFFER_EVENT == dec_event) {
+    dec_event = vsi_dec_handle_io_buffer(h, v4l2_msg);
+  }
+
+  while (DEC_EMPTY_EVENT != dec_event) {
+    int status_index = vsi_dec_find_event_index_in_fsm_table(h, dec_event);
+
+    if (INVALIDE_DEC_TABLE_INDEX != status_index) {
+      HANTRO_LOG(
+          HANTRO_LEVEL_DEBUG, "Inst[%lx]: event [%s], state [%s] -> [%s]
",
+          h->instance_id,
+          dec_event_name[dec_event], dec_state_name[h->dec_cur_state],
+          dec_state_name[vsi_v4l2dec_fsm_trans_table[status_index].next_state]);
+
+      if (vsi_v4l2dec_fsm_trans_table[status_index].eventActFun) {
+        int ret =
+            vsi_v4l2dec_fsm_trans_table[status_index].eventActFun(h, v4l2_msg);
+        if (0 == ret) {
+          h->dec_cur_state =
+              vsi_v4l2dec_fsm_trans_table[status_index].next_state;
+        }
+      } else {
+        if (h->dec_fatal_error) {
+          dec_event = DEC_FATAL_ERROR_EVENT;
+          continue;
+        }
+        HANTRO_LOG(HANTRO_LEVEL_WARNING,
+                   "Didn't find event function , shouldn't go here
");
+      }
+    }
+
+    if (h->dec_cur_state == DAEMON_DEC_STATE_DESTROYED) break;
+
+    dec_event = vsi_dec_streaming_capture(h, v4l2_msg);
+    if (dec_event != DEC_EMPTY_EVENT) continue;
+
+    dec_event = vsi_dec_streaming_output(h, v4l2_msg);
+  }
+
+  vsi_dec_msg_done(h, v4l2_msg);
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG,
+             "Inst[%lx]: finish one external event, curr state [%s] 
",
+             h->instance_id,
+             dec_state_name[h->dec_cur_state]);
+  return (h->dec_cur_state == DAEMON_DEC_STATE_DESTROYED);
+}
+
+/**
+ * @brief vsi_destroy_decoder(), destroy decoder inst.
+ * @param void* codec: decoder instance.
+ * @return int32_t: 0: succeed; Others: failure.
+ */
+static int32_t vsi_destroy_decoder(void *codec) {
+  v4l2_dec_inst *h = (v4l2_dec_inst *)codec;
+
+  if (h == NULL) {
+    return -1;
+  }
+
+  if (h->bufferlist_input) {
+    bufferlist_destroy(h->bufferlist_input);
+    free(h->bufferlist_input);
+    h->bufferlist_input = NULL;
+  }
+
+  dpb_destroy(h);
+
+  return 0;
+}
+
+/**
+ * @brief vsi_dec_in_change(), check if decoder is in source change state.
+ * @param void* codec: decoder instance.
+ * @return int32_t: 0: NOT; 1: YES.
+ */
+static int32_t vsi_dec_in_change(void *codec) {
+  v4l2_dec_inst *h = (v4l2_dec_inst *)codec;
+
+  if (h == NULL) {
+    return -1;
+  }
+
+  return (h->dec_cur_state == DAEMON_DEC_STATE_SOURCE_CHANGE);
+}
+
+/**
+ * @brief vsi_create_decoder(), create decoder inst.
+ * @param v4l2_daemon_inst* daemon_inst: decoder instance.
+ * @return void *: decoder instance.
+ */
+void *vsi_create_decoder(v4l2_daemon_inst *daemon_inst) {
+  v4l2_dec_inst *h = NULL;
+
+  ASSERT(daemon_inst->codec_mode == DAEMON_MODE_DECODER);
+
+  h = (v4l2_dec_inst *)malloc(sizeof(v4l2_dec_inst));
+  ASSERT(h);
+  memset(h, 0, sizeof(v4l2_dec_inst));
+
+  h->handler = daemon_inst;
+  h->codec_fmt = daemon_inst->codec_fmt;
+  h->instance_id = daemon_inst->instance_id;
+
+  h->dec_cur_state = DAEMON_DEC_STATE_OPEN;
+  h->curr_inbuf_idx = INVALID_IOBUFF_IDX;
+  h->dec_drain_tid = -1;
+  h->dec_output_fmt = DEC_REF_FRM_RASTER_SCAN;  // DEC_REF_FRM_TILED_DEFAULT;
+  h->dec_pixel_fmt = DEC_OUT_PIXEL_DEFAULT;
+
+  dpb_init(h);
+  h->bufferlist_input = (BUFFERLIST *)malloc(sizeof(BUFFERLIST));
+  ASSERT(h->bufferlist_input != NULL);
+  bufferlist_init(h->bufferlist_input, MAX_BUFFER_SIZE);
+
+  daemon_inst->func.proc = vsi_dec_fsm_event_handle;
+  daemon_inst->func.destroy = vsi_destroy_decoder;
+  daemon_inst->func.in_source_change = vsi_dec_in_change;
+  return (void *)h;
+}
+
+/**
+ * @brief DECODING_EVENT @open, set codec format on OUTPUT.
+ * @param .
+ * @return .
+ */
+int vsi_dec_set_format(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  if (v4l2_msg->codec_fmt == V4L2_DAEMON_CODEC_UNKNOW_TYPE) {
+    return -1;
+  }
+
+  // get coded format from client
+  h->codec_fmt = v4l2_msg->codec_fmt;
+  h->dec_no_reordering =
+      v4l2_msg->params.dec_params.io_buffer.no_reordering_decoding ? 1 : 0;
+  h->srcwidth = v4l2_msg->params.dec_params.io_buffer.srcwidth;
+  h->srcheight = v4l2_msg->params.dec_params.io_buffer.srcheight;
+  vsi_dec_register_fsm_table(h);
+  ASSERT(h->vsi_v4l2m2m_decoder);
+
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+  if (dec->attributes & DEC_ATTR_SUPPORT_SECURE_MODE) {
+    h->secure_mode_on = v4l2_msg->params.dec_params.io_buffer.securemode_on;
+  }
+
+#ifndef DEC_INPUT_NO_COPY
+  if (h->secure_mode_on) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "Inst[%lx]: Not support secure playback in INPUT_COPY mode!
",
+               h->instance_id);
+  }
+#endif
+
+  // create decoder-instance
+  vsi_dec_init(h, v4l2_msg);
+  if (h->decoder_inst == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "Inst[%lx]: Failed to create decoder instance for format %d
",
+               h->instance_id,
+               h->codec_fmt);
+    ASSERT(0);
+    h->codec_fmt = V4L2_DAEMON_CODEC_UNKNOW_TYPE;
+    h->dec_fatal_error = DAEMON_ERR_DEC_FATAL_ERROR;
+    return -1;
+  }
+
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_output_state2 = 0;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_output_act = DAEMON_QUEUE_ACT_NONE;
+  h->dec_capture_act = DAEMON_QUEUE_ACT_NONE;
+  h->stream_in_mem.logical_size = 0;
+
+#ifdef DEC_INPUT_NO_COPY
+  h->dec_cur_input_vaddr = NULL;
+#endif
+
+  h->dec_add_buffer_allowed = 1;
+  capture_tot_size = 0;
+  return 0;
+}
+
+/**
+ * @brief OUTPUT_STREAMON @init, switch state from init to capture-setup.
+ * @param .
+ * @return .
+ */
+int vsi_dec_capture_setup0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_INIT);
+  h->dec_output_state = DAEMON_QUEUE_STATE_ON;
+  return 0;
+}
+
+/**
+ * @brief SOURCE_CHANGE @capture-setup, do nothing
+ *        -- flush (DQBUF) capture queue should be handled by CAPTURE_STREAMOFF.
+ * @param .
+ * @return .
+ */
+int vsi_dec_capture_setup1(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP);
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PEND_OFF) {
+    h->dec_output_state2 = 1;
+  }
+  h->dec_output_state = DAEMON_QUEUE_STATE_PAUSE;
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMOFF @capture-setup, returns all queued capture buffers
+ * @param .
+ * @return .
+ */
+int vsi_dec_capture_setup2(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE ||
+         h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP);
+
+  // All decoded buffers should not be pending in capture queue. So, just flush
+  // it.
+  vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_add_buffer_allowed = 1;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_output_state = DAEMON_QUEUE_STATE_PAUSE;
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMON/V4L2_DECCMD_START @capture-setup, start streaming on
+ * capture queue.
+ * @param .
+ * @return .
+ */
+int vsi_dec_capture_setup3(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE ||
+         h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP);
+
+  h->dec_capture_state = DAEMON_QUEUE_STATE_ON;
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PAUSE) {
+    h->dec_output_state = DAEMON_QUEUE_STATE_ON;
+    if (h->dec_output_state2) h->dec_output_state = DAEMON_QUEUE_STATE_PEND_OFF;
+    h->dec_output_state2 = 0;
+  }
+
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PAUSE) {
+    h->dec_output_state = DAEMON_QUEUE_STATE_ON;
+  }
+
+  h->dec_wait_dbp_buf = 0;
+  return 0;
+}
+
+int vsi_dec_capture_setup4(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP);
+  vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_add_buffer_allowed = 1;
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PEND_OFF) {
+    h->dec_output_state2 = 1;
+  }
+  h->dec_output_state = DAEMON_QUEUE_STATE_PAUSE;
+  return 0;
+}
+
+/**
+ * @brief DEC_PENDING_FLUSH_EVENT @decode, pause OUTPUT queue, CAPTURE streaming
+ * remains.
+ * @param .
+ * @return .
+ */
+int vsi_dec_pause0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE);
+
+  while (0 == vsi_dec_dequeue_pic(h))
+    ;
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_ON &&
+      h->dec_capture_state == DAEMON_QUEUE_STATE_ON) {
+    h->dec_output_state = DAEMON_QUEUE_STATE_PAUSE;
+  } else if (h->dec_output_state == DAEMON_QUEUE_STATE_PAUSE) {
+    // h->dec_capture_act = DAEMON_QUEUE_ACT_CONSUME;
+    h->dec_output_state = DAEMON_QUEUE_STATE_ON;
+    if (h->dec_output_state2) h->dec_output_state = DAEMON_QUEUE_STATE_PEND_OFF;
+    h->dec_output_state2 = 0;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief V4L2_DEC_CMD_STOP @decode, turn off OUTPUT queue and start draining.
+ * @param .
+ * @return .
+ */
+int vsi_dec_drain0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  //    ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE);
+
+  // Not flush all queued buffers on OUTPUT, according to spec4.5.1.10
+  h->dec_output_state = DAEMON_QUEUE_STATE_PEND_OFF;
+  h->dec_output_act = DAEMON_QUEUE_ACT_EOS;
+  return 0;
+}
+
+/**
+ * @brief DEC_GOT_EOS_MARK_EVENT @decode/capture-setup, or
+ * @brief DEC_PENDING_FLUSH_EVENT @drain,
+ * @brief  to take all of decoded pictures.
+ * @param .
+ * @return .
+ */
+int vsi_dec_drain1(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  while (0 == vsi_dec_dequeue_pic(h))
+    ;
+  return 0;
+}
+
+/**
+ * @brief V4L2_DEC_CMD_STOP @capture-setup, turn off OUTPUT queue.
+ * @param .
+ * @return .
+ */
+int vsi_dec_drain2(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP);
+
+  // Not flush all queued buffers on OUTPUT, according to spec4.5.1.10
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PAUSE)
+    h->dec_output_state2 = 1;
+  else
+    h->dec_output_state = DAEMON_QUEUE_STATE_PEND_OFF;
+
+  h->dec_output_act = DAEMON_QUEUE_ACT_EOS;
+  return 0;
+}
+
+/**
+ * @brief DEC_RECEIVE_CAPTUREON_EVENT @drain, capture stream on.
+ * @param .
+ * @return .
+ */
+int vsi_dec_drain3(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DRAIN);
+
+  h->dec_capture_state = DAEMON_QUEUE_STATE_ON;
+  h->dec_wait_dbp_buf = 0;
+  return 0;
+}
+
+
+/**
+ * @brief OUTPUT_STREAMOFF @decode/source_change, flush all the pending OUTPUT
+ * buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_seek0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  vsi_v4l2m2m2_deccodec *dec =
+      (vsi_v4l2m2m2_deccodec *)(h->vsi_v4l2m2m_decoder);
+
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE ||
+         h->dec_cur_state == DAEMON_DEC_STATE_STOPPED ||
+         h->dec_cur_state == DAEMON_DEC_STATE_CAPTURE_SETUP ||
+         h->dec_cur_state == DAEMON_DEC_STATE_END_OF_STREAM ||
+         h->dec_cur_state == DAEMON_DEC_STATE_SOURCE_CHANGE);
+  vsi_dec_flush_input(h, v4l2_msg);
+  while (0 == vsi_dec_drop_pic(h))
+    ;
+
+  if (h->dec_cur_state != DAEMON_DEC_STATE_STOPPED) {
+    dec->seek(h, v4l2_msg);
+  }
+
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  // just throw away the decoded pictures.
+  h->dec_capture_act = DAEMON_QUEUE_ACT_DROP;
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMOFF/V4L2_DEC_CMD_STOP @seek, drop all the decoded (not
+ * dequeued yet) CAPTURE buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_seek1(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_SEEK);
+
+//  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_act = DAEMON_QUEUE_ACT_DROP;
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMON/V4L2_DEC_CMD_START @seek, turn on CAPTURE streaming.
+ * @param .
+ * @return .
+ */
+int vsi_dec_seek2(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  h->dec_capture_eos = 0;
+
+  h->dec_capture_state = DAEMON_QUEUE_STATE_ON;
+  return 0;
+}
+
+/**
+ * @brief OUTPUT_STREAMON @seek, turn on OUTPUT streaming.
+ * @param .
+ * @return .
+ */
+int vsi_dec_seek3(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_SEEK);
+
+  if (h->existed_dpb_nums)
+    h->dec_output_state = DAEMON_QUEUE_STATE_ON;
+  else
+    h->dec_output_state = DAEMON_QUEUE_STATE_PAUSE;
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMOFF @seek, drop all the decoded (not
+ * dequeued yet) CAPTURE buffers and destroy existed dpb buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_seek4(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_SEEK);
+  h->dec_add_buffer_allowed = 1;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_act = DAEMON_QUEUE_ACT_DROP;
+  vsi_dec_flush_output(h, v4l2_msg);
+  return 0;
+}
+
+/**
+ * @brief SOURCE_CHANGE @decode/drain, implicit drain CAPTURE queue.
+ * @param .
+ * @return .
+ */
+int vsi_dec_reschange0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE ||
+         h->dec_cur_state == DAEMON_DEC_STATE_DRAIN);
+  if (h->dec_output_state == DAEMON_QUEUE_STATE_PEND_OFF) {
+    h->dec_output_state2 = 1;
+  }
+  h->dec_output_state = DAEMON_QUEUE_STATE_PAUSE;
+  // h->dec_capture_act = DAEMON_QUEUE_ACT_FLUSH;
+  return 0;
+}
+
+/**
+ * @brief DEC_LAST_PIC EVENT @source_change, do nothing.
+ * @param .
+ * @return .
+ */
+int vsi_dec_reschange1(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_SOURCE_CHANGE);
+
+  // vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_add_buffer_allowed = 0;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  return 0;
+}
+
+/**
+ * @brief DEC_RECEIVE_CAPTUREOFF_EVENT EVENT @source_change, destroy existed dpb buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_reschange2(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_SOURCE_CHANGE);
+  while (0 == vsi_dec_drop_pic(h))
+    ;
+   vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: Reveive CAPTURE_OFF @ source_change
",
+             h->instance_id);
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMOFF @decode/drain, drop all the pending OUTPUT & CAPTURE
+ * buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_stop0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE ||
+         h->dec_cur_state == DAEMON_DEC_STATE_DRAIN);
+  vsi_dec_flush_input(h, v4l2_msg);
+  //    vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  return 0;
+}
+
+/**
+ * @brief OUTPUT_STREAMON @stopped, turn on OUTPUT streaming, start to decode.
+ * @param .
+ * @return .
+ */
+int vsi_dec_stop1(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_STOPPED);
+
+  h->dec_output_state = DAEMON_QUEUE_STATE_ON;
+  return 0;
+}
+
+/**
+ * @brief DESTROY @stopped, destroy instance.
+ * @param .
+ * @return .
+ */
+int vsi_dec_stop2(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_STOPPED);
+
+  vsi_dec_destroy(h, v4l2_msg);
+  return 0;
+}
+
+/**
+ * @brief DESTROY @any non-stopped state, destroy instance.
+ * @param .
+ * @return .
+ */
+int vsi_dec_stop3(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  vsi_dec_flush_input(h, v4l2_msg);
+  vsi_dec_flush_output(h, v4l2_msg);
+
+  vsi_dec_destroy(h, v4l2_msg);
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMOFF @decode/drain, drop all the pending OUTPUT & CAPTURE
+ * buffers, and destroy existed dpb buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_stop4(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE ||
+         h->dec_cur_state == DAEMON_DEC_STATE_DRAIN);
+  vsi_dec_flush_input(h, v4l2_msg);
+  vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  return 0;
+}
+
+/**
+ * @brief CAPTURE_STREAMOFF @stop, destroy existed dpb buffers
+ * buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_stop5(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_STOPPED);
+  ASSERT(h->dec_capture_state == DAEMON_QUEUE_STATE_OFF);
+  vsi_dec_flush_output(h, v4l2_msg);
+  return 0;
+}
+
+/**
+ * @brief DEC_FATAL_ERROR EVENT @open, flush all OUTPUT & CAPTURE buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_fatal_error0(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_OPEN);
+
+  vsi_dec_flush_input(h, v4l2_msg);
+  vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_DEC_FATAL_ERROR);
+  return 0;
+}
+
+/**
+ * @brief DEC_FATAL_ERROR EVENT @decode, flush all OUTPUT & CAPTURE buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_fatal_error1(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  vsi_dec_flush_input(h, v4l2_msg);
+  vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  send_fatalerror_orphan_msg(h->instance_id, h->dec_fatal_error ?
+                             h->dec_fatal_error : DAEMON_ERR_DEC_FATAL_ERROR);
+  return 0;
+}
+
+/**
+ * @brief DEC_FATAL_ERROR EVENT @init/drain, flush all OUTPUT & CAPTURE buffers.
+ * @param .
+ * @return .
+ */
+int vsi_dec_fatal_error2(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  ASSERT(h->dec_cur_state == DAEMON_DEC_STATE_DECODE);
+
+#if 1
+  vsi_dec_stop0(h, v4l2_msg);
+  send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_DEC_FATAL_ERROR);
+  return 0;
+#else
+  vsi_dec_flush_input(h, v4l2_msg);
+  vsi_dec_flush_output(h, v4l2_msg);
+  h->dec_output_state = DAEMON_QUEUE_STATE_OFF;
+  h->dec_capture_state = DAEMON_QUEUE_STATE_OFF;
+  return 0;
+#endif
+}
+
+/**
+ * @brief do nothing.
+ * @param .
+ * @return .
+ */
+int vsi_dec_trans_state(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) { return 0; }
+
+v4l2_decoder_fsm_element vsi_v4l2dec_fsm_trans_table[] = {
+    /*OPEN*/
+    {DEC_BUFFER_EVENT,              DAEMON_DEC_STATE_OPEN,              vsi_dec_set_format,         DAEMON_DEC_STATE_INIT},
+    {DEC_FATAL_ERROR_EVENT,         DAEMON_DEC_STATE_OPEN,              vsi_dec_fatal_error0,       DAEMON_DEC_STATE_STOPPED},
+
+    /*INIT*/
+    {DEC_RECEIVE_OUTPUTON_EVENT,    DAEMON_DEC_STATE_INIT,              vsi_dec_capture_setup0,     DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_BUFFER_EVENT,              DAEMON_DEC_STATE_INIT,              vsi_dec_capture_setup0,     DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_INIT,              vsi_dec_stop3,              DAEMON_DEC_STATE_DESTROYED},
+    {DEC_FATAL_ERROR_EVENT,         DAEMON_DEC_STATE_INIT,              vsi_dec_fatal_error1,       DAEMON_DEC_STATE_STOPPED},
+
+    /*CAPTURE-SETUP*/
+    {DEC_SOURCE_CHANGE_EVENT,       DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_capture_setup1,     DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_OUTPUTOFF_EVENT,   DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_seek0,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_CAPTUREOFF_EVENT,  DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_capture_setup4,     DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_CMDSTART_EVENT,    DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_capture_setup3,     DAEMON_DEC_STATE_DECODE},
+    {DEC_RECEIVE_CMDSTOP_EVENT,     DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_drain2,             DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_CAPTUREON_EVENT,   DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_capture_setup3,     DAEMON_DEC_STATE_DECODE},
+    {DEC_GOT_EOS_MARK_EVENT,        DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_drain1,             DAEMON_DEC_STATE_DRAIN},
+    {DEC_LAST_PIC_EVENT,            DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_stop0,              DAEMON_DEC_STATE_STOPPED},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_stop3,              DAEMON_DEC_STATE_DESTROYED},
+    {DEC_FATAL_ERROR_EVENT,         DAEMON_DEC_STATE_CAPTURE_SETUP,     vsi_dec_fatal_error1,       DAEMON_DEC_STATE_STOPPED},
+
+    /*DECODING*/
+    {DEC_BUFFER_EVENT,              DAEMON_DEC_STATE_DECODE,            vsi_dec_trans_state,        DAEMON_DEC_STATE_DECODE},
+    {DEC_PENDING_FLUSH_EVENT,       DAEMON_DEC_STATE_DECODE,            vsi_dec_pause0,             DAEMON_DEC_STATE_DECODE},
+    {DEC_SOURCE_CHANGE_EVENT,       DAEMON_DEC_STATE_DECODE,            vsi_dec_reschange0,         DAEMON_DEC_STATE_SOURCE_CHANGE},
+    {DEC_RECEIVE_OUTPUTOFF_EVENT,   DAEMON_DEC_STATE_DECODE,            vsi_dec_seek0,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_CAPTUREOFF_EVENT,  DAEMON_DEC_STATE_DECODE,            vsi_dec_capture_setup2,     DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_CAPTUREON_EVENT,   DAEMON_DEC_STATE_DECODE,            vsi_dec_capture_setup3,     DAEMON_DEC_STATE_DECODE},
+    {DEC_RECEIVE_CMDSTOP_EVENT,     DAEMON_DEC_STATE_DECODE,            vsi_dec_drain0,             DAEMON_DEC_STATE_DRAIN},
+    {DEC_GOT_EOS_MARK_EVENT,        DAEMON_DEC_STATE_DECODE,            vsi_dec_drain1,             DAEMON_DEC_STATE_DRAIN},
+    {DEC_FATAL_ERROR_EVENT,         DAEMON_DEC_STATE_DECODE,            vsi_dec_fatal_error2,       DAEMON_DEC_STATE_STOPPED},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_DECODE,            vsi_dec_stop3,              DAEMON_DEC_STATE_DESTROYED},
+
+    /*SEEK*/
+    {DEC_RECEIVE_CAPTUREOFF_EVENT,  DAEMON_DEC_STATE_SEEK,              vsi_dec_seek4,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_CAPTUREON_EVENT,   DAEMON_DEC_STATE_SEEK,              vsi_dec_seek2,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_CMDSTOP_EVENT,     DAEMON_DEC_STATE_SEEK,              vsi_dec_seek1,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_CMDSTART_EVENT,    DAEMON_DEC_STATE_SEEK,              vsi_dec_seek2,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_OUTPUTON_EVENT,    DAEMON_DEC_STATE_SEEK,              vsi_dec_seek3,              DAEMON_DEC_STATE_DECODE},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_SEEK,              vsi_dec_stop3,              DAEMON_DEC_STATE_DESTROYED},
+    {DEC_FATAL_ERROR_EVENT,         DAEMON_DEC_STATE_SEEK,              vsi_dec_fatal_error1,       DAEMON_DEC_STATE_STOPPED},
+
+    /*SOURCE(RESOLUTION) CHANGE*/
+    {DEC_LAST_PIC_EVENT,            DAEMON_DEC_STATE_SOURCE_CHANGE,     vsi_dec_reschange1,         DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_OUTPUTOFF_EVENT,   DAEMON_DEC_STATE_SOURCE_CHANGE,     vsi_dec_seek0,              DAEMON_DEC_STATE_SEEK},
+    {DEC_RECEIVE_CAPTUREON_EVENT,   DAEMON_DEC_STATE_SOURCE_CHANGE,     vsi_dec_trans_state,        DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_CAPTUREOFF_EVENT,  DAEMON_DEC_STATE_SOURCE_CHANGE,     vsi_dec_reschange2,         DAEMON_DEC_STATE_CAPTURE_SETUP},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_SOURCE_CHANGE,     vsi_dec_stop3,              DAEMON_DEC_STATE_DESTROYED},
+
+    /*END OF STREAM*/
+    {DEC_BUFFER_EVENT,              DAEMON_DEC_STATE_END_OF_STREAM,     vsi_dec_trans_state,        DAEMON_DEC_STATE_DRAIN},
+    {DEC_RECEIVE_OUTPUTOFF_EVENT,   DAEMON_DEC_STATE_END_OF_STREAM,     vsi_dec_seek0,              DAEMON_DEC_STATE_SEEK},
+
+    /*DRAIN*/
+    {DEC_BUFFER_EVENT,              DAEMON_DEC_STATE_DRAIN,             vsi_dec_trans_state,        DAEMON_DEC_STATE_DRAIN},
+    {DEC_PENDING_FLUSH_EVENT,       DAEMON_DEC_STATE_DRAIN,             vsi_dec_drain1,             DAEMON_DEC_STATE_DRAIN},
+    {DEC_SOURCE_CHANGE_EVENT,       DAEMON_DEC_STATE_DRAIN,             vsi_dec_reschange0,         DAEMON_DEC_STATE_SOURCE_CHANGE},
+    {DEC_LAST_PIC_EVENT,            DAEMON_DEC_STATE_DRAIN,             vsi_dec_stop0,              DAEMON_DEC_STATE_STOPPED},
+    {DEC_RECEIVE_CAPTUREON_EVENT,   DAEMON_DEC_STATE_DRAIN,             vsi_dec_drain3,             DAEMON_DEC_STATE_DRAIN},
+    {DEC_RECEIVE_OUTPUTOFF_EVENT,   DAEMON_DEC_STATE_DRAIN,             vsi_dec_stop0,              DAEMON_DEC_STATE_STOPPED},
+    {DEC_RECEIVE_CAPTUREOFF_EVENT,  DAEMON_DEC_STATE_DRAIN,             vsi_dec_stop4,              DAEMON_DEC_STATE_STOPPED},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_DRAIN,             vsi_dec_stop3,              DAEMON_DEC_STATE_DESTROYED},
+    {DEC_FATAL_ERROR_EVENT,         DAEMON_DEC_STATE_DRAIN,             vsi_dec_fatal_error1,       DAEMON_DEC_STATE_STOPPED},
+
+    /*STOPPPED*/
+    {DEC_RECEIVE_OUTPUTOFF_EVENT,   DAEMON_DEC_STATE_STOPPED,           vsi_dec_seek0,              DAEMON_DEC_STATE_SEEK}, 
+    {DEC_RECEIVE_OUTPUTON_EVENT,    DAEMON_DEC_STATE_STOPPED,           vsi_dec_stop1,              DAEMON_DEC_STATE_DECODE},
+    {DEC_RECEIVE_CAPTUREOFF_EVENT,  DAEMON_DEC_STATE_STOPPED,           vsi_dec_stop5,              DAEMON_DEC_STATE_STOPPED},
+    {DEC_RECEIVE_CAPTUREON_EVENT,   DAEMON_DEC_STATE_STOPPED,           vsi_dec_seek2,              DAEMON_DEC_STATE_DECODE},
+    {DEC_RECEIVE_DESTROY_EVENT,     DAEMON_DEC_STATE_STOPPED,           vsi_dec_stop2,              DAEMON_DEC_STATE_DESTROYED},
+
+};
+int vsi_fsm_trans_table_count = sizeof(vsi_v4l2dec_fsm_trans_table) /
+                                sizeof((vsi_v4l2dec_fsm_trans_table)[0]);
diff --git a/v4l2_vsi_daemon/src/vsi_dec.h b/v4l2_vsi_daemon/src/vsi_dec.h
new file mode 100755
index 0000000..d83635c
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec.h
@@ -0,0 +1,363 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef VSI_DEC_DEC_H
+#define VSI_DEC_DEC_H
+
+#include "buffer_list.h"
+#include "daemon_instance.h"
+#include "dwl.h"
+#include "vsi_daemon_debug.h"
+
+/****************************************************************************
+ *
+ * Macros definitions
+ *
+ ***************************************************************************/
+#define NXP_TIMESTAMP_MANAGER
+
+#define MAX_DEC_BUFFERS 32
+#define TIMESTAMP_SLOT_NUM 256
+
+#define VSI_DEC_GOT_OUTPUT_DATA 0
+#define VSI_DEC_EMPTY_OUTPUT_DATA 1
+
+/* Decoder engine attributes*/
+#define DEC_ATTR_NONE 0x00000000
+#define DEC_ATTR_EOS_THREAD 0x00000001
+#define DEC_ATTR_SUPPORT_SECURE_MODE 0x00000002
+
+#ifndef DEC_COPY_INPUT
+#define DEC_INPUT_NO_COPY
+#else
+#define STREAM_INBUFF_SIZE (4 * 1024 * 1024)
+#endif
+
+#define EXTRA_DPB_BUFFER_NUM (1)
+
+/* error values definition returned by dequeue_pic/dequeue_empty_pic */
+#define DEQUEUE_ERR_PIC_NOT_AVAIL (-1)
+#define DEQUEUE_ERR_BUF_NOT_AVAIL (-2)
+#define NEXT_MULTIPLE(value, n) (((value) + (n)-1) & ~((n)-1))
+
+/****************************************************************************
+ *
+ * enum definitions
+ *
+ ***************************************************************************/
+typedef enum {
+  DAEMON_DEC_STATE_OPEN,
+  DAEMON_DEC_STATE_INIT,
+  DAEMON_DEC_STATE_CAPTURE_SETUP,
+  DAEMON_DEC_STATE_DECODE,
+  DAEMON_DEC_STATE_SOURCE_CHANGE,
+  DAEMON_DEC_STATE_SEEK,
+  DAEMON_DEC_STATE_END_OF_STREAM,
+  DAEMON_DEC_STATE_DRAIN,
+  DAEMON_DEC_STATE_STOPPED,
+  DAEMON_DEC_STATE_DESTROYED,
+
+  DAEMON_DEC_STATE_TOTAL
+} v4l2_inst_dec_state;
+
+typedef enum {
+  DAEMON_QUEUE_ACT_NONE,
+  DAEMON_QUEUE_ACT_FLUSH,  // For capture queue only, to return all queued
+                           // buffers to client (dqbuf).
+  DAEMON_QUEUE_ACT_DROP,  // For capture queue, drop decoded buffers (not
+                          // dqbuf).
+  DAEMON_QUEUE_ACT_EOS,  // For output queue only, to indicate the last queued
+                         // buffer is last (end-of-stream) OUTPUT buffer.
+  DAEMON_QUEUE_ACT_CONSUME,  // For capture queue only, to return all dpb buffer
+                             // to control-software.
+} v4l2_queue_action;
+
+typedef enum {
+  DAEMON_QUEUE_STATE_OFF,
+  DAEMON_QUEUE_STATE_ON,
+  DAEMON_QUEUE_STATE_PEND_OFF,  // Process all queued buffers, then set state to
+                                // off.
+  DAEMON_QUEUE_STATE_PAUSE,  // For output queue only, to pause output queue
+                             // streaming.
+} v4l2_queue_state;
+
+typedef enum {
+  DEC_EMPTY_EVENT,
+  // external driectly motivate
+  DEC_RECEIVE_CAPTUREON_EVENT,
+  DEC_RECEIVE_CAPTUREOFF_EVENT,
+  DEC_RECEIVE_OUTPUTON_EVENT,
+  DEC_RECEIVE_OUTPUTOFF_EVENT,
+  DEC_RECEIVE_CMDSTOP_EVENT,
+  DEC_RECEIVE_CMDSTART_EVENT,
+  DEC_RECEIVE_DESTROY_EVENT,
+
+  // indrirectly motivate
+  DEC_BUFFER_EVENT,
+  DEC_LAST_PIC_EVENT,
+  DEC_CACHE_IO_BUFFER_EVENT,  // 9
+  DEC_FAKE_EVENT,
+  // internal motivate
+  DEC_SOURCE_CHANGE_EVENT,
+  DEC_PIC_DECODED_EVENT,
+  DEC_DECODING_FAILED_EVENT,
+  DEC_GOT_EOS_MARK_EVENT,
+  DEC_NO_DECODING_BUFFER_EVENT,    // buffer is not consumed
+  DEC_WAIT_DECODING_BUFFER_EVENT,  // no decoding buffer set to decoder yet
+  DEC_PENDING_FLUSH_EVENT,  // decoder requires to flush all decoded frames.
+
+  // abnormal event
+  DEC_DECODING_ERROR_EVENT,
+  DEC_FATAL_ERROR_EVENT,
+  DEC_DECODING_TOTAL_EVENT,
+} v4l2_inst_dec_event;
+
+enum v4l2_daemon_dpb_status {
+  DPB_STATUS_INVALID,
+  DPB_STATUS_EMPTY,
+  DPB_STATUS_DECODE,
+  DPB_STATUS_RENDER,
+  DPB_STATUS_PSEUDO_DECODE,
+  DPB_STATUS_PSEUDO_RENDER
+};
+
+/****************************************************************************
+ *
+ * data struct definitions
+ *
+ ***************************************************************************/
+typedef struct _v4l2_dec_inst v4l2_dec_inst;
+typedef struct {
+  v4l2_inst_dec_event dec_event;
+  v4l2_inst_dec_state cur_state;
+  int (*eventActFun)(v4l2_dec_inst *, vsi_v4l2_msg *);
+  v4l2_inst_dec_state next_state;
+} v4l2_decoder_fsm_element;
+
+struct v4l2_decoder_dbp {
+  int32_t buff_idx;
+  enum v4l2_daemon_dpb_status status;
+  struct DWLLinearMem buff;
+  void *pic_ctx;  // dec_picture;
+};
+
+struct _v4l2_dec_inst {
+  v4l2_daemon_codec_fmt codec_fmt;
+  unsigned long instance_id;
+
+  /*handlers*/
+  v4l2_daemon_inst *handler;
+  void *vsi_v4l2m2m_decoder;
+  void *decoder_inst;
+  const void *dwl_inst;
+
+  /*configurations*/
+  uint32_t dec_no_reordering;
+  uint32_t secure_mode_on;
+  enum DecDpbFlags dec_output_fmt;
+  enum DecPicturePixelFormat dec_pixel_fmt;
+  int32_t srcwidth;     // encode width
+  int32_t srcheight;    // encode height
+
+  /*states*/
+  v4l2_inst_dec_state dec_cur_state;
+  // queues state, mainly set by state proc.
+  // [dec_output_state,dec_capture_state]:
+  //     [off,x ] DEP can not decode, but can get decoded pictures.
+  //     [on,off] DEP can only decode header.
+  //     [on,1off DEP can decode normally.
+  v4l2_queue_state dec_output_state;
+  v4l2_queue_state dec_capture_state;
+  int dec_output_state2;
+
+  v4l2_queue_action dec_output_act;
+  v4l2_queue_action dec_capture_act;
+
+  /*counters*/
+  uint32_t dec_pic_id;
+  uint32_t dec_out_pic_id;
+  uint32_t input_frame_cnt;
+  uint32_t output_frame_cnt;
+
+  /*dpb buffers*/
+  uint32_t existed_dpb_nums;
+  uint32_t dpb_buffer_added;
+  struct v4l2_decoder_dbp dpb_buffers[MAX_DEC_BUFFERS];
+  uint32_t dec_add_buffer_allowed;
+  uint32_t dec_wait_dbp_buf;
+
+  /*input managements*/
+  BUFFERLIST *bufferlist_input;
+  uint32_t dec_in_pic_id;
+  int32_t curr_inbuf_idx;
+  uint32_t *dec_cur_input_vaddr;
+  struct DWLLinearMem stream_in_mem;
+  uint32_t dec_in_new_packet;
+
+  /*stream/pic info*/
+  v4l2_daemon_dec_info dec_info;
+  v4l2_daemon_pic_info pic_info;
+  uint32_t dec_interlaced_sequence;
+
+  /*draining managements*/
+  pthread_t dec_drain_thread;
+  int dec_drain_tid;
+  uint32_t dec_output_last_inbuf_idx;
+  uint32_t dec_eos;
+  uint32_t dec_capture_eos;
+  uint32_t dec_last_pic_got;
+  uint32_t dec_last_pic_sent;
+
+  /*time-stamp managements*/
+  void *tsm;
+  uint32_t need_resync_tsm;
+  uint32_t consumed_len;
+  uint32_t dec_inpkt_pic_decoded_cnt;
+#ifndef NXP_TIMESTAMP_MANAGER
+  uint64_t dec_timestamp_values[TIMESTAMP_SLOT_NUM];
+#endif
+
+  /*status flags*/
+  int32_t dec_fatal_error;
+  uint32_t dec_aborted;
+
+  /*privates related to different formats*/
+  void *priv_data;
+  void *priv_pic_data;
+  uint32_t dec_inpkt_ignore_picconsumed_event;
+
+  /*obsoleted*/
+  void *dec_dll_handle;
+};
+
+typedef struct {
+  uint32_t pic_width;   /* pixels width of the picture as stored in memory */
+  uint32_t pic_height;  /* pixel height of the picture as stored in memory */
+  uint32_t pic_corrupt; /* Indicates that picture is corrupted */
+  uint32_t bit_depth;   /* bit depth per pixel stored in memory */
+  uint32_t pic_stride;  /* Byte width of the picture as stored in memory */
+
+  uint32_t pic_id; /* Picture id specified by corresponding dec_input*/
+
+  vpu_addr_t output_picture_bus_address; /* DMA bus address of the output
+                                            picture buffer */
+  vpu_addr_t
+      output_picture_chroma_bus_address; /* DMA bus address of the output
+                                            picture buffer */
+  vpu_addr_t output_rfc_luma_bus_address; /* Bus address of the luminance table */
+  vpu_addr_t output_rfc_chroma_bus_address; /* Bus address of the chrominance table */
+
+  uint32_t sar_width;  /* sample aspect ratio */
+  uint32_t sar_height; /* sample aspect ratio */
+
+  /* video signal info for HDR */
+  uint32_t video_range; /* black level and range of luma chroma signals, If 0,
+                           not present */
+  uint32_t
+      colour_description_present_flag; /* indicate
+                                          colour_primaries/transfer_characteristics/matrix_coeffs
+                                          present or not */
+  uint32_t colour_primaries; /* indicates the chromaticity coordinates of the
+                                source primaries */
+  uint32_t transfer_characteristics; /* indicate the reference opto-electronic
+                                        transfer characteristic function */
+  uint32_t
+      matrix_coefficients; /* the matrix coefficients used in deriving luma and
+                              chroma signals */
+  uint32_t chroma_loc_info_present_flag;     /* indicate
+                                                chroma_sample_loc_type_top_field or
+                                                bottom field are present or not */
+  uint32_t chroma_sample_loc_type_top_field; /* specify the location of chroma
+                                                samples */
+  uint32_t chroma_sample_loc_type_bottom_field; /* specify the location of
+                                                   chroma samples */
+
+  /* HDR10 metadata */
+  uint32_t present_flag;
+  uint32_t red_primary_x;
+  uint32_t red_primary_y;
+  uint32_t green_primary_x;
+  uint32_t green_primary_y;
+  uint32_t blue_primary_x;
+  uint32_t blue_primary_y;
+  uint32_t white_point_x;
+  uint32_t white_point_y;
+  uint32_t max_mastering_luminance;
+  uint32_t min_mastering_luminance;
+  uint32_t max_content_light_level;        // MaxCLL
+  uint32_t max_frame_average_light_level;  // MaxFALL
+
+  void *priv_pic_data;
+  uint32_t chroma_size;
+
+  uint32_t crop_left;
+  uint32_t crop_top;
+  uint32_t crop_width;
+  uint32_t crop_height;
+} vsi_v4l2_dec_picture;
+
+typedef struct vsi_v4l2m2m2_deccodec {
+  const char *name;
+  v4l2_daemon_codec_fmt codec_id;
+  uint32_t capabilities;
+  uint32_t attributes;
+  const char *wrapper_name;
+  uint32_t pic_ctx_size;
+  v4l2_inst_dec_event (*decode)(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg);
+  v4l2_inst_dec_event (*init)(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg);
+  v4l2_inst_dec_event (*destroy)(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg);
+  int (*drain)(v4l2_dec_inst *h);
+  v4l2_inst_dec_event (*seek)(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg);
+  int (*get_pic)(v4l2_dec_inst *h, vsi_v4l2_dec_picture *dec_pic_info,
+                 uint32_t eos);
+  int (*release_pic)(v4l2_dec_inst *h, void *pic);
+  int (*add_buffer)(v4l2_dec_inst *h, struct DWLLinearMem *mem_obj);
+  int (*remove_buffer)(v4l2_dec_inst *h);
+} vsi_v4l2m2m2_deccodec;
+
+#define VSIM2MDEC(NAME, CODEC, PIC_CTX_SIZE, ATTR)             \
+  vsi_v4l2m2m2_deccodec vsidaemon_##NAME##_v4l2m2m_decoder = { \
+      .name = #NAME "_v4l2m2m",                                \
+      .codec_id = CODEC,                                       \
+      .pic_ctx_size = PIC_CTX_SIZE,                            \
+      .init = NAME##_dec_init,                                 \
+      .decode = NAME##_dec_decode,                             \
+      .destroy = NAME##_dec_destroy,                           \
+      .drain = NAME##_dec_drain,                               \
+      .seek = NAME##_dec_seek,                                 \
+      .get_pic = NAME##_dec_get_pic,                           \
+      .release_pic = NAME##_dec_release_pic,                   \
+      .add_buffer = NAME##_dec_add_buffer,                     \
+      .remove_buffer = NAME##_dec_remove_buffer,               \
+      .capabilities = 1,                                       \
+      .wrapper_name = "vsiv4l2daemon",                         \
+      .attributes = ATTR,                                      \
+  }
+
+extern v4l2_decoder_fsm_element vsi_v4l2dec_fsm_trans_table[];
+extern int vsi_fsm_trans_table_count;
+
+#endif  // VSI_DEC_DEC_H
diff --git a/v4l2_vsi_daemon/src/vsi_dec_avs.c b/v4l2_vsi_daemon/src/vsi_dec_avs.c
new file mode 100755
index 0000000..bfba6ef
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_avs.c
@@ -0,0 +1,486 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_avs.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include <dlfcn.h>
+
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+#include "avsdecapi.h"
+
+#ifdef VSI_CMODEL
+#include "tb_cfg.h"
+#endif
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+/**
+ * @brief avs_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int avs_dec_release_pic(v4l2_dec_inst* h, void* pic) {
+  AvsDecRet ret;
+  ASSERT(pic);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "AvsDecPictureConsumed  bus address: %lx
",
+             ((AvsDecPicture*)pic)->output_picture_bus_address);
+  ret = AvsDecPictureConsumed(h->decoder_inst, (AvsDecPicture*)pic);
+  ASSERT(ret == AVSDEC_OK);
+  return (ret == AVSDEC_OK) ? 0 : -1;
+}
+static int avs_dec_remove_buffer(v4l2_dec_inst* h) {
+  AvsDecRet rv = AVSDEC_OK;
+  rv = AvsDecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+/**
+ * @brief avs_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int avs_dec_add_buffer(v4l2_dec_inst* h, struct DWLLinearMem* mem_obj) {
+  AvsDecRet rv = AVSDEC_OK;
+  if (mem_obj) {
+    rv = AvsDecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "AvsDecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == AVSDEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == AVSDEC_OK || rv == AVSDEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief avs_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void avs_dec_add_external_buffer(v4l2_dec_inst* h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief avs_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param uint32_t eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int avs_dec_get_pic(v4l2_dec_inst* h, vsi_v4l2_dec_picture* dec_pic_info,
+                           uint32_t eos) {
+  AvsDecPicture* dec_picture = (AvsDecPicture*)h->priv_pic_data;
+  AvsDecRet re = AVSDEC_OK;
+  do {
+    re = AvsDecNextPicture(h->decoder_inst, dec_picture, eos);
+  } while (eos && (re != AVSDEC_END_OF_STREAM) && (re != AVSDEC_PIC_RDY) &&
+           (re != AVSDEC_OK));
+  if (AVSDEC_PIC_RDY != re) return -1;
+  if (h->dec_interlaced_sequence && dec_picture->first_field) {
+    re = AvsDecNextPicture(h->decoder_inst, dec_picture, eos);
+    if (re != AVSDEC_PIC_RDY) return -1;
+  }
+
+  AvsDecInfo dec_info = {0};
+  AvsDecGetInfo(h->decoder_inst, &dec_info);
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  dec_pic_info->pic_stride = dec_picture->frame_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_picture_bus_address +
+      dec_pic_info->pic_stride * dec_pic_info->pic_width;
+
+  dec_pic_info->sar_width = 0;
+  dec_pic_info->sar_height = 0;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief avs_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param AvsDecInfo* dec_info: new seq. header info.
+ * @param AvsDecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static uint32_t avs_dec_check_res_change(v4l2_dec_inst* h, AvsDecInfo* dec_info,
+                                         AvsDecBufferInfo* buf_info) {
+  uint32_t res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if (dec_info->frame_width != h->dec_info.frame_width ||
+      dec_info->frame_height != h->dec_info.frame_height ||
+      dec_info->coded_width != h->dec_info.visible_rect.width ||
+      dec_info->coded_height != h->dec_info.visible_rect.height ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->frame_width, dec_info->frame_height);
+    h->dec_info.frame_width = dec_info->frame_width;
+    h->dec_info.frame_height = dec_info->frame_height;
+    h->dec_info.visible_rect.width = dec_info->coded_width;
+    h->dec_info.visible_rect.height = dec_info->coded_height;
+
+    h->dec_info.visible_rect.left = 0;
+    h->dec_info.visible_rect.top = 0;
+
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_interlaced_sequence = dec_info->interlaced_sequence;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+
+/**
+ * @brief avs_update_input(), update in_mem & dec_input according to dec_output
+ * info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param AvsDecInput *dec_input.
+ * @param AvsDecOutput *dec_output.
+ * @return .
+ */
+static void avs_update_input(struct DWLLinearMem* in_mem,
+                             AvsDecInput* dec_input, AvsDecOutput* dec_output) {
+  dec_input->data_len = dec_output->data_left;
+  dec_input->stream = dec_output->strm_curr_pos;
+  dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  in_mem->logical_size = dec_input->data_len;
+  in_mem->bus_address = dec_input->stream_bus_address;
+  in_mem->virtual_address = (u32*)dec_input->stream;
+}
+
+/**
+ * @brief avs_dec_init(), avs decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event avs_dec_init(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  AvsDecApiVersion dec_api;
+  AvsDecBuild dec_build;
+  AvsDecRet re;
+  struct DecDownscaleCfg dscale_cfg;
+  enum DecDpbFlags flags = 0;
+  u32 ds_ratio_x = 0, ds_ratio_y = 0;
+  /* Print API version number */
+  dec_api = AvsDecGetAPIVersion();
+  dec_build = AvsDecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 Avs Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_AVS_DEC;
+
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT) {
+    flags |= DEC_REF_FRM_TILED_DEFAULT;
+    flags |= DEC_DPB_ALLOW_FIELD_ORDERING;
+  }
+
+  dscale_cfg.down_scale_x = ds_ratio_x;
+  dscale_cfg.down_scale_y = ds_ratio_y;
+
+  re = AvsDecInit((AvsDecInst*)(&h->decoder_inst), h->dwl_inst, DEC_EC_NONE, 0,
+                  flags, 0, 0, &dscale_cfg);
+  if (re != AVSDEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "AvsDecInit failed
");
+    goto end;
+  }
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief avs_dec_decode(), avs decoding function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event avs_dec_decode(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+  u32 skip_non_reference = 0;
+
+  AvsDecInput dec_input = {0};
+  AvsDecOutput dec_output = {0};
+  AvsDecInfo dec_info;
+  AvsDecBufferInfo hbuf = {0};
+
+  struct DWLLinearMem* in_mem = &h->stream_in_mem;
+
+  AvsDecInst dec_inst = h->decoder_inst;
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.stream = (u8*)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream, dec_input.stream_bus_address,
+             dec_input.data_len);
+
+  do {
+    ret = AvsDecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "AvsDecDecode ret %d decoded pic %d, out_pid %d
", ret,
+               h->dec_pic_id, h->dec_out_pic_id);
+    switch (ret) {
+      case AVSDEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case AVSDEC_HDRS_RDY:
+        AvsDecGetBufferInfo(dec_inst, &hbuf);
+        if (AvsDecGetInfo(dec_inst, &dec_info) != AVSDEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        break;
+
+      case AVSDEC_PIC_DECODED:
+        if (AvsDecGetInfo(dec_inst, &dec_info) != AVSDEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case AVSDEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+      case AVSDEC_STRM_PROCESSED:
+      case AVSDEC_NONREF_PIC_SKIPPED:
+        break;
+
+      case AVSDEC_BUF_EMPTY:
+      case AVSDEC_STRM_ERROR:
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        break;
+
+      case AVSDEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Waiting for frame buffers
");
+
+        // h->dec_add_buffer_allowed = 1;
+        AvsDecGetBufferInfo(dec_inst, &hbuf);
+        if (AvsDecGetInfo(dec_inst, &dec_info) != AVSDEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto error;
+        }
+
+        if (avs_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          h->consumed_len += dec_input.data_len - dec_output.data_left;
+          goto update_input;
+        }
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          avs_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+        break;
+
+      case AVSDEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case AVSDEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          avs_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto update_input;
+        }
+
+      case AVSDEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+    /* break out of do-while if max_num_pics reached (data_len set to 0) */
+    if (dec_input.data_len == 0) break;
+
+    avs_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.data_len > 0);
+
+  in_mem->logical_size = 0;
+
+  if ((ret != AVSDEC_OK) && (ret != AVSDEC_STRM_PROCESSED) &&
+      (ret != AVSDEC_NONREF_PIC_SKIPPED) && (ret != AVSDEC_PIC_DECODED)) {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  }
+error:
+  if (dec_output.data_left == dec_input.data_len) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  avs_update_input(in_mem, &dec_input, &dec_output);
+
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief avs_dec_destroy(), avs decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event avs_dec_destroy(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  AvsDecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish 
");
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief avs_dec_drain(), avs draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return int: value of AvsDecEndOfStream return.
+ */
+int avs_dec_drain(v4l2_dec_inst* h) {
+  AvsDecRet ret = AVSDEC_OK;
+  ret = AvsDecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == AVSDEC_OK);
+  return ret;
+}
+
+/**
+ * @brief avs_dec_seek(), avs seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event avs_dec_seek(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  AvsDecRet ret = AVSDEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = AvsDecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "AvsDecAbort returns %d
", ret);
+  ret = AvsDecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(avs, V4L2_DAEMON_CODEC_DEC_AVS2, sizeof(AvsDecPicture),
+          DEC_ATTR_NONE);  // vsidaemon_avs_v4l2m2m_decoder
diff --git a/v4l2_vsi_daemon/src/vsi_dec_h264.c b/v4l2_vsi_daemon/src/vsi_dec_h264.c
new file mode 100755
index 0000000..a16636d
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_h264.c
@@ -0,0 +1,613 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_h264.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include <dlfcn.h>
+
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+#include "h264decapi.h"
+
+#ifdef VSI_CMODEL
+#include "tb_cfg.h"
+//#include "h264hwd_container.h"
+#include "deccfg.h"
+#endif
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+static u32 ds_ratio_x, ds_ratio_y;
+static u32 dpb_mode = DEC_DPB_FRAME;
+
+v4l2_inst_dec_event h264_dec_seek(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg);
+
+/**
+ * @brief h264_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int h264_dec_release_pic(v4l2_dec_inst* h, void* pic) {
+  H264DecRet ret;
+  ASSERT(pic);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "H264DecPictureConsumed  bus address: %lx
",
+             ((H264DecPicture*)pic)->output_picture_bus_address);
+  ret = H264DecPictureConsumed(h->decoder_inst, (H264DecPicture*)pic);
+
+  ASSERT(ret == H264DEC_OK);
+  return (ret == H264DEC_OK) ? 0 : -1;
+}
+
+static int h264_dec_remove_buffer(v4l2_dec_inst* h) {
+  H264DecRet rv = H264DEC_OK;
+  rv = H264DecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+/**
+ * @brief h264_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int h264_dec_add_buffer(v4l2_dec_inst* h, struct DWLLinearMem* mem_obj) {
+  H264DecRet rv = H264DEC_OK;
+  if (mem_obj) {
+    rv = H264DecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "H264DecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == H264DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == H264DEC_OK || rv == H264DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief h264_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void h264_dec_add_external_buffer(v4l2_dec_inst* h) {
+#if 1
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+#else
+  H264DecRet rv = H264DEC_OK;
+  struct DWLLinearMem* mem;
+  for (int i = 0; i < h->existed_dpb_nums; i++) {
+    mem = dpb_get_buffer(h, i);
+    if (mem) {
+      rv = H264DecAddBuffer(h->decoder_inst, mem);
+      HANTRO_LOG(HANTRO_LEVEL_INFO,
+                 "H264DecAddBuffer rv = %d, %p, %p bus address: %lx
", rv,
+                 h->decoder_inst, mem, mem->bus_address);
+    }
+  }
+#endif
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief h264_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param uint32_t eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int h264_dec_get_pic(v4l2_dec_inst* h,
+                            vsi_v4l2_dec_picture* dec_pic_info, uint32_t eos) {
+  H264DecPicture* dec_picture = (H264DecPicture*)h->priv_pic_data;
+  H264DecRet re = H264DEC_OK;
+#if 1
+  re = H264DecNextPicture(h->decoder_inst, dec_picture, 0);
+
+  if (H264DEC_PIC_RDY != re) {
+    if (eos) {
+      do {
+        re = H264DecNextPicture(h->decoder_inst, dec_picture, 0);
+      } while (re != H264DEC_END_OF_STREAM && re != H264DEC_PIC_RDY &&
+               (re == H264DEC_OK && h->dec_aborted == 0));
+      if (re == H264DEC_END_OF_STREAM) {
+        h264_dec_seek(h, NULL);
+        h->dec_aborted = 1;
+      }
+    }
+    if (H264DEC_PIC_RDY != re) return -1;
+  }
+#else
+
+  do {
+    re = H264DecNextPicture(h->decoder_inst, dec_picture, 0);
+  } while (eos && re != H264DEC_END_OF_STREAM && re != H264DEC_PIC_RDY);
+  if (H264DEC_PIC_RDY != re) return -1;
+#endif
+  H264DecInfo dec_info = {0};
+  H264DecGetInfo(h->decoder_inst, &dec_info);
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->pic_width;
+  dec_pic_info->pic_height = dec_picture->pic_height;
+  dec_pic_info->pic_stride = dec_picture->pic_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = dec_picture->crop_params.crop_left_offset;
+  dec_pic_info->crop_top = dec_picture->crop_params.crop_top_offset;
+  dec_pic_info->crop_width = dec_picture->crop_params.crop_out_width;
+  dec_pic_info->crop_height = dec_picture->crop_params.crop_out_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+
+  dec_pic_info->output_picture_chroma_bus_address =
+      (dec_info.mono_chrome == 1)
+          ? (vpu_addr_t)0
+          : (dec_picture->output_picture_bus_address +
+             dec_picture->pic_stride * dec_picture->pic_height);
+
+  dec_pic_info->sar_width = dec_picture->sar_width;
+  dec_pic_info->sar_height = dec_picture->sar_height;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief h264_dec_get_vui_info(), get vui info.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param H264DecInfo* dec_info: new seq. header info.
+ * @return .
+ */
+static void h264_dec_get_vui_info(v4l2_dec_inst* h, H264DecInfo* dec_info) {
+  h->dec_info.colour_description_present_flag =
+      dec_info->colour_description_present_flag;
+  h->dec_info.matrix_coefficients = dec_info->matrix_coefficients;
+  h->dec_info.colour_primaries = dec_info->colour_primaries;
+  h->dec_info.transfer_characteristics = dec_info->transfer_characteristics;
+  h->dec_info.video_range = dec_info->video_range;
+}
+
+/**
+ * @brief h264_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param H264DecInfo* dec_info: new seq. header info.
+ * @param H264DecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static uint32_t h264_dec_check_res_change(v4l2_dec_inst* h,
+                                          H264DecInfo* dec_info,
+                                          H264DecBufferInfo* buf_info) {
+  uint32_t res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((dec_info->pic_width != h->dec_info.frame_width) ||
+      (dec_info->pic_height != h->dec_info.frame_height) ||
+      (dec_info->crop_params.crop_left_offset !=
+       h->dec_info.visible_rect.left) ||
+      (dec_info->crop_params.crop_out_width !=
+       h->dec_info.visible_rect.width) ||
+      (dec_info->crop_params.crop_top_offset != h->dec_info.visible_rect.top) ||
+      (dec_info->crop_params.crop_out_height !=
+       h->dec_info.visible_rect.height) ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->pic_width, dec_info->pic_height);
+    h->dec_info.frame_width = dec_info->pic_width;
+    h->dec_info.frame_height = dec_info->pic_height;
+    h->dec_info.visible_rect.left = dec_info->crop_params.crop_left_offset;
+    h->dec_info.visible_rect.width = dec_info->crop_params.crop_out_width;
+    h->dec_info.visible_rect.top = dec_info->crop_params.crop_top_offset;
+    h->dec_info.visible_rect.height = dec_info->crop_params.crop_out_height;
+    h->dec_info.src_pix_fmt = (dec_info->output_format != H264DEC_YUV400)
+                                  ? VSI_V4L2_DEC_PIX_FMT_NV12
+                                  : VSI_V4L2_DEC_PIX_FMT_400;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+
+/**
+ * @brief h264_update_input(), update in_mem & dec_input according to dec_output
+ * info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param H264DecInput *dec_input.
+ * @param H264DecOutput *dec_output.
+ * @return .
+ */
+static void h264_update_input(struct DWLLinearMem* in_mem,
+                              H264DecInput* dec_input,
+                              H264DecOutput* dec_output) {
+  if (dec_output->data_left) {
+    dec_input->stream_bus_address +=
+        (dec_output->strm_curr_pos - dec_input->stream);
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+  } else {
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+    dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  }
+  in_mem->logical_size = dec_input->data_len;
+  in_mem->bus_address = dec_input->stream_bus_address;
+  in_mem->virtual_address = (u32*)dec_input->stream;
+}
+
+/**
+ * @brief h264_dec_init(), h264 decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event h264_dec_init(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  u32 use_display_smoothing = 0;
+
+  H264DecApiVersion dec_api;
+  H264DecBuild dec_build;
+  H264DecRet re;
+  struct DecDownscaleCfg dscale_cfg;
+  enum DecDpbFlags flags = 0;
+  /* Print API version number */
+  dec_api = H264DecGetAPIVersion();
+  dec_build = H264DecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 H.264 Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_H264_DEC;
+
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT) {
+    flags |= DEC_REF_FRM_TILED_DEFAULT;
+    flags |= DEC_DPB_ALLOW_FIELD_ORDERING;
+    dpb_mode = DEC_DPB_INTERLACED_FIELD;
+  }
+
+  dscale_cfg.down_scale_x = ds_ratio_x;
+  dscale_cfg.down_scale_y = ds_ratio_y;
+
+  re = H264DecInit((H264DecInst*)(&h->decoder_inst), h->dwl_inst,
+                   h->dec_no_reordering, DEC_EC_NONE, use_display_smoothing,
+                   flags, 0, 0, h->secure_mode_on, &dscale_cfg);
+  if (re != H264DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264DecInit failed
");
+    goto end;
+  }
+
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief h264_dec_decode(), h264 decoding function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event h264_dec_decode(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+  u32 skip_non_reference = 0;
+
+  H264DecInput dec_input = {0};
+  H264DecOutput dec_output = {0};
+  H264DecInfo dec_info;
+  H264DecBufferInfo hbuf = {0};
+  H264DecConfig dec_cfg = {0};
+
+  struct DWLLinearMem* in_mem = &h->stream_in_mem;
+
+  H264DecInst dec_inst = h->decoder_inst;
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.stream = (u8*)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream, dec_input.stream_bus_address,
+             dec_input.data_len);
+
+  h->dec_aborted = 0;
+  do {
+    ret = H264DecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "H264DecDecode ret %d decoded pic %d, out_pid %d
", ret,
+               h->dec_pic_id, h->dec_out_pic_id);
+    switch (ret) {
+      case H264DEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case H264DEC_HDRS_RDY:
+        H264DecGetBufferInfo(dec_inst, &hbuf);
+        if (H264DecGetInfo(dec_inst, &dec_info) != H264DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+#if 0
+            if(h264_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+                re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+                h->dec_add_buffer_allowed = 0;
+                goto update_input;
+             }
+#endif
+        dec_cfg.dpb_flags = 0;
+        if (h->dec_output_fmt) dec_cfg.dpb_flags |= DEC_REF_FRM_TILED_DEFAULT;
+
+        if (dpb_mode == DEC_DPB_INTERLACED_FIELD)
+          dec_cfg.dpb_flags |= DEC_DPB_ALLOW_FIELD_ORDERING;
+        dec_cfg.use_adaptive_buffers = 0;
+        dec_cfg.guard_size = 0;
+        dec_cfg.use_secure_mode = 0;
+        if (H264DEC_OK !=
+            H264DecSetInfo((H264DecInst)(h->decoder_inst), &dec_cfg)) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264DecSetInfo failed
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h264_dec_get_vui_info(h, &dec_info);
+        break;
+
+      case H264DEC_ADVANCED_TOOLS:
+        ASSERT(dec_output.data_left);
+        break;
+
+      case H264DEC_PIC_DECODED:
+        if (H264DecGetInfo(dec_inst, &dec_info) != H264DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case H264DEC_PENDING_FLUSH:
+        if (H264DecGetInfo(dec_inst, &dec_info) != H264DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        /* Reset buffers added and stop adding extra buffers when wh changed. */
+        /*if((dec_info.pic_width != h->dec_info.frame_width) ||
+                (dec_info.pic_height != h->dec_info.frame_height)) */ {
+          /* ctrlsw needs application to take away all of decoded pictures,
+              otherwise, xxxDecDecode() will wait output-empty locally.
+              So, we shouldn't check if resolution is identical or not here.*/
+          re_dec_event = DEC_PENDING_FLUSH_EVENT;
+          goto update_input;
+        }
+        break;
+
+      case H264DEC_FIELD_DECODED:
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Field stream, data left %d
",
+                   dec_output.data_left);
+        h->dec_pic_id++;
+        break;
+
+      case H264DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+      case H264DEC_STRM_PROCESSED:
+      case H264DEC_NONREF_PIC_SKIPPED:
+        break;
+
+      case H264DEC_BUF_EMPTY:
+      case H264DEC_STRM_ERROR:
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        break;
+
+      case H264DEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Waiting for frame buffers
");
+
+        // h->dec_add_buffer_allowed = 1;
+        H264DecGetBufferInfo(dec_inst, &hbuf);
+        if (H264DecGetInfo(dec_inst, &dec_info) != H264DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        if (h264_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          //                h->consumed_len += dec_input.data_len -
+          //                dec_output.data_left;
+          goto update_input;
+        }
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          h264_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+        break;
+
+      case H264DEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case H264DEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          h264_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto update_input;
+        }
+
+      case H264DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+    /* break out of do-while if max_num_pics reached (data_len set to 0) */
+    if (dec_input.data_len == 0) break;
+
+    h264_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.data_len > 0);
+
+  in_mem->logical_size = 0;
+
+  if ((ret != H264DEC_OK) && (ret != H264DEC_STRM_PROCESSED) &&
+      (ret != H264DEC_NONREF_PIC_SKIPPED) && (ret != H264DEC_PIC_DECODED) &&
+      (ret != H264DEC_FIELD_DECODED)) {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  }
+error:
+  if (dec_output.data_left == dec_input.data_len) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  h->consumed_len += dec_input.data_len - dec_output.data_left;
+  h264_update_input(in_mem, &dec_input, &dec_output);
+
+end:
+  if(ret != H264DEC_STRM_PROCESSED) {
+    h->dec_inpkt_ignore_picconsumed_event = 0;
+  }
+  return re_dec_event;
+}
+
+/**
+ * @brief h264_dec_destroy(), h264 decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event h264_dec_destroy(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  H264DecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish 
");
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief h264_dec_drain(), h264 draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return int: value of H264DecEndOfStream return.
+ */
+int h264_dec_drain(v4l2_dec_inst* h) {
+  H264DecRet ret = H264DEC_OK;
+  ret = H264DecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == H264DEC_OK);
+  return ret;
+}
+
+/**
+ * @brief h264_dec_seek(), h264 seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event h264_dec_seek(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  H264DecRet ret = H264DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = H264DecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "H264DecAbort returns %d
", ret);
+  ret = H264DecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+// vsidaemon_h264_v4l2m2m_decoder
+VSIM2MDEC(h264, V4L2_DAEMON_CODEC_DEC_H264, sizeof(H264DecPicture),
+          DEC_ATTR_EOS_THREAD | DEC_ATTR_SUPPORT_SECURE_MODE);
diff --git a/v4l2_vsi_daemon/src/vsi_dec_hevc.c b/v4l2_vsi_daemon/src/vsi_dec_hevc.c
new file mode 100755
index 0000000..2e51104
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_hevc.c
@@ -0,0 +1,778 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_hevc.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include <dlfcn.h>
+
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+#include "dwl.h"
+#include "hevcdecapi.h"
+//#include "hevc_container.h"
+
+#ifdef VSI_CMODEL
+#include "regdrv.h"
+#include "tb_cfg.h"
+#include "tb_stream_corrupt.h"
+#include "tb_sw_performance.h"
+#include "tb_tiled.h"
+#endif
+
+/*------------------------------------------------------------------------*/
+#define BUFFER_ALIGN_FACTOR (64)
+#define ALIGN_OFFSET(A) ((A) & (BUFFER_ALIGN_FACTOR - 1))
+#define ALIGN(A) ((A) & (~(BUFFER_ALIGN_FACTOR - 1)))
+/*------------------------------------------------------------------------*/
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+/*------------------------------------------------------------------------*/
+typedef struct {
+  struct HevcDecConfig dec_cfg;
+
+  enum DecDpbFlags dec_output_fmt;
+  enum DecPicturePixelFormat dec_pixel_fmt;
+
+  int32_t set_new_info;
+} HEVC_PRIV_DATA;
+/*------------------------------------------------------------------------*/
+
+#if 0  // obsolete functions
+static void * (*G2DWLInit)(struct DWLInitParam * param) = NULL;
+static i32 (*G2DWLRelease)(const void *instance) = NULL;
+
+static void hevc_dec_dlsym_priv_func(v4l2_dec_inst* h)
+{
+    ASSERT(h->dec_dll_handle);
+    G2DWLInit = dlsym(h->dec_dll_handle, "DWLInit");
+    G2DWLRelease = dlsym(h->dec_dll_handle, "DWLRelease");
+    ASSERT(G2DWLInit);
+    ASSERT(G2DWLRelease);
+}
+#endif
+
+/*------------------------------------------------------------------------*/
+v4l2_inst_dec_event hevc_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg);
+/*------------------------------------------------------------------------*/
+
+/**
+ * @brief hevc_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int hevc_dec_release_pic(v4l2_dec_inst *h, void *pic) {
+  enum DecRet ret;
+
+  ASSERT(pic);
+  ret = HevcDecPictureConsumed(h->decoder_inst, (struct HevcDecPicture *)pic);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: HevcDecPictureConsumed ret = %d, %p
",
+             h->instance_id, ret, pic);
+
+  ASSERT(ret == DEC_OK);
+  return (ret == DEC_OK) ? 0 : -1;
+}
+
+/**
+ * @brief hevc_dec_set_info(), set output & pixel format.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static uint32_t hevc_dec_set_info(v4l2_dec_inst *h) {
+  HEVC_PRIV_DATA *priv = (HEVC_PRIV_DATA *)h->priv_data;
+  struct HevcDecConfig *dec_cfg = &(priv->dec_cfg);
+  enum DecRet rv = DEC_OK;
+
+  if (priv->dec_output_fmt == h->dec_output_fmt &&
+      priv->dec_pixel_fmt == h->dec_pixel_fmt) {
+    return 0;
+  }
+
+  if (priv->dec_output_fmt != h->dec_output_fmt) {
+    if (h->dec_output_fmt) {
+      dec_cfg->output_format = DEC_OUT_FRM_TILED_4X4;
+    } else {
+      dec_cfg->output_format = DEC_OUT_FRM_RASTER_SCAN;
+    }
+
+    priv->dec_output_fmt = h->dec_output_fmt;
+    priv->set_new_info = 1;
+  }
+
+  priv->dec_pixel_fmt = h->dec_pixel_fmt;
+  dec_cfg->pixel_format = h->dec_pixel_fmt;
+  rv = HevcDecSetInfo(h->decoder_inst, &priv->dec_cfg);
+  (void)rv;
+  return 0;
+}
+static int hevc_dec_remove_buffer(v4l2_dec_inst* h) {
+  enum DecRet rv = DEC_OK;
+  rv = HevcDecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: rv = %d
", h->instance_id, rv);
+  return 0;
+}
+
+/**
+ * @brief hevc_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int hevc_dec_add_buffer(v4l2_dec_inst *h, struct DWLLinearMem *mem_obj) {
+  enum DecRet rv = DEC_OK;
+  HEVC_PRIV_DATA *priv = (HEVC_PRIV_DATA *)h->priv_data;
+  if (mem_obj) {
+    if (h->existed_dpb_nums == 0) {
+      hevc_dec_set_info(h);
+    }
+
+    if (priv->set_new_info) {
+      // if new output format is set, don't do AddBuffer().
+      return 0;
+    }
+
+    rv = HevcDecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: HevcDecAddBuffer ret = %d, %p
",
+               h->instance_id, rv, mem_obj);
+    if (rv == DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == DEC_OK || rv == DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief hevc_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void hevc_dec_add_external_buffer(v4l2_dec_inst *h) {
+#if 1
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: Add all queued buffers to ctrsw
",
+             h->instance_id);
+  dpb_get_buffers(h);
+#else
+  enum DecRet rv;
+  struct DWLLinearMem *mem;
+  for (int i = 0; i < h->existed_dpb_nums; i++) {
+    mem = dpb_get_buffer(h, i);
+    if (mem) {
+      rv = HevcDecAddBuffer(h->decoder_inst, mem);
+      HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: HevcDecAddBuffer ret = %d, %p
",
+                 h->instance_id, rv, mem);
+    }
+  }
+#endif
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief hevc_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param uint32_t eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int hevc_dec_get_pic(v4l2_dec_inst *h,
+                            vsi_v4l2_dec_picture *dec_pic_info, uint32_t eos) {
+  struct HevcDecPicture *dec_picture =
+      (struct HevcDecPicture *)h->priv_pic_data;
+  enum DecRet re = DEC_OK;
+  re = HevcDecNextPicture(h->decoder_inst, dec_picture);
+  if (DEC_PIC_RDY != re) {
+    if (eos) {
+      do {
+        re = HevcDecNextPicture(h->decoder_inst, dec_picture);
+      } while (re != DEC_END_OF_STREAM && re != DEC_PIC_RDY &&
+               (re == DEC_OK && h->dec_aborted == 0));
+      if (re == DEC_END_OF_STREAM) {
+        // workaround for JIRA521: DecEndOfStream() can't flush out all of
+        // decoded pictures.
+        hevc_dec_seek(h, NULL);
+        h->dec_aborted = 1;
+      }
+    }
+    if (re != DEC_PIC_RDY) return -1;
+  }
+
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->pic_width;
+  dec_pic_info->pic_height = dec_picture->pic_height;
+  dec_pic_info->pic_stride = dec_picture->pic_stride;
+  dec_pic_info->pic_corrupt = dec_picture->pic_corrupt;
+  dec_pic_info->bit_depth = dec_picture->dec_info.bit_depth;
+  dec_pic_info->crop_left = dec_picture->crop_params.crop_left_offset;
+  dec_pic_info->crop_top = dec_picture->crop_params.crop_top_offset;
+  dec_pic_info->crop_width = dec_picture->crop_params.crop_out_width;
+  dec_pic_info->crop_height = dec_picture->crop_params.crop_out_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_picture_chroma_bus_address;
+  dec_pic_info->output_rfc_luma_bus_address = dec_picture->output_rfc_luma_bus_address;
+  dec_pic_info->output_rfc_chroma_bus_address = dec_picture->output_rfc_chroma_bus_address;  
+
+  dec_pic_info->sar_width = dec_picture->dec_info.sar_width;
+  dec_pic_info->sar_height = dec_picture->dec_info.sar_height;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = dec_picture->dec_info.video_range;
+  dec_pic_info->colour_description_present_flag =
+      dec_picture->dec_info.colour_description_present_flag;
+  dec_pic_info->colour_primaries = dec_picture->dec_info.colour_primaries;
+  dec_pic_info->transfer_characteristics =
+      dec_picture->dec_info.transfer_characteristics;
+  dec_pic_info->matrix_coefficients = dec_picture->dec_info.matrix_coefficients;
+  dec_pic_info->chroma_loc_info_present_flag =
+      dec_picture->dec_info.chroma_loc_info_present_flag;
+  dec_pic_info->chroma_sample_loc_type_top_field =
+      dec_picture->dec_info.chroma_sample_loc_type_top_field;
+  dec_pic_info->chroma_sample_loc_type_bottom_field =
+      dec_picture->dec_info.chroma_sample_loc_type_bottom_field;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag =
+      dec_picture->dec_info.hdr10_metadata.present_flag;
+  dec_pic_info->red_primary_x =
+      dec_picture->dec_info.hdr10_metadata.red_primary_x;
+  dec_pic_info->red_primary_y =
+      dec_picture->dec_info.hdr10_metadata.red_primary_y;
+  dec_pic_info->green_primary_x =
+      dec_picture->dec_info.hdr10_metadata.green_primary_x;
+  dec_pic_info->green_primary_y =
+      dec_picture->dec_info.hdr10_metadata.green_primary_y;
+  dec_pic_info->blue_primary_x =
+      dec_picture->dec_info.hdr10_metadata.blue_primary_x;
+  dec_pic_info->blue_primary_y =
+      dec_picture->dec_info.hdr10_metadata.blue_primary_y;
+  dec_pic_info->white_point_x =
+      dec_picture->dec_info.hdr10_metadata.white_point_x;
+  dec_pic_info->white_point_y =
+      dec_picture->dec_info.hdr10_metadata.white_point_y;
+  dec_pic_info->max_mastering_luminance =
+      dec_picture->dec_info.hdr10_metadata.max_mastering_luminance;
+  dec_pic_info->min_mastering_luminance =
+      dec_picture->dec_info.hdr10_metadata.min_mastering_luminance;
+  dec_pic_info->max_content_light_level =
+      dec_picture->dec_info.hdr10_metadata.max_content_light_level;
+  dec_pic_info->max_frame_average_light_level =
+      dec_picture->dec_info.hdr10_metadata.max_frame_average_light_level;
+
+  return 0;
+}
+
+/**
+ * @brief hevc_dec_get_vui_info(), get vui info.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param HevcDecInfo* dec_info: new seq. header info.
+ * @return .
+ */
+static void hevc_dec_get_vui_info(v4l2_dec_inst *h,
+                                  struct HevcDecInfo *dec_info) {
+  h->dec_info.colour_description_present_flag =
+      dec_info->colour_description_present_flag;
+  h->dec_info.matrix_coefficients = dec_info->matrix_coefficients;
+  h->dec_info.colour_primaries = dec_info->colour_primaries;
+  h->dec_info.transfer_characteristics = dec_info->transfer_characteristics;
+  h->dec_info.video_range = dec_info->video_range;
+}
+
+static void hevc_dec_get_hdr10_metadata(v4l2_dec_inst *h,
+                                        struct HevcDecInfo *dec_info) {
+  h->dec_info.vpu_hdr10_meta.hasHdr10Meta =
+      dec_info->hdr10_metadata.present_flag;
+  h->dec_info.vpu_hdr10_meta.redPrimary[0] =
+      dec_info->hdr10_metadata.red_primary_x;
+  h->dec_info.vpu_hdr10_meta.redPrimary[1] =
+      dec_info->hdr10_metadata.red_primary_y;
+  h->dec_info.vpu_hdr10_meta.greenPrimary[0] =
+      dec_info->hdr10_metadata.green_primary_x;
+  h->dec_info.vpu_hdr10_meta.greenPrimary[1] =
+      dec_info->hdr10_metadata.green_primary_y;
+  h->dec_info.vpu_hdr10_meta.bluePrimary[0] =
+      dec_info->hdr10_metadata.blue_primary_x;
+  h->dec_info.vpu_hdr10_meta.bluePrimary[1] =
+      dec_info->hdr10_metadata.blue_primary_y;
+  h->dec_info.vpu_hdr10_meta.whitePoint[0] =
+      dec_info->hdr10_metadata.white_point_x;
+  h->dec_info.vpu_hdr10_meta.whitePoint[1] =
+      dec_info->hdr10_metadata.white_point_y;
+  h->dec_info.vpu_hdr10_meta.maxMasteringLuminance =
+      dec_info->hdr10_metadata.max_mastering_luminance;
+  h->dec_info.vpu_hdr10_meta.minMasteringLuminance =
+      dec_info->hdr10_metadata.min_mastering_luminance;
+  h->dec_info.vpu_hdr10_meta.maxContentLightLevel =
+      dec_info->hdr10_metadata.max_content_light_level;
+  h->dec_info.vpu_hdr10_meta.maxFrameAverageLightLevel =
+      dec_info->hdr10_metadata.max_frame_average_light_level;
+}
+/**
+ * @brief hevc_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param HevcDecInfo* dec_info: new seq. header info.
+ * @param HevcDecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static uint32_t hevc_dec_check_res_change(v4l2_dec_inst *h,
+                                          struct HevcDecInfo *dec_info,
+                                          struct HevcDecBufferInfo *buf_info) {
+  uint32_t res_change = 0;
+  u32 pixel_width = dec_info->pic_width;
+  u32 bit_depth = 8;
+  enum DecRet re = DEC_OK;
+
+  re = HevcDecGetSpsBitDepth(h->decoder_inst, &bit_depth);
+  if(re != DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "HevcDecGetSpsBitDepth Failed re = %d
", re);
+    bit_depth = dec_info->bit_depth;
+  }
+  if ((pixel_width != h->dec_info.frame_width) ||
+      (dec_info->pic_height != h->dec_info.frame_height) ||
+      (bit_depth != h->dec_info.bit_depth)
+      /*        || (dec_info->crop_params.crop_left_offset !=
+         h->dec_info.visible_rect.left) */
+      ||
+      (dec_info->crop_params.crop_out_width != h->dec_info.visible_rect.width)
+      /*        || (dec_info->crop_params.crop_top_offset !=
+         h->dec_info.visible_rect.top) */
+      || (dec_info->crop_params.crop_out_height !=
+          h->dec_info.visible_rect.height) ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)||
+      (h->dec_info.dpb_buffer_size != buf_info->next_buf_size)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Inst[%lx]: Res-resolution Change <%dx%d> -> <%dx%d>, bit_depth %d -> %d 
",
+               h->instance_id,
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->pic_width, dec_info->pic_height,
+               h->dec_info.bit_depth, bit_depth);
+
+    h->dec_info.frame_width = pixel_width;
+    h->dec_info.frame_height = dec_info->pic_height;
+    h->dec_info.bit_depth = bit_depth;
+    h->dec_info.visible_rect.left = dec_info->crop_params.crop_left_offset;
+    h->dec_info.visible_rect.width = dec_info->crop_params.crop_out_width;
+    h->dec_info.visible_rect.top = dec_info->crop_params.crop_top_offset;
+    h->dec_info.visible_rect.height = dec_info->crop_params.crop_out_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_info.pic_wstride = dec_info->pic_stride;
+    hevc_dec_get_hdr10_metadata(h, dec_info);
+    res_change = 1;
+  }
+
+  return res_change;
+}
+
+/**
+ * @brief hevc_update_input(), update in_mem & dec_input according to dec_output
+ * info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param HevcDecInput *dec_input.
+ * @param HevcDecOutput *dec_output.
+ * @return .
+ */
+static void hevc_update_input(struct DWLLinearMem *in_mem,
+                              struct HevcDecInput *dec_input,
+                              struct HevcDecOutput *dec_output) {
+  if (dec_output->data_left) {
+    dec_input->stream_bus_address +=
+        (dec_output->strm_curr_pos - dec_input->stream);
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+  } else {
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+    dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  }
+
+  in_mem->bus_address = dec_input->stream_bus_address;
+  in_mem->logical_size = dec_input->data_len;
+  in_mem->virtual_address = (u32 *)dec_input->stream;
+}
+
+/**
+ * @brief hevc_dec_init(), hevc decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event hevc_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  enum DecRet ret;
+  HEVC_PRIV_DATA *priv;
+  struct DWLInitParam dwl_params = {DWL_CLIENT_TYPE_HEVC_DEC};
+  HevcDecBuild dec_build;
+
+  dec_build = HevcDecGetBuild();
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "dec_build <0x%x,0x%x>
", dec_build.sw_build,
+             dec_build.hw_build);
+
+  h->dwl_inst = DWLInit(&dwl_params);
+  ASSERT(h->dwl_inst);
+
+  h->priv_data = malloc(sizeof(HEVC_PRIV_DATA));
+  ASSERT(h->priv_data);
+  memset(h->priv_data, 0, sizeof(HEVC_PRIV_DATA));
+  priv = (HEVC_PRIV_DATA *)h->priv_data;
+
+  /* initialize decoder. If unsuccessful -> exit */
+  struct HevcDecConfig *dec_cfg = &(priv->dec_cfg);
+  dec_cfg->no_output_reordering = h->dec_no_reordering;
+  dec_cfg->use_video_freeze_concealment = 0;
+#ifdef HAS_FULL_DECFMT
+  dec_cfg->use_video_compressor = 1;
+#else
+  dec_cfg->use_video_compressor = 0;
+#endif
+  dec_cfg->use_fetch_one_pic = 0;
+  dec_cfg->use_ringbuffer = 0;
+  dec_cfg->output_format =
+      h->dec_output_fmt ? DEC_OUT_FRM_TILED_4X4 : DEC_OUT_FRM_RASTER_SCAN;
+
+  dec_cfg->pixel_format = h->dec_pixel_fmt;
+
+  dec_cfg->dscale_cfg.down_scale_x = 1;
+  dec_cfg->dscale_cfg.down_scale_y = 1;
+  dec_cfg->guard_size = 0;
+  dec_cfg->use_adaptive_buffers = 0;
+  dec_cfg->use_secure_mode = h->secure_mode_on;
+
+  ret = HevcDecInit((HevcDecInst *)(&h->decoder_inst), h->dwl_inst, dec_cfg);
+
+  if (ret != DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: DECODER INITIALIZATION FAILED
",
+              h->instance_id);
+    goto end;
+  }
+
+  priv->dec_output_fmt = h->dec_output_fmt;
+  priv->dec_pixel_fmt = dec_cfg->pixel_format;
+  priv->set_new_info = 0;
+  return DEC_EMPTY_EVENT;
+end:
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief hevc_dec_decode(), hevc decoding function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event hevc_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+
+  enum DecRet ret = DEC_OK;
+  HEVC_PRIV_DATA *priv = (HEVC_PRIV_DATA *)h->priv_data;
+
+  struct HevcDecInfo dec_info = {0};
+  struct HevcDecBufferInfo hbuf = {0};
+
+  struct HevcDecInput dec_input = {0};
+  struct HevcDecOutput dec_output = {0};
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+
+  HevcDecInst dec_inst = h->decoder_inst;
+
+  dec_input.stream = (u8 *)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+
+  dec_input.buffer = dec_input.stream;
+  dec_input.buffer_bus_address = ALIGN(dec_input.stream_bus_address);
+  dec_input.buff_len =
+      in_mem->logical_size + ALIGN_OFFSET(dec_input.stream_bus_address);
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: stream len: %d
",
+             h->instance_id, dec_input.data_len);
+
+  h->dec_aborted = 0;
+  do {
+    /* Picture ID is the picture number in decoding order */
+    ret = HevcDecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: HevcDecDecode ret %d decoded pic %d
",
+               h->instance_id, ret, h->dec_pic_id);
+    switch (ret) {
+      case DEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: UNSUPPORTED STREAM!
",
+                  h->instance_id);
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case DEC_HDRS_RDY:
+        HevcDecGetBufferInfo(dec_inst, &hbuf);
+        /* Stream headers were successfully decoded
+         * -> stream information is available for query now */
+        if (HevcDecGetInfo(dec_inst, &dec_info) != DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                     "Inst[%lx]: ERROR in getting stream info!
",
+                     h->instance_id);
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+#if 0
+            if(hevc_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+                re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+                h->dec_add_buffer_allowed = 0;
+                goto update_input; //end;
+            }
+#else
+        HANTRO_LOG(HANTRO_LEVEL_INFO,
+                   "Inst[%lx]: HDRS_RDY resolution: <%dx%d> -> <%dx%d>
",
+                   h->instance_id,
+                   h->dec_info.frame_width, h->dec_info.frame_height,
+                   dec_info.pic_width, dec_info.pic_height);
+#endif
+        hevc_dec_get_vui_info(h, &dec_info);
+        break;
+
+      case DEC_ADVANCED_TOOLS:
+        /* ASO/STREAM ERROR was noticed in the stream. The decoder has to
+         * reallocate resources */
+        ASSERT(dec_output.data_left);
+        break;
+
+      case DEC_PIC_DECODED:
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case DEC_PENDING_FLUSH:
+
+        /* Stream headers were successfully decoded
+         * -> stream information is available for query now */
+        if (HevcDecGetInfo(dec_inst, &dec_info) != DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                     "Inst[%lx]: ERROR in getting stream info!
",
+                     h->instance_id);
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        /* Reset buffers added and stop adding extra buffers when wh changed. */
+        /* if((dec_info.pic_width != h->dec_info.frame_width) ||
+               (dec_info.pic_height != h->dec_info.frame_height)) */ {
+          /* ctrlsw needs application to take away all of decoded pictures,
+              otherwise, xxxDecDecode() will wait output-empty locally.
+              So, we shouldn't check if resolution is identical or not here.*/
+          re_dec_event = DEC_PENDING_FLUSH_EVENT;
+          goto update_input;
+        }
+        break;
+
+      case DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+
+      case DEC_STRM_PROCESSED:
+      case DEC_NONREF_PIC_SKIPPED:
+        break;
+
+      case DEC_BUF_EMPTY:
+      case DEC_STRM_ERROR:
+        /* Used to indicate that picture decoding needs to finalized prior to
+         * corrupting next picture
+         * pic_rdy = 0; */
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        break;
+
+      case DEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: Waiting for frame buffers
",
+                   h->instance_id);
+
+#if 0
+            h->dec_add_buffer_allowed = 1;
+#else
+        HevcDecGetBufferInfo(dec_inst, &hbuf);
+        /* Stream headers were successfully decoded
+         * -> stream information is available for query now */
+        if (HevcDecGetInfo(dec_inst, &dec_info) != DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                     "Inst[%lx]: ERROR in getting stream info!
",
+                     h->instance_id);
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        if (hevc_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          //                h->dec_add_buffer_allowed = 0;
+        if (priv->set_new_info) {
+            priv->set_new_info = 0;
+        }
+          goto update_input;  // end;
+        }
+#endif
+
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Inst[%lx]: Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->instance_id,
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          hevc_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+
+        break;
+
+      case DEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case DEC_NO_DECODING_BUFFER:
+        re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+        goto end;
+
+      case DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: Timeout
", h->instance_id);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: FATAL ERROR: %d
",
+                  h->instance_id, ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+    /* break out of do-while if max_num_pics reached (data_len set to 0) */
+    if (dec_input.data_len == 0) break;
+
+    hevc_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.data_len > 0);
+
+  in_mem->logical_size = 0;
+
+  if ((ret != DEC_OK) && (ret != DEC_STRM_PROCESSED) &&
+      (ret != DEC_NONREF_PIC_SKIPPED) && (ret != DEC_PIC_DECODED) &&
+      (ret != DEC_PIC_CONSUMED)) {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  }
+error:
+  if (dec_output.data_left == dec_input.data_len) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  h->consumed_len += dec_input.data_len - dec_output.data_left;
+  hevc_update_input(in_mem, &dec_input, &dec_output);
+
+end:
+  if(ret != DEC_STRM_PROCESSED) {
+    h->dec_inpkt_ignore_picconsumed_event = 0;
+  }
+  return re_dec_event;
+}
+
+/**
+ * @brief hevc_dec_destroy(), hevc decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event hevc_dec_destroy(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: begin
", h->instance_id);
+  if (h->priv_data) {
+    free(h->priv_data);
+    h->priv_data = NULL;
+  }
+  HevcDecRelease(h->decoder_inst);
+#ifdef VSI_CMODEL
+  DWLRelease(h->dwl_inst);
+#else
+  DWLRelease(h->dwl_inst);
+#endif
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: finish
", h->instance_id);
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief hevc_dec_drain(), hevc drain, free existed buffers in dpb.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return int: value of HevcDecEndOfStream return.
+ */
+int hevc_dec_drain(v4l2_dec_inst *h) {
+  enum DecRet ret = DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: drain
", h->instance_id);
+  ret = HevcDecEndOfStream(h->decoder_inst);
+  ASSERT(ret == DEC_OK);
+  return ret;
+}
+
+/**
+ * @brief hevc_dec_seek(), hevc seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event hevc_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  enum DecRet ret = DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: seek
", h->instance_id);
+
+  ret = HevcDecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Inst[%lx]: HevcDecAbort returns %d
",
+             h->instance_id, ret);
+  ret = HevcDecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+// vsidaemon_hevc_v4l2m2m_decoder
+VSIM2MDEC(hevc, V4L2_DAEMON_CODEC_DEC_HEVC, sizeof(struct HevcDecPicture),
+          DEC_ATTR_EOS_THREAD | DEC_ATTR_SUPPORT_SECURE_MODE);
diff --git a/v4l2_vsi_daemon/src/vsi_dec_jpeg.c b/v4l2_vsi_daemon/src/vsi_dec_jpeg.c
new file mode 100755
index 0000000..d6454bb
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_jpeg.c
@@ -0,0 +1,575 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_jpeg.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+
+#include "vsi_dec.h"
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+
+#include "jpegdecapi.h"
+
+#ifdef VSI_CMODEL
+#include "deccfg.h"
+#endif
+
+#define MAX_BUFFER_NUM (32)
+#define TRUE (1)
+#define FALSE (0)
+#define MCU_SIZE (16)
+#define MCU_MAX_COUNT (8100)
+typedef struct {
+  struct DWLLinearMem mem_obj[MAX_BUFFER_NUM];
+  int head;
+  int tail;
+} JpegBufferQueue;
+
+typedef struct {
+  JpegBufferQueue out_buffer_for_decoding;
+  JpegBufferQueue out_buffer_for_dequeue;
+  JpegDecImageInfo jpg_img_info;
+} JpegDecPrivData;
+
+static vsi_v4l2dec_pixfmt jpeg_dec_get_src_pixfmt(u32 output_format) {
+  vsi_v4l2dec_pixfmt ret = VSI_V4L2_DEC_PIX_FMT_NV12;
+  switch (output_format) {
+    case JPEGDEC_YCbCr420_SEMIPLANAR:
+      ret = VSI_V4L2_DEC_PIX_FMT_NV12;
+      break;
+    case JPEGDEC_YCbCr400:
+      ret = VSI_V4L2_DEC_PIX_FMT_400;
+      break;
+    case JPEGDEC_YCbCr411_SEMIPLANAR:
+      ret = VSI_V4L2_DEC_PIX_FMT_411SP;
+      break;
+    case JPEGDEC_YCbCr422_SEMIPLANAR:
+      ret = VSI_V4L2_DEC_PIX_FMT_422SP;
+      break;
+    case JPEGDEC_YCbCr444_SEMIPLANAR:
+      ret = VSI_V4L2_DEC_PIX_FMT_444SP;
+      break;
+    default:
+      break;
+  }
+  return ret;
+}
+
+static void jpeg_init_buf_queue(JpegBufferQueue *buf_q) {
+  buf_q->tail = 0;
+  buf_q->head = 0;
+}
+
+static u32 jpeg_is_full_buf_queue(JpegBufferQueue *buf_q) {
+  if (buf_q->tail == ((buf_q->head + 1) % MAX_BUFFER_NUM))
+    return TRUE;
+  else {
+    return FALSE;
+  }
+}
+
+static u32 jpeg_is_empty_buf_queue(JpegBufferQueue *buf_q) {
+  if (buf_q->tail == buf_q->head)
+    return TRUE;
+  else {
+    return FALSE;
+  }
+}
+
+static int jpeg_buf_enqueue(JpegBufferQueue *buf_q,
+                            struct DWLLinearMem *out_buffer) {
+  if (jpeg_is_full_buf_queue(buf_q) == TRUE) return -1;
+  memcpy(&buf_q->mem_obj[buf_q->head], out_buffer, sizeof(struct DWLLinearMem));
+  buf_q->head = (buf_q->head + 1) % MAX_BUFFER_NUM;
+  return 0;
+}
+
+static int jpeg_buffer_dequeue(JpegBufferQueue *buf_q,
+                               struct DWLLinearMem **display_mem) {
+  if (jpeg_is_empty_buf_queue(buf_q) == TRUE) return -1;
+  *display_mem = &buf_q->mem_obj[buf_q->tail];
+  buf_q->tail = (buf_q->tail + 1) % MAX_BUFFER_NUM;
+  return 0;
+}
+
+/**
+ * @brief jpeg_get_output_size(), get the output picture size.
+ * @param JpegDecImageInfo image_info
+ * @return int: output size.
+ */
+static u32 jpeg_get_output_size(JpegDecImageInfo *image_info) {
+  u32 output_size = 0;
+  if (image_info->output_format == JPEGDEC_YCbCr420_SEMIPLANAR ||
+      image_info->output_format == JPEGDEC_YCbCr411_SEMIPLANAR) {
+    output_size =
+        (image_info->output_width * image_info->output_height) * 3 / 2;
+  } else if (image_info->output_format == JPEGDEC_YCbCr422_SEMIPLANAR ||
+             image_info->output_format == JPEGDEC_YCbCr440) {
+    output_size = (image_info->output_width * image_info->output_height) * 2;
+  } else if (image_info->output_format == JPEGDEC_YCbCr444_SEMIPLANAR) {
+    output_size = (image_info->output_width * image_info->output_height) * 3;
+  } else if (image_info->output_format == JPEGDEC_YCbCr400) {
+    output_size = image_info->output_width * image_info->output_height;
+  } else {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "unknow image format 0x%x.
",
+               image_info->output_format);
+    ASSERT(0);
+  }
+  return output_size;
+}
+
+static u32 jpeg_get_chroma_size(JpegDecImageInfo *image_info) {
+  u32 chroma_size = 0;
+  if (image_info->output_format == JPEGDEC_YCbCr420_SEMIPLANAR ||
+      image_info->output_format == JPEGDEC_YCbCr411_SEMIPLANAR) {
+    chroma_size = 0;
+  } else if (image_info->output_format == JPEGDEC_YCbCr422_SEMIPLANAR ||
+             image_info->output_format == JPEGDEC_YCbCr440) {
+    chroma_size = image_info->output_width * image_info->output_height;
+  } else if (image_info->output_format == JPEGDEC_YCbCr444_SEMIPLANAR) {
+    chroma_size = (image_info->output_width * image_info->output_height) * 2;
+  }
+  return chroma_size;
+}
+
+/**
+ * @brief jpeg_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int jpeg_dec_release_pic(v4l2_dec_inst *h, void *pic) {
+  int rv = -1;
+  if (pic) {
+    rv = jpeg_buf_enqueue(
+        &((JpegDecPrivData *)h->priv_data)->out_buffer_for_decoding,
+        (struct DWLLinearMem *)pic);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Jpeg Dec Consumed  bus address: %lx
",
+               ((struct DWLLinearMem *)pic)->bus_address);
+  }
+  return rv;
+}
+
+static int jpeg_dec_remove_buffer(v4l2_dec_inst* h) {
+  struct DWLLinearMem *mem = NULL;
+  while(jpeg_buffer_dequeue(&((JpegDecPrivData *)h->priv_data)->out_buffer_for_decoding, &mem) == 0) ;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish
");
+  return 0;
+}
+
+/**
+ * @brief jpeg_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int jpeg_dec_add_buffer(v4l2_dec_inst *h, struct DWLLinearMem *mem_obj) {
+  int rv = -1;
+  if (mem_obj) {
+    rv = jpeg_buf_enqueue(
+        &((JpegDecPrivData *)h->priv_data)->out_buffer_for_decoding, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "JpegDecAddBuffer rv = %d, %p
", rv,
+               mem_obj);
+  }
+  return rv;
+}
+
+/**
+ * @brief jpeg_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void jpeg_dec_add_external_buffer(v4l2_dec_inst *h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief jpeg_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param u32 eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int jpeg_dec_get_pic(v4l2_dec_inst *h,
+                            vsi_v4l2_dec_picture *dec_pic_info, u32 eos) {
+  int mem_ret = 0;
+  struct DWLLinearMem *display_mem = NULL;
+  JpegDecPrivData *jpeg_priv_data = (JpegDecPrivData *)h->priv_data;
+  mem_ret = jpeg_buffer_dequeue(&jpeg_priv_data->out_buffer_for_dequeue,
+                                &display_mem);
+  if (mem_ret == -1) return -1;
+  JpegDecImageInfo img_info = jpeg_priv_data->jpg_img_info;
+  u32 chroma_size = jpeg_get_chroma_size(&img_info);
+  ASSERT(display_mem);
+  dec_pic_info->priv_pic_data = display_mem;
+  dec_pic_info->pic_width = h->dec_info.frame_width;
+  dec_pic_info->pic_height = h->dec_info.frame_height;
+  dec_pic_info->pic_stride = h->dec_info.frame_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = h->dec_info.frame_width;
+  dec_pic_info->crop_height = h->dec_info.frame_height;
+  dec_pic_info->output_picture_bus_address = display_mem->bus_address;
+  if (img_info.output_format == JPEGDEC_YCbCr400) {
+    dec_pic_info->output_picture_chroma_bus_address = 0;
+  } else {
+    dec_pic_info->output_picture_chroma_bus_address =
+        display_mem->bus_address +
+        h->dec_info.frame_width * h->dec_info.frame_width;
+    dec_pic_info->chroma_size = chroma_size;
+  }
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief jpeg_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param JpegDecImageInfo image_info
+ * @return int: 0: no change; 1: changed.
+ */
+static u32 jpeg_dec_check_res_change(v4l2_dec_inst *h,
+                                     JpegDecImageInfo *image_info,
+                                     u32 buf_size) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((image_info->output_width != h->dec_info.frame_width) ||
+      (image_info->output_height != h->dec_info.frame_height) ||
+      (image_info->display_width != h->dec_info.visible_rect.width) ||
+      (image_info->display_height != h->dec_info.visible_rect.height) ||
+      (buf_size != h->dec_info.dpb_buffer_size)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               image_info->output_width, image_info->output_height);
+    h->dec_info.frame_width = image_info->output_width;
+    h->dec_info.frame_height = image_info->output_height;
+    h->dec_info.visible_rect.left = 0;
+    h->dec_info.visible_rect.width = image_info->display_width;
+    h->dec_info.visible_rect.top = 0;
+    h->dec_info.visible_rect.height = image_info->display_height;
+    h->dec_info.needed_dpb_nums = 1;
+    h->dec_info.src_pix_fmt =
+        jpeg_dec_get_src_pixfmt(image_info->output_format);
+    h->dec_info.dpb_buffer_size = buf_size;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+  return res_change;
+}
+
+/**
+ * @brief jpeg_update_input(), update in_mem & dec_input according to dec_output
+ * info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param JpegDecInput *dec_input.
+ * @param JpegDecOutput *dec_output.
+ * @return
+ */
+static void jpeg_update_input(struct DWLLinearMem *in_mem,
+                              JpegDecInput *dec_input,
+                              JpegDecOutput *dec_output) {}
+
+/**
+ * @brief jpeg_dec_init(), jpeg decoder init functioin
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event jpeg_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  JpegDecApiVersion dec_api;
+  JpegDecBuild dec_build;
+  JpegDecRet re;
+  /* Print API version number */
+  dec_api = JpegGetAPIVersion();
+  dec_build = JpegDecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 JPEG Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_JPEG_DEC;
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  re = JpegDecInit((JpegDecInst *)(&h->decoder_inst));
+  if (re != JPEGDEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "JpegDecInit failed
");
+    goto end;
+  }
+
+  h->priv_data = malloc(sizeof(JpegDecPrivData));
+  JpegDecPrivData *jpeg_priv_data = (JpegDecPrivData *)h->priv_data;
+  ASSERT(jpeg_priv_data);
+  jpeg_init_buf_queue(&jpeg_priv_data->out_buffer_for_decoding);
+  jpeg_init_buf_queue(&jpeg_priv_data->out_buffer_for_dequeue);
+  memset(&jpeg_priv_data->jpg_img_info, 0, sizeof(JpegDecImageInfo));
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+static void jpeg_set_dec_output_addr(JpegDecInput *dec_input,
+                                     struct DWLLinearMem *input_mem,
+                                     JpegDecImageInfo *image_info,
+                                     u32 slice_index) {
+  u32 luma_size = image_info->output_width * image_info->output_height;
+  u32 slice_luma_offset = 0;
+  u32 slice_chroma_offset = 0;
+  if (dec_input->slice_mb_set > 0) {
+    u32 slice_height = dec_input->slice_mb_set * MCU_SIZE;
+    slice_luma_offset = slice_height * image_info->output_width * slice_index;
+    if (image_info->output_format == JPEGDEC_YCbCr420_SEMIPLANAR ||
+        image_info->output_format == JPEGDEC_YCbCr411_SEMIPLANAR)
+      slice_chroma_offset =
+          slice_height * image_info->output_width * slice_index / 2;
+    else if (image_info->output_format == JPEGDEC_YCbCr422_SEMIPLANAR ||
+             image_info->output_format == JPEGDEC_YCbCr440)
+      slice_chroma_offset =
+          slice_height * image_info->output_width * slice_index;
+    else if (image_info->output_format == JPEGDEC_YCbCr444_SEMIPLANAR)
+      slice_chroma_offset =
+          slice_height * image_info->output_width * slice_index * 2;
+    else if (image_info->output_format == JPEGDEC_YCbCr400) {
+      slice_chroma_offset = 0;
+    } else {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Unkonwn image format 0x%x
",
+                 image_info->output_format);
+      ASSERT(0);
+      slice_chroma_offset = 0;
+    }
+  }
+
+  dec_input->picture_buffer_y.virtual_address =
+      (u32 *)((u8 *)input_mem->virtual_address + slice_luma_offset);
+  dec_input->picture_buffer_y.bus_address =
+      input_mem->bus_address + slice_luma_offset;
+
+  if (image_info->output_format == JPEGDEC_YCbCr400) {
+    dec_input->picture_buffer_cb_cr.virtual_address = 0;
+    dec_input->picture_buffer_cb_cr.bus_address = 0;
+  } else {
+    dec_input->picture_buffer_cb_cr.virtual_address =
+        (u32 *)((u8 *)input_mem->virtual_address + luma_size +
+                slice_chroma_offset);
+    dec_input->picture_buffer_cb_cr.bus_address =
+        input_mem->bus_address + luma_size + slice_chroma_offset;
+  }
+}
+
+/**
+ * @brief jpeg_dec_decode(), jpeg decoding functioin
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event jpeg_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  JpegDecRet ret = JPEGDEC_OK;
+  int buf_size = 0;
+  int timeout_count = 0;
+  u32 slice_index = 0;
+  JpegDecInput dec_input = {0};
+  JpegDecOutput dec_output = {0};
+  JpegDecImageInfo image_info = {0};
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+  struct DWLLinearMem *out_buffer = NULL;
+  JpegDecInst dec_inst = h->decoder_inst;
+
+  dec_input.stream_buffer.virtual_address = (u32 *)in_mem->virtual_address;
+  dec_input.stream_buffer.bus_address = in_mem->bus_address;
+  dec_input.stream_length = in_mem->logical_size;
+  JpegDecRet info_ret = JPEGDEC_OK;
+  JpegDecPrivData *jpeg_priv_data = (JpegDecPrivData *)h->priv_data;
+
+  if (jpeg_is_empty_buf_queue(&jpeg_priv_data->out_buffer_for_decoding) &&
+      h->existed_dpb_nums) {
+    re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+    goto end;
+  }
+  if (h->dec_in_new_packet) {
+    info_ret = JpegDecGetImageInfo(dec_inst, &dec_input, &image_info);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "JpegDecGetImageInfo ret %d
", info_ret);
+    if (info_ret != JPEGDEC_OK) {
+      re_dec_event = DEC_EMPTY_EVENT;
+      goto error;
+    }
+    jpeg_priv_data->jpg_img_info = image_info;
+    buf_size = jpeg_get_output_size(&image_info);
+    if (buf_size == 0) {
+      re_dec_event = DEC_FATAL_ERROR_EVENT;
+      goto error;
+    }
+    if (jpeg_dec_check_res_change(h, &image_info, buf_size)) {
+      jpeg_init_buf_queue(&jpeg_priv_data->out_buffer_for_decoding);
+      jpeg_init_buf_queue(&jpeg_priv_data->out_buffer_for_dequeue);
+      return DEC_SOURCE_CHANGE_EVENT;
+    }
+  }
+
+  image_info = jpeg_priv_data->jpg_img_info;
+  if (image_info.output_width / MCU_SIZE * image_info.output_height / MCU_SIZE >
+      MCU_MAX_COUNT) {
+    dec_input.slice_mb_set =
+        MCU_MAX_COUNT / (image_info.output_width / MCU_SIZE);
+  } else {
+    dec_input.slice_mb_set = 0;
+  }
+
+  if (jpeg_buffer_dequeue(&jpeg_priv_data->out_buffer_for_decoding,
+                          &out_buffer) == -1) {
+    ASSERT(0);
+  }
+
+  jpeg_set_dec_output_addr(&dec_input, out_buffer, &image_info, slice_index);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream_buffer.virtual_address,
+             dec_input.stream_buffer.bus_address, dec_input.stream_length);
+
+  do {
+    ret = JpegDecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "JpegDecDecode ret %d
", ret);
+    switch (ret) {
+      case JPEGDEC_HW_TIMEOUT:
+        timeout_count++;
+        if (timeout_count < 100) {
+          slice_index = 0;
+          jpeg_set_dec_output_addr(&dec_input, out_buffer, &image_info,
+                                  slice_index);
+          break;
+        }
+        ret = JPEGDEC_FRAME_READY;
+
+      case JPEGDEC_FRAME_READY:
+        jpeg_buf_enqueue(&jpeg_priv_data->out_buffer_for_dequeue, out_buffer);
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        h->consumed_len += dec_input.stream_length;
+#endif
+        break;
+
+      case JPEGDEC_SLICE_READY:
+        slice_index++;
+        jpeg_set_dec_output_addr(&dec_input, out_buffer, &image_info,
+                                 slice_index);
+        break;
+      case JPEGDEC_SCAN_PROCESSED:
+      case JPEGDEC_STRM_PROCESSED:
+        break;
+
+      case JPEGDEC_STRM_ERROR:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "stream error
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto error;
+
+#if 0
+        case JPEGDEC_HW_TIMEOUT:
+            HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+            re_dec_event = DEC_FATAL_ERROR_EVENT;
+            goto end;
+#endif
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto error;
+    }
+
+  } while (ret != JPEGDEC_FRAME_READY);
+error:
+  in_mem->logical_size = 0;
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief jpeg_dec_destroy(), jpeg decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event jpeg_dec_destroy(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  JpegDecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+  if (h->priv_data) {
+    free(h->priv_data);
+    h->priv_data = NULL;
+  }
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish 
");
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief jpeg_dec_drain(), jpeg draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return int: value of JpegDecEndOfStream return.
+ */
+static int jpeg_dec_drain(v4l2_dec_inst *h) { return 0; }
+
+/**
+ * @brief jpeg_dec_seek(), jpeg seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event jpeg_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(jpeg, V4L2_DAEMON_CODEC_DEC_JPEG, sizeof(struct DWLLinearMem),
+          DEC_ATTR_NONE);  // vsidaemon_jpeg_v4l2m2m_decoder
diff --git a/v4l2_vsi_daemon/src/vsi_dec_mpeg2.c b/v4l2_vsi_daemon/src/vsi_dec_mpeg2.c
new file mode 100755
index 0000000..66fdf55
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_mpeg2.c
@@ -0,0 +1,518 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_mpeg2.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+
+#include "vsi_dec.h"
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+
+#include "mpeg2decapi.h"
+
+#ifdef VSI_CMODEL
+#include "mpeg2hwd_container.h"
+#include "regdrv_g1.h"
+#include "tb_cfg.h"
+#endif
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+#if 0  // obsolete functions
+static void * (*G1DWLInit)(struct DWLInitParam * param) = NULL;
+static i32 (*G1DWLRelease)(const void *instance) = NULL;
+
+static void mpeg2_dec_dlsym_priv_func(v4l2_dec_inst* h)
+{
+    ASSERT(h->dec_dll_handle);
+    G1DWLInit = dlsym(h->dec_dll_handle, "DWLInit");
+    G1DWLRelease = dlsym(h->dec_dll_handle, "DWLRelease");
+    ASSERT(G1DWLInit);
+    ASSERT(G1DWLRelease);
+}
+#endif
+
+/**
+ * @brief mpeg2_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int mpeg2_dec_release_pic(v4l2_dec_inst* h, void* pic) {
+  Mpeg2DecRet ret = MPEG2DEC_OK;
+  ASSERT(pic);
+  ret = Mpeg2DecPictureConsumed(h->decoder_inst, (Mpeg2DecPicture*)pic);
+
+  ASSERT(ret == MPEG2DEC_OK);
+  return (ret == MPEG2DEC_OK) ? 0 : -1;
+}
+
+static int mpeg2_dec_remove_buffer(v4l2_dec_inst* h) {
+  Mpeg2DecRet rv = MPEG2DEC_OK;
+  rv = Mpeg2DecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+static int mpeg2_dec_add_buffer(v4l2_dec_inst* h,
+                                struct DWLLinearMem* mem_obj) {
+  Mpeg2DecRet rv = MPEG2DEC_OK;
+  if (mem_obj) {
+    rv = Mpeg2DecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Mpeg2DecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == MPEG2DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == MPEG2DEC_OK || rv == MPEG2DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief mpeg2_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void mpeg2_dec_add_external_buffer(v4l2_dec_inst* h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief mpeg2_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param u32 eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int mpeg2_dec_get_pic(v4l2_dec_inst* h,
+                             vsi_v4l2_dec_picture* dec_pic_info, u32 eos) {
+  Mpeg2DecPicture* dec_picture = (Mpeg2DecPicture*)h->priv_pic_data;
+  Mpeg2DecRet re = MPEG2DEC_OK;
+
+  do {
+    re = Mpeg2DecNextPicture(h->decoder_inst, dec_picture, 0);
+  } while (eos && (re != MPEG2DEC_END_OF_STREAM) && (re != MPEG2DEC_PIC_RDY) &&
+           (re != MPEG2DEC_OK));
+
+  if (re != MPEG2DEC_PIC_RDY) return -1;
+
+  if (h->dec_interlaced_sequence) {
+    if (dec_picture->output_other_field) {
+      re = Mpeg2DecNextPicture(h->decoder_inst, dec_picture, 0);
+      if (re != MPEG2DEC_PIC_RDY) return -1;
+    }
+  }
+
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  dec_pic_info->pic_stride = dec_picture->frame_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_picture_bus_address +
+      dec_picture->frame_width * dec_picture->frame_height;
+
+  dec_pic_info->sar_width = 0;
+  dec_pic_info->sar_height = 0;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief mpeg2_dec_get_vui_info(), get vui info.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param Mpeg2DecInfo* dec_info: new seq. header info.
+ * @return .
+ */
+static void mpeg2_dec_get_vui_info(v4l2_dec_inst* h, Mpeg2DecInfo* dec_info) {
+  h->dec_info.colour_description_present_flag =
+      dec_info->colour_description_present_flag;
+  h->dec_info.matrix_coefficients = dec_info->matrix_coefficients;
+  h->dec_info.colour_primaries = dec_info->colour_primaries;
+  h->dec_info.transfer_characteristics = dec_info->transfer_characteristics;
+  h->dec_info.video_range = dec_info->video_range;
+}
+
+/**
+ * @brief mpeg2_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param Mpeg2DecInfo* dec_info: new seq. header info.
+ * @param Mpeg2DecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static u32 mpeg2_dec_check_res_change(v4l2_dec_inst* h, Mpeg2DecInfo* dec_info,
+                                      Mpeg2DecBufferInfo* buf_info) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((dec_info->frame_width != h->dec_info.frame_width) ||
+      (dec_info->frame_height != h->dec_info.frame_height) ||
+      (dec_info->coded_width != h->dec_info.visible_rect.width) ||
+      (dec_info->coded_height != h->dec_info.visible_rect.height) ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->frame_width, dec_info->frame_height);
+    h->dec_info.frame_width = dec_info->frame_width;
+    h->dec_info.frame_height = dec_info->frame_height;
+    h->dec_info.visible_rect.width = dec_info->coded_width;
+    h->dec_info.visible_rect.height = dec_info->coded_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_interlaced_sequence = dec_info->interlaced_sequence;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+
+/**
+ * @brief mpeg2_update_input(), update in_mem & dec_input according to
+ * dec_output info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param Mpeg2DecInput *dec_input.
+ * @param Mpeg2DecOutput *dec_output.
+ * @return .
+ */
+static void mpeg2_update_input(struct DWLLinearMem* in_mem,
+                               Mpeg2DecInput* dec_input,
+                               Mpeg2DecOutput* dec_output) {
+  if (dec_output->data_left) {
+    dec_input->stream_bus_address +=
+        (dec_output->strm_curr_pos - dec_input->stream);
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+  } else {
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+    dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  }
+  in_mem->logical_size = dec_input->data_len;
+  in_mem->virtual_address = (u32*)dec_input->stream;
+  in_mem->bus_address = dec_input->stream_bus_address;
+}
+
+/**
+ * @brief mpeg2_dec_init(), mpeg2 decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event mpeg2_dec_init(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  Mpeg2DecRet ret;
+  struct DecDownscaleCfg dscale_cfg;
+  u32 num_frame_buffers = 0;
+  u32 dpb_mode = DEC_DPB_FRAME;
+  struct DWLInitParam dwl_init;
+
+  dwl_init.client_type = DWL_CLIENT_TYPE_MPEG2_DEC;
+
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  dscale_cfg.down_scale_x = 0;
+  dscale_cfg.down_scale_y = 0;
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT)
+    dpb_mode = DEC_DPB_INTERLACED_FIELD;
+
+  ret = Mpeg2DecInit((Mpeg2DecInst*)(&h->decoder_inst), h->dwl_inst, 0,
+                     num_frame_buffers,
+                     h->dec_output_fmt | (dpb_mode == DEC_DPB_INTERLACED_FIELD
+                                              ? DEC_DPB_ALLOW_FIELD_ORDERING
+                                              : 0),
+                     0, 0, &dscale_cfg);
+  if (MPEG2DEC_OK != ret) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Mpeg2DecInit failed
");
+    goto end;
+  }
+
+  return DEC_EMPTY_EVENT;
+
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief mpeg2_dec_decode(), mpeg decoding function.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event:event for state machine.
+ */
+v4l2_inst_dec_event mpeg2_dec_decode(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  u32 skip_non_reference = 0;
+
+  Mpeg2DecRet ret = MPEG2DEC_OK;
+  Mpeg2DecInput dec_input = {0};
+  Mpeg2DecOutput dec_output = {0};
+  Mpeg2DecInfo dec_info = {0};
+  Mpeg2DecBufferInfo hbuf = {0};
+
+  struct DWLLinearMem* in_mem = &h->stream_in_mem;
+  Mpeg2DecInst dec_inst = h->decoder_inst;
+
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.stream = (u8*)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+  dec_input.pic_id = h->dec_pic_id; /*curr_pic_id*/
+
+  do {
+    ret = Mpeg2DecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Mpeg2DecDecode ret %d decoded pic %d
", ret,
+               h->dec_pic_id);
+
+    switch (ret) {
+      case MPEG2DEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case MPEG2DEC_HDRS_RDY:
+#ifdef VSI_CMODEL
+        TBSetRefbuMemModel(&tb_cfg, ((DecContainer*)dec_inst)->mpeg2_regs,
+                           &((DecContainer*)dec_inst)->ref_buffer_ctrl);
+#endif
+
+        Mpeg2DecGetBufferInfo(dec_inst, &hbuf);
+        if (Mpeg2DecGetInfo(dec_inst, &dec_info) != MPEG2DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+#if 0
+            if(mpeg2_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+                 re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+                 goto update_input;
+             }
+#endif
+        mpeg2_dec_get_vui_info(h, &dec_info);
+        break;
+
+      case MPEG2DEC_PIC_DECODED:
+        if (Mpeg2DecGetInfo(dec_inst, &dec_info) != MPEG2DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+      case MPEG2DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+        break;
+      case MPEG2DEC_NONREF_PIC_SKIPPED:
+      case MPEG2DEC_STRM_PROCESSED:
+        break;
+      case MPEG2DEC_BUF_EMPTY:
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        break;
+
+      case MPEG2DEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Waiting for frame buffers
");
+        Mpeg2DecGetBufferInfo(dec_inst, &hbuf);
+        if (Mpeg2DecGetInfo(dec_inst, &dec_info) != MPEG2DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto error;
+        }
+
+        if (mpeg2_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          h->consumed_len += dec_input.data_len - dec_output.data_left;
+          goto update_input;
+        }
+
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          mpeg2_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+        break;
+
+      case MPEG2DEC_OK:
+        break;
+
+      case MPEG2DEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          mpeg2_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto update_input;
+        }
+
+      case MPEG2DEC_PARAM_ERROR:
+      case MPEG2DEC_STRM_ERROR:
+      case MPEG2DEC_HW_BUS_ERROR:
+        HANTRO_LOG(HANTRO_LEVEL_WARNING, "INCORRECT STREAM PARAMS
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case MPEG2DEC_END_OF_STREAM:
+        re_dec_event = DEC_GOT_EOS_MARK_EVENT;
+        goto end;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+    /* break out of do-while if max_num_pics reached (data_len set to 0) */
+    if (dec_input.data_len == 0) break;
+
+    mpeg2_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.data_len > 0);
+  in_mem->logical_size = 0;
+  if ((ret == MPEG2DEC_OK) || (ret == MPEG2DEC_STRM_PROCESSED) ||
+      (ret == MPEG2DEC_NONREF_PIC_SKIPPED) || (ret == MPEG2DEC_PIC_DECODED)) {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  }
+error:
+  if (dec_output.data_left == dec_input.data_len) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  mpeg2_update_input(in_mem, &dec_input, &dec_output);
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief mpeg2_dec_destroy(), mpeg decoder destory function.
+ * @param v4l2_dec_inst* inst: daemon instance (IN).
+ * @param vsi_v4l2_msg* v4l2_msg: output buffer which send to v4l2-driver (IN).
+ * @return v4l2_inst_dec_event:state event
+ */
+v4l2_inst_dec_event mpeg2_dec_destroy(v4l2_dec_inst* h,
+                                      vsi_v4l2_msg* v4l2_msg) {
+  Mpeg2DecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief mpeg2_dec_drain(), mpeg decoder draining function.
+ * @param v4l2_dec_inst* inst: daemon instance (IN).
+ * @return int: value of Mpeg2DecEndOfStream return.
+ */
+int mpeg2_dec_drain(v4l2_dec_inst* h) {
+  Mpeg2DecRet ret = MPEG2DEC_OK;
+  ret = Mpeg2DecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == MPEG2DEC_OK);
+  return ret;
+}
+
+/**
+ * @brief mpeg2_dec_seek(), mpeg decoder seek function.
+ * @param v4l2_dec_inst* inst: daemon instance (IN).
+ * @param vsi_v4l2_msg* v4l2_msg: output buffer which send to v4l2-driver (IN).
+ * @return v4l2_inst_dec_event:state event
+ */
+v4l2_inst_dec_event mpeg2_dec_seek(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  Mpeg2DecRet ret = MPEG2DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = Mpeg2DecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Mpeg2DecAbort returns %d
", ret);
+  ret = Mpeg2DecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(mpeg2, V4L2_DAEMON_CODEC_DEC_MPEG2, sizeof(Mpeg2DecPicture),
+          DEC_ATTR_NONE);  // vsidaemon_mpeg2_v4l2m2m_decoder
diff --git a/v4l2_vsi_daemon/src/vsi_dec_mpeg4.c b/v4l2_vsi_daemon/src/vsi_dec_mpeg4.c
new file mode 100755
index 0000000..c056351
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_mpeg4.c
@@ -0,0 +1,535 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_mpeg4.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include <dlfcn.h>
+
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+#include "mp4decapi.h"
+
+#ifdef VSI_CMODEL
+#include "mp4dechwd_container.h"
+#include "tb_cfg.h"
+#endif
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+#define DEFAULT_FILED_STATUS (0)
+#define WAIT_SEC_FILED (1)
+#define GOT_SEC_FILED (2)
+
+typedef struct { u32 field_status; } mpeg4_dec_priv_data;
+
+/**
+ * @brief mpeg4_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int mpeg4_dec_release_pic(v4l2_dec_inst *h, void *pic) {
+  MP4DecRet ret;
+  ASSERT(pic);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "MP4DecPictureConsumed  bus address: %lx
",
+             ((MP4DecPicture *)pic)->output_picture_bus_address);
+  ret = MP4DecPictureConsumed(h->decoder_inst, (MP4DecPicture *)pic);
+
+  ASSERT(ret == MP4DEC_OK);
+  return (ret == MP4DEC_OK) ? 0 : -1;
+}
+static int mpeg4_dec_remove_buffer(v4l2_dec_inst* h) {
+  MP4DecRet rv = MP4DEC_OK;
+  rv = MP4DecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+/**
+ * @brief mpeg4_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int mpeg4_dec_add_buffer(v4l2_dec_inst *h,
+                                struct DWLLinearMem *mem_obj) {
+  MP4DecRet rv = MP4DEC_OK;
+  if (mem_obj) {
+    rv = MP4DecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "MP4DecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == MP4DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == MP4DEC_OK || rv == MP4DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief mpeg4_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void mpeg4_dec_add_external_buffer(v4l2_dec_inst *h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief mpeg4_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param u32 eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int mpeg4_dec_get_pic(v4l2_dec_inst *h,
+                             vsi_v4l2_dec_picture *dec_pic_info, u32 eos) {
+  mpeg4_dec_priv_data *mp4_priv = (mpeg4_dec_priv_data *)h->priv_data;
+  MP4DecPicture *dec_picture = (MP4DecPicture *)h->priv_pic_data;
+  MP4DecRet re = MP4DEC_OK;
+
+  do {
+    re = MP4DecNextPicture(h->decoder_inst, dec_picture, 0);
+  } while (eos && (re != MP4DEC_END_OF_STREAM) && (re != MP4DEC_PIC_RDY) &&
+           (re != MP4DEC_OK));
+
+  if (re != MP4DEC_PIC_RDY) return -1;
+
+  if (dec_picture->field_picture) {
+    if (mp4_priv->field_status == DEFAULT_FILED_STATUS) {
+      re = MP4DecNextPicture(h->decoder_inst, dec_picture, 0);
+      if (re != MP4DEC_PIC_RDY) {
+        mp4_priv->field_status = WAIT_SEC_FILED;
+        return -1;
+      }
+    } else if (mp4_priv->field_status == WAIT_SEC_FILED) {
+      mp4_priv->field_status = GOT_SEC_FILED;
+    }
+    mp4_priv->field_status = DEFAULT_FILED_STATUS;
+  }
+
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  dec_pic_info->pic_stride = dec_picture->frame_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_picture_bus_address +
+      dec_picture->frame_width * dec_picture->frame_height;
+
+  dec_pic_info->sar_width =
+      dec_picture->coded_width;  // unsure the coded_width or the frame_width.
+  dec_pic_info->sar_height = dec_picture->coded_height;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief mpeg4_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param MP4DecInfo* dec_info: new seq. header info.
+ * @param MP4DecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static u32 mpeg4_dec_check_res_change(v4l2_dec_inst *h, MP4DecInfo *dec_info,
+                                      MP4DecBufferInfo *buf_info) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((dec_info->frame_width != h->dec_info.frame_width) ||
+      (dec_info->frame_height != h->dec_info.frame_height) ||
+      (dec_info->coded_width != h->dec_info.visible_rect.width) ||
+      (dec_info->coded_height != h->dec_info.visible_rect.height) ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->frame_width, dec_info->frame_height);
+    h->dec_info.frame_width = dec_info->frame_width;
+    h->dec_info.frame_height = dec_info->frame_height;
+    h->dec_info.visible_rect.width = dec_info->coded_width;
+    h->dec_info.visible_rect.height = dec_info->coded_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+/**
+ * @brief mpeg4_update_input(), update in_mem & dec_input according to
+ * dec_output info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param MP4DecInput *dec_input.
+ * @param MP4DecOutput *dec_output.
+ * @return
+ */
+static void mpeg4_update_input(struct DWLLinearMem *in_mem,
+                               MP4DecInput *dec_input,
+                               MP4DecOutput *dec_output) {
+  if (dec_output->data_left) {
+    dec_input->stream_bus_address +=
+        (dec_output->strm_curr_pos - dec_input->stream);
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+  } else {
+    dec_input->data_len = dec_output->data_left;
+    dec_input->stream = dec_output->strm_curr_pos;
+    dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  }
+  in_mem->logical_size = dec_input->data_len;
+  in_mem->bus_address = dec_input->stream_bus_address;
+  in_mem->virtual_address = (u32 *)dec_input->stream;
+}
+
+/**
+ * @brief mpeg4_dec_init(), mpeg4 decoder init functioin
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event mpeg4_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  MP4DecApiVersion dec_api;
+  MP4DecBuild dec_build;
+  MP4DecRet re;
+  u32 dpb_mode = DEC_DPB_FRAME;
+  u32 ds_ratio_x = 0, ds_ratio_y = 0;
+  struct DecDownscaleCfg dscale_cfg;
+
+  /* Print API version number */
+  dec_api = MP4DecGetAPIVersion();
+  dec_build = MP4DecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 MPEG4 Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_MPEG4_DEC;
+
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  dscale_cfg.down_scale_x = ds_ratio_x;
+  dscale_cfg.down_scale_y = ds_ratio_y;
+
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT)
+    dpb_mode = DEC_DPB_INTERLACED_FIELD;
+
+  re =
+      MP4DecInit((MP4DecInst *)(&h->decoder_inst), h->dwl_inst, MP4DEC_MPEG4, 0,
+                 0, h->dec_output_fmt | (dpb_mode == DEC_DPB_INTERLACED_FIELD
+                                             ? DEC_DPB_ALLOW_FIELD_ORDERING
+                                             : 0),
+                 0, 0, &dscale_cfg);
+
+  if (re != MP4DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "MP4DecInit failed
");
+    goto end;
+  }
+
+#ifdef VSI_CMODEL
+  if (TBGetDecRlcModeForced(&tb_cfg) != 0) {
+    /*Force the decoder into RLC mode */
+    ((DecContainer *)h->decoder_inst)->rlc_mode = 1;
+  }
+#endif
+
+  h->priv_data = calloc(1, sizeof(mpeg4_dec_priv_data));
+  ASSERT(h->priv_data);
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief mpeg4_dec_decode(), mpeg4 decoding functioin
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event mpeg4_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+  u32 skip_non_reference = 0;
+
+  MP4DecInput dec_input = {0};
+  MP4DecOutput dec_output = {0};
+  MP4DecInfo dec_info;
+  MP4DecBufferInfo hbuf = {0};
+  MP4DecRet re_buf_info;
+
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+
+  MP4DecInst dec_inst = h->decoder_inst;
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.stream = (u8 *)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+  dec_input.pic_id = h->dec_pic_id; /*curr_pic_id*/
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream, dec_input.stream_bus_address,
+             dec_input.data_len);
+
+  do {
+    ret = MP4DecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "MP4DecDecode ret %d decoded pic %d, out_pid %d
", ret,
+               h->dec_pic_id, h->dec_out_pic_id);
+    switch (ret) {
+      case MP4DEC_STRM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case MP4DEC_HDRS_RDY:
+      case MP4DEC_DP_HDRS_RDY:
+        re_buf_info = MP4DecGetBufferInfo(dec_inst, &hbuf);
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "MP4DecGetBufferInfo ret %d
",
+                   re_buf_info);
+        if (MP4DecGetInfo(dec_inst, &dec_info) != MP4DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        break;
+
+      case MP4DEC_PIC_DECODED:
+        if (MP4DecGetInfo(dec_inst, &dec_info) != MP4DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case MP4DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+      case MP4DEC_STRM_PROCESSED:
+      case MP4DEC_NONREF_PIC_SKIPPED:
+      case MP4DEC_VOS_END:
+        break;
+
+      case MP4DEC_BUF_EMPTY:
+      case MP4DEC_PARAM_ERROR:
+      case MP4DEC_STRM_ERROR:
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        // dec_output.data_left = 0;
+        break;
+
+      case MP4DEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Waiting for frame buffers
");
+        re_buf_info = MP4DecGetBufferInfo(dec_inst, &hbuf);
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "MP4DecGetBufferInfo ret %d
",
+                   re_buf_info);
+        if (MP4DecGetInfo(dec_inst, &dec_info) != MP4DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto error;
+        }
+
+        if (mpeg4_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+          goto update_input;
+        }
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          mpeg4_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+
+        break;
+
+      case MP4DEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case MP4DEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          mpeg4_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+      case MP4DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.data_len - dec_output.data_left;
+
+    /* break out of do-while if max_num_pics reached (data_len set to 0) */
+    if (dec_input.data_len == 0) break;
+
+    mpeg4_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.data_len > 0);
+
+  in_mem->logical_size = 0;
+
+  if ((ret != MP4DEC_OK) && (ret != MP4DEC_STRM_PROCESSED) &&
+      (ret != MP4DEC_NONREF_PIC_SKIPPED) && (ret != MP4DEC_PIC_DECODED)) {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  }
+
+error:
+  if (dec_output.data_left == dec_input.data_len) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  mpeg4_update_input(in_mem, &dec_input, &dec_output);
+
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief mpeg4_dec_destroy(), mpeg4 decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event mpeg4_dec_destroy(v4l2_dec_inst *h,
+                                      vsi_v4l2_msg *v4l2_msg) {
+  if (h->priv_data) {
+    free(h->priv_data);
+    h->priv_data = NULL;
+  }
+  MP4DecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish 
");
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief mpeg4_dec_drain(), mpeg4 draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return int: value of MP4DecEndOfStream return.
+ */
+int mpeg4_dec_drain(v4l2_dec_inst *h) {
+  MP4DecRet ret = MP4DEC_OK;
+  ret = MP4DecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == MP4DEC_OK);
+  return ret;
+}
+
+/**
+ * @brief mpeg4_dec_seek(), mpeg4 seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event mpeg4_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  MP4DecRet ret = MP4DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = MP4DecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "MP4DecAbort returns %d
", ret);
+  ret = MP4DecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(mpeg4, V4L2_DAEMON_CODEC_DEC_MPEG4, sizeof(MP4DecPicture),
+          DEC_ATTR_NONE);  // vsidaemon_mpeg4_v4l2m2m_decoder
diff --git a/v4l2_vsi_daemon/src/vsi_dec_rv.c b/v4l2_vsi_daemon/src/vsi_dec_rv.c
new file mode 100755
index 0000000..f02649f
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_rv.c
@@ -0,0 +1,648 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_rv.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+
+#include <dlfcn.h>
+
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+#include "rvdecapi.h"
+
+#ifdef VSI_CMODEL
+#include "deccfg.h"
+#include "tb_cfg.h"
+#endif
+
+#define FAKE_DECODER_INST (-1)
+#define FRAME_BUFFERS (0)
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+#define ERROR_MODE (-1)
+#define RV_MODE 0
+#define RAW_MODE 1
+#define RV_SLICE_DATA_ALIGN 1
+#define RV_MAX_SLICE_NUM 128
+
+typedef struct RV_PRIV_DATA {
+  u32 stream_mode;
+  u32 total_slice_info_size;
+  u32 slice_info_num;
+  RvDecSliceInfo slice_info[128];
+} RV_PRIV_DATA;
+
+static i32 rv_get_stream_mode(struct DWLLinearMem *in_mem) {
+  u8 *buff = (u8 *)in_mem->virtual_address;
+  if (strncmp((const char *)(buff + 8), "RV30", 4) == 0 ||
+      (strncmp((const char *)(buff + 8), "RV40", 4) == 0)) {
+    return RV_MODE;
+  } else {
+    return RAW_MODE;
+  }
+}
+
+static u32 rv_dec_parse_sliceinfo(struct DWLLinearMem *in_mem,
+                                  RvDecSliceInfo *slice_info) {
+  u32 slice_info_num = 0, frame_length = 0, hdr_bytes = 0;
+  u32 i;
+  u8 *buff = NULL;
+
+  if (RV_MODE == rv_get_stream_mode(in_mem)) {
+        u8 *frame_hdr_p = (u8 *)in_mem->virtual_address;
+        u32 frame_hdr_length = (frame_hdr_p[0] << 24) | (frame_hdr_p[1] << 16) | (frame_hdr_p[2] << 8) | (frame_hdr_p[3] << 0);
+        if (frame_hdr_length >= in_mem->logical_size) {
+            HANTRO_LOG(HANTRO_LEVEL_DEBUG, "repeatedly transfer codec data
");
+            return 0;
+        }
+        in_mem->logical_size -= frame_hdr_length;
+        in_mem->virtual_address = (u32 *)((u8 *)in_mem->virtual_address + frame_hdr_length);
+        in_mem->bus_address = (addr_t)((u8 *)in_mem->bus_address + frame_hdr_length);
+  }
+
+  buff = (u8 *)in_mem->virtual_address;
+
+  frame_length =
+      (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | (buff[3] << 0);
+
+  buff += 16;
+  slice_info_num =
+      (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | (buff[3] << 0);
+  if ((slice_info_num > RV_MAX_SLICE_NUM) || (slice_info_num == 0)) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "slice_info_num invalid: %d
", slice_info_num);
+    return 0;
+  }
+
+  hdr_bytes = 20 + slice_info_num * 8;
+  if ((frame_length == 0) || (frame_length > (in_mem->logical_size - hdr_bytes))) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "frame_length(%d), buffer payload size(%d)
",
+                frame_length, in_mem->logical_size - hdr_bytes);
+    return 0;
+  }
+
+  for (i = 0; i < slice_info_num; i++) {
+    buff += 4;
+    slice_info[i].is_valid =
+        (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | (buff[3] << 0);
+    buff += 4;
+    slice_info[i].offset =
+        (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | (buff[3] << 0);
+  }
+
+  return slice_info_num;
+}
+
+static void rv_dec_init_rv_mode(v4l2_dec_inst *h) {
+  u8 *buff;
+  int nPicWidth, nPicHeight;
+  u32 is_rv8 = 0, num_frame_sizes = 0, length = 0, frame_code_len = 0;
+  u32 frame_sizes[18];
+  u32 size[9] = {0, 1, 1, 2, 2, 3, 3, 3, 3};
+  u32 tiled_output = DEC_REF_FRM_RASTER_SCAN;
+
+  struct DecDownscaleCfg dscale_cfg = {0};
+  RvDecRet re;
+
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+  buff = (u8 *)in_mem->virtual_address;
+  length = (buff[0] << 24) | (buff[1] << 16) | (buff[2] << 8) | (buff[3] << 0);
+  (void)length;
+  if (strncmp((const char *)(buff + 8), "RV30", 4) == 0)
+    is_rv8 = 1;
+  else
+    is_rv8 = 0;
+
+  nPicWidth = (buff[12] << 8) | buff[13];
+  nPicHeight = (buff[14] << 8) | buff[15];
+
+  if (is_rv8) {
+    u32 j = 0;
+    u8 *p = buff + 26;
+    num_frame_sizes = 1 + (p[1] & 0x7);
+    p += 8;
+    frame_sizes[0] = nPicWidth;
+    frame_sizes[1] = nPicHeight;
+    for (j = 1; j < num_frame_sizes; j++) {
+      frame_sizes[2 * j + 0] = (*p++) << 2;
+      frame_sizes[2 * j + 1] = (*p++) << 2;
+    }
+  }
+
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT)
+    tiled_output = DEC_REF_FRM_TILED_DEFAULT;
+
+  frame_code_len = size[num_frame_sizes];
+  re = RvDecInit((RvDecInst *)(&h->decoder_inst), h->dwl_inst, 0,
+                 frame_code_len, frame_sizes, is_rv8 ? 0 : 1, nPicWidth,
+                 nPicHeight, FRAME_BUFFERS, tiled_output, 0, 0, &dscale_cfg);
+
+  if (re != RVDEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "rvDecInit failed
");
+    ASSERT(0);
+  }
+  in_mem->logical_size -= length;
+  in_mem->virtual_address = (u32 *)((u8 *)in_mem->virtual_address + length);
+  in_mem->bus_address = (addr_t)((u8 *)in_mem->bus_address + length);
+  if (in_mem->logical_size != 0) {
+    HANTRO_LOG(HANTRO_LEVEL_WARNING,
+               "dirty stream header data in one buffer
");
+  }
+}
+
+static void rv_dec_init_raw_mode(v4l2_dec_inst *h) {
+  u8 *buff;
+  u32 is_rv8 = 0;
+  u32 tiled_output = DEC_REF_FRM_RASTER_SCAN;
+  struct DecDownscaleCfg dscale_cfg = {0};
+  RvDecRet re;
+
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+  buff = (u8 *)in_mem->virtual_address;
+  if (buff[0] == 0 && buff[1] == 0 && buff[2] == 1) {
+    is_rv8 = 1;
+  }
+
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT)
+    tiled_output = DEC_REF_FRM_TILED_DEFAULT;
+
+  re = RvDecInit((RvDecInst *)(&h->decoder_inst), h->dwl_inst,
+                 DEC_EC_PICTURE_FREEZE, 0, 0, is_rv8 ? 0 : 1, 0, 0,
+                 FRAME_BUFFERS, tiled_output, 0, 0, &dscale_cfg);
+  if (re != RVDEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "rvDecInit failed
");
+    ASSERT(0);
+  }
+}
+
+/**
+ * @brief rv_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int rv_dec_release_pic(v4l2_dec_inst *h, void *pic) {
+  RvDecRet ret;
+  ASSERT(pic);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rvDecPictureConsumed  bus address: %lx
",
+             ((RvDecPicture *)pic)->output_picture_bus_address);
+  ret = RvDecPictureConsumed(h->decoder_inst, (RvDecPicture *)pic);
+  ASSERT(ret == RVDEC_OK);
+  return (ret == RVDEC_OK) ? 0 : -1;
+}
+static int rv_dec_remove_buffer(v4l2_dec_inst* h) {
+  RvDecRet rv = RVDEC_OK;
+  rv = RvDecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+
+/**
+ * @brief rv_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int rv_dec_add_buffer(v4l2_dec_inst *h, struct DWLLinearMem *mem_obj) {
+  RvDecRet rv = RVDEC_OK;
+  if (mem_obj) {
+    rv = RvDecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "RvDecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == RVDEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == RVDEC_OK || rv == RVDEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief rv_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void rv_dec_add_external_buffer(v4l2_dec_inst *h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief rv_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param u32 eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int rv_dec_get_pic(v4l2_dec_inst *h, vsi_v4l2_dec_picture *dec_pic_info,
+                          u32 eos) {
+  RvDecInfo dec_info = {0};
+  RvDecPicture *dec_picture = (RvDecPicture *)h->priv_pic_data;
+  RvDecRet re = RVDEC_OK;
+  do {
+    re = RvDecNextPicture(h->decoder_inst, dec_picture, 0);
+  } while (eos && re != RVDEC_END_OF_STREAM && re != RVDEC_PIC_RDY &&
+           re != RVDEC_OK);
+
+  if (RVDEC_PIC_RDY != re) return -1;
+
+  RvDecGetInfo(h->decoder_inst, &dec_info);
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  dec_pic_info->pic_stride = dec_picture->frame_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_picture_bus_address +
+      dec_pic_info->pic_stride * dec_picture->frame_height;
+
+  dec_pic_info->sar_width = 0;
+  dec_pic_info->sar_height = 0;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief rv_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param RvDecInfo* dec_info: new seq. header info.
+ * @param RvDecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static u32 rv_dec_check_res_change(v4l2_dec_inst *h, RvDecInfo *dec_info,
+                                   RvDecBufferInfo *buf_info) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((dec_info->frame_width * 16 != h->dec_info.frame_width) ||
+      (dec_info->frame_height * 16 != h->dec_info.frame_height) ||
+      (dec_info->coded_width != h->dec_info.visible_rect.width) ||
+      (dec_info->coded_height != h->dec_info.visible_rect.height) ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_WARNING,
+               "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->frame_width * 16, dec_info->frame_height * 16);
+    h->dec_info.frame_width = dec_info->frame_width * 16;
+    h->dec_info.frame_height = dec_info->frame_height * 16;
+    h->dec_info.visible_rect.left = 0;
+    h->dec_info.visible_rect.top = 0;
+    h->dec_info.visible_rect.width = dec_info->coded_width;
+    h->dec_info.visible_rect.height = dec_info->coded_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+  return res_change;
+}
+
+/**
+ * @brief rv_update_input(), update in_mem according to dec_output info.
+ * @param struct DWLLinearMem *in_mem.
+ * @param RvDecInput *dec_input.
+ * @param RvDecOutput *dec_output.
+ * @return .
+ */
+static void rv_update_input(struct DWLLinearMem *in_mem,
+                            RvDecOutput *dec_output) {
+#if 0
+    ASSERT(dec_output->data_left == 0);
+    in_mem->logical_size = 0;//dec_output->data_left;
+#else
+  in_mem->logical_size =
+      0;  // Raw mode dec_output->data_left =1 when finish decode
+#endif
+}
+
+/**
+ * @brief rv_dec_init(), rv decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event rv_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  RvDecApiVersion dec_api;
+  RvDecBuild dec_build;
+  /* Print API version number */
+  dec_api = RvDecGetAPIVersion();
+  dec_build = RvDecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 H.264 Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_RV_DEC;
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+  h->decoder_inst = (void *)FAKE_DECODER_INST;
+  h->priv_data = calloc(1, sizeof(RV_PRIV_DATA));
+  ASSERT(h->priv_data);
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief rv_dec_decode(), rv decoding function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event rv_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+  u32 strm_processed_count = 32;
+  u32 skip_non_reference = 0;
+  RvDecInput dec_input = {0};
+  RvDecOutput dec_output = {0};
+  RvDecInfo dec_info = {0};
+  RvDecBufferInfo hbuf = {0};
+  RvDecInst dec_inst = NULL;
+  struct DWLLinearMem *in_mem = NULL;
+  RV_PRIV_DATA *rv_priv = (RV_PRIV_DATA *)h->priv_data;
+  if (h->decoder_inst == (void *)FAKE_DECODER_INST) {
+    rv_priv->stream_mode = rv_get_stream_mode(&h->stream_in_mem);
+    if (rv_priv->stream_mode == RV_MODE) {
+      rv_dec_init_rv_mode(h);
+      goto end;
+    } else {
+      rv_dec_init_raw_mode(h);
+    }
+  }
+  dec_inst = h->decoder_inst;
+  in_mem = &h->stream_in_mem;
+  if (rv_priv->stream_mode == RV_MODE) {
+    if (rv_priv->total_slice_info_size == 0) {
+      rv_priv->slice_info_num =
+          rv_dec_parse_sliceinfo(in_mem, rv_priv->slice_info);
+      if (rv_priv->slice_info_num == 0) 
+        goto update_input;
+
+      rv_priv->total_slice_info_size = NEXT_MULTIPLE(
+          16 + rv_priv->slice_info_num * 8 + 4, RV_SLICE_DATA_ALIGN);
+      in_mem->logical_size -= rv_priv->total_slice_info_size;
+#if 0
+            memmove((u8 *)in_mem->virtual_address, 
+                    (u8 *)in_mem->virtual_address + rv_priv->total_slice_info_size,
+                    in_mem->logical_size);
+#else
+      in_mem->virtual_address = (u32 *)((u8 *)in_mem->virtual_address +
+                                        rv_priv->total_slice_info_size);
+      in_mem->bus_address =
+          (addr_t)((u8 *)in_mem->bus_address + rv_priv->total_slice_info_size);
+#endif
+    }
+  }
+
+  dec_input.stream = (u8 *)in_mem->virtual_address;
+  dec_input.stream_bus_address = (addr_t)in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+
+  dec_input.slice_info_num =
+      (rv_priv->stream_mode == RV_MODE) ? rv_priv->slice_info_num : 0;
+  dec_input.slice_info =
+      (rv_priv->stream_mode == RV_MODE) ? rv_priv->slice_info : NULL;
+
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.pic_id = h->dec_pic_id;
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream, dec_input.stream_bus_address,
+             dec_input.data_len);
+  do {
+    ret = RvDecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "RvDecDecode ret %d decoded pic %d, out_pid %d
", ret,
+               h->dec_pic_id, h->dec_out_pic_id);
+    switch (ret) {
+      case RVDEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case RVDEC_HDRS_RDY:
+        RvDecGetBufferInfo(dec_inst, &hbuf);
+        if (RvDecGetInfo(dec_inst, &dec_info) != RVDEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        break;
+
+      case RVDEC_PIC_DECODED:
+        if (RvDecGetInfo(dec_inst, &dec_info) != RVDEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        dec_input.data_len = dec_output.data_left;
+#endif
+        goto update_input;
+
+      case RVDEC_OK:
+      case RVDEC_PIC_CONSUMED:
+      case RVDEC_NONREF_PIC_SKIPPED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len - dec_output.data_left;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+#endif
+      goto update_input;
+
+      case RVDEC_STRM_PROCESSED:
+        if (dec_output.data_left == dec_input.data_len && strm_processed_count--) {
+            break;
+        }
+        goto update_input;
+
+      case RVDEC_BUF_EMPTY:
+      case RVDEC_STRM_ERROR:
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        break;
+
+      case RVDEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Waiting for frame buffers
");
+        RvDecGetBufferInfo(dec_inst, &hbuf);
+        if (RvDecGetInfo(dec_inst, &dec_info) != RVDEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        if (rv_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          h->consumed_len += dec_input.data_len - dec_output.data_left;
+          goto end;
+        }
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          rv_dec_add_external_buffer(h);
+        } else {
+          goto end;
+        }
+        break;
+
+      case RVDEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          rv_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+      case RVDEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+    }
+    h->consumed_len += dec_input.data_len - dec_output.data_left;
+  } while (dec_output.data_left > 0);
+
+  if ((ret != RVDEC_OK) && (ret != RVDEC_STRM_PROCESSED) &&
+      (ret != RVDEC_NONREF_PIC_SKIPPED) && (ret != RVDEC_PIC_DECODED) &&
+      (ret != RVDEC_PIC_CONSUMED)) {
+    re_dec_event = DEC_FATAL_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+  }
+
+update_input:
+  rv_priv->total_slice_info_size = 0;
+  rv_update_input(in_mem, &dec_output);
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief rv_dec_destroy(), rv decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event rv_dec_destroy(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  if (h->priv_data) {
+    free(h->priv_data);
+    h->priv_data = NULL;
+  }
+  RvDecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish 
");
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief rv_dec_drain(), rv draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return int: value of rvDecEndOfStream return.
+ */
+int rv_dec_drain(v4l2_dec_inst *h) {
+  RvDecRet ret = RVDEC_OK;
+  ret = RvDecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == RVDEC_OK);
+  return ret;
+}
+
+/**
+ * @brief rv_dec_seek(), rv seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event rv_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  RvDecRet ret = RVDEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = RvDecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rvDecAbort returns %d
", ret);
+  ret = RvDecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(rv, V4L2_DAEMON_CODEC_DEC_RV, sizeof(RvDecPicture),
+          DEC_ATTR_NONE);  // vsidaemon_rv_v4l2m2m_decoder
diff --git a/v4l2_vsi_daemon/src/vsi_dec_vc1.c b/v4l2_vsi_daemon/src/vsi_dec_vc1.c
new file mode 100755
index 0000000..c0f40fe
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_vc1.c
@@ -0,0 +1,875 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_vc1.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+#include <dlfcn.h>
+
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+#include "vsi_dec.h"
+
+#include "vc1decapi.h"
+
+#ifdef VSI_CMODEL
+#include "deccfg.h"
+#include "tb_cfg.h"
+#include "vc1hwd_container.h"
+#endif
+
+#define SHOW1(p) \
+  (p[0]);        \
+  p += 1;
+#define SHOW2(p)        \
+  (p[0]) | (p[1] << 8); \
+  p += 2;
+#define SHOW3(p)                       \
+  (p[0]) | (p[1] << 8) | (p[2] << 16); \
+  p += 3;
+#define SHOW4(p)                                      \
+  (p[0]) | (p[1] << 8) | (p[2] << 16) | (p[3] << 24); \
+  p += 4;
+#define VC1L_FILE_HEADER_SIZE (9 * 4)
+#define FAKE_DECODER_INST (-1)
+#define VC1_IS_NAL_HDR(data, offset)                           \
+  ((data[offset + 0] == 0x00) && (data[offset + 1] == 0x00) && \
+   (data[offset + 2] == 0x01))
+
+static u32 ds_ratio_x, ds_ratio_y;
+static u32 tiled_output = DEC_REF_FRM_RASTER_SCAN;
+static u32 dpb_mode = DEC_DPB_FRAME;
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+static const u8 *DecodeRCV(const u8 *stream, u32 strm_len,
+                           VC1DecMetaData *meta_data) \
+{
+  u32 tmp1 = 0;
+  u8 *p;
+  u32 rcv_metadata_size = 0;
+  p = (u8 *)stream;
+
+  if (strm_len >= 20 /*RCV Seq Hdr length*/) {
+    // standard RCV sequence Header
+    tmp1 = SHOW3(p);
+    tmp1 = SHOW1(p);
+    rcv_metadata_size = SHOW4(p);
+
+    if ((tmp1 & 0x85) != 0x85 || rcv_metadata_size != 0x4) {
+      // not a RCV Seq Hdr.
+      return stream;
+    }
+
+    /* Decode image dimensions */
+    p += rcv_metadata_size;
+    tmp1 = SHOW4(p);
+    meta_data->max_coded_height = tmp1;
+    tmp1 = SHOW4(p);
+    meta_data->max_coded_width = tmp1;
+
+    return (stream + 8);
+  }
+
+  return stream;
+}
+
+/**
+ * @brief vc1_dec_release_pic(), to notify ctrlsw one output picture has been
+ * consumed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param void* pic: pointer of consumed pic.
+ * @return .
+ */
+static int vc1_dec_release_pic(v4l2_dec_inst *h, void *pic) {
+  VC1DecRet ret;
+  ASSERT(pic);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "VC1DecPictureConsumed  bus address: %lx
",
+             ((VC1DecPicture *)pic)->output_picture_bus_address);
+  ret = VC1DecPictureConsumed(h->decoder_inst, (VC1DecPicture *)pic);
+
+  ASSERT(ret == VC1DEC_OK);
+  return (ret == VC1DEC_OK) ? 0 : -1;
+}
+static int vc1_dec_remove_buffer(v4l2_dec_inst *h) {
+  VC1DecRet rv = VC1DEC_OK;
+  rv = VC1DecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+/**
+ * @brief vc1_dec_add_buffer(), to add one queued buffer into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return 0: succeed; other: failed.
+ */
+static int vc1_dec_add_buffer(v4l2_dec_inst *h, struct DWLLinearMem *mem_obj) {
+  VC1DecRet rv = VC1DEC_OK;
+  if (mem_obj) {
+    rv = VC1DecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "VC1DecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == VC1DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == VC1DEC_OK || rv == VC1DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+/**
+ * @brief vc1_dec_add_external_buffer(), to add queued buffers into ctrlsw.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static void vc1_dec_add_external_buffer(v4l2_dec_inst *h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+/**
+ * @brief vc1_dec_get_pic(), get one renderable pic from dpb.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_dec_picture* dec_pic_info: pointer of pic info.
+ * @param u32 eos: to indicate end of stream or not.
+ * @return int: 0: get an output pic successfully; others: failed to get.
+ */
+static int vc1_dec_get_pic(v4l2_dec_inst *h, vsi_v4l2_dec_picture *dec_pic_info,
+                           u32 eos) {
+  VC1DecPicture *dec_picture = (VC1DecPicture *)h->priv_pic_data;
+  VC1DecRet re = VC1DEC_OK;
+
+  do {
+    re = VC1DecNextPicture(h->decoder_inst, dec_picture, 0);
+  } while (eos && (re != VC1DEC_END_OF_STREAM) && (re != VC1DEC_PIC_RDY) &&
+           (re != VC1DEC_OK));
+  if (re != VC1DEC_PIC_RDY) return -1;
+
+  if (h->dec_interlaced_sequence && dec_picture->first_field) {
+    re = VC1DecNextPicture(h->decoder_inst, dec_picture, 0);
+    if (re != VC1DEC_PIC_RDY) return -1;
+  }
+
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  dec_pic_info->pic_stride = dec_picture->frame_width;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_picture_bus_address;
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_picture_bus_address +
+      dec_picture->frame_width * dec_picture->frame_height;
+
+  dec_pic_info->sar_width = dec_picture->coded_width;
+  dec_pic_info->sar_height = dec_picture->coded_height;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+/**
+ * @brief vc1_dec_check_res_change(), check if resolution changed.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param VC1DecInfo* dec_info: new seq. header info.
+ * @param VC1DecBufferInfo buf_info: new buffer info.
+ * @return int: 0: no change; 1: changed.
+ */
+static u32 vc1_dec_check_res_change(v4l2_dec_inst *h, VC1DecInfo *dec_info,
+                                    VC1DecBufferInfo *buf_info) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((NEXT_MULTIPLE(dec_info->max_coded_width, 16) !=
+       h->dec_info.frame_width) ||
+      (NEXT_MULTIPLE(dec_info->max_coded_height, 16) !=
+       h->dec_info.frame_height) ||
+      ((buf_info->buf_num + EXTRA_DPB_BUFFER_NUM) !=
+       h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "VC1 Max codec w/h Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->max_coded_width, dec_info->max_coded_height);
+    h->dec_info.frame_width = NEXT_MULTIPLE(dec_info->max_coded_width, 16);
+    h->dec_info.frame_height = NEXT_MULTIPLE(dec_info->max_coded_height, 16);
+    h->dec_info.visible_rect.left = 0;
+    h->dec_info.visible_rect.width = dec_info->max_coded_width;
+    h->dec_info.visible_rect.top = 0;
+    h->dec_info.visible_rect.height = dec_info->max_coded_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = buf_info->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = buf_info->next_buf_size;
+    h->dec_interlaced_sequence = dec_info->interlaced_sequence;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+/**
+ * @brief vc1l_update_input(), update in_mem & dec_input according to dec_output
+ * info for vc1 base/main profile.
+ * @param struct DWLLinearMem *in_mem.
+ * @param VC1DecInput *dec_input.
+ * @param VC1DecOutput *dec_output.
+ * @return .
+ */
+static void vc1l_update_input(struct DWLLinearMem *in_mem,
+                              VC1DecInput *dec_input,
+                              VC1DecOutput *dec_output) {
+  if (dec_output->data_left) {
+    // dec_input->stream_bus_address += (dec_output->p_stream_curr_pos -
+    // dec_input->stream);
+    // dec_input->stream_size = dec_output->data_left;
+    // dec_input->stream = dec_output->p_stream_curr_pos;
+  } else {
+    dec_input->stream_size = dec_output->data_left;
+    // dec_input->stream = dec_output->p_stream_curr_pos;
+    // dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  }
+  in_mem->logical_size = dec_input->stream_size;
+  in_mem->bus_address = dec_input->stream_bus_address;
+  in_mem->virtual_address = (u32 *)dec_input->stream;
+}
+
+/**
+ * @brief vc1l_dec_init(), vc1 decoder init function for vc1 base/main profile.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vc1l_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  VC1DecApiVersion dec_api;
+  VC1DecBuild dec_build;
+  /* Print API version number */
+  dec_api = VC1DecGetAPIVersion();
+  dec_build = VC1DecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 VC1 Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_VC1_DEC;
+  h->decoder_inst = (void *)FAKE_DECODER_INST;
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief vc1l_dec_decode(), vc1 decoding function for base/main profile.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vc1l_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+  u32 skip_non_reference = 0;
+
+  VC1DecInput dec_input = {0};
+  VC1DecOutput dec_output = {0};
+  VC1DecInfo dec_info = {0};
+  VC1DecBufferInfo hbuf = {0};
+
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+  VC1DecInst dec_inst = h->decoder_inst;
+  dec_input.stream = (u8 *)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.stream_size = in_mem->logical_size;
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+  if (h->decoder_inst == (void *)FAKE_DECODER_INST) {
+    const u8 *tmp_strm = dec_input.stream;
+    const u8 *p_meta_data = NULL;
+    struct DecDownscaleCfg dscale_cfg = {0};
+    dscale_cfg.down_scale_x = ds_ratio_x;
+    dscale_cfg.down_scale_y = ds_ratio_y;
+    VC1DecRet re;
+    enum DecDpbFlags flags = 0;
+    u32 num_frame_buffers = 0;
+    VC1DecMetaData meta_data = {0};
+
+    p_meta_data = DecodeRCV(tmp_strm, dec_input.stream_size, &meta_data);
+    VC1DecUnpackMetaData(p_meta_data, 4, &meta_data);
+    if (meta_data.max_coded_width == 0 || meta_data.max_coded_height == 0) {
+      meta_data.max_coded_width =
+          v4l2_msg->params.dec_params.io_buffer.srcwidth;
+      meta_data.max_coded_height =
+          v4l2_msg->params.dec_params.io_buffer.srcheight;
+    }
+    if (tiled_output) flags |= DEC_REF_FRM_TILED_DEFAULT;
+    if (dpb_mode == DEC_DPB_INTERLACED_FIELD)
+      flags |= DEC_DPB_ALLOW_FIELD_ORDERING;
+
+    re = VC1DecInit((VC1DecInst *)(&h->decoder_inst), h->dwl_inst, &meta_data,
+#ifdef VSI_CMODEL
+                    TBGetDecErrorConcealment(&tb_cfg),
+#else
+                    DEC_EC_NONE,
+#endif
+                    num_frame_buffers, flags, 0, 0, &dscale_cfg);
+
+    if (re != VC1DEC_OK) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "VC1DecInit failed
");
+      goto end;
+    }
+    in_mem->logical_size = 0;
+    dec_inst = h->decoder_inst;
+    goto end;
+  }
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream, dec_input.stream_bus_address,
+             dec_input.stream_size);
+  do {
+    ret = VC1DecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "VC1DecDecode ret %d decoded pic %d, out_pid %d
", ret,
+               h->dec_pic_id, h->dec_out_pic_id);
+    switch (ret) {
+      case VC1DEC_FORMAT_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case VC1DEC_RESOLUTION_CHANGED:
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting dec info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "New res w/h <%dx%d>
",
+                   dec_info.coded_width, dec_info.coded_height);
+        break;
+
+      case VC1DEC_HDRS_RDY:
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        if ((dec_info.max_coded_width > h->dec_info.frame_width) ||
+            (dec_info.max_coded_height > h->dec_info.frame_height)) {
+          HANTRO_LOG(HANTRO_LEVEL_WARNING,
+                     "daemon get larger framed w/h <%dx%d>-><%dx%d>
",
+                     h->dec_info.frame_width, h->dec_info.frame_height,
+                     dec_info.max_coded_width, dec_info.max_coded_height);
+        }
+        break;
+
+      case VC1DEC_WAITING_FOR_BUFFER:
+        VC1DecGetBufferInfo(dec_inst, &hbuf);
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting dec info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        if (vc1_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          h->consumed_len += dec_input.stream_size - dec_output.data_left;
+          goto update_input;
+        }
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+        if (h->dpb_buffer_added == 0) {
+          vc1_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+        break;
+
+      case VC1DEC_PIC_DECODED:
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.stream_size - dec_output.data_left;
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case VC1DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.stream_size - dec_output.data_left;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case VC1DEC_END_OF_SEQ:
+        dec_input.stream_size = 0;
+        break;
+
+      case VC1DEC_STRM_PROCESSED:
+      case VC1DEC_NONREF_PIC_SKIPPED:
+        // dec_output.data_left = 0;
+        break;
+
+      case VC1DEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case VC1DEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          vc1_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+      case VC1DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.stream_size - dec_output.data_left;
+
+    if (dec_input.stream_size == 0) break;
+
+    vc1l_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.stream_size > 0);
+
+  in_mem->logical_size = 0;
+
+  if ((ret != VC1DEC_OK) && (ret != VC1DEC_STRM_PROCESSED) &&
+      (ret != VC1DEC_NONREF_PIC_SKIPPED) && (ret != VC1DEC_PIC_DECODED) &&
+      (ret != VC1DEC_PIC_CONSUMED)) {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  }
+
+error:
+  if (dec_output.data_left == dec_input.stream_size) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+
+update_input:
+  vc1l_update_input(in_mem, &dec_input, &dec_output);
+
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief vc1g_update_input(), update in_mem & dec_input according to dec_output
+ * info for vc1 advance profile.
+ * @param struct DWLLinearMem *in_mem.
+ * @param VC1DecInput *dec_input.
+ * @param VC1DecOutput *dec_output.
+ * @return .
+ */
+static void vc1g_update_input(struct DWLLinearMem *in_mem,
+                              VC1DecInput *dec_input,
+                              VC1DecOutput *dec_output) {
+  if (dec_output->data_left) {
+    dec_input->stream_bus_address +=
+        (dec_output->p_stream_curr_pos - dec_input->stream);
+    dec_input->stream_size = dec_output->data_left;
+    dec_input->stream = dec_output->p_stream_curr_pos;
+  } else {
+    dec_input->stream_size = dec_output->data_left;
+    dec_input->stream = dec_output->p_stream_curr_pos;
+    dec_input->stream_bus_address = dec_output->strm_curr_bus_address;
+  }
+  in_mem->logical_size = dec_input->stream_size;
+  in_mem->bus_address = dec_input->stream_bus_address;
+  in_mem->virtual_address = (u32 *)dec_input->stream;
+}
+
+/**
+ * @brief vc1g_dec_init(), vc1 decoder init function for advance profile.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vc1g_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  VC1DecApiVersion dec_api;
+  VC1DecBuild dec_build;
+  struct DecDownscaleCfg dscale_cfg;
+  VC1DecRet re;
+  /* Print API version number */
+  dec_api = VC1DecGetAPIVersion();
+  dec_build = VC1DecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 VC1 Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_VC1_DEC;
+
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  dscale_cfg.down_scale_x = ds_ratio_x;
+  dscale_cfg.down_scale_y = ds_ratio_y;
+  enum DecDpbFlags flags = 0;
+  u32 num_frame_buffers = 0;
+  VC1DecMetaData meta_data = {0};
+  meta_data.profile = 8;
+
+  if (tiled_output) flags |= DEC_REF_FRM_TILED_DEFAULT;
+  if (dpb_mode == DEC_DPB_INTERLACED_FIELD)
+    flags |= DEC_DPB_ALLOW_FIELD_ORDERING;
+
+  re = VC1DecInit((VC1DecInst *)(&h->decoder_inst), h->dwl_inst, &meta_data,
+#ifdef VSI_CMODEL
+                  TBGetDecErrorConcealment(&tb_cfg),
+#else
+                  DEC_EC_NONE,
+#endif
+                  num_frame_buffers, flags, 0, 0, &dscale_cfg);
+
+  if (re != VC1DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VC1DecInit failed
");
+    goto end;
+  }
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief vc1g_dec_decode(), vc1 decoding function for advance profile.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vc1g_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+  u32 skip_non_reference = 0;
+  u32 raw_frame_data = 0;
+  VC1DecInput dec_input = {0};
+  VC1DecOutput dec_output = {0};
+  VC1DecInfo dec_info = {0};
+  VC1DecBufferInfo hbuf = {0};
+
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+  VC1DecInst dec_inst = h->decoder_inst;
+  dec_input.stream = (u8 *)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.skip_non_reference = skip_non_reference;
+  dec_input.stream_size = in_mem->logical_size;
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+  if (h->dec_in_new_packet) {
+    if (VC1_IS_NAL_HDR(dec_input.stream, 0) ||
+        VC1_IS_NAL_HDR(dec_input.stream, 1))
+      raw_frame_data = 0;
+    else
+      raw_frame_data = 1;
+    VC1DecSetFrameDataMode(dec_inst, raw_frame_data);
+  }
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "input: %p %lx stream len: %d
",
+             dec_input.stream, dec_input.stream_bus_address,
+             dec_input.stream_size);
+  do {
+    ret = VC1DecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "VC1DecDecode ret %d decoded pic %d, out_pid %d
", ret,
+               h->dec_pic_id, h->dec_out_pic_id);
+    switch (ret) {
+      case VC1DEC_FORMAT_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case VC1DEC_RESOLUTION_CHANGED:
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting dec info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "New res w/h <%dx%d>
",
+                   dec_info.coded_width, dec_info.coded_height);
+        break;
+
+      case VC1DEC_HDRS_RDY:
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        if ((dec_info.max_coded_width > h->dec_info.frame_width) ||
+            (dec_info.max_coded_height > h->dec_info.frame_height)) {
+          HANTRO_LOG(HANTRO_LEVEL_WARNING,
+                     "daemon get larger framed w/h <%dx%d>-><%dx%d>
",
+                     h->dec_info.frame_width, h->dec_info.frame_height,
+                     dec_info.max_coded_width, dec_info.max_coded_height);
+        }
+        break;
+
+      case VC1DEC_WAITING_FOR_BUFFER:
+        VC1DecGetBufferInfo(dec_inst, &hbuf);
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting dec info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        if (vc1_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          h->consumed_len += dec_input.stream_size - dec_output.data_left;
+          goto update_input;
+        }
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+        if (h->dpb_buffer_added == 0) {
+          vc1_dec_add_external_buffer(h);
+        } else {
+          goto update_input;
+        }
+        break;
+
+      case VC1DEC_PIC_DECODED:
+        if (VC1DecGetInfo(dec_inst, &dec_info) != VC1DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.stream_size - dec_output.data_left;
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case VC1DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.stream_size - dec_output.data_left;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+        break;
+
+      case VC1DEC_END_OF_SEQ:
+        dec_input.stream_size = 0;
+        break;
+
+      case VC1DEC_STRM_PROCESSED:
+      case VC1DEC_NONREF_PIC_SKIPPED:
+        // dec_output.data_left = 0;
+        break;
+
+      case VC1DEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case VC1DEC_NO_DECODING_BUFFER:
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          vc1_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+      case VC1DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+
+    h->consumed_len += dec_input.stream_size - dec_output.data_left;
+
+    if (dec_input.stream_size == 0) break;
+
+    vc1g_update_input(in_mem, &dec_input, &dec_output);
+
+  } while (dec_input.stream_size > 0);
+
+  in_mem->logical_size = 0;
+
+  if ((ret != VC1DEC_OK) && (ret != VC1DEC_STRM_PROCESSED) &&
+      (ret != VC1DEC_NONREF_PIC_SKIPPED) && (ret != VC1DEC_PIC_DECODED) &&
+      (ret != VC1DEC_PIC_CONSUMED)) {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  }
+
+error:
+  if (dec_output.data_left == dec_input.stream_size) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  vc1g_update_input(in_mem, &dec_input, &dec_output);
+
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief vc1_dec_destroy(), vc1 decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vc1_dec_destroy(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  VC1DecRelease(h->decoder_inst);
+  DWLRelease(h->dwl_inst);
+
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "finish 
");
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief vc1_dec_drain(), vc1 draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return int: value of VC1DecEndOfStream return.
+ */
+int vc1_dec_drain(v4l2_dec_inst *h) {
+  VC1DecRet ret = VC1DEC_OK;
+  ret = VC1DecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == VC1DEC_OK);
+  return ret;
+}
+
+/**
+ * @brief vc1_dec_seek(), vc1 seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vc1_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  VC1DecRet ret = VC1DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = VC1DecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "VC1DecAbort returns %d
", ret);
+  ret = VC1DecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+vsi_v4l2m2m2_deccodec vsidaemon_vc1l_v4l2m2m_decoder = {
+    .name = "vc1l_v4l2m2m",
+    .codec_id = V4L2_DAEMON_CODEC_DEC_VC1_L,
+    .pic_ctx_size = sizeof(VC1DecPicture),
+    .init = vc1l_dec_init,
+    .decode = vc1l_dec_decode,
+    .destroy = vc1_dec_destroy,
+    .drain = vc1_dec_drain,
+    .seek = vc1_dec_seek,
+    .get_pic = vc1_dec_get_pic,
+    .release_pic = vc1_dec_release_pic,
+    .add_buffer = vc1_dec_add_buffer,
+    .remove_buffer = vc1_dec_remove_buffer,
+    .capabilities = 1,
+    .wrapper_name = "vsiv4l2daemon",
+    .attributes = DEC_ATTR_NONE,
+};
+
+vsi_v4l2m2m2_deccodec vsidaemon_vc1g_v4l2m2m_decoder = {
+    .name = "vc1g_v4l2m2m",
+    .codec_id = V4L2_DAEMON_CODEC_DEC_VC1_G,
+    .pic_ctx_size = sizeof(VC1DecPicture),
+    .init = vc1g_dec_init,
+    .decode = vc1g_dec_decode,
+    .destroy = vc1_dec_destroy,
+    .drain = vc1_dec_drain,
+    .seek = vc1_dec_seek,
+    .get_pic = vc1_dec_get_pic,
+    .release_pic = vc1_dec_release_pic,
+    .add_buffer = vc1_dec_add_buffer,
+    .remove_buffer = vc1_dec_remove_buffer,
+    .capabilities = 1,
+    .wrapper_name = "vsiv4l2daemon",
+    .attributes = DEC_ATTR_NONE,
+};
diff --git a/v4l2_vsi_daemon/src/vsi_dec_vp8.c b/v4l2_vsi_daemon/src/vsi_dec_vp8.c
new file mode 100755
index 0000000..bb459e4
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_vp8.c
@@ -0,0 +1,422 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_vp8.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+
+#include "vsi_dec.h"
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+
+#include "vp8decapi.h"
+
+#ifdef VSI_CMODEL
+#include "tb_cfg.h"
+//#include "vp8hwd_container.h"
+#endif
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+static u32 webp_loop = 0;
+
+// stubs function in case multi-frame in one package
+static int vp8_dec_has_more_frames(v4l2_dec_inst* h, VP8DecInput* dec_input) {
+  return dec_input->data_len ? 1 : 0;
+}
+
+static int vp8_dec_release_pic(v4l2_dec_inst* h, void* pic) {
+  VP8DecRet ret;
+  ret = VP8DecPictureConsumed(h->decoder_inst, (VP8DecPicture*)pic);
+
+  ASSERT(ret == VP8DEC_OK);
+  return (ret == VP8DEC_OK) ? 0 : -1;
+}
+
+static int vp8_dec_remove_buffer(v4l2_dec_inst* h) {
+  VP8DecRet rv = VP8DEC_OK;
+  rv = VP8DecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return VP8DEC_OK;
+}
+
+static int vp8_dec_add_buffer(v4l2_dec_inst* h, struct DWLLinearMem* mem_obj) {
+  VP8DecRet rv = VP8DEC_OK;
+  if (mem_obj) {
+    rv = VP8DecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "VP8DecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == VP8DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == VP8DEC_OK || rv == VP8DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+}
+
+static void vp8_dec_add_external_buffer(v4l2_dec_inst* h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+static int vp8_dec_get_pic(v4l2_dec_inst* h, vsi_v4l2_dec_picture* dec_pic_info,
+                           u32 eos) {
+  VP8DecPicture* dec_picture = (VP8DecPicture*)h->priv_pic_data;
+  VP8DecRet re = VP8DEC_OK;
+
+  do {
+    re = VP8DecNextPicture(h->decoder_inst, dec_picture, 0);
+  } while (eos && (re != VP8DEC_END_OF_STREAM) && (re != VP8DEC_PIC_RDY) &&
+           (re != VP8DEC_OK));
+
+  if (re != VP8DEC_PIC_RDY) return -1;
+
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  dec_pic_info->pic_stride = dec_picture->luma_stride;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = 8;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_frame_bus_address;
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_frame_bus_address_c;
+
+  dec_pic_info->sar_width = 0;
+  dec_pic_info->sar_height = 0;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+static u32 vp8_dec_check_res_change(v4l2_dec_inst* h, VP8DecInfo* dec_info,
+                                    VP8DecBufferInfo* hbuf) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = 8;
+  if ((dec_info->frame_width != h->dec_info.frame_width) ||
+      (dec_info->frame_height != h->dec_info.frame_height) ||
+      (dec_info->coded_width != h->dec_info.visible_rect.width) ||
+      (dec_info->coded_height != h->dec_info.visible_rect.height) ||
+      ((hbuf->buf_num + EXTRA_DPB_BUFFER_NUM) != h->dec_info.needed_dpb_nums)) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->frame_width, dec_info->frame_height);
+    h->dec_info.frame_width = dec_info->frame_width;
+    h->dec_info.frame_height = dec_info->frame_height;
+    h->dec_info.visible_rect.width = dec_info->coded_width;
+    h->dec_info.visible_rect.height = dec_info->coded_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = hbuf->buf_num + EXTRA_DPB_BUFFER_NUM;
+    h->dec_info.dpb_buffer_size = hbuf->next_buf_size;
+    h->dec_info.pic_wstride = h->dec_info.frame_width;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+
+/*
+ * @brief vp8_dec_init(), vp8 decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp8_dec_init(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  VP8DecFormat dec_format;
+
+  VP8DecApiVersion dec_api;
+  VP8DecBuild dec_build;
+  VP8DecRet re;
+  enum DecDpbFlags flags = DEC_REF_FRM_RASTER_SCAN;
+
+  /* Print API version number */
+  dec_api = VP8DecGetAPIVersion();
+  dec_build = VP8DecGetBuild();
+  HANTRO_LOG(
+      HANTRO_LEVEL_INFO,
+      "
X170 VP8 Decoder API v%d.%d - SW build: %d.%d - HW build: %x

",
+      dec_api.major, dec_api.minor, dec_build.sw_build >> 16,
+      dec_build.sw_build & 0xFFFF, dec_build.hw_build);
+
+  struct DWLInitParam dwl_init;
+  dwl_init.client_type = DWL_CLIENT_TYPE_VP8_DEC;
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  // TBD: VP8 decoder can support VP7/VP8/WebP, need input info to identify it.
+  dec_format = VP8DEC_VP8;
+
+  if (h->dec_output_fmt == DEC_REF_FRM_TILED_DEFAULT)
+    flags = DEC_REF_FRM_TILED_DEFAULT;
+
+  re = VP8DecInit((VP8DecInst*)(&h->decoder_inst), h->dwl_inst, dec_format,
+                  DEC_EC_NONE, 0, flags, 0, 0);
+  if (re != VP8DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8DecInit failed
");
+    goto end;
+  }
+
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief vp8_dec_decode(), vp8 decoding function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp8_dec_decode(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  i32 ret = 0;
+
+  VP8DecInput dec_input = {0};
+  VP8DecOutput dec_output = {0};
+  VP8DecInfo dec_info;
+  VP8DecRet tmp;
+  VP8DecBufferInfo hbuf = {0};
+
+  struct DWLLinearMem* in_mem = &h->stream_in_mem;
+  VP8DecInst dec_inst = h->decoder_inst;
+
+  dec_input.stream = (u8*)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+  dec_input.slice_height = 0;          // TBD, for webP
+
+  h->dec_last_pic_got = 0;
+
+  do {
+    ret = VP8DecDecode(dec_inst, &dec_input, &dec_output);
+
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "VP8DecDecode ret %d decoded pic %d
", ret,
+               h->dec_pic_id);
+
+    switch (ret) {
+      case VP8DEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case VP8DEC_HDRS_RDY:
+        break;
+
+      case VP8DEC_PIC_CONSUMED:
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len;
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        in_mem->logical_size = 0;
+        goto end;
+#endif
+        dec_input.data_len = 0;
+        break;
+
+      case VP8DEC_PIC_DECODED:
+        /* case VP8DEC_FREEZED_PIC_RDY: */
+        /* Picture is now ready */
+        h->dec_pic_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        h->consumed_len += dec_input.data_len;
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        in_mem->logical_size = 0;
+        goto end;
+#endif
+        dec_input.data_len = 0;
+        break;
+
+      case VP8DEC_STRM_ERROR:
+        dec_input.data_len = 0;
+        break;
+
+      case VP8DEC_STRM_PROCESSED:
+        if (dec_output.data_left == 0) {
+          dec_input.data_len = 0;
+        }
+        break;
+
+      case VP8DEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO,
+                   "Strm Processed or Waiting for frame buffers
");
+        VP8DecGetBufferInfo(dec_inst, &hbuf);
+        tmp = VP8DecGetInfo(dec_inst, &dec_info);
+        if (tmp != VP8DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        if (dec_info.coded_height == 0 || dec_info.coded_width == 0) {
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        if (vp8_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          goto end;
+        }
+
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          vp8_dec_add_external_buffer(h);
+        } else {
+          goto end;
+        }
+        break;
+
+      case VP8DEC_OK:
+        if (dec_output.data_left == 0) {
+          dec_input.data_len = 0;
+          break;
+        }
+        /* nothing to do, just call again */
+        break;
+
+      case VP8DEC_NO_DECODING_BUFFER:
+        ASSERT(dec_output.data_left);
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          vp8_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+      // TBD:
+      case VP8DEC_SLICE_RDY:
+        webp_loop = 1;
+        break;
+
+      case VP8DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "FATAL ERROR: %d
", ret);
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto error;
+    }
+  } while (vp8_dec_has_more_frames(h, &dec_input));
+
+  in_mem->logical_size = 0;
+
+  if ((ret == VP8DEC_OK) || (ret == VP8DEC_STRM_PROCESSED) ||
+      (ret == VP8DEC_PIC_DECODED) || (ret == VP8DEC_PIC_CONSUMED)) {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  }
+error:
+  in_mem->logical_size = 0;
+end:
+  return re_dec_event;
+}
+
+/**
+ * @brief vp8_dec_destroy(), vp8 decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp8_dec_destroy(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  VP8DecRelease(h->decoder_inst);
+
+  DWLRelease(h->dwl_inst);
+
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief vp8_dec_drain(), vp8 draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return int: value of VP8DecEndOfStream return.
+ */
+int vp8_dec_drain(v4l2_dec_inst* h) {
+  VP8DecRet ret = VP8DEC_OK;
+  ret = VP8DecEndOfStream(h->decoder_inst, 1);
+  ASSERT(ret == VP8DEC_OK || ret == VP8DEC_END_OF_STREAM);
+  return ret;
+}
+
+/**
+ * @brief vp8_dec_seek(), vp8 seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp8_dec_seek(v4l2_dec_inst* h, vsi_v4l2_msg* v4l2_msg) {
+  VP8DecRet ret = VP8DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = VP8DecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "VP8DecAbort returns %d
", ret);
+  ret = VP8DecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(vp8, V4L2_DAEMON_CODEC_DEC_VP8, sizeof(VP8DecPicture), DEC_ATTR_NONE);
diff --git a/v4l2_vsi_daemon/src/vsi_dec_vp9.c b/v4l2_vsi_daemon/src/vsi_dec_vp9.c
new file mode 100755
index 0000000..cd67791
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_dec_vp9.c
@@ -0,0 +1,649 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_dec_vp9.c
+ * @brief V4L2 Daemon video process file.
+ * @version 0.10- Initial version
+ */
+
+#include "vsi_dec.h"
+#include "buffer_list.h"
+#include "dec_dpb_buff.h"
+
+#include "vp9decapi.h"
+
+#ifdef VSI_CMODEL
+#include "tb_cfg.h"
+#endif
+
+/*------------------------------------------------------------------------*/
+#define VP9DEC_DPB_NUMS (9)
+#define BUFFER_ALIGN_FACTOR (64)
+#define ALIGN_OFFSET(A) ((A) & (BUFFER_ALIGN_FACTOR - 1))
+#define ALIGN(A) ((A) & (~(BUFFER_ALIGN_FACTOR - 1)))
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+/*------------------------------------------------------------------------*/
+
+#ifdef VSI_CMODEL
+extern struct TBCfg tb_cfg;
+#endif
+
+/*------------------------------------------------------------------------*/
+typedef struct {
+  u32 is_superFrm;  // 0: not a super frame; 1: is a super frame.
+  u32 count;        // frame count in this super frame
+  u32 index_size;   // index size of this super frame
+  u32 cur_frm_id;   // current frame id to decode
+  u32 size[8];      // payload size of each frame
+  u32 offset[8];    // offset of each frame in current input packet.
+} VPX_SUPER_FRAME_INFO;
+
+typedef struct {
+  VPX_SUPER_FRAME_INFO super_frame_info;
+  struct Vp9DecConfig dec_cfg;
+
+  enum DecDpbFlags dec_output_fmt;
+  enum DecPicturePixelFormat dec_pixel_fmt;
+  uint32_t set_new_info;
+  u32 pic_buff_size;  //output (picture) buffer size calculated by src w/h.
+} VP9_PRIV_DATA;
+
+// stubs function in case multi-frame in one package
+static int vp9_dec_has_more_frames(v4l2_dec_inst *h,
+                                   struct Vp9DecInput *dec_input) {
+  return dec_input->data_len ? 1 : 0;
+}
+
+static int vp9_dec_release_pic(v4l2_dec_inst *h, void *pic) {
+  enum DecRet ret;
+  ret = Vp9DecPictureConsumed(h->decoder_inst, (struct Vp9DecPicture *)pic);
+  ASSERT(ret == DEC_OK);
+  return (ret == DEC_OK) ? 0 : -1;
+}
+
+/**
+ * @brief vp9_dec_set_info(), , set output & pixel format.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return .
+ */
+static u32 vp9_dec_set_info(v4l2_dec_inst *h) {
+  VP9_PRIV_DATA *priv = (VP9_PRIV_DATA *)h->priv_data;
+  struct Vp9DecConfig *dec_cfg = &(priv->dec_cfg);
+  enum DecRet rv = DEC_OK;
+
+  if (priv->dec_output_fmt == h->dec_output_fmt &&
+      priv->dec_pixel_fmt == h->dec_pixel_fmt) {
+    return 0;
+  }
+
+  if (priv->dec_output_fmt != h->dec_output_fmt) {
+    if (h->dec_output_fmt) {
+      dec_cfg->output_format = DEC_OUT_FRM_TILED_4X4;
+    } else {
+      dec_cfg->output_format = DEC_OUT_FRM_RASTER_SCAN;
+    }
+    priv->dec_output_fmt = h->dec_output_fmt;
+    priv->set_new_info = 1;
+  }
+
+  dec_cfg->pixel_format = h->dec_pixel_fmt;
+  priv->dec_pixel_fmt = h->dec_pixel_fmt;
+  rv = Vp9DecSetInfo(h->decoder_inst, &priv->dec_cfg);
+  priv->pic_buff_size = 0;
+  (void)rv;
+  return 0;
+}
+
+static int vp9_dec_remove_buffer(v4l2_dec_inst* h) {
+  enum DecRet rv = DEC_OK;
+  rv = Vp9DecRemoveBuffer(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "rv = %d, %p
", rv, h->decoder_inst);
+  return 0;
+}
+
+static int vp9_dec_add_buffer(v4l2_dec_inst *h, struct DWLLinearMem *mem_obj) {
+#if 1
+  enum DecRet rv = DEC_OK;
+  VP9_PRIV_DATA *priv = (VP9_PRIV_DATA *)h->priv_data;
+  if (mem_obj) {
+    if (h->existed_dpb_nums == 0) {
+      vp9_dec_set_info(h);
+    }
+
+    if (priv->set_new_info) {
+      return 0;
+    }
+    rv = Vp9DecAddBuffer(h->decoder_inst, mem_obj);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Vp9DecAddBuffer rv = %d, %p, %p
", rv,
+               h->decoder_inst, mem_obj);
+    if (rv == DEC_PARAM_ERROR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Inst[%lx]: Buffer is too small!
",
+            h->instance_id);
+    }
+  }
+  return (rv == DEC_OK || rv == DEC_WAITING_FOR_BUFFER) ? 0 : 1;
+#endif
+}
+
+static void vp9_dec_add_external_buffer(v4l2_dec_inst *h) {
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Add all queued buffers to ctrsw
");
+  dpb_get_buffers(h);
+  h->dpb_buffer_added = 1;
+}
+
+static int vp9_dec_get_pic(v4l2_dec_inst *h, vsi_v4l2_dec_picture *dec_pic_info,
+                           u32 eos) {
+  struct Vp9DecPicture *dec_picture = (struct Vp9DecPicture *)h->priv_pic_data;
+  u32 stride = 0;
+  enum DecRet re = DEC_OK;
+
+  do {
+    re = Vp9DecNextPicture(h->decoder_inst, dec_picture);
+  } while (eos && (re != DEC_END_OF_STREAM) && (re != DEC_PIC_RDY) &&
+           (re != DEC_OK));
+
+  if(re == DEC_FLUSHED)
+    re = Vp9DecNextPicture(h->decoder_inst, dec_picture);
+
+  if (re != DEC_PIC_RDY) return -1;
+
+  dec_pic_info->priv_pic_data = h->priv_pic_data;
+  dec_pic_info->pic_id = dec_picture->pic_id;
+
+  dec_pic_info->pic_width = dec_picture->frame_width;
+  dec_pic_info->pic_height = dec_picture->frame_height;
+  stride = ((u8 *)dec_picture->output_chroma_base -
+            (u8 *)dec_picture->output_luma_base) / dec_picture->frame_height;
+
+  if(stride != dec_picture->pic_stride) {
+    HANTRO_LOG(HANTRO_LEVEL_WARNING, "un-matched stride: calc %d, get %d
", 
+	           stride, dec_picture->pic_stride);
+  }
+
+  dec_pic_info->pic_stride = dec_picture->pic_stride;
+  dec_pic_info->pic_corrupt = 0;
+  dec_pic_info->bit_depth = dec_picture->bit_depth_luma;
+  dec_pic_info->crop_left = 0;
+  dec_pic_info->crop_top = 0;
+  dec_pic_info->crop_width = dec_picture->coded_width;
+  dec_pic_info->crop_height = dec_picture->coded_height;
+  dec_pic_info->output_picture_bus_address =
+      dec_picture->output_luma_bus_address;
+  dec_pic_info->output_picture_chroma_bus_address =
+      dec_picture->output_chroma_bus_address;
+  dec_pic_info->output_rfc_luma_bus_address = dec_picture->output_rfc_luma_bus_address;
+  dec_pic_info->output_rfc_chroma_bus_address = dec_picture->output_rfc_chroma_bus_address;
+
+  dec_pic_info->sar_width = 0;
+  dec_pic_info->sar_height = 0;
+  /* video signal info for HDR */
+  dec_pic_info->video_range = 0;
+  dec_pic_info->colour_description_present_flag = 0;
+  dec_pic_info->colour_primaries = 0;
+  dec_pic_info->transfer_characteristics = 0;
+  dec_pic_info->matrix_coefficients = 0;
+  dec_pic_info->chroma_loc_info_present_flag = 0;
+  dec_pic_info->chroma_sample_loc_type_top_field = 0;
+  dec_pic_info->chroma_sample_loc_type_bottom_field = 0;
+  /* HDR10 metadata */
+  dec_pic_info->present_flag = 0;
+  dec_pic_info->red_primary_x = 0;
+  dec_pic_info->red_primary_y = 0;
+  dec_pic_info->green_primary_x = 0;
+  dec_pic_info->green_primary_y = 0;
+  dec_pic_info->blue_primary_x = 0;
+  dec_pic_info->blue_primary_y = 0;
+  dec_pic_info->white_point_x = 0;
+  dec_pic_info->white_point_y = 0;
+  dec_pic_info->max_mastering_luminance = 0;
+  dec_pic_info->min_mastering_luminance = 0;
+  dec_pic_info->max_content_light_level = 0;
+  dec_pic_info->max_frame_average_light_level = 0;
+  return 0;
+}
+
+#if 0
+static u32 vp9_calc_osize(v4l2_dec_inst *h,
+                          struct Vp9DecInfo *dec_info,
+                          struct Vp9DecBufferInfo *hbuf) {
+  VP9_PRIV_DATA *priv = (VP9_PRIV_DATA *)h->priv_data;
+  u64 size = 0;
+  h->srcwidth = MAX(h->srcwidth, MAX(dec_info->frame_width, dec_info->scaled_width));
+  h->srcheight = MAX(h->srcheight, MAX(dec_info->frame_height, dec_info->scaled_height));
+  size = (((u64)h->srcwidth + 15) & (~15)) * (((u64)h->srcheight + 7) & (~7));
+  size *= (u64)hbuf->next_buf_size * 16 / dec_info->bit_depth;
+  priv->pic_buff_size = (u32)(size / (h->dec_info.frame_width * h->dec_info.frame_height));
+  return priv->pic_buff_size;
+}
+#endif
+
+static u32 vp9_dec_check_res_change(v4l2_dec_inst *h,
+                                    struct Vp9DecInfo *dec_info,
+                                    struct Vp9DecBufferInfo *hbuf) {
+  u32 res_change = 0;
+  h->dec_info.bit_depth = dec_info->bit_depth;
+  if ((dec_info->frame_width != h->dec_info.frame_width) ||
+      (dec_info->frame_height != h->dec_info.frame_height) ||
+      (dec_info->coded_width != h->dec_info.visible_rect.width) ||
+      (dec_info->coded_height != h->dec_info.visible_rect.height) ||
+      ((hbuf->buf_num + EXTRA_DPB_BUFFER_NUM) != h->dec_info.needed_dpb_nums) ||
+      hbuf->next_buf_size != h->dec_info.dpb_buffer_size) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Res-resolution Change <%dx%d> -> <%dx%d>
",
+               h->dec_info.frame_width, h->dec_info.frame_height,
+               dec_info->frame_width, dec_info->frame_height);
+    h->dec_info.frame_width = dec_info->frame_width;
+    h->dec_info.frame_height = dec_info->frame_height;
+    h->dec_info.visible_rect.width = dec_info->coded_width;
+    h->dec_info.visible_rect.height = dec_info->coded_height;
+    h->dec_info.src_pix_fmt = VSI_V4L2_DEC_PIX_FMT_NV12;
+    h->dec_info.needed_dpb_nums = hbuf->buf_num + EXTRA_DPB_BUFFER_NUM;
+#if 0
+    h->dec_info.dpb_buffer_size = vp9_calc_osize(h, dec_info, hbuf);
+#else
+    h->dec_info.dpb_buffer_size = hbuf->next_buf_size;
+#endif
+
+    h->dec_info.pic_wstride = dec_info->pic_stride;
+    res_change = 1;
+  }
+
+  return res_change;
+}
+
+
+/*
+ * @brief vp9_dec_init(), vp9 decoder init function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp9_dec_init(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  enum DecRet ret = DEC_OK;
+  VP9_PRIV_DATA *priv;
+  struct DWLInitParam dwl_init = {0};
+  dwl_init.client_type = DWL_CLIENT_TYPE_VP9_DEC;
+  h->dwl_inst = DWLInit(&dwl_init);
+  ASSERT(h->dwl_inst);
+
+  h->priv_data = malloc(sizeof(VP9_PRIV_DATA));
+  ASSERT(h->priv_data);
+  memset(h->priv_data, 0, sizeof(VP9_PRIV_DATA));
+  priv = (VP9_PRIV_DATA *)h->priv_data;
+
+  struct Vp9DecConfig *dec_cfg = &(priv->dec_cfg);
+#ifdef VSI_CMODEL
+  dec_cfg->use_video_freeze_concealment = TBGetDecIntraFreezeEnable(&tb_cfg);
+#endif
+
+  dec_cfg->num_frame_buffers = VP9DEC_DPB_NUMS;
+#ifdef HAS_FULL_DECFMT
+  dec_cfg->use_video_compressor = 1;
+#else
+  dec_cfg->use_video_compressor = 0;
+#endif
+  dec_cfg->use_fetch_one_pic = 0;
+  dec_cfg->use_ringbuffer = 0;
+  dec_cfg->output_format =
+      h->dec_output_fmt ? DEC_OUT_FRM_TILED_4X4 : DEC_OUT_FRM_RASTER_SCAN;
+
+  dec_cfg->pixel_format = h->dec_pixel_fmt;
+
+  dec_cfg->dscale_cfg.down_scale_x = 1;
+  dec_cfg->dscale_cfg.down_scale_y = 1;
+  dec_cfg->use_secure_mode = h->secure_mode_on;
+  dec_cfg->use_cts_test = 1;
+  priv->set_new_info = 0;
+
+  ret = Vp9DecInit((Vp9DecInst *)(&h->decoder_inst), h->dwl_inst, dec_cfg);
+  if (ret != DEC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Vp9DecInit failed
");
+    goto end;
+  }
+
+  priv->dec_output_fmt = h->dec_output_fmt;
+  priv->dec_pixel_fmt = dec_cfg->pixel_format;
+  return DEC_EMPTY_EVENT;
+end:
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "failed
");
+  return DEC_FATAL_ERROR_EVENT;
+}
+
+/**
+ * @brief vpx_parse_superframeIndex(), parse super-frame index.
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @return
+ */
+static void vpx_parse_superframeIndex(v4l2_dec_inst *h) {
+  u8 marker;
+  u32 count = 0;
+  VPX_SUPER_FRAME_INFO *sf_info =
+      &(((VP9_PRIV_DATA *)h->priv_data)->super_frame_info);
+  const u8 *data;
+  size_t data_sz;
+  u32 this_sz = 0, total_sz = 0;
+
+  sf_info->is_superFrm = 0;
+
+  data = (u8 *)h->stream_in_mem.virtual_address;
+  data_sz = h->stream_in_mem.logical_size;
+
+  marker = DWLPrivateAreaReadByte(data + data_sz - 1);
+
+  sf_info->index_size = 0;
+
+  if ((marker & 0xe0) == 0xc0) {
+    const u32 frames = (marker & 0x7) + 1;
+    const u32 mag = ((marker >> 3) & 0x3) + 1;
+    sf_info->index_size = 2 + mag * frames;
+    u8 index_value;
+
+    if (data_sz >= sf_info->index_size) {
+      const u8 *x = data + data_sz - sf_info->index_size;
+      index_value = DWLPrivateAreaReadByte(x++);
+      if (index_value == marker) {
+        /* found a valid superframe index */
+        u32 i, j;
+        for (i = 0; i < frames; i++) {
+          this_sz = 0;
+          for (j = 0; j < mag; j++) {
+            this_sz |= DWLPrivateAreaReadByte(x++) << (j * 8);
+          }
+          sf_info->size[i] = this_sz;
+          sf_info->offset[i] = total_sz;
+          total_sz += this_sz;
+        }
+        count = frames;
+      }
+      sf_info->is_superFrm = 1;
+      sf_info->cur_frm_id = 0;
+    }
+  }
+  sf_info->count = count;
+}
+
+/**
+ * @brief vp9_dec_decode(), vp9 decoding function
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp9_dec_decode(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  v4l2_inst_dec_event re_dec_event = DEC_EMPTY_EVENT;
+  VP9_PRIV_DATA *priv = (VP9_PRIV_DATA *)h->priv_data;
+  i32 ret = 0;
+  VPX_SUPER_FRAME_INFO *sf_info =
+      &(((VP9_PRIV_DATA *)h->priv_data)->super_frame_info);
+
+  struct Vp9DecInfo dec_info = {0};
+  enum DecRet tmp;
+  struct Vp9DecBufferInfo hbuf = {0};
+
+  struct Vp9DecInput dec_input = {0};
+  struct Vp9DecOutput dec_output = {0};
+  struct DWLLinearMem *in_mem = &h->stream_in_mem;
+  Vp9DecInst dec_inst = h->decoder_inst;
+
+  dec_input.stream = (u8 *)in_mem->virtual_address;
+  dec_input.stream_bus_address = in_mem->bus_address;
+  dec_input.data_len = in_mem->logical_size;
+
+  dec_input.buffer = dec_input.stream;
+  dec_input.buffer_bus_address = ALIGN(dec_input.stream_bus_address);
+  dec_input.buff_len =
+      in_mem->logical_size + ALIGN_OFFSET(dec_input.stream_bus_address);
+
+  dec_input.pic_id = h->dec_in_pic_id; /*curr_pic_id*/
+
+  if (h->dec_in_new_packet) {
+    vpx_parse_superframeIndex(h);
+  }
+
+  if (sf_info->is_superFrm) {
+    u32 offset = sf_info->offset[sf_info->cur_frm_id];
+    dec_input.stream = (u8 *)in_mem->virtual_address + offset;
+    dec_input.stream_bus_address = in_mem->bus_address + offset;
+    dec_input.data_len = sf_info->size[sf_info->cur_frm_id];
+  }
+
+  do {
+    ret = Vp9DecDecode(dec_inst, &dec_input, &dec_output);
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "Vp9DecDecode ret %d decoded pic %d
", ret,
+               h->dec_pic_id);
+
+    switch (ret) {
+      case DEC_STREAM_NOT_SUPPORTED:
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "UNSUPPORTED STREAM! 
");
+        re_dec_event = DEC_FATAL_ERROR_EVENT;
+        goto end;
+
+      case DEC_HDRS_RDY:
+        Vp9DecGetBufferInfo(dec_inst, &hbuf);
+        tmp = Vp9DecGetInfo(dec_inst, &dec_info);
+        if (tmp != DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+#if 0
+            if(vp9_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+                 h->dec_add_buffer_allowed = 0;
+                 re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+                 goto end;
+            }
+#else
+        HANTRO_LOG(HANTRO_LEVEL_INFO,
+                   "HDRS_RDY resolution: <%dx%d> -> <%dx%d>
",
+                   h->dec_info.frame_width, h->dec_info.frame_height,
+                   dec_info.frame_width, dec_info.frame_height);
+#endif
+        break;
+
+      case DEC_PIC_DECODED:
+        /* case DEC_FREEZED_PIC_RDY: */
+        /* Picture is now ready */
+        h->dec_pic_id++;
+        sf_info->cur_frm_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_PIC_DECODED_EVENT;
+        goto update_input;
+#endif
+        dec_input.data_len = 0;
+        break;
+
+      case DEC_PENDING_FLUSH:
+        if (Vp9DecGetInfo(dec_inst, &dec_info) != DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+        re_dec_event = DEC_PENDING_FLUSH_EVENT;  // DEC_PENDING_CONSUME_EVENT;
+        goto end;
+
+      case DEC_PIC_CONSUMED:
+        sf_info->cur_frm_id++;
+#ifdef NXP_TIMESTAMP_MANAGER
+        re_dec_event = DEC_DECODING_FAILED_EVENT;
+        goto update_input;
+#endif
+        dec_input.data_len = 0;
+        break;
+
+      case DEC_WAITING_FOR_BUFFER:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Waiting for frame buffers
");
+#if 0
+            h->dec_add_buffer_allowed = 1;
+#else
+        Vp9DecGetBufferInfo(dec_inst, &hbuf);
+        /* Stream headers were successfully decoded
+         * -> stream information is available for query now */
+        if (Vp9DecGetInfo(dec_inst, &dec_info) != DEC_OK) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "ERROR in getting stream info!
");
+          re_dec_event = DEC_FATAL_ERROR_EVENT;
+          goto end;
+        }
+
+        if (vp9_dec_check_res_change(h, &dec_info, &hbuf) != 0) {
+          re_dec_event = DEC_SOURCE_CHANGE_EVENT;
+          if (priv->set_new_info) {
+              priv->set_new_info = 0;
+          }
+          goto end;
+        }
+
+#endif
+        if (h->dec_info.needed_dpb_nums > h->existed_dpb_nums) {
+          HANTRO_LOG(HANTRO_LEVEL_INFO,
+                     "Mismatch: needed dpb num %d, existed dpb num %d
",
+                     h->dec_info.needed_dpb_nums, h->existed_dpb_nums);
+          re_dec_event = DEC_WAIT_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+
+        if (h->dpb_buffer_added == 0) {
+          vp9_dec_add_external_buffer(h);
+        } else {
+          goto end;
+        }
+        break;
+
+      case DEC_OK:
+        /* nothing to do, just call again */
+        break;
+
+      case DEC_NO_DECODING_BUFFER:
+        ASSERT(dec_output.data_left);
+        if (h->dpb_buffer_added == 0 &&
+            (h->dec_info.needed_dpb_nums <= h->existed_dpb_nums)) {
+          vp9_dec_add_external_buffer(h);
+          break;
+        } else {
+          re_dec_event = DEC_NO_DECODING_BUFFER_EVENT;
+          goto end;
+        }
+      case DEC_HW_TIMEOUT:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Timeout
");
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      case DEC_STRM_PROCESSED:
+      case DEC_STRM_ERROR:
+        if (dec_output.data_left == dec_input.data_len) {
+          in_mem->logical_size = 0;
+          goto end;
+        }
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "NOT expected result: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+
+      default:
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "NOT expected result: %d
", ret);
+        re_dec_event = DEC_DECODING_ERROR_EVENT;
+        goto error;
+    }
+  } while (vp9_dec_has_more_frames(h, &dec_input));
+
+  in_mem->logical_size = 0;
+
+  if ((ret == DEC_OK) || (ret == DEC_STRM_PROCESSED) ||
+      (ret == DEC_PIC_DECODED) || (ret == DEC_PIC_CONSUMED)) {
+    re_dec_event = DEC_EMPTY_EVENT;
+    goto end;
+  } else {
+    re_dec_event = DEC_DECODING_ERROR_EVENT;
+    goto end;
+  }
+error:
+  if (dec_output.data_left == dec_input.data_len) {
+    in_mem->logical_size = 0;
+    goto end;
+  }
+update_input:
+  h->consumed_len += dec_input.data_len;
+  if (sf_info->is_superFrm) {
+    if (sf_info->count > sf_info->cur_frm_id) {
+      h->consumed_len += sf_info->index_size;
+      goto end;
+    }
+  }
+  in_mem->logical_size = 0;
+
+end:
+  if(ret != DEC_STRM_PROCESSED) {
+    h->dec_inpkt_ignore_picconsumed_event = 0;
+  }
+  return re_dec_event;
+}
+
+/**
+ * @brief vp9_dec_destroy(), vp9 decoder destroy
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp9_dec_destroy(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  if (h->priv_data) {
+    free(h->priv_data);
+    h->priv_data = NULL;
+  }
+  Vp9DecRelease(h->decoder_inst);
+
+  DWLRelease(h->dwl_inst);
+
+  return DEC_EMPTY_EVENT;
+}
+
+/**
+ * @brief vp9_dec_drain(), vp9 draing
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return int: value of Vp9DecEndOfStream return.
+ */
+int vp9_dec_drain(v4l2_dec_inst *h) {
+  enum DecRet ret = DEC_OK;
+  ret = Vp9DecEndOfStream(h->decoder_inst);
+  ASSERT(ret == DEC_OK);
+  return ret;
+}
+
+/**
+ * @brief vp9_dec_seek(), vp9 seek
+ * @param v4l2_dec_inst* h: daemon instance.
+ * @param vsi_v4l2_msg* v4l2_msg: message from v4l2 driver.
+ * @return v4l2_inst_dec_event: event for state machine.
+ */
+v4l2_inst_dec_event vp9_dec_seek(v4l2_dec_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  enum DecRet ret = DEC_OK;
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "seek
");
+  ret = Vp9DecAbort(h->decoder_inst);
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "Vp9DecAbort returns %d
", ret);
+  ret = Vp9DecAbortAfter(h->decoder_inst);
+  return DEC_EMPTY_EVENT;
+}
+
+VSIM2MDEC(vp9, V4L2_DAEMON_CODEC_DEC_VP9, sizeof(struct Vp9DecPicture),
+          DEC_ATTR_EOS_THREAD | DEC_ATTR_SUPPORT_SECURE_MODE);
diff --git a/v4l2_vsi_daemon/src/vsi_enc.c b/v4l2_vsi_daemon/src/vsi_enc.c
new file mode 100755
index 0000000..012ac43
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc.c
@@ -0,0 +1,1048 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_enc_video.c
+ * @brief V4L2 Daemon video process header file.
+ * @version 0.10- Initial version
+ */
+#include <math.h>
+
+#include "buffer_list.h"
+#include "fifo.h"
+#include "vsi_daemon_debug.h"
+#include "vsi_enc.h"
+
+#include "ewl.h"
+#ifndef USE_H1
+#include "vsi_enc_video_h2.h"
+#else
+#include "vsi_enc_video_h1.h"
+#endif
+#define MAX(a, b) ((a) > (b) ? (a) : (b))
+#define MIN(a, b) ((a) < (b) ? (a) : (b))
+
+static int trans_msg_coding_type(int type) {
+  if (type == 0)
+    return FRAMETYPE_I;
+  else if (type == 1)
+    return FRAMETYPE_P;
+  else if (type == 2)
+    return FRAMETYPE_B;
+  else {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Unsupported input.
");
+    ASSERT(0);
+    return 0;
+  }
+}
+
+static void enc_unmap_io_buff(v4l2_enc_inst *h,
+                              v4l2_daemon_enc_buffers *io_buf) {
+#ifndef USE_HW
+    unmap_phy_addr_daemon(
+        (uint32_t *)io_buf->busLuma,
+        io_buf->busLumaSize + io_buf->busChromaUSize + io_buf->busChromaVSize);
+#endif
+    unmap_phy_addr_daemon(h->saveOriOutBuf, io_buf->outBufSize);
+}
+
+static void handle_encoder_err(v4l2_enc_inst *h, vsi_v4l2_msg *v4l2_msg,
+                               v4l2_daemon_enc_buffers *io_buf,
+                               int32_t stream_size, int32_t ret, int if_unmap) {
+  if (if_unmap) {
+    enc_unmap_io_buff(h, io_buf);
+  }
+  send_enc_orphan_msg(v4l2_msg, io_buf->inbufidx, io_buf->outbufidx,
+                      stream_size, ret);
+  h->func.close(h);
+  h->inst = NULL;
+}
+
+void check_if_cbr_bitrate_changed(v4l2_enc_inst *h,
+                                  v4l2_daemon_enc_params *enc_params) {
+  if (enc_params->specific.enc_h26x_cmd.picRc == 1 &&
+      enc_params->specific.enc_h26x_cmd.hrdConformance == 1 &&
+      enc_params->general.bitPerSecond != h->cbr_last_bitrate) {
+    h->cbr_last_bitrate = enc_params->general.bitPerSecond;
+    h->cbr_bitrate_change = 1;
+  }
+}
+
+/**
+ * @brief _enc_init_func_ptr(), init the function point of the encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return void
+ */
+static void _enc_init_func_ptr(v4l2_enc_inst *h) {
+  ASSERT(h);
+#ifndef USE_H1
+  h->func.init = encoder_init_h2;
+  h->func.check_codec_format = encoder_check_codec_format_h2;
+  h->func.get_input = encoder_get_input_h2;
+  h->func.set_parameter = encoder_set_parameter_h2;
+  h->func.start = encoder_start_h2;
+  h->func.encode = encoder_encode_h2;
+  h->func.find_next_pic = encoder_find_next_pic_h2;
+  h->func.end = encoder_end_h2;
+  h->func.close = encoder_close_h2;
+  h->func.get_attr = encoder_get_attr_h2;
+  h->func.reset_enc = reset_enc_h2;
+#else
+  h->func.init = encoder_init_h1;
+  h->func.check_codec_format = encoder_check_codec_format_h1;
+  h->func.get_input = encoder_get_input_h1;
+  h->func.set_parameter = encoder_set_parameter_h1;
+  h->func.start = encoder_start_h1;
+  h->func.encode = encoder_encode_h1;
+  h->func.find_next_pic = encoder_find_next_pic_h1;
+  h->func.end = encoder_end_h1;
+  h->func.close = encoder_close_h1;
+  h->func.get_attr = encoder_get_attr_h1;
+  h->func.reset_enc = reset_enc_h1;
+#endif
+}
+
+void pair_io_buffer(v4l2_enc_inst *h) {
+    BUFFER *p_buffer_get_output = NULL;
+    BUFFER *p_buffer_get_input = NULL;
+    BUFFER *p_buffer_reorder = NULL;
+    // pairing I/O buffers
+    if (bufferlist_get_size(h->bufferlist_input) &&
+        bufferlist_get_size(h->bufferlist_output)) {
+      p_buffer_get_input = bufferlist_get_buffer(h->bufferlist_input);
+      p_buffer_get_output = bufferlist_get_buffer(h->bufferlist_output);
+      ASSERT((p_buffer_get_input != NULL) && (p_buffer_get_output != NULL));
+
+      p_buffer_get_input->enc_cmd.io_buffer.busOutBuf =
+          p_buffer_get_output->enc_cmd.io_buffer.busOutBuf;
+      p_buffer_get_input->enc_cmd.io_buffer.outBufSize =
+          p_buffer_get_output->enc_cmd.io_buffer.outBufSize;
+      p_buffer_get_input->enc_cmd.io_buffer.outbufidx =
+          p_buffer_get_output->enc_cmd.io_buffer.outbufidx;  // save buf idx.
+      p_buffer_reorder = (BUFFER *)malloc(sizeof(BUFFER));
+      memcpy(&p_buffer_reorder->enc_cmd, &p_buffer_get_input->enc_cmd,
+             sizeof(struct v4l2_daemon_enc_params));
+      p_buffer_reorder->frame_display_id =
+          p_buffer_get_input->frame_display_id;  // output num is more than
+                                                 // input num, pick the small
+                                                 // one.
+      bufferlist_push_buffer(h->bufferlist_reorder, p_buffer_reorder);
+
+      free(p_buffer_get_input);
+      free(p_buffer_get_output);
+      bufferlist_remove(h->bufferlist_input, 0);
+      bufferlist_remove(h->bufferlist_output, 0);
+    }
+}
+
+
+/*void is_buffer_in_enqueue_list(v4l2_enc_inst *h) {
+}
+*/
+
+/**
+ * @brief enc_cmd_processor(), process the input command. After
+ V4L2_DAEMON_VIDIOC_BUF_RDY received,
+          the input and output buffers are put into 2 bufferlist, respectively.
+ If both the sizes of input
+          and output buffers are none 0, it will pair the input and output
+ buffer, and add to the another
+          bufferlist. If one of the input and output buffers is 0, it will not
+ pair the input and output buffers,
+          and return a H26X_ENC_PAIRING state.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: v4l2 message.
+ * @return int32_t:The encoder state.
+ */
+int32_t enc_cmd_processor(v4l2_enc_inst *h, struct vsi_v4l2_msg *v4l2_msg) {
+  BUFFER *p_buffer_input = NULL;
+  BUFFER *p_buffer_output = NULL;
+
+  //    uint32_t list_num = 0xffffffff;
+  switch (v4l2_msg->cmd_id) {
+    case V4L2_DAEMON_VIDIOC_BUF_RDY:
+      if (v4l2_msg->params.enc_params.io_buffer.inbufidx != -1)  // input
+      {
+        p_buffer_input = (BUFFER *)malloc(sizeof(BUFFER));
+        p_buffer_input->frame_display_id = h->input_frame_cnt++;
+        if (v4l2_msg->param_type & UPDATE_INFO) {
+          memcpy(&h->mediaconfig, &v4l2_msg->params.enc_params,
+                 sizeof(struct v4l2_daemon_enc_params));
+          //this var might not be updated in next BUFRDY msg
+          h->mediaconfig.specific.enc_h26x_cmd.force_idr = 0;
+          memcpy(&p_buffer_input->enc_cmd, &v4l2_msg->params.enc_params,
+                 sizeof(struct v4l2_daemon_enc_params));
+        } else {
+          memcpy(&p_buffer_input->enc_cmd, &h->mediaconfig,
+                 sizeof(struct v4l2_daemon_enc_params));
+          memcpy(&p_buffer_input->enc_cmd.io_buffer,
+                 &v4l2_msg->params.enc_params.io_buffer,
+                 sizeof(v4l2_daemon_enc_buffers));
+          memcpy(&p_buffer_input->enc_cmd.general,
+                 &v4l2_msg->params.enc_params.general,
+                 sizeof(v4l2_daemon_enc_general_cmd));
+        }
+        // HANTRO_LOG(HANTRO_LEVEL_INFO, "[0x%lx] New input: frame %d : %d :
+        // %d
", h->handler->instance_id,p_buffer_input->frame_display_id,
+        // p_buffer_input->enc_cmd.io_buffer.bytesused,v4l2_msg->params.enc_params.io_buffer.inbufidx);
+        bufferlist_push_buffer(h->bufferlist_input, p_buffer_input);
+      } else if (v4l2_msg->params.enc_params.io_buffer.outbufidx !=
+                 -1)  // output
+      {
+        p_buffer_output = (BUFFER *)malloc(sizeof(BUFFER));
+        p_buffer_output->frame_display_id = h->output_frame_cnt++;
+        // HANTRO_LOG(HANTRO_LEVEL_INFO, "[0x%lx] New output: frame %d state
+        // %d
", h->handler->instance_id, p_buffer_output->frame_display_id,
+        // h->state);
+        if (v4l2_msg->param_type & UPDATE_INFO) {
+          memcpy(&h->mediaconfig, &v4l2_msg->params.enc_params,
+                 sizeof(struct v4l2_daemon_enc_params));
+          memcpy(&p_buffer_output->enc_cmd, &v4l2_msg->params.enc_params,
+                 sizeof(struct v4l2_daemon_enc_params));
+        } else {
+          memcpy(&p_buffer_output->enc_cmd, &h->mediaconfig,
+                 sizeof(struct v4l2_daemon_enc_params));
+          memcpy(&p_buffer_output->enc_cmd.io_buffer,
+                 &v4l2_msg->params.enc_params.io_buffer,
+                 sizeof(v4l2_daemon_enc_buffers));
+          memcpy(&p_buffer_output->enc_cmd.general,
+                 &v4l2_msg->params.enc_params.general,
+                 sizeof(v4l2_daemon_enc_general_cmd));
+        }
+        bufferlist_push_buffer(h->bufferlist_output, p_buffer_output);
+      } else {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "No I/O buffer in BUF_RDY message.
");
+        ASSERT(0);
+      }
+
+      // pairing I/O buffers
+      if(bufferlist_get_size(h->bufferlist_input) &&
+         bufferlist_get_size(h->bufferlist_output) ){
+          pair_io_buffer(h);
+          if (((h->state == ENC_ENCODING) ||
+               (h->state == ENC_PAIRING)) &&
+              (h->already_streamon == 1)) {
+            h->state = (h->already_command_stop) ? ENC_DRAIN : ENC_ENCODING;
+          }
+      }
+      else if (h->drain_input_num_total > 0) {
+            h->state = ENC_PAIRING;
+      }
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMON:
+      if (v4l2_msg->param_type == 0)  // no parameter
+      {
+      } else if (v4l2_msg->param_type ==
+                 1)  // all parameters. include input output and parameters.
+      {
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "Has Param when streamon.
");
+      }
+      if (v4l2_msg->param_type == 0 &&
+        (h->state == ENC_ENCODING || h->state == ENC_PAIRING || h->state == ENC_DRAIN)) {
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, "ignore stream on because current state is %d.
", h->state);
+        break;
+      }
+      h->state = ENC_INIT;
+      h->already_streamon = 1;
+      h->already_command_stop = h->drain_input_num_total =
+          h->drain_input_num_now = 0;
+      if (v4l2_msg->param_type)
+        h->flushbuf = 1;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_CMD_STOP:  // this is for flush.
+      h->already_command_stop = 1;
+      h->drain_input_num_total = bufferlist_get_size(h->bufferlist_input);
+      h->drain_input_num_now = 0;
+      h->state = ENC_DRAIN;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMOFF:
+    case V4L2_DAEMON_VIDIOC_EXIT:
+      h->state = ENC_RELEASED;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_FAKE:
+      break;
+    default:
+      break;
+  }
+  return 0;
+}
+
+static int64_t monotonic_time(void) {
+  struct timespec ts;
+  clock_gettime(CLOCK_MONOTONIC, &ts);
+  return (((int64_t)ts.tv_sec) * 1000000) + (ts.tv_nsec / 1000);
+}
+
+/**
+ * @brief enc_state_processor(), process the input state returned from
+ enc_cmd_processor().
+          If the state is ENC_INIT, all the parameters is ready for the encoder
+ and will be set to
+          respective structure and the encoder instance will be created. Then
+ the stream is going to be
+          encoded. If error happens, it will send orphan message to driver. If
+ the state is H26X_ENC_ENCODING,
+          the encoder is encoding the stream. If the state is H26X_ENC_DRAIN,
+ the encoder is going to handle
+          the tail of the stream, maybe last GOP or lookahead tail. If the state
+ is H26X_ENC_STOPPED,
+          the encoder is going to stop, destroy the encoder instance and the
+ worker thread will exit soon.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: v4l2 message.
+ * @return int32_t:The encoder state after process.
+ */
+v4l2_inst_state enc_state_processor(v4l2_enc_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  BUFFER *p_buffer = NULL;
+  BUFFER *p_buffer_output = NULL;
+  v4l2_daemon_enc_params *enc_params = NULL;
+  v4l2_daemon_enc_buffers *io_buf = NULL;
+  uint32_t list_num = 0xffffffff;
+  uint32_t size_header_plus_i = 0;
+  int32_t gop_tail_size = 0;
+  enc_inst_attr attr;
+  int codingType = 0;
+  int ret = 0;
+  int64_t start_time = monotonic_time();
+
+  switch (h->state) {
+    case ENC_INIT:
+      if (h->flushbuf) {
+        h->func.get_attr(h->codec_fmt, &attr);
+        ASSERT(h->enc_params);
+        memset(h->enc_params, 0, attr.param_size);
+        h->func.init(h);
+        h->flushbuf = 0;
+      }
+      /*init step 1: confirm encoder is supported by hw.*/
+      if (h->func.check_codec_format(h) != 0) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "Not support format %d.
",
+                   h->codec_fmt);
+        send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_ENC_NOT_SUPPORT);
+      }
+
+      /*init step 2: find the buffer to encode.*/
+      p_buffer = bufferlist_get_head(h->bufferlist_reorder);  // match 0
+      if (p_buffer == NULL) {
+        HANTRO_LOG(HANTRO_LEVEL_INFO,
+                   "No source buffer @ INIT state, wait...
");
+        return ENC_INIT;
+      }
+      enc_params = &p_buffer->enc_cmd;
+      io_buf = &enc_params->io_buffer;
+      bufferlist_remove(h->bufferlist_reorder, 0);
+
+      /*init step 3: set all parameters including config, rate control, prep and
+       * coding control*/
+      /*make sure first encoded frame is I*/
+      ret = h->func.set_parameter(h, enc_params, 1);
+      if (ret) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "set_parameter() failed, ret=%d
", ret);
+        handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 1);
+        free(p_buffer);  // already consumed
+        send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_ENC_PARA);
+        return ENC_STOPPED;
+      }
+
+      /*init step 4: encoder start, generate header.*/
+      ret = h->func.start(h, &size_header_plus_i);
+      if (ret) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "start() failed, ret=%d
", ret);
+        handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 1);
+        free(p_buffer);  // already consumed
+        return ENC_STOPPED;
+      }
+
+      int32_t header_size = size_header_plus_i;
+
+      /*init step 5: encoder encode, encode the frame.*/
+      ret = h->func.encode(h, &size_header_plus_i, &codingType);
+      enc_unmap_io_buff(h, io_buf);
+      if (ret != DAEMON_ENC_FRAME_READY && ret != DAEMON_ENC_FRAME_ENQUEUE) {
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "encode() @INIT state failed, ret=%d
",
+                   ret);
+        handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 0);
+        free(p_buffer);  // already consumed
+        return ENC_STOPPED;
+      }
+
+      int32_t payload_size = size_header_plus_i - header_size;
+
+      h->total_frames++;
+      h->total_time += monotonic_time() - start_time;
+      /*init step 5: inform driver when finished one frame.*/
+      v4l2_msg->param_type = trans_msg_coding_type(codingType);
+      v4l2_msg->params.enc_params.io_buffer.timestamp = io_buf->timestamp;
+      send_enc_orphan_msg(v4l2_msg, io_buf->inbufidx, io_buf->outbufidx,
+                          size_header_plus_i, ret);
+
+      //payload_size = 0; hard code for test
+      /* if the first frame is not encoded correctly, stop the encoder and inform driver. */
+      if(payload_size == 0 /*&& ret == 0*/) {//assume there is no enqueue ret.
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "encode() @INIT state failed, payload size is 0. ret=%d
", ret);
+          handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, DAEMON_ERR_ENC_FATAL_ERROR, 0);
+          free(p_buffer);   //already consumed
+          return ENC_STOPPED;
+      }
+
+      free(p_buffer);
+      h->state = ENC_ENCODING;
+      break;
+
+    case ENC_ENCODING:
+      /*encoding step 1: find next picture, get buffer and set gop structure.*/
+      if(v4l2_msg->cmd_id == V4L2_DAEMON_VIDIOC_ENC_RESET) {
+          if (h->bufferlist_input) bufferlist_flush(h->bufferlist_input);
+          if (h->bufferlist_output) bufferlist_flush(h->bufferlist_output);
+          if (h->bufferlist_reorder) bufferlist_flush(h->bufferlist_reorder);
+          h->input_frame_cnt = 0;
+          h->func.reset_enc(h);
+          return ENC_ENCODING;
+      }
+
+      h->func.find_next_pic(h, &p_buffer, &list_num);
+      if (p_buffer == NULL) {
+        break;
+      }
+      enc_params = &p_buffer->enc_cmd;
+      io_buf = &enc_params->io_buffer;
+      bufferlist_remove(h->bufferlist_reorder, list_num);
+
+      /*encoding step 2: set all parameters including config, rate control, prep
+       * and coding control*/
+      ret = h->func.set_parameter(h, enc_params, 0);
+      if (ret) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "set_parameter() failed, ret=%d
", ret);
+        handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 1);
+        free(p_buffer);  // already consumed
+        send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_ENC_PARA);
+        return ENC_STOPPED;
+      }
+
+      if (h->cbr_bitrate_change == 1 && h->next_pic_type == 0) {
+        h->func.end(h, &size_header_plus_i);
+        enc_unmap_io_buff(h, io_buf);
+        h->cbr_bitrate_change = 0;
+        h->state = ENC_INIT;
+        p_buffer->enc_cmd.specific.enc_h26x_cmd.qpHdr = -1;  // Let rc
+                                                             // calculate.
+        bufferlist_push_buffer(h->bufferlist_reorder,
+                               p_buffer);  // return this buffer.
+        return h->state;
+      }
+      /*encoding step 3: encoder encode, encode the frame.*/
+      ret = h->func.encode(h, &size_header_plus_i, &codingType);
+      enc_unmap_io_buff(h, io_buf);
+      if (ret != DAEMON_ENC_FRAME_READY && ret != DAEMON_ENC_FRAME_ENQUEUE) {
+        HANTRO_LOG(HANTRO_LEVEL_INFO, "encode() failed, ret=%d
", ret);
+        handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 0);
+        free(p_buffer);  // already consumed
+        return ENC_STOPPED;
+      }
+      h->total_frames++;
+      h->total_time += monotonic_time() - start_time;
+
+      /* hard code for test overflow*/
+      /*if(h->total_frames == 2) {
+          size_header_plus_i = 0;
+      }*/
+
+      /*encoding step 4: inform driver when finished one frame.*/
+      if(size_header_plus_i > 0) {
+          v4l2_msg->param_type = trans_msg_coding_type(codingType);
+          v4l2_msg->params.enc_params.io_buffer.timestamp = io_buf->timestamp;
+          send_enc_orphan_msg(v4l2_msg, io_buf->inbufidx, io_buf->outbufidx,
+                              size_header_plus_i, ret);
+      }
+      else if(size_header_plus_i == 0) {
+          v4l2_msg->params.enc_params.io_buffer.timestamp = io_buf->timestamp;
+          send_enc_orphan_msg(v4l2_msg, io_buf->inbufidx, -1, size_header_plus_i, ret);
+
+          p_buffer_output = (BUFFER *)malloc(sizeof(BUFFER));
+          memcpy(p_buffer_output, p_buffer, sizeof(BUFFER));
+          bufferlist_push_buffer(h->bufferlist_output, p_buffer_output);//return this buffer.
+          pair_io_buffer(h);
+      }
+
+      if (h->bufferlist_reorder->size) {
+        send_fake_cmd(h->handler);
+      }
+      free(p_buffer);  // already consumed
+      break;
+
+    case ENC_DRAIN:
+      /*drain step 1: consume left input buffers.*/
+      if (h->drain_input_num_total > 0) {
+        gop_tail_size = bufferlist_get_size(h->bufferlist_reorder);
+        for (int32_t itmp = 0; itmp < gop_tail_size; itmp++) {
+          /*find next picture.*/
+          h->func.find_next_pic(h, &p_buffer, &list_num);
+          if (p_buffer == NULL) {
+            HANTRO_LOG(HANTRO_LEVEL_INFO,
+                       "Can't find paired I/O buffers @ DRAIN state
");
+            send_enc_orphan_msg(v4l2_msg, -1, -1, size_header_plus_i, DAEMON_ERR_ENC_BUF_MISSED);
+            goto _label_enc_stopped;
+          }
+          enc_params = &p_buffer->enc_cmd;
+          io_buf = &enc_params->io_buffer;
+
+          /*set all parameters including config, rate control, prep and coding
+           * control*/
+          ret = h->func.set_parameter(h, enc_params, 0);
+          if (ret) {
+            HANTRO_LOG(HANTRO_LEVEL_ERROR, "set_parameter() failed, ret=%d
",
+                       ret);
+            handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 1);
+            free(p_buffer);  // already consumed
+            send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_ENC_PARA);
+            return ENC_STOPPED;
+          }
+
+          bufferlist_remove(h->bufferlist_reorder, list_num);
+
+          /*encode the frame.*/
+          ret = h->func.encode(h, &size_header_plus_i, &codingType);
+          enc_unmap_io_buff(h, io_buf);
+
+          h->drain_input_num_now++;
+          if (ret != DAEMON_ENC_FRAME_READY && ret != DAEMON_ENC_FRAME_ENQUEUE) {
+            HANTRO_LOG(HANTRO_LEVEL_INFO,
+                       "encode failed @ DRAIN state, ret=%d
", ret);
+            handle_encoder_err(h, v4l2_msg, io_buf, size_header_plus_i, ret, 1);
+            free(p_buffer);  // already consumed
+            return ENC_STOPPED;
+          }
+          h->total_frames++;
+          h->total_time += monotonic_time() - start_time;
+          /*inform driver when finished one frame.*/
+
+          if(size_header_plus_i > 0) {
+              v4l2_msg->param_type = trans_msg_coding_type(codingType);
+              if (h->drain_input_num_now == h->drain_input_num_total) {
+                  h->drain_input_num_total = 0;  // will send eos
+              }
+              v4l2_msg->params.enc_params.io_buffer.timestamp = io_buf->timestamp;
+              send_enc_orphan_msg(v4l2_msg, io_buf->inbufidx, io_buf->outbufidx,
+                                  size_header_plus_i, ret);
+          }
+          /*acctually, in drain state, the output buffer is enough even if we don't return the buffer.*/
+          else if(size_header_plus_i == 0) {
+              v4l2_msg->params.enc_params.io_buffer.timestamp = io_buf->timestamp;
+              send_enc_orphan_msg(v4l2_msg, io_buf->inbufidx, -1, size_header_plus_i, ret);
+
+              p_buffer_output = (BUFFER *)malloc(sizeof(BUFFER));
+              memcpy(p_buffer_output, p_buffer, sizeof(BUFFER));
+              bufferlist_push_buffer(h->bufferlist_output, p_buffer_output);//return this buffer.
+          }
+          free(p_buffer);  // already consumed
+          p_buffer = NULL;          
+        }
+      }
+      /*drain step 2: send eos after all left input buffer consumed.*/
+      else if (h->drain_input_num_total == 0) {
+        p_buffer = bufferlist_get_buffer(h->bufferlist_output);
+        if (p_buffer ==
+            NULL) {  // wait destination buffer for sequence end content
+          break;
+        }
+        enc_params = &p_buffer->enc_cmd;
+        io_buf = &enc_params->io_buffer;
+
+        h->func.get_input(h, enc_params, 0);
+
+        h->func.end(h, &size_header_plus_i);
+
+        unmap_phy_addr_daemon(h->saveOriOutBuf, io_buf->outBufSize);
+        send_enc_outputbuf_orphan_msg(v4l2_msg, io_buf->outbufidx,
+                                      size_header_plus_i, LAST_BUFFER_FLAG);
+        h->drain_input_num_total = -1;
+        bufferlist_remove(h->bufferlist_output, 0);
+        free(p_buffer);
+        send_fake_cmd(h->handler);
+        break;
+      }
+      /*drain step 3: send LAST_BUFFER_FLAG.*/
+      else if (h->drain_input_num_total == -1) {
+        p_buffer = bufferlist_get_buffer(h->bufferlist_output);
+        if (p_buffer == NULL) {  // wait destination buffer for LAST_BUFFER
+          break;
+        }
+        send_enc_outputbuf_orphan_msg(v4l2_msg,
+                                      p_buffer->enc_cmd.io_buffer.outbufidx, 0,
+                                      LAST_BUFFER_FLAG);
+        h->drain_input_num_total = -2;
+        bufferlist_remove(h->bufferlist_output, 0);
+        free(p_buffer);
+        h->state = ENC_STOPPED;
+        h->input_frame_cnt = 0;
+        break;
+      }
+      break;
+
+    case ENC_STOPPED:
+      if (h->total_time > 0) {
+        HANTRO_LOG(HANTRO_LEVEL_INFO,
+                   "Encoded frames: %ld, encode fps: %0.2f
", h->total_frames,
+                   ((double)h->total_frames * 1000000) / h->total_time);
+      }
+      if (h->inst) {
+        h->func.close(h);
+        h->inst = NULL;
+        h->state = ENC_NONE;
+      }
+      return ENC_STOPPED;
+    case ENC_RELEASED:
+      if (h->inst) {
+        h->func.close(h);
+        h->inst = NULL;
+        h->state = ENC_NONE;
+      }
+      return ENC_RELEASED;
+    default:
+      break;
+  }
+  return h->state;
+
+_label_enc_stopped:
+  h->func.close(h);
+  h->inst = NULL;
+  return ENC_STOPPED;
+}
+
+/**
+ * @brief vsi_encoder_proc(), encoder message processor.
+ * @param void* codec: encoder instance.
+ * @return int32_t: 0: succeed; 1: encoder is destroy-able.
+ */
+static int32_t vsi_encoder_proc(void *codec, struct vsi_v4l2_msg *msg) {
+  v4l2_enc_inst *h = (v4l2_enc_inst *)codec;
+  v4l2_inst_state state;
+
+  ASSERT(h);
+
+  enc_cmd_processor(h, msg);
+  state = enc_state_processor(h, msg);
+
+  return (state == ENC_RELEASED);
+}
+
+/**
+ * @brief vsi_destroy_encoder(), destroy encoder inst.
+ * @param void* codec: encoder instance.
+ * @return int32_t: 0: succeed; Others: failure.
+ */
+static int32_t vsi_destroy_encoder(void *codec) {
+  v4l2_enc_inst *h = (v4l2_enc_inst *)codec;
+
+  if (h == NULL) {
+    return -1;
+  }
+
+  h->func.close(h);
+
+  if (h->bufferlist_reorder) {
+    bufferlist_destroy(h->bufferlist_reorder);
+    free(h->bufferlist_reorder);
+    h->bufferlist_reorder = NULL;
+  }
+  if (h->bufferlist_input) {
+    bufferlist_destroy(h->bufferlist_input);
+    free(h->bufferlist_input);
+    h->bufferlist_input = NULL;
+  }
+  if (h->bufferlist_output) {
+    bufferlist_destroy(h->bufferlist_output);
+    free(h->bufferlist_output);
+    h->bufferlist_output = NULL;
+  }
+
+  if (h->enc_params) {
+    free(h->enc_params);
+    h->enc_params = NULL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief vsi_create_encoder(), create encoder inst.
+ * @param v4l2_daemon_inst* daemon_inst: daemon instance.
+ * @return void *: encoder instance.
+ */
+void *vsi_create_encoder(v4l2_daemon_inst *daemon_inst) {
+  v4l2_enc_inst *h = NULL;
+  enc_inst_attr attr;
+
+  ASSERT(daemon_inst->codec_mode == DAEMON_MODE_ENCODER);
+
+  h = (v4l2_enc_inst *)malloc(sizeof(v4l2_enc_inst));
+  ASSERT(h);
+  memset(h, 0, sizeof(v4l2_enc_inst));
+
+  h->handler = daemon_inst;
+  h->codec_fmt = daemon_inst->codec_fmt;
+  h->instance_id = daemon_inst->instance_id;
+  _enc_init_func_ptr(h);
+
+  h->func.get_attr(h->codec_fmt, &attr);
+  h->enc_params = malloc(attr.param_size);
+  ASSERT(h->enc_params);
+  memset(h->enc_params, 0, attr.param_size);
+
+  h->bufferlist_reorder = (BUFFERLIST *)malloc(sizeof(BUFFERLIST));
+  h->bufferlist_input = (BUFFERLIST *)malloc(sizeof(BUFFERLIST));
+  h->bufferlist_output = (BUFFERLIST *)malloc(sizeof(BUFFERLIST));
+  ASSERT(h->bufferlist_reorder != NULL);
+  ASSERT(h->bufferlist_input != NULL);
+  ASSERT(h->bufferlist_output != NULL);
+
+  bufferlist_init(h->bufferlist_reorder, MAX_BUFFER_SIZE);
+  bufferlist_init(h->bufferlist_input, MAX_BUFFER_SIZE);
+  bufferlist_init(h->bufferlist_output, MAX_BUFFER_SIZE);
+
+  h->func.init(h);
+
+  daemon_inst->func.proc = vsi_encoder_proc;
+  daemon_inst->func.destroy = vsi_destroy_encoder;
+  daemon_inst->func.in_source_change = NULL;
+
+  return (void *)h;
+}
+
+/**
+ * @brief vsi_enc_get_codec_format(), get supported codec formats.
+ * @param struct vsi_v4l2_dev_info *hwinfo: output info.
+ * @return int, 0 means support at least 1 format, -1 means error.
+ */
+int vsi_enc_get_codec_format(struct vsi_v4l2_dev_info *hwinfo) {
+  EWLHwConfig_t configure_t = {0};
+  int core_num = 0, has_hevc = 0, has_h264 = 0, has_av1 = 0, has_vp8 = 0,
+      has_vp9 = 0, has_jpeg = 0;
+
+  hwinfo->encformat = 0;
+
+#if (defined(NXP) && !defined(USE_H1))  // nxp v2
+  core_num = EWLGetCoreNum();
+  ASSERT(core_num != 0);
+
+  for (int i = 0; i < core_num; i++) {
+    configure_t = EWLReadAsicConfig(i);
+    has_hevc |= configure_t.hevcEnabled;
+    has_h264 |= configure_t.h264Enabled;
+    has_vp9 |= configure_t.vp9Enabled;
+    has_jpeg |= configure_t.jpegEnabled;
+  }
+  hwinfo->enc_corenum = core_num;
+  hwinfo->enc_isH1 = 0;
+
+#elif (!defined(NXP) && !defined(USE_H1))  // current vc8000e(v2,2020.06)
+  core_num = EWLGetCoreNum(NULL);
+  ASSERT(core_num != 0);
+
+  for (int i = 0; i < core_num; i++) {
+    configure_t = EWLReadAsicConfig(i, NULL);
+    has_h264 |= configure_t.h264Enabled;
+    has_hevc |= configure_t.hevcEnabled;
+    has_av1 |= configure_t.av1Enabled;
+    has_vp9 |= configure_t.vp9Enabled;
+    has_jpeg |= configure_t.jpegEnabled;
+  }
+  hwinfo->enc_corenum = core_num;
+  hwinfo->enc_isH1 = 0;
+#elif (defined(NXP) && defined(USE_H1))    // h1 single core
+  core_num = 1;
+
+  configure_t = EWLReadAsicConfig();
+  has_h264 |= configure_t.h264Enabled;
+  has_jpeg |= configure_t.jpegEnabled;
+  has_vp8 |= configure_t.vp8Enabled;
+
+  hwinfo->enc_corenum = core_num;
+  hwinfo->enc_isH1 = 1;
+#endif
+
+  hwinfo->encformat = ((has_hevc << ENC_HAS_HEVC) | (has_h264 << ENC_HAS_H264) |
+                       (has_av1 << ENC_HAS_AV1) | (has_vp8 << ENC_HAS_VP8) |
+                       (has_vp9 << ENC_HAS_VP9) | (has_jpeg << ENC_HAS_JPEG));
+  if (hwinfo->encformat)
+    return 0;
+  else
+    return -1;
+}
+
+#define HEVC_LEVEL_NUM 13
+#define H264_LEVEL_NUM 20
+
+const uint32_t VCEncMaxPicSizeHevc[ HEVC_LEVEL_NUM ] =
+{
+  36864, 122880, 245760, 552960, 983040, 2228224, 2228224, 8912896,
+  8912896, 8912896, 35651584, 35651584, 35651584
+};
+const uint32_t VCEncMaxFSH264[ H264_LEVEL_NUM ] =
+{
+  99*256, 99*256, 396*256, 396*256, 396*256, 396*256, 792*256, 1620*256
+  , 1620*256, 3600*256, 5120*256, 8192*256, 8192*256
+  , 8704*256, 22080*256, 36864*256, 36864*256
+  , 139264*256, 139264*256, 139264*256
+};
+
+const unsigned long long VCEncMaxSBPSHevc[ HEVC_LEVEL_NUM ] =
+{
+  552960, 3686400, 7372800, 16588800, 33177600, 66846720, 133693440, 267386880,
+  534773760, 1069547520, 1069547520, 2139095040, 4278190080
+};
+const unsigned long long  VCEncMaxSBPSH264[ H264_LEVEL_NUM ] =
+{
+  1485*256, 1485*256, 3000*256, 6000*256, 11880*256, 11880*256, 19800*256, 20250*256
+  , 40500*256, 108000*256, 216000*256, 245760*256, 245760*256
+  , 522240*256, 589824*256, 983040*256, 2073600*256
+  , 4177920*256, 8355840*256, 16711680ULL*256
+};
+const uint32_t VCEncMaxCPBSHevc[ HEVC_LEVEL_NUM ] =
+{
+  350000, 1500000, 3000000, 6000000, 10000000, 12000000, 20000000,
+  25000000, 40000000, 60000000, 60000000, 120000000, 240000000
+};
+const uint32_t VCEncMaxCPBSH264[ H264_LEVEL_NUM ] =
+{
+  175000, 350000, 500000, 1000000, 2000000, 2000000, 4000000, 4000000
+  , 10000000, 14000000, 20000000, 25000000, 62500000
+  , 62500000, 135000000, 240000000, 240000000
+  , 240000000, 480000000, 800000000
+};
+
+uint32_t getMaxCpbSize( v4l2_daemon_codec_fmt codecFormat , i32 levelIdx )
+{
+  ASSERT( levelIdx >= 0);
+  i32 level      = MAX(0, levelIdx);
+  u32 maxCpbSize = 0;
+
+  switch( codecFormat )
+  {
+    case V4L2_DAEMON_CODEC_ENC_HEVC:
+      ASSERT( level < HEVC_LEVEL_NUM );
+      level      = MIN( level, (HEVC_LEVEL_NUM - 1));
+      maxCpbSize = VCEncMaxCPBSHevc[ level ];
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_H264:
+      ASSERT( level < H264_LEVEL_NUM );
+      level      = MIN( level, (H264_LEVEL_NUM - 1));
+      maxCpbSize = VCEncMaxCPBSH264[ level ];
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_AV1:
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_VP9:
+      break;
+
+    default:
+      break;
+  }
+
+  return maxCpbSize;
+}
+
+static uint32_t getMaxPicSize( v4l2_daemon_codec_fmt codecFormat , i32 levelIdx )
+{
+  ASSERT( levelIdx >= 0);
+  i32 level      = MAX(0, levelIdx);
+  u32 maxPicSize = 0;
+
+  switch( codecFormat )
+  {
+    case V4L2_DAEMON_CODEC_ENC_HEVC:
+      ASSERT( level < HEVC_LEVEL_NUM );
+      level      = MIN( level, (HEVC_LEVEL_NUM - 1));
+      maxPicSize = VCEncMaxPicSizeHevc[ level ];
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_H264:
+      ASSERT( level < H264_LEVEL_NUM );
+      level      = MIN( level, (H264_LEVEL_NUM - 1));
+      maxPicSize = VCEncMaxFSH264[ level ];
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_AV1:
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_VP9:
+      break;
+
+    default:
+      break;
+  }
+
+  return maxPicSize;
+}
+
+static unsigned long long getMaxSBPS( v4l2_daemon_codec_fmt codecFormat , int32_t levelIdx )
+{
+  ASSERT( levelIdx >= 0);
+  i32 level   = MAX(0, levelIdx);
+  u64 maxSBPS = 0;
+
+  switch( codecFormat )
+  {
+    case V4L2_DAEMON_CODEC_ENC_HEVC:
+      ASSERT( level < HEVC_LEVEL_NUM );
+      level   = MIN( level, (HEVC_LEVEL_NUM - 1));
+      maxSBPS = VCEncMaxSBPSHevc[ level ];
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_H264:
+      ASSERT( level < H264_LEVEL_NUM );
+      level   = MIN( level, (H264_LEVEL_NUM - 1));
+      maxSBPS = VCEncMaxSBPSH264[ level ];
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_AV1:
+      break;
+
+    case V4L2_DAEMON_CODEC_ENC_VP9:
+      break;
+
+    default:
+      break;
+  }
+
+  return maxSBPS;
+}
+
+#ifdef USE_H1
+#define H1_H264_LVL_NUM	16
+static const uint32_t MaxBRH264[H1_H264_LVL_NUM] = {
+    76800, 153600, 230400, 460800, 921600, 2400000, 4800000, 4800000, 12000000,
+    16800000, 24000000, 24000000, 60000000, 60000000, 162000000, 288000000
+};
+
+static uint32_t getMaxBR(v4l2_daemon_codec_fmt codecFormat, int32_t levelIdx, int32_t profile)
+{
+    ASSERT(levelIdx >= 0);
+    int32_t level = MAX(0, levelIdx);
+    uint32_t maxBR = 0;
+
+    switch(codecFormat)
+    {
+    case V4L2_DAEMON_CODEC_ENC_H264:
+        level = MIN(level, (H1_H264_LVL_NUM - 1));
+        maxBR = MaxBRH264[level];
+        break;
+    default:
+        break;
+    }
+
+    return maxBR;
+}
+#else		//USE_H1
+static const uint32_t VCEncMaxBR[HEVC_LEVEL_NUM + H264_LEVEL_NUM] = {
+  /* HEVC Level Limits */
+  350000, 1500000, 3000000, 6000000, 10000000, 12000000, 20000000,
+  25000000, 40000000, 60000000, 60000000, 120000000, 240000000
+  /* H.264 Level Limits */
+  , 64000, 128000, 192000, 384000, 768000, 2000000, 4000000, 4000000
+  , 10000000, 14000000, 20000000, 20000000, 50000000
+  , 50000000, 135000000, 240000000, 240000000
+  , 240000000, 480000000, 800000000
+};
+
+static uint32_t getMaxBR(v4l2_daemon_codec_fmt codecFormat, int32_t level, int32_t profile)
+{
+  float h264_high10_factor = 1;
+  if(profile == 11)				//VCENC_H264_HIGH_PROFILE
+    h264_high10_factor = 1.25;
+  else if(profile == 12)		//VCENC_H264_HIGH_10_PROFILE
+    h264_high10_factor = 3.0;
+  //tier is always main for now
+  if (codecFormat == V4L2_DAEMON_CODEC_ENC_HEVC)
+    return VCEncMaxBR[level] * h264_high10_factor;
+  if (codecFormat == V4L2_DAEMON_CODEC_ENC_H264)
+    return VCEncMaxBR[level + HEVC_LEVEL_NUM] * h264_high10_factor;
+  return 0;
+}
+#endif	//USE_H1
+
+int32_t calculate_level(v4l2_daemon_codec_fmt     format, int32_t width, int32_t height,
+                            uint32_t frameRateNum, uint32_t frameRateDenom, uint32_t bitPerSecond, int32_t profile)
+{
+    uint32_t sample_per_picture = width * height;
+    uint32_t sample_per_second = sample_per_picture * frameRateNum / frameRateDenom;
+    int32_t i = 0, j = 0, k = 0, leveIdx = 0;
+    int32_t maxLevel = 0;
+    switch(format)
+    {
+      case V4L2_DAEMON_CODEC_ENC_HEVC:
+        maxLevel = HEVC_LEVEL_NUM - 1;
+        break;
+      case V4L2_DAEMON_CODEC_ENC_H264:
+        maxLevel = H264_LEVEL_NUM - 1;
+        break;
+      default:
+        break;
+    }
+
+    if(sample_per_picture >  getMaxPicSize(format, maxLevel) || sample_per_second > getMaxSBPS(format, maxLevel))
+    {
+      HANTRO_LOG(HANTRO_LEVEL_INFO, "encoder level max.
");
+    }
+    for(i = 0; i < maxLevel; i++)
+    {
+      if(sample_per_picture <= getMaxPicSize(format, i))
+        break;
+    }
+    for(j = 0; j < maxLevel; j++)
+    {
+      if(sample_per_second <= getMaxSBPS(format, j))
+        break;
+    }
+    for (k = 0; k < maxLevel; k++)
+    {
+        if(bitPerSecond <= getMaxBR(format, k, profile))
+           break;
+    }
+
+    leveIdx = MAX(MAX(i, j), k);
+    return leveIdx;
+}
+
+int32_t is_input_level_ilegal(v4l2_daemon_codec_fmt format, int32_t width, int32_t height,
+                                    uint32_t frameRateNum, uint32_t frameRateDenom, int32_t level_idx_input) {
+    uint32_t sample_per_picture = width * height;
+    uint32_t sample_per_second = sample_per_picture * frameRateNum / frameRateDenom;
+
+    uint32_t sample_per_picture_limit = getMaxPicSize(format, level_idx_input);
+    unsigned long long sample_per_second_limit = getMaxSBPS(format, level_idx_input);
+    if((sample_per_picture > sample_per_picture_limit) || (sample_per_second > sample_per_second_limit)) {
+        return 1;
+    }
+    else
+        return 0;
+}
diff --git a/v4l2_vsi_daemon/src/vsi_enc.h b/v4l2_vsi_daemon/src/vsi_enc.h
new file mode 100755
index 0000000..f922a87
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc.h
@@ -0,0 +1,171 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef VSI_ENC_VIDEO_H
+#define VSI_ENC_VIDEO_H
+#include "buffer_list.h"
+#include "command_defines.h"
+#include "daemon_instance.h"
+
+/**
+ * @file vsi_enc.h
+ * @brief V4L2 Daemon video process header file.
+ * @version 0.10- Initial version
+ */
+
+typedef enum {
+  ENC_NONE,      // none.
+  ENC_PAIRING,   // make input and output address togother?!
+  ENC_INIT,      // init inst and encode the 1st frame.
+  ENC_ENCODING,  // working.
+  ENC_DRAIN,     // 2pass/muti-core flush, b-frames encoding.
+  ENC_STOPPED,
+  ENC_RELEASED,
+} v4l2_inst_state;
+
+typedef struct {
+  int32_t has_h264;
+  int32_t has_hevc;
+  int32_t has_jpeg;
+  int32_t has_vp8;
+  int32_t max_width_hevc;
+  int32_t max_width_h264;
+  int32_t max_width_jpeg;
+  int32_t max_width_vp8;
+} configures;
+
+typedef struct { uint32_t param_size; } enc_inst_attr;
+
+typedef struct _v4l2_enc_inst v4l2_enc_inst;
+
+typedef struct {
+  void (*init)(v4l2_enc_inst* h);
+  int32_t (*check_codec_format)(v4l2_enc_inst* h);
+  void (*get_input)(v4l2_enc_inst* h, v4l2_daemon_enc_params* enc_params,
+                    int32_t if_config);
+  int32_t (*set_parameter)(v4l2_enc_inst* h, v4l2_daemon_enc_params* enc_params,
+                           int32_t if_config);
+  int32_t (*start)(v4l2_enc_inst* h, uint32_t* size_header_plus_i);
+  int32_t (*encode)(v4l2_enc_inst* h, uint32_t* size_header_plus_i,
+                    uint32_t* codingType);
+  int32_t (*find_next_pic)(v4l2_enc_inst* h, BUFFER** p_buffer,
+                           uint32_t* list_num);
+  int32_t (*end)(v4l2_enc_inst* h, uint32_t* size_header_plus_i);
+  int32_t (*close)(v4l2_enc_inst* h);
+  void (*get_attr)(v4l2_daemon_codec_fmt fmt, enc_inst_attr* attr);
+  void (*reset_enc)(v4l2_enc_inst* h);
+} daemon_enc_callback_t;
+
+struct _v4l2_enc_inst {
+  v4l2_daemon_inst* handler;
+  unsigned long instance_id;
+
+  const void* inst;
+  v4l2_inst_state state;
+
+  uint32_t input_frame_cnt;
+  uint32_t output_frame_cnt;
+
+  v4l2_daemon_codec_fmt codec_fmt;
+  void* enc_params;
+
+  v4l2_daemon_enc_params mediaconfig;
+
+  daemon_enc_callback_t func;
+  uint32_t cbr_last_bitrate;
+  uint32_t cbr_bitrate_change;
+  uint32_t next_pic_type;
+
+  int32_t curr_inbuf_idx;
+
+  BUFFERLIST* bufferlist_reorder;  // buffer(inout addr+parms) push in display
+                                   // order, get in h order.
+  BUFFERLIST* bufferlist_input;
+  BUFFERLIST* bufferlist_output;
+
+  int32_t already_streamon;
+  int32_t already_command_stop;
+  int32_t drain_input_num_total;
+  int32_t drain_input_num_now;
+  int32_t flushbuf;
+
+  configures configure_t;
+
+  uint32_t* saveOriOutBuf;
+  int64_t total_time;
+  int64_t total_frames;
+};
+
+/**
+ * @brief h26x_encode_cmd_processor(), process the input command. After
+ V4L2_DAEMON_VIDIOC_BUF_RDY received,
+          the input and output buffers are put into 2 bufferlist, respectively.
+ If both the sizes of input
+          and output buffers are none 0, it will pair the input and output
+ buffer, and add to the another
+          bufferlist. If one of the input and output buffers is 0, it will not
+ pair the input and output buffers,
+          and return a H26X_ENC_PAIRING state.
+ * @param v4l2_enc_inst* h: daemon instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: v4l2 message.
+ * @return int32_t value:The encoder state.
+ */
+int32_t enc_cmd_processor(v4l2_enc_inst* h, struct vsi_v4l2_msg* v4l2_msg);
+
+/**
+ * @brief h26x_encode_state_processor(), process the input state returned from
+ h26x_encode_cmd_processor().
+          If the state is H26X_ENC_INIT, all the parameters is ready for the
+ encoder and will be set to
+          respective structure and the encoder instance will be created. Then
+ the stream is going to be
+          encoded. If error happens, it will send orphan message to driver. If
+ the state is H26X_ENC_ENCODING,
+          the encoder is encoding the stream. If the state is H26X_ENC_DRAIN,
+ the encoder is going to handle
+          the tail of the stream, maybe last GOP or lookahead tail. If the state
+ is H26X_ENC_STOPPED,
+          the encoder is going to stop, destroy the encoder instance and the
+ worker thread will exit soon.
+ * @param v4l2_enc_inst* h: daemon instance.
+ * @param struct vsi_v4l2_msg* v4l2_msg: v4l2 message.
+ * @return int32_t value:The encoder state after process.
+ */
+v4l2_inst_state enc_state_processor(v4l2_enc_inst* h,
+                                    struct vsi_v4l2_msg* v4l2_msg);
+
+void check_if_cbr_bitrate_changed(v4l2_enc_inst* h,
+                                  v4l2_daemon_enc_params* enc_params);
+
+
+int32_t calculate_level(v4l2_daemon_codec_fmt format, int32_t width, int32_t height,
+                        uint32_t frameRateNum, uint32_t frameRateDenom, uint32_t bitPerSecond, int32_t profile);
+
+int32_t is_input_level_ilegal(v4l2_daemon_codec_fmt format, int32_t width, int32_t height,
+                        uint32_t frameRateNum, uint32_t frameRateDenom, int32_t level_idx_input);
+uint32_t getMaxCpbSize( v4l2_daemon_codec_fmt codecFormat , int32_t levelIdx );
+
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_img_h1.c b/v4l2_vsi_daemon/src/vsi_enc_img_h1.c
new file mode 100755
index 0000000..b0a7615
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_img_h1.c
@@ -0,0 +1,58 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef NXP
+
+#include "vsi_enc_img_h1.h"
+#include "buffer_list.h"
+#include "fifo.h"
+#include "jpegencapi.h"
+
+#define USER_DEFINED_QTABLE 10
+
+/* An example of user defined quantization table */
+const u8 qTable[64] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+
+int32_t jpeg_encode_cmd_processor(v4l2_enc_inst* h,
+                                  struct vsi_v4l2_msg* v4l2_msg) {
+  return 0;
+}
+static void close_jpeg_encoder(v4l2_enc_inst* h) {}
+static int32_t set_jpeg_parameters(v4l2_enc_inst* h,
+                                   v4l2_daemon_enc_params* enc_params,
+                                   int32_t if_config) {
+  return 0;
+}
+
+int32_t jpeg_encode_state_processor(v4l2_enc_inst* h,
+                                    struct vsi_v4l2_msg* v4l2_msg) {
+  return 0;
+}
+
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_img_h1.h b/v4l2_vsi_daemon/src/vsi_enc_img_h1.h
new file mode 100755
index 0000000..c58ec87
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_img_h1.h
@@ -0,0 +1,38 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#ifndef NXP
+
+#ifndef VSI_ENC_IMG_H
+#define VSI_ENC_IMG_H
+#include "vsi_enc.h"
+
+int32_t jpeg_encode_cmd_processor(v4l2_enc_inst* h,
+                                  struct vsi_v4l2_msg* v4l2_msg);
+int32_t jpeg_encode_state_processor(v4l2_enc_inst* h,
+                                    struct vsi_v4l2_msg* v4l2_msg);
+
+#endif
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_img_h2.c b/v4l2_vsi_daemon/src/vsi_enc_img_h2.c
new file mode 100755
index 0000000..b352293
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_img_h2.c
@@ -0,0 +1,405 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#ifndef NXP
+
+#include "vsi_enc_img_h2.h"
+#include "buffer_list.h"
+#include "fifo.h"
+#include "vsi_enc_img_h2_priv.h"
+
+#define USER_DEFINED_QTABLE 10
+
+/* An example of user defined quantization table */
+const u8 qTable[64] = {1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
+                       1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1};
+
+int32_t jpeg_encode_cmd_processor(v4l2_enc_inst *h,
+                                  struct vsi_v4l2_msg *v4l2_msg) {
+  BUFFER *p_buffer_input = NULL;
+  BUFFER *p_buffer_get_output = NULL;
+  BUFFER *p_buffer_output = NULL;
+  BUFFER *p_buffer_get_input = NULL;
+  BUFFER *p_buffer_reorder = NULL;
+  uint32_t list_num = 0xffffffff;
+
+  switch (v4l2_msg->cmd_id) {
+    case V4L2_DAEMON_VIDIOC_BUF_RDY:
+      if (v4l2_msg->params.enc_params.io_buffer.inbufidx != -1)  // input
+      {
+        p_buffer_input = (BUFFER *)malloc(sizeof(BUFFER));
+        p_buffer_input->frame_display_id = h->input_frame_cnt;
+        memcpy(&p_buffer_input->enc_cmd, &v4l2_msg->params.enc_params,
+               sizeof(struct v4l2_daemon_enc_params));
+
+        /*if input buffer comes, check the output bufferlist, if size>0, a full
+        inout parameters can be a pair.
+        pair to one params, and push into reorder buffer list. Change the state
+        to encode if it is H26X_ENC_INIT now.*/
+        if (bufferlist_get_size(h->bufferlist_output) > 0)  // paired
+        {
+          p_buffer_get_output = bufferlist_find_buffer(
+              h->bufferlist_output, p_buffer_input->frame_display_id,
+              &list_num);
+          if (p_buffer_get_output == NULL) {
+            HANTRO_LOG(HANTRO_LEVEL_ERROR, "bug in buffer list.
");
+            ASSERT(0);
+          } else  // pair to one params, and push into reorder buffer list.
+          {
+            p_buffer_input->enc_cmd.io_buffer.busOutBuf =
+                p_buffer_get_output->enc_cmd.io_buffer.busOutBuf;
+            p_buffer_input->enc_cmd.io_buffer.outBufSize =
+                p_buffer_get_output->enc_cmd.io_buffer.outBufSize;
+
+            p_buffer_reorder = (BUFFER *)malloc(sizeof(BUFFER));
+            memcpy(&p_buffer_reorder->enc_cmd, &p_buffer_input->enc_cmd,
+                   sizeof(struct v4l2_daemon_enc_params));
+            p_buffer_reorder->frame_display_id =
+                h->input_frame_cnt;  // output num is more than input num, pick
+                                     // the small one.
+            bufferlist_push_buffer(h->bufferlist_reorder, p_buffer_reorder);
+          }
+          free(p_buffer_get_output);
+          bufferlist_remove(h->bufferlist_output, list_num);
+
+          if (((h->state == JPEG_ENC_INIT) || (h->state == JPEG_ENC_ENCODING) ||
+               (h->state == JPEG_ENC_PAIRING)) &&
+              (h->already_streamon == 1)) {
+            h->state = JPEG_ENC_ENCODING;
+          }
+        } else  // not paired.
+        {
+          bufferlist_push_buffer(h->bufferlist_input, p_buffer_input);
+          h->state = JPEG_ENC_PAIRING;
+        }
+        h->input_frame_cnt++;
+      } else if (v4l2_msg->params.enc_params.io_buffer.outbufidx !=
+                 -1)  // output
+      {
+        p_buffer_output = (BUFFER *)malloc(sizeof(BUFFER));
+        p_buffer_output->frame_display_id = h->output_frame_cnt;
+        memcpy(&p_buffer_output->enc_cmd, &v4l2_msg->params.enc_params,
+               sizeof(struct v4l2_daemon_enc_params));
+
+        if (bufferlist_get_size(h->bufferlist_input) > 0)  // paired
+        {
+          p_buffer_get_input = bufferlist_find_buffer(
+              h->bufferlist_input, p_buffer_output->frame_display_id,
+              &list_num);
+          if (p_buffer_get_input == NULL) {
+            HANTRO_LOG(HANTRO_LEVEL_ERROR, "bug in buffer list.
");
+            ASSERT(0);
+          } else  // pair to one params, and push into reorder buffer list.
+          {
+            p_buffer_get_input->enc_cmd.io_buffer.busOutBuf =
+                p_buffer_output->enc_cmd.io_buffer.busOutBuf;
+            p_buffer_get_input->enc_cmd.io_buffer.outBufSize =
+                p_buffer_output->enc_cmd.io_buffer.outBufSize;
+
+            p_buffer_reorder = (BUFFER *)malloc(sizeof(BUFFER));
+            memcpy(&p_buffer_reorder->enc_cmd, &p_buffer_get_input->enc_cmd,
+                   sizeof(struct v4l2_daemon_enc_params));
+            p_buffer_reorder->frame_display_id =
+                h->output_frame_cnt;  // input num is more than output num, pick
+                                      // the small one.
+            bufferlist_push_buffer(h->bufferlist_reorder, p_buffer_reorder);
+          }
+          free(p_buffer_get_output);
+          bufferlist_remove(h->bufferlist_input, list_num);
+
+          if (((h->state == JPEG_ENC_INIT) || (h->state == JPEG_ENC_ENCODING) ||
+               (h->state == JPEG_ENC_PAIRING)) &&
+              (h->already_streamon == 1)) {
+            h->state = JPEG_ENC_ENCODING;
+          }
+
+          h->output_frame_cnt++;
+        } else  // not paired.
+        {
+          bufferlist_push_buffer(h->bufferlist_output, p_buffer_output);
+          h->state = JPEG_ENC_PAIRING;
+        }
+        // to do
+      } else {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "error no io buffers.
");
+        ASSERT(0);
+      }
+      break;
+
+    case V4L2_DAEMON_VIDIOC_STREAMON_CAPTURE:
+      if (v4l2_msg->param_type == 0)  // no parameter
+      {
+      } else if (v4l2_msg->param_type ==
+                 1)  // all parameters. include input output and parameters.
+      {
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Has Param when streamon.
");
+        int32_t frame_display_id = (h->input_frame_cnt >= h->output_frame_cnt)
+                                       ? (h->output_frame_cnt - 1)
+                                       : (h->input_frame_cnt - 1);
+        p_buffer_reorder = bufferlist_find_buffer(h->bufferlist_reorder,
+                                                  frame_display_id, &list_num);
+        if (p_buffer_reorder == NULL) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "should not be null.
");
+          ASSERT(0);
+        }
+        bufferlist_remove(h->bufferlist_reorder, list_num);
+        memcpy(&p_buffer_reorder->enc_cmd.general,
+               &v4l2_msg->params.enc_params.general,
+               sizeof(struct v4l2_daemon_enc_general_cmd));
+        memcpy(&p_buffer_reorder->enc_cmd.specific.enc_h26x_cmd,
+               &v4l2_msg->params.enc_params.specific.enc_h26x_cmd,
+               sizeof(struct v4l2_daemon_enc_h26x_cmd));
+        bufferlist_push_buffer(h->bufferlist_reorder, p_buffer_reorder);
+      }
+
+      h->state = JPEG_ENC_INIT;
+      h->already_streamon = 1;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_CMD_STOP:
+    case V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE:
+      h->state = JPEG_ENC_STOPPED;
+      break;
+
+    case V4L2_DAEMON_VIDIOC_FAKE:
+      break;
+    default:
+      break;
+  }
+  return 0;
+}
+static void close_jpeg_encoder(v4l2_enc_inst *h) {}
+static int32_t set_jpeg_parameters(v4l2_enc_inst *h,
+                                   v4l2_daemon_enc_params *enc_params,
+                                   int32_t if_config) {
+  JpegEncIn *encIn = &h->params.jpeg_enc_param.jpeg_in;
+
+  /*--------------------------------- 1.
+   * JpegEncCfg----------------------------------------*/
+  if (if_config) {
+    JpegEncCfg *cfg = &h->params.jpeg_enc_param.jpeg_config;
+
+    /* Encoder initialization */
+    if (enc_params->general.width == -1)
+      enc_params->general.width = enc_params->general.lumWidthSrc;
+
+    if (enc_params->general.height == -1)
+      enc_params->general.height = enc_params->general.lumHeightSrc;
+
+    if (enc_params->specific.enc_jpeg_cmd.exp_of_input_alignment == 7) {
+      if (enc_params->specific.enc_jpeg_cmd.frameType == JPEGENC_YUV420_PLANAR)
+        enc_params->general.horOffsetSrc =
+            ((enc_params->general.horOffsetSrc + 256 - 1) & (~(256 - 1)));
+      else
+        enc_params->general.horOffsetSrc =
+            ((enc_params->general.horOffsetSrc + 128 - 1) & (~(128 - 1)));
+
+      if ((enc_params->general.lumWidthSrc - enc_params->general.horOffsetSrc) <
+          enc_params->general.width)
+        enc_params->general.horOffsetSrc = 0;
+    }
+
+    /* lossless mode */
+    if (enc_params->specific.enc_jpeg_cmd.predictMode != 0) {
+      cfg->losslessEn = 1;
+      cfg->predictMode = enc_params->specific.enc_jpeg_cmd.predictMode;
+      cfg->ptransValue = enc_params->specific.enc_jpeg_cmd.ptransValue;
+    } else {
+      cfg->losslessEn = 0;
+    }
+
+    cfg->rotation = (JpegEncPictureRotation)enc_params->general.rotation;
+    cfg->inputWidth =
+        (enc_params->general.lumWidthSrc + 15) & (~15); /* API limitation */
+    if (cfg->inputWidth != (u32)enc_params->general.lumWidthSrc)
+      HANTRO_LOG(HANTRO_LEVEL_WARNING,
+                 "Warning: Input width must be multiple of 16!
");
+    cfg->inputHeight = enc_params->general.lumHeightSrc;
+
+    if (cfg->rotation && cfg->rotation != JPEGENC_ROTATE_180) {
+      /* full */
+      cfg->xOffset = enc_params->general.verOffsetSrc;
+      cfg->yOffset = enc_params->general.horOffsetSrc;
+
+      cfg->codingWidth = enc_params->general.height;
+      cfg->codingHeight = enc_params->general.width;
+      cfg->xDensity = enc_params->specific.enc_jpeg_cmd.ydensity;
+      cfg->yDensity = enc_params->specific.enc_jpeg_cmd.xdensity;
+    } else {
+      /* full */
+      cfg->xOffset = enc_params->general.horOffsetSrc;
+      cfg->yOffset = enc_params->general.verOffsetSrc;
+
+      cfg->codingWidth = enc_params->general.width;
+      cfg->codingHeight = enc_params->general.height;
+      cfg->xDensity = enc_params->specific.enc_jpeg_cmd.xdensity;
+      cfg->yDensity = enc_params->specific.enc_jpeg_cmd.ydensity;
+    }
+    cfg->mirror = enc_params->general.mirror;
+
+    if (enc_params->specific.enc_jpeg_cmd.qLevel == USER_DEFINED_QTABLE) {
+      cfg->qTableLuma = qTable;
+      cfg->qTableChroma = qTable;
+    } else
+      cfg->qLevel = enc_params->specific.enc_jpeg_cmd.qLevel;
+
+    cfg->restartInterval = enc_params->specific.enc_jpeg_cmd.restartInterval;
+    cfg->codingType =
+        (JpegEncCodingType)enc_params->specific.enc_jpeg_cmd.partialCoding;
+    cfg->frameType =
+        (JpegEncFrameType)enc_params->specific.enc_jpeg_cmd.frameType;
+    cfg->unitsType =
+        (JpegEncAppUnitsType)enc_params->specific.enc_jpeg_cmd.unitsType;
+    cfg->markerType =
+        (JpegEncTableMarkerType)enc_params->specific.enc_jpeg_cmd.markerType;
+    cfg->colorConversion.type =
+        (JpegEncColorConversionType)enc_params->general.colorConversion;
+    if (cfg->colorConversion.type == JPEGENC_RGBTOYUV_USER_DEFINED) {
+      /* User defined RGB to YCbCr conversion coefficients, scaled by 16-bits */
+      cfg->colorConversion.coeffA = 20000;
+      cfg->colorConversion.coeffB = 44000;
+      cfg->colorConversion.coeffC = 5000;
+      cfg->colorConversion.coeffE = 35000;
+      cfg->colorConversion.coeffF = 38000;
+      cfg->colorConversion.coeffG = 35000;
+      cfg->colorConversion.coeffH = 38000;
+      cfg->colorConversion.LumaOffset = 0;
+    }
+    // writeOutput = enc_params->specific.enc_jpeg_cmd.write;
+    cfg->codingMode =
+        (JpegEncCodingMode)enc_params->specific.enc_jpeg_cmd.codingMode;
+
+    /* constant chroma control */
+    cfg->constChromaEn = enc_params->specific.enc_jpeg_cmd.constChromaEn;
+    cfg->constCb = enc_params->specific.enc_jpeg_cmd.constCb;
+    cfg->constCr = enc_params->specific.enc_jpeg_cmd.constCr;
+
+    /* jpeg rc*/
+    cfg->targetBitPerSecond = enc_params->specific.enc_jpeg_cmd.bitPerSecond;
+    cfg->frameRateNum = 1;
+    cfg->frameRateDenom = 1;
+
+    // framerate valid only when RC enabled
+    if (enc_params->specific.enc_jpeg_cmd.bitPerSecond) {
+      cfg->frameRateNum = enc_params->general.outputRateNumer;
+      cfg->frameRateDenom = enc_params->general.outputRateDenom;
+    }
+    cfg->qpmin = enc_params->specific.enc_jpeg_cmd.qpmin;
+    cfg->qpmax = enc_params->specific.enc_jpeg_cmd.qpmax;
+    cfg->fixedQP = enc_params->specific.enc_jpeg_cmd.fixedQP;
+    cfg->rcMode = enc_params->specific.enc_jpeg_cmd.rcMode;
+    cfg->picQpDeltaMax = enc_params->specific.enc_jpeg_cmd.picQpDeltaMax;
+    cfg->picQpDeltaMin = enc_params->specific.enc_jpeg_cmd.picQpDeltaMin;
+
+    /*stride*/
+    cfg->exp_of_input_alignment =
+        enc_params->specific.enc_jpeg_cmd.exp_of_input_alignment;
+
+    if (enc_params->specific.enc_jpeg_cmd.thumbnail < 0 ||
+        enc_params->specific.enc_jpeg_cmd.thumbnail > 3) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Not valid thumbnail format!
");
+      return -1;
+    }
+  }
+
+  /*--------------------------------- 2.
+   * JpegEncIn----------------------------------------*/
+  encIn->busLum = enc_params->io_buffer.busLuma;
+  encIn->busCb = enc_params->io_buffer.busChromaU;
+  encIn->busCr = enc_params->io_buffer.busChromaV;
+  encIn->pOutBuf[0] = (u8 *)enc_params->io_buffer.busOutBuf;
+  encIn->busOutBuf[0] = enc_params->io_buffer.busOutBuf;
+  encIn->outBufSize[0] = enc_params->io_buffer.outBufSize;
+
+  encIn->frameHeader = 1;
+  return 0;
+}
+
+int32_t jpeg_encode_state_processor(v4l2_enc_inst *h,
+                                    struct vsi_v4l2_msg *v4l2_msg) {
+  vsi_v4l2_msg msg;
+  JpegEncRet ret;
+  BUFFER *p_buffer = NULL;
+  uint32_t list_num = 0xffffffff;
+
+  switch (h->state) {
+    case JPEG_ENC_INIT:
+      p_buffer = bufferlist_find_buffer(h->bufferlist_reorder, 0,
+                                        &list_num);  // match 0
+      if (p_buffer == NULL) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                   "error, state H26X_ENC_INIT should get one buffer.
");
+        ASSERT(0);
+      } else {
+        bufferlist_remove(h->bufferlist_reorder, list_num);
+      }
+
+      set_jpeg_parameters(h, &p_buffer->enc_cmd, 1);
+      if ((ret = JpegEncInit(&h->params.jpeg_enc_param.jpeg_config,
+                             &h->inst.jpeg_enc_inst, NULL)) != JPEGENC_OK) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                   "Failed to initialize the encoder. Error code: %8i
", ret);
+        return (int32_t)ret;
+      }
+      ret = JpegEncSetPictureSize(h->inst.jpeg_enc_inst,
+                                  &h->params.jpeg_enc_param.jpeg_config);
+      if (ret != JPEGENC_OK) {
+        ASSERT(0);
+      }
+
+      ret = JpegEncEncode(h->inst.jpeg_enc_inst,
+                          &h->params.jpeg_enc_param.jpeg_in,
+                          &h->params.jpeg_enc_param.jpeg_out);
+      /*inform driver.*/
+      msg.error = (int)ret;
+      msg.inst_id = h->instance_id;
+      if (pipe_fd) {
+        send_notif_to_v4l2(pipe_fd, &msg, sizeof(struct vsi_v4l2_msg));
+      }
+      break;
+
+    case JPEG_ENC_ENCODING:
+      ret = JpegEncSetPictureSize(&h->inst.jpeg_enc_inst,
+                                  &h->params.jpeg_enc_param.jpeg_config);
+      if (ret != JPEGENC_OK) {
+        ASSERT(0);
+      }
+
+      ret = JpegEncEncode(h->inst.jpeg_enc_inst,
+                          &h->params.jpeg_enc_param.jpeg_in,
+                          &h->params.jpeg_enc_param.jpeg_out);
+      break;
+
+    case JPEG_ENC_STOPPED:
+      close_jpeg_encoder(h);
+      return JPEG_ENC_STOPPED;
+    default:
+      break;
+  }
+  return 0;
+}
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_img_h2.h b/v4l2_vsi_daemon/src/vsi_enc_img_h2.h
new file mode 100755
index 0000000..c58ec87
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_img_h2.h
@@ -0,0 +1,38 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#ifndef NXP
+
+#ifndef VSI_ENC_IMG_H
+#define VSI_ENC_IMG_H
+#include "vsi_enc.h"
+
+int32_t jpeg_encode_cmd_processor(v4l2_enc_inst* h,
+                                  struct vsi_v4l2_msg* v4l2_msg);
+int32_t jpeg_encode_state_processor(v4l2_enc_inst* h,
+                                    struct vsi_v4l2_msg* v4l2_msg);
+
+#endif
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_img_h2_priv.h b/v4l2_vsi_daemon/src/vsi_enc_img_h2_priv.h
new file mode 100755
index 0000000..575647b
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_img_h2_priv.h
@@ -0,0 +1,44 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+#ifndef NXP
+
+#ifndef __VSI_ENC_IMG_PRIV_H__
+#define __VSI_ENC_IMG_PRIV_H__
+
+#include "ewl.h"
+#include "jpegencapi.h"
+
+typedef struct {
+  JpegEncIn jpeg_in;
+  JpegEncOut jpeg_out;
+
+  uint8_t luma_qmatrix[64];
+  uint8_t chma_qmatrix[64];
+  JpegEncCfg jpeg_config;
+} jpeg_enc_params;
+
+#endif /*__VSI_ENC_IMG_PRIV_H__*/
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_video_h1.c b/v4l2_vsi_daemon/src/vsi_enc_video_h1.c
new file mode 100755
index 0000000..5cd2690
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_video_h1.c
@@ -0,0 +1,1333 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_enc_video.c
+ * @brief V4L2 Daemon video process header file.
+ * @version 0.10- Initial version
+ */
+#include "vsi_enc_video_h1.h"
+#include <math.h>
+#include "buffer_list.h"
+#include "fifo.h"
+#include "vsi_daemon_debug.h"
+#include "vsi_enc.h"
+#include "vsi_enc_video_h1_priv.h"
+
+#define H264ENC_MIN_ENC_WIDTH 144  // confirm with YiZhong, 144x96
+#define H264ENC_MAX_ENC_WIDTH 4080
+#define H264ENC_MIN_ENC_HEIGHT 96
+#define H264ENC_MAX_ENC_HEIGHT 4080
+#define H264ENC_MAX_MBS_PER_PIC 65025 /* 4080x4080 */
+
+#define VP8ENC_MIN_ENC_WIDTH 144
+#define VP8ENC_MAX_ENC_WIDTH 4080
+#define VP8ENC_MIN_ENC_HEIGHT 96
+#define VP8ENC_MAX_ENC_HEIGHT 4080
+#define VP8ENC_MAX_MBS_PER_PIC 65025 /* 4080x4080 */
+
+i32 H264EncSetVuiColorDescription(
+    H264EncInst inst, u32 vuiVideoSignalTypePresentFlag, u32 vuiVideoFormat,
+    u32 vuiColorDescripPresentFlag, u32 vuiColorPrimaries,
+    u32 vuiTransferCharacteristics, u32 vuiMatrixCoefficients);
+//#define OUTPUT_VP8_HEADER
+#ifdef OUTPUT_VP8_HEADER
+#define IVF_HDR_BYTES 32
+#define IVF_FRM_BYTES 12
+void IvfHeader(u8 *dst, uint32_t width, uint32_t height,
+               uint32_t outputRateNumer, uint32_t outputRateDenom,
+               uint64_t frameCntTotal) {
+  u8 data[IVF_HDR_BYTES] = {0};
+
+  /* File header signature */
+  data[0] = 'D';
+  data[1] = 'K';
+  data[2] = 'I';
+  data[3] = 'F';
+
+  /* File format version and file header size */
+  data[6] = 32;
+
+  /* Video data FourCC */
+  data[8] = 'V';
+  data[9] = 'P';
+  data[10] = '8';
+  data[11] = '0';
+
+  /* Video Image width and height */
+  data[12] = width & 0xff;
+  data[13] = (width >> 8) & 0xff;
+  data[14] = height & 0xff;
+  data[15] = (height >> 8) & 0xff;
+
+  /* Frame rate rate */
+  data[16] = outputRateNumer & 0xff;
+  data[17] = (outputRateNumer >> 8) & 0xff;
+  data[18] = (outputRateNumer >> 16) & 0xff;
+  data[19] = (outputRateNumer >> 24) & 0xff;
+
+  /* Frame rate scale */
+  data[20] = outputRateDenom & 0xff;
+  data[21] = (outputRateDenom >> 8) & 0xff;
+  data[22] = (outputRateDenom >> 16) & 0xff;
+  data[23] = (outputRateDenom >> 24) & 0xff;
+
+  /* Video length in frames */
+  data[24] = frameCntTotal & 0xff;
+  data[25] = (frameCntTotal >> 8) & 0xff;
+  data[26] = (frameCntTotal >> 16) & 0xff;
+  data[27] = (frameCntTotal >> 24) & 0xff;
+
+  memcpy(dst, data, IVF_HDR_BYTES);
+}
+
+/*------------------------------------------------------------------------------
+    IvfFrame
+------------------------------------------------------------------------------*/
+void IvfFrame(u8 *dst, uint32_t frameSize, uint64_t frameCntTotal) {
+  uint32_t byteCnt = 0;
+  u8 data[IVF_FRM_BYTES];
+
+  /* Frame size (4 bytes) */
+  byteCnt = frameSize;
+  data[0] = byteCnt & 0xff;
+  data[1] = (byteCnt >> 8) & 0xff;
+  data[2] = (byteCnt >> 16) & 0xff;
+  data[3] = (byteCnt >> 24) & 0xff;
+
+  /* Timestamp (8 bytes) */
+  data[4] = (frameCntTotal)&0xff;
+  data[5] = ((frameCntTotal) >> 8) & 0xff;
+  data[6] = ((frameCntTotal) >> 16) & 0xff;
+  data[7] = ((frameCntTotal) >> 24) & 0xff;
+  data[8] = ((frameCntTotal) >> 32) & 0xff;
+  data[9] = ((frameCntTotal) >> 40) & 0xff;
+  data[10] = ((frameCntTotal) >> 48) & 0xff;
+  data[11] = ((frameCntTotal) >> 56) & 0xff;
+
+  memcpy(dst, data, IVF_FRM_BYTES);
+}
+#endif
+
+static H264EncLevel getLevelH264(i32 levelIdx)
+{
+  switch (levelIdx)
+  {
+    case 0:
+      return H264ENC_LEVEL_1;
+    case 1:
+      return H264ENC_LEVEL_1_b;
+    case 2:
+      return H264ENC_LEVEL_1_1;
+    case 3:
+      return H264ENC_LEVEL_1_2;
+    case 4:
+      return H264ENC_LEVEL_1_3;
+    case 5:
+      return H264ENC_LEVEL_2;
+    case 6:
+      return H264ENC_LEVEL_2_1;
+    case 7:
+      return H264ENC_LEVEL_2_2;
+    case 8:
+      return H264ENC_LEVEL_3;
+    case 9:
+      return H264ENC_LEVEL_3_1;
+    case 10:
+      return H264ENC_LEVEL_3_2;
+    case 11:
+      return H264ENC_LEVEL_4;
+    case 12:
+      return H264ENC_LEVEL_4_1;
+    case 13:
+      return H264ENC_LEVEL_4_2;
+    case 14:
+      return H264ENC_LEVEL_5;
+    case 15:
+      return H264ENC_LEVEL_5_1;
+
+    default:
+      return H264ENC_LEVEL_5_1;
+  }
+}
+
+static int32_t getLevelIdxH264(H264EncLevel level)
+{
+  switch (level)
+  {
+    case H264ENC_LEVEL_1:
+      return 0;
+    case H264ENC_LEVEL_1_b:
+      return 1;
+    case H264ENC_LEVEL_1_1:
+      return 2;
+    case H264ENC_LEVEL_1_2:
+      return 3;
+    case H264ENC_LEVEL_1_3:
+      return 4;
+    case H264ENC_LEVEL_2:
+      return 5;
+    case H264ENC_LEVEL_2_1:
+      return 6;
+    case H264ENC_LEVEL_2_2:
+      return 7;
+    case H264ENC_LEVEL_3:
+      return 8;
+    case H264ENC_LEVEL_3_1:
+      return 9;
+    case H264ENC_LEVEL_3_2:
+      return 10;
+    case H264ENC_LEVEL_4:
+      return 11;
+    case H264ENC_LEVEL_4_1:
+      return 12;
+    case H264ENC_LEVEL_4_2:
+      return 13;
+    case H264ENC_LEVEL_5:
+      return 14;
+    case H264ENC_LEVEL_5_1:
+      return 15;
+    default:
+      ASSERT(0);
+  }
+  return 0;
+}
+
+/**
+ * @brief init_encoder_h264(), create & init h264 enc instance.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int init_encoder_h264(v4l2_enc_inst *h,
+                             v4l2_daemon_enc_params *enc_params) {
+  H264EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+
+  H264EncConfig *cfg = (void *)&h264_params->video_config;
+  if (enc_params->general.rotation && enc_params->general.rotation != 3) {
+    cfg->width = enc_params->general.height;
+    cfg->height = enc_params->general.width;
+  } else {
+    cfg->width = enc_params->general.width;
+    cfg->height = enc_params->general.height;
+  }
+  if (cfg->width < H264ENC_MIN_ENC_WIDTH || (cfg->width & 0x3) != 0 ||
+      cfg->height < H264ENC_MIN_ENC_HEIGHT || (cfg->height & 0x1) != 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+               cfg->width, cfg->height);
+    return DAEMON_ERR_ENC_PARA;
+  }
+  if (cfg->width > h->configure_t.max_width_h264 ||
+      cfg->height > H264ENC_MAX_ENC_HEIGHT) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+               cfg->width, cfg->height);
+    return DAEMON_ERR_ENC_NOT_SUPPORT;
+  }
+  /* total macroblocks per picture limit */
+  if (((cfg->height + 15) / 16) * ((cfg->width + 15) / 16) >
+      H264ENC_MAX_MBS_PER_PIC) {
+    return DAEMON_ERR_ENC_NOT_SUPPORT;
+  }
+  cfg->frameRateDenom = enc_params->general.outputRateDenom;
+  cfg->frameRateNum = enc_params->general.outputRateNumer;
+  if ((cfg->frameRateNum == 0 || cfg->frameRateDenom == 0) ||
+      (cfg->frameRateDenom > cfg->frameRateNum &&
+       !(cfg->frameRateDenom == 1001 &&
+         cfg->frameRateNum == 1000))) { /* special allowal of 1000/1001, 0.99
+                                           fps by customer request */
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Framerate is not set properly, set to default (30fps).
");
+    cfg->frameRateDenom = 1;
+    cfg->frameRateNum = 30;
+  }
+  /* intra tools in sps and pps */
+  cfg->streamType = (enc_params->specific.enc_h26x_cmd.byteStream)
+                        ? H264ENC_BYTE_STREAM
+                        : H264ENC_NAL_UNIT_STREAM;
+  cfg->level = H264ENC_LEVEL_5_1;
+  if (enc_params->specific.enc_h26x_cmd.avclevel != DEFAULTLEVEL)
+    cfg->level = (H264EncLevel)enc_params->specific.enc_h26x_cmd.avclevel;
+
+  int32_t levelIdx = getLevelIdxH264(cfg->level);
+
+  if(1 == is_input_level_ilegal(h->codec_fmt, cfg->width, cfg->height,
+                                cfg->frameRateNum, cfg->frameRateDenom, levelIdx)) {
+      levelIdx = calculate_level(h->codec_fmt, cfg->width, cfg->height,
+                                cfg->frameRateNum, cfg->frameRateDenom, enc_params->general.bitPerSecond, enc_params->specific.enc_h26x_cmd.profile);
+      cfg->level = getLevelH264(levelIdx);
+      send_warning_orphan_msg(h->instance_id, WARN_LEVEL);
+  }
+
+  /* Find the max number of reference frame */
+  if (enc_params->specific.enc_h26x_cmd.intraPicRate == 1)
+    cfg->refFrameAmount = 1;
+  else
+    cfg->refFrameAmount = 1;
+
+  ret = H264EncInit(cfg, &h->inst);
+  if (ret != H264ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncInit() failed. vsi_ret=%d
",
+                ret);
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief init_encoder_vp8(), create & init h264 enc instance.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int init_encoder_vp8(v4l2_enc_inst *h,
+                            v4l2_daemon_enc_params *enc_params) {
+  VP8EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  VP8EncConfig *cfg = &vp8_params->vp8_config;
+  if (enc_params->general.rotation && enc_params->general.rotation != 3) {
+    cfg->width = enc_params->general.height;
+    cfg->height = enc_params->general.width;
+  } else {
+    cfg->width = enc_params->general.width;
+    cfg->height = enc_params->general.height;
+  }
+  if (cfg->width < VP8ENC_MIN_ENC_WIDTH || (cfg->width & 0x3) != 0 ||
+      cfg->height < VP8ENC_MIN_ENC_HEIGHT || (cfg->height & 0x1) != 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+               cfg->width, cfg->height);
+    return DAEMON_ERR_ENC_PARA;
+  }
+  if (cfg->width > h->configure_t.max_width_vp8 ||
+      cfg->height > VP8ENC_MAX_ENC_HEIGHT) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+               cfg->width, cfg->height);
+    return DAEMON_ERR_ENC_NOT_SUPPORT;
+  }
+  /* total macroblocks per picture limit */
+  if (((cfg->height + 15) / 16) * ((cfg->width + 15) / 16) >
+      VP8ENC_MAX_MBS_PER_PIC) {
+    return DAEMON_ERR_ENC_NOT_SUPPORT;
+  }
+  cfg->frameRateDenom = enc_params->general.outputRateDenom;
+  cfg->frameRateNum = enc_params->general.outputRateNumer;
+  if ((cfg->frameRateNum == 0 || cfg->frameRateDenom == 0) ||
+      (cfg->frameRateDenom > cfg->frameRateNum &&
+       !(cfg->frameRateDenom == 1001 &&
+         cfg->frameRateNum == 1000))) { /* special allowal of 1000/1001, 0.99
+                                           fps by customer request */
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Framerate is not set properly, set to default (30fps).
");
+    cfg->frameRateDenom = 1;
+    cfg->frameRateNum = 30;
+  }
+  /* Find the max number of reference frame */
+  if (enc_params->specific.enc_h26x_cmd.intraPicRate == 1) {
+    cfg->refFrameAmount = 1;
+  } else {
+    cfg->refFrameAmount = 1;
+  }
+
+  ret = VP8EncInit(cfg, &h->inst);
+  if (ret != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncInit() failed. vsi_ret=%d
",
+                ret);
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief set_rate_control_h264(), set rate control.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_rate_control_h264(v4l2_enc_inst *h,
+                                 v4l2_daemon_enc_params *enc_params) {
+  H264EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+
+  H264EncRateCtrl *rcCfg = &h264_params->video_rate_ctrl;
+  H264EncConfig *cfg = &h264_params->video_config;
+
+  if ((ret = H264EncGetRateCtrl(h->inst, rcCfg)) != H264ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncGetRateCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  if (enc_params->specific.enc_h26x_cmd.qpHdr != -1)
+    rcCfg->qpHdr = enc_params->specific.enc_h26x_cmd.qpHdr;
+  else
+    rcCfg->qpHdr = -1;
+
+  if (!h->next_pic_type &&
+      enc_params->specific.enc_h26x_cmd.qpHdrI_h26x != -1) {  // I
+    rcCfg->qpHdr = rcCfg->fixedIntraQp =
+        enc_params->specific.enc_h26x_cmd.qpHdrI_h26x;
+  } else if (h->next_pic_type &&
+             enc_params->specific.enc_h26x_cmd.qpHdrP_h26x != -1) {  // P
+    rcCfg->qpHdr = enc_params->specific.enc_h26x_cmd.qpHdrP_h26x;
+  }
+
+  if (enc_params->specific.enc_h26x_cmd.picSkip != -1)
+    rcCfg->pictureSkip = enc_params->specific.enc_h26x_cmd.picSkip;
+  else
+    rcCfg->pictureSkip = 0;
+  if (enc_params->specific.enc_h26x_cmd.picRc != -1)
+    rcCfg->pictureRc = enc_params->specific.enc_h26x_cmd.picRc;
+  else
+    rcCfg->pictureRc = 0;
+  if (enc_params->general.bitPerSecond != -1)
+    rcCfg->bitPerSecond = enc_params->general.bitPerSecond;
+  if (enc_params->specific.enc_h26x_cmd.hrdConformance != -1)
+    rcCfg->hrd = enc_params->specific.enc_h26x_cmd.hrdConformance;
+  if (enc_params->specific.enc_h26x_cmd.picRc == 0) rcCfg->hrd = 0;
+
+  enc_params->specific.enc_h26x_cmd.cpbSize = -1;
+  if (enc_params->specific.enc_h26x_cmd.cpbSize != -1)
+    rcCfg->hrdCpbSize = enc_params->specific.enc_h26x_cmd.cpbSize;
+  else {//cpbSize default value.
+    int32_t levelIdx = getLevelIdxH264(cfg->level);
+    rcCfg->hrdCpbSize = getMaxCpbSize(h->codec_fmt, levelIdx);
+  }
+  if (enc_params->specific.enc_h26x_cmd.intraQpDelta != -1)
+    rcCfg->intraQpDelta = enc_params->specific.enc_h26x_cmd.intraQpDelta;
+  rcCfg->fixedIntraQp = enc_params->specific.enc_h26x_cmd.fixedIntraQp;
+  rcCfg->gopLen = enc_params->specific.enc_h26x_cmd.intraPicRate;
+  if(rcCfg->gopLen > 300)
+      rcCfg->gopLen = 300;
+  if (rcCfg->hrd == 1 && rcCfg->pictureRc == 1) {  // cbr mode
+    h->cbr_last_bitrate = enc_params->general.bitPerSecond;
+  }
+  if ((enc_params->specific.enc_h26x_cmd.qpMin_h26x >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMin_h26x <= 51))
+    rcCfg->qpMin = enc_params->specific.enc_h26x_cmd.qpMin_h26x;
+  else
+    rcCfg->qpMin = 0;
+  if ((enc_params->specific.enc_h26x_cmd.qpMax_h26x >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMax_h26x <= 51))
+    rcCfg->qpMax = enc_params->specific.enc_h26x_cmd.qpMax_h26x;
+  else
+    rcCfg->qpMax = 51;
+
+  if ((ret = H264EncSetRateCtrl(
+            h->inst, rcCfg)) != H264ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncSetRateCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief set_rate_control_vp8(), set rate control.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_rate_control_vp8(v4l2_enc_inst *h,
+                                v4l2_daemon_enc_params *enc_params) {
+  VP8EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  VP8EncRateCtrl *rcCfg = &vp8_params->vp8_rate_ctrl;
+
+  if ((ret = VP8EncGetRateCtrl(h->inst, rcCfg)) != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncGetRateCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  if (enc_params->specific.enc_h26x_cmd.qpHdr != -1)
+    rcCfg->qpHdr = enc_params->specific.enc_h26x_cmd.qpHdr;
+  else
+    rcCfg->qpHdr = -1;
+  if (!h->next_pic_type &&
+      enc_params->specific.enc_h26x_cmd.qpHdrI_vpx != -1) {  // I
+    rcCfg->qpHdr = rcCfg->fixedIntraQp =
+        enc_params->specific.enc_h26x_cmd.qpHdrI_vpx;
+  } else if (h->next_pic_type &&
+             enc_params->specific.enc_h26x_cmd.qpHdrP_vpx != -1) {  // P
+    rcCfg->qpHdr = enc_params->specific.enc_h26x_cmd.qpHdrP_vpx;
+  }
+
+  if (enc_params->specific.enc_h26x_cmd.picSkip != -1)
+    rcCfg->pictureSkip = enc_params->specific.enc_h26x_cmd.picSkip;
+  else
+    rcCfg->pictureSkip = 0;
+  if (enc_params->specific.enc_h26x_cmd.picRc != -1)
+    rcCfg->pictureRc = enc_params->specific.enc_h26x_cmd.picRc;
+  else
+    rcCfg->pictureRc = 0;
+  if (enc_params->general.bitPerSecond != -1)
+    rcCfg->bitPerSecond = enc_params->general.bitPerSecond;
+  if (enc_params->specific.enc_h26x_cmd.intraQpDelta != -1)
+    rcCfg->intraQpDelta = enc_params->specific.enc_h26x_cmd.intraQpDelta;
+  rcCfg->fixedIntraQp = enc_params->specific.enc_h26x_cmd.fixedIntraQp;
+
+  rcCfg->intraPictureRate = enc_params->specific.enc_h26x_cmd.intraPicRate;
+
+  rcCfg->bitrateWindow = enc_params->specific.enc_h26x_cmd.intraPicRate;
+  if (rcCfg->bitrateWindow > 300)
+    rcCfg->bitrateWindow = 300;
+
+  if ((enc_params->specific.enc_h26x_cmd.qpMin_vpx >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMin_vpx <= 127))
+    rcCfg->qpMin = enc_params->specific.enc_h26x_cmd.qpMin_vpx;
+  else
+    rcCfg->qpMin = 0;
+  if ((enc_params->specific.enc_h26x_cmd.qpMax_vpx >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMax_vpx <= 127))
+    rcCfg->qpMax = enc_params->specific.enc_h26x_cmd.qpMax_vpx;
+  else
+    rcCfg->qpMax = 127;
+
+  if ((ret = VP8EncSetRateCtrl(h->inst, rcCfg)) != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncSetRateCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  if (rcCfg->pictureRc)
+    h->cbr_last_bitrate = rcCfg->bitPerSecond;
+
+  return 0;
+}
+
+/**
+ * @brief set_pre_process_h264(), set pre-processing config.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_pre_process_h264(v4l2_enc_inst *h,
+                                 v4l2_daemon_enc_params *enc_params) {
+  H264EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+
+  H264EncPreProcessingCfg *preProcCfg = &h264_params->video_prep;
+
+  if ((ret = H264EncGetPreProcessing(h->inst, preProcCfg)) != H264ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncGetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  preProcCfg->inputType = enc_params->general.inputFormat;
+  preProcCfg->inputType = (H264EncPictureType)enc_params->general.inputFormat;
+  preProcCfg->rotation = (H264EncPictureRotation)enc_params->general.rotation;
+  preProcCfg->origWidth = enc_params->general.lumWidthSrc;
+  preProcCfg->origHeight = enc_params->general.lumHeightSrc;
+  if (enc_params->specific.enc_h26x_cmd.interlacedFrame)
+    preProcCfg->origHeight /= 2;
+  if (enc_params->general.horOffsetSrc != -1)
+    preProcCfg->xOffset = enc_params->general.horOffsetSrc;
+  if (enc_params->general.verOffsetSrc != -1)
+    preProcCfg->yOffset = enc_params->general.verOffsetSrc;
+  if (enc_params->general.colorConversion != -1)
+    preProcCfg->colorConversion.type =
+        (H264EncColorConversionType)enc_params->general.colorConversion;
+  if (preProcCfg->colorConversion.type == H264ENC_RGBTOYUV_USER_DEFINED) {
+    preProcCfg->colorConversion.coeffA = 20000;
+    preProcCfg->colorConversion.coeffB = 44000;
+    preProcCfg->colorConversion.coeffC = 5000;
+    preProcCfg->colorConversion.coeffE = 35000;
+    preProcCfg->colorConversion.coeffF = 38000;
+  }
+  if (enc_params->general.scaledWidth * enc_params->general.scaledHeight > 0)
+    preProcCfg->scaledOutput = 1;
+
+  if ((ret = H264EncSetPreProcessing(h->inst, preProcCfg)) != H264ENC_OK) {
+    // close_h26x_encoder(h);
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncSetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief set_pre_process_vp8(), set pre-processing config.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_pre_process_vp8(v4l2_enc_inst *h,
+                                v4l2_daemon_enc_params *enc_params) {
+  VP8EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+  VP8EncPreProcessingCfg *preProcCfg = &vp8_params->vp8_prep;
+
+  if ((ret = VP8EncGetPreProcessing(h->inst, preProcCfg)) != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncGetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  preProcCfg->inputType = enc_params->general.inputFormat;
+  preProcCfg->inputType = (VP8EncPictureType)enc_params->general.inputFormat;
+  preProcCfg->rotation = (VP8EncPictureRotation)enc_params->general.rotation;
+  preProcCfg->origWidth = enc_params->general.lumWidthSrc;
+  preProcCfg->origHeight = enc_params->general.lumHeightSrc;
+  if (enc_params->specific.enc_h26x_cmd.interlacedFrame)
+    preProcCfg->origHeight /= 2;
+  if (enc_params->general.horOffsetSrc != -1)
+    preProcCfg->xOffset = enc_params->general.horOffsetSrc;
+  if (enc_params->general.verOffsetSrc != -1)
+    preProcCfg->yOffset = enc_params->general.verOffsetSrc;
+  if (enc_params->general.colorConversion != -1)
+    preProcCfg->colorConversion.type =
+        (VP8EncColorConversionType)enc_params->general.colorConversion;
+  if (preProcCfg->colorConversion.type == VP8ENC_RGBTOYUV_USER_DEFINED) {
+    preProcCfg->colorConversion.coeffA = 20000;
+    preProcCfg->colorConversion.coeffB = 44000;
+    preProcCfg->colorConversion.coeffC = 5000;
+    preProcCfg->colorConversion.coeffE = 35000;
+    preProcCfg->colorConversion.coeffF = 38000;
+  }
+  if (enc_params->general.scaledWidth * enc_params->general.scaledHeight > 0)
+    preProcCfg->scaledOutput = 1;
+
+  if ((ret = VP8EncSetPreProcessing(h->inst, preProcCfg)) != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncSetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+static int32_t check_area_h264(v4l2_enc_inst *hinst, H264EncPictureArea *area, int32_t width,
+                        int32_t height) {
+  int32_t w = (width + 15) / 16;
+  int32_t h = (height + 15) / 16;
+
+  if ((area->left < w) && (area->right < w) && (area->top < h) &&
+      (area->bottom < h))
+    return 0;
+
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "ROI area check error.
");
+  send_warning_orphan_msg(hinst->instance_id, WARN_ROIREGION);
+  return -1;
+}
+
+static int32_t check_area_vp8(v4l2_enc_inst *hinst, VP8EncPictureArea *area, int32_t width, int32_t height)
+{
+    int32_t w = (width+15)/16;
+    int32_t h = (height+15)/16;
+
+    if ((area->left < w) && (area->right < w) &&
+        (area->top < h) && (area->bottom < h)) return 0;
+
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "ROI area check error.
");
+    send_warning_orphan_msg(hinst->instance_id, WARN_ROIREGION);
+    return -1;
+}
+
+/**
+ * @brief set_coding_control_h264(), set coding control.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_coding_control_h264(v4l2_enc_inst *h,
+                                    v4l2_daemon_enc_params *enc_params) {
+  H264EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+  H264EncCodingCtrl *codingCfg = &h264_params->video_coding_ctrl;
+
+  if ((ret = H264EncGetCodingCtrl(h->inst, codingCfg)) != H264ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncGetCodingCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  if (enc_params->specific.enc_h26x_cmd.sliceSize != -1)
+    codingCfg->sliceSize = enc_params->specific.enc_h26x_cmd.sliceSize;
+  if (enc_params->specific.enc_h26x_cmd.enableCabac != -1)
+    codingCfg->enableCabac = enc_params->specific.enc_h26x_cmd.enableCabac;
+  codingCfg->videoFullRange = 0;
+  if (enc_params->specific.enc_h26x_cmd.videoRange != -1)
+    codingCfg->videoFullRange = enc_params->specific.enc_h26x_cmd.videoRange;
+  codingCfg->disableDeblockingFilter =
+      (enc_params->specific.enc_h26x_cmd.disableDeblocking != 0);
+  if (enc_params->specific.enc_h26x_cmd.sei)
+    codingCfg->seiMessages = 1;
+  else
+    codingCfg->seiMessages = 0;
+  codingCfg->gdrDuration = enc_params->specific.enc_h26x_cmd.gdrDuration;
+  codingCfg->fieldOrder = enc_params->specific.enc_h26x_cmd.fieldOrder;
+  codingCfg->cirStart = enc_params->specific.enc_h26x_cmd.cirStart;
+  codingCfg->cirInterval = enc_params->specific.enc_h26x_cmd.cirInterval;
+
+  int32_t encode_width = enc_params->general.width;
+  int32_t encode_height = enc_params->general.height;
+
+  if (codingCfg->gdrDuration == 0) {
+    codingCfg->intraArea.top = enc_params->specific.enc_h26x_cmd.intraAreaTop;
+    codingCfg->intraArea.left = enc_params->specific.enc_h26x_cmd.intraAreaLeft;
+    codingCfg->intraArea.bottom =
+        enc_params->specific.enc_h26x_cmd.intraAreaBottom;
+    codingCfg->intraArea.right =
+        enc_params->specific.enc_h26x_cmd.intraAreaRight;
+    codingCfg->intraArea.enable =
+        enc_params->specific.enc_h26x_cmd.intraAreaEnable;
+  } else {
+    // intraArea will be used by GDR, customer can not use intraArea when GDR is
+    // enabled.
+    codingCfg->intraArea.enable = 0;
+  }
+  if (codingCfg->gdrDuration == 0) {
+    codingCfg->roi1Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[0];
+    codingCfg->roi1Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[0];
+    codingCfg->roi1Area.bottom =
+        enc_params->specific.enc_h26x_cmd.roiAreaBottom[0];
+    codingCfg->roi1Area.right =
+        enc_params->specific.enc_h26x_cmd.roiAreaRight[0];
+    codingCfg->roi1Area.enable =
+        enc_params->specific.enc_h26x_cmd.roiAreaEnable[0];
+    codingCfg->roi1DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[0];
+    if (check_area_h264(h, &codingCfg->roi1Area, encode_width, encode_height) !=
+            0 ||
+        codingCfg->roi1DeltaQp == 0)
+      codingCfg->roi1Area.enable = 0;
+#if 0  // hard code for test
+        codingCfg->roi1Area.top = 0;
+        codingCfg->roi1Area.left = 0;
+        codingCfg->roi1Area.bottom = 3;
+        codingCfg->roi1Area.right = 3;
+        codingCfg->roi1Area.enable = 1;
+        codingCfg->roi1DeltaQp = -5;
+#endif
+  } else {
+    codingCfg->roi1Area.enable = 0;
+  }
+
+  codingCfg->roi2Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[1];
+  codingCfg->roi2Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[1];
+  codingCfg->roi2Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[1];
+  codingCfg->roi2Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[1];
+  codingCfg->roi2Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[1];
+  codingCfg->roi2DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[1];
+  if (check_area_h264(h, &codingCfg->roi2Area, encode_width, encode_height) != 0 ||
+      codingCfg->roi2DeltaQp == 0)
+    codingCfg->roi2Area.enable = 0;
+
+  if ((ret = H264EncSetCodingCtrl(
+            h->inst, &h264_params->video_coding_ctrl)) != H264ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncSetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief set_coding_control_vp8(), set coding control.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_coding_control_vp8(v4l2_enc_inst *h,
+                                   v4l2_daemon_enc_params *enc_params) {
+  VP8EncRet ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  VP8EncCodingCtrl *codingCfg = &vp8_params->vp8_coding_ctrl;
+  int32_t encode_width = enc_params->general.width;
+  int32_t encode_height = enc_params->general.height;
+
+  if ((ret = VP8EncGetCodingCtrl(h->inst, codingCfg)) != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncGetCodingCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  codingCfg->cirStart = enc_params->specific.enc_h26x_cmd.cirStart;
+  codingCfg->cirInterval = enc_params->specific.enc_h26x_cmd.cirInterval;
+
+  codingCfg->roi1Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[0];
+  codingCfg->roi1Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[0];
+  codingCfg->roi1Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[0];
+  codingCfg->roi1Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[0];
+  codingCfg->roi1Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[0];
+  codingCfg->roi1DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[0];
+  if (check_area_vp8(h, &codingCfg->roi1Area, encode_width, encode_height) != 0 ||
+      codingCfg->roi1DeltaQp == 0)
+    codingCfg->roi1Area.enable = 0;
+
+  codingCfg->roi2Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[1];
+  codingCfg->roi2Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[1];
+  codingCfg->roi2Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[1];
+  codingCfg->roi2Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[1];
+  codingCfg->roi2Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[1];
+  codingCfg->roi2DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[1];
+  if (check_area_vp8(h, &codingCfg->roi2Area, encode_width, encode_height) != 0 ||
+      codingCfg->roi2DeltaQp == 0)
+    codingCfg->roi2Area.enable = 0;
+
+  if ((ret = VP8EncSetCodingCtrl(h->inst, codingCfg)) != VP8ENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncSetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief set_vui_h264(), set vui info to encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_vui_h264(v4l2_enc_inst *h, v4l2_daemon_enc_params *enc_params) {
+  H264EncRet ret;
+  ret = H264EncSetVuiColorDescription(
+      h->inst,
+      enc_params->specific.enc_h26x_cmd.vuiVideoSignalTypePresentFlag,
+      enc_params->specific.enc_h26x_cmd.vuiVideoFormat,
+      enc_params->specific.enc_h26x_cmd.vuiColorDescripPresentFlag,
+      enc_params->specific.enc_h26x_cmd.vuiColorPrimaries,
+      enc_params->specific.enc_h26x_cmd.vuiTransferCharacteristics,
+      enc_params->specific.enc_h26x_cmd.vuiMatrixCoefficients);
+
+  if (ret != H264ENC_OK) return DAEMON_ERR_ENC_INTERNAL;
+
+  return 0;
+}
+
+/**
+ * @brief set_vui_vp8(), set vui info to encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return int: 0: succeed, Others: failed
+ */
+static int set_vui_vp8(v4l2_enc_inst *h, v4l2_daemon_enc_params *enc_params) {
+  (void)h;
+  (void)enc_params;
+  return 0;
+}
+
+
+/**
+ * @brief encoder_init_h1(), init H1 data structures.
+ * @param v4l2_enc_inst* h, encoder instance.
+ * @return .
+ */
+void encoder_init_h1(v4l2_enc_inst *h) {
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+
+  // do nothing, as the memory has been set to 0 when create encoder instance.
+  if(h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    params->init_encoder = init_encoder_h264;
+    params->set_coding_ctrl = set_coding_control_h264;
+    params->set_rate_ctrl = set_rate_control_h264;
+    params->set_pre_process = set_pre_process_h264;
+    params->set_vui = set_vui_h264;
+  } else if(h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    params->init_encoder = init_encoder_vp8;
+    params->set_coding_ctrl = set_coding_control_vp8;
+    params->set_rate_ctrl = set_rate_control_vp8;
+    params->set_pre_process = set_pre_process_vp8;
+    params->set_vui = set_vui_vp8;
+  }
+}
+
+/**
+ * @brief encoder_check_codec_format_h1(), before encode, confirm if hw support
+ * this format.
+ * @param v4l2_enc_inst* h, encoder instance.
+ * @return int, 0 is supported, -1 is unsupported.
+ */
+int encoder_check_codec_format_h1(v4l2_enc_inst *h) {
+  EWLHwConfig_t configure_t;
+
+#if (defined(NXP) && defined(USE_H1))  // h1 single core
+  configure_t = EWLReadAsicConfig();
+  h->configure_t.has_h264 |= configure_t.h264Enabled;
+  h->configure_t.has_jpeg |= configure_t.jpegEnabled;
+  h->configure_t.has_vp8 |= configure_t.vp8Enabled;
+  if (h->configure_t.has_h264) {
+    h->configure_t.max_width_h264 = configure_t.maxEncodedWidth;
+  }
+  if (h->configure_t.has_vp8) {
+    h->configure_t.max_width_vp8 = configure_t.maxEncodedWidth;
+  }
+#endif
+  if ((h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) &&
+      (h->configure_t.has_vp8 == 1))
+    return 0;
+  else if ((h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) &&
+           (h->configure_t.has_h264 == 1))
+    return 0;
+  else
+    return -1;
+}
+
+/**
+ * @brief encoder_get_input_h1(), write message from V4l2 parameter to encoder
+ * instance.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if init gop config of encIn.
+ * @return void.
+ */
+void encoder_get_input_h1(v4l2_enc_inst *h, v4l2_daemon_enc_params *enc_params,
+                          int32_t if_config) {
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+  uint32_t size_lum = 0;
+  uint32_t size_ch = 0;
+
+  H264EncIn *h264EncIn = NULL;
+  VP8EncIn *vp8EncIn = NULL;
+
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    h264EncIn = &h264_params->video_in;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    vp8EncIn = &vp8_params->vp8_enc_in;
+  }
+  size_lum = ((enc_params->general.lumWidthSrc + 15) & (~15)) *
+             enc_params->general.lumHeightSrc;  // Now 8 bit yuv only
+  size_ch = size_lum / 2;
+
+#ifndef USE_HW
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    h264EncIn->busLuma =
+        (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busLuma,
+                                    enc_params->io_buffer.busLumaSize);
+    if (enc_params->io_buffer.busChromaU != 0)
+      h264EncIn->busChromaU =
+          (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busChromaU,
+                                      enc_params->io_buffer.busChromaUSize);
+    else
+      h264EncIn->busChromaU = h264EncIn->busLuma + size_lum;
+
+    if (enc_params->io_buffer.busChromaV != 0)
+      h264EncIn->busChromaV =
+          (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busChromaV,
+                                      enc_params->io_buffer.busChromaVSize);
+    else
+      h264EncIn->busChromaV = h264EncIn->busChromaU + size_ch / 2;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    vp8EncIn->busLuma =
+        (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busLuma,
+                                    enc_params->io_buffer.busLumaSize);
+    if (enc_params->io_buffer.busChromaU != 0)
+      vp8EncIn->busChromaU =
+          (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busChromaU,
+                                      enc_params->io_buffer.busChromaUSize);
+    else
+      vp8EncIn->busChromaU = vp8EncIn->busLuma + size_lum;
+
+    if (enc_params->io_buffer.busChromaV != 0)
+      vp8EncIn->busChromaV =
+          (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busChromaV,
+                                      enc_params->io_buffer.busChromaVSize);
+    else
+      vp8EncIn->busChromaV = vp8EncIn->busChromaU + size_ch / 2;
+  }
+#else
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    h264EncIn->busLuma = enc_params->io_buffer.busLuma;
+    if (enc_params->io_buffer.busChromaU != 0)
+      h264EncIn->busChromaU = enc_params->io_buffer.busChromaU;
+    else
+      h264EncIn->busChromaU = h264EncIn->busLuma + size_lum;
+    if (enc_params->io_buffer.busChromaV != 0)
+      h264EncIn->busChromaV = enc_params->io_buffer.busChromaV;
+    else
+      h264EncIn->busChromaV = h264EncIn->busChromaU + size_ch / 2;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    vp8EncIn->busLuma = enc_params->io_buffer.busLuma;
+    if (enc_params->io_buffer.busChromaU != 0)
+      vp8EncIn->busChromaU = enc_params->io_buffer.busChromaU;
+    else
+      vp8EncIn->busChromaU = vp8EncIn->busLuma + size_lum;
+    if (enc_params->io_buffer.busChromaV != 0)
+      vp8EncIn->busChromaV = enc_params->io_buffer.busChromaV;
+    else
+      vp8EncIn->busChromaV = vp8EncIn->busChromaU + size_ch / 2;
+  }
+#endif
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    h->saveOriOutBuf = h264EncIn->pOutBuf =
+        mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busOutBuf,
+                             enc_params->io_buffer.outBufSize);
+#ifdef USE_HW
+    h264EncIn->busOutBuf = enc_params->io_buffer.busOutBuf;
+#else
+    h264EncIn->busOutBuf = (ptr_t)h264EncIn->pOutBuf;
+#endif
+    h264EncIn->outBufSize = enc_params->io_buffer.outBufSize;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    h->saveOriOutBuf = vp8EncIn->pOutBuf =
+        mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busOutBuf,
+                             enc_params->io_buffer.outBufSize);
+#ifdef USE_HW
+    vp8EncIn->busOutBuf = enc_params->io_buffer.busOutBuf;
+#else
+    vp8EncIn->busOutBuf = (ptr_t)vp8EncIn->pOutBuf;
+#endif
+    vp8EncIn->outBufSize = enc_params->io_buffer.outBufSize;
+  }
+
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    if (enc_params->general.outputRateDenom != 0)
+      h264EncIn->timeIncrement = enc_params->general.outputRateDenom;
+    else
+      h264EncIn->timeIncrement = 1;
+    if (enc_params->specific.enc_h26x_cmd.force_idr) {
+      h264EncIn->codingType = H264ENC_INTRA_FRAME;
+      h->next_pic_type = (int)H264ENC_INTRA_FRAME;
+    }
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    if (enc_params->general.outputRateDenom != 0)
+      vp8EncIn->timeIncrement = enc_params->general.outputRateDenom;
+    else
+      vp8EncIn->timeIncrement = 1;
+
+    if (enc_params->specific.enc_h26x_cmd.force_idr) {
+      vp8EncIn->codingType = VP8ENC_INTRA_FRAME;
+      h->next_pic_type = (int)VP8ENC_INTRA_FRAME;
+    }
+  }
+}
+
+/**
+ * @brief encoder_set_parameter_h1(), set encoder parameters.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if configure the encoder.
+ * @return int: api return value.
+ */
+int encoder_set_parameter_h1(v4l2_enc_inst *h,
+                             v4l2_daemon_enc_params *enc_params,
+                             int32_t if_config) {
+  int ret;
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+
+  encoder_get_input_h1(h, enc_params, if_config);
+
+  /* Encoder setup: init instance.*/
+  if (if_config == 1) {
+    ret = params->init_encoder(h, enc_params);
+    if (ret) return ret;
+
+    h->total_frames = 0;
+  }
+
+  /* Encoder setup: rate control */
+  if ((if_config == 1) || (enc_params->specific.enc_h26x_cmd.picRc == 0) ||
+      (enc_params->specific.enc_h26x_cmd.hrdConformance != 1 &&
+       if_config != 1)) {
+    ret = params->set_rate_ctrl(h, enc_params);
+    if (ret) return ret;
+  }
+
+  /*Check if the cbr bit rate is changed.*/
+  check_if_cbr_bitrate_changed(h, enc_params);
+
+  /*Encoder setup: PreP setup */
+  ret = params->set_pre_process(h, enc_params);
+  if (ret) return ret;
+
+  /* Encoder setup: coding control */
+  ret = params->set_coding_ctrl(h, enc_params);
+  if (ret) return ret;
+
+  /* Encoder setup: color description */
+  ret = params->set_vui(h, enc_params);
+  if (ret) return ret;
+
+  return 0;
+}
+
+/**
+ * @brief encoder_start_h1(), start encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @return int: api return value.
+ */
+int encoder_start_h1(v4l2_enc_inst *h, uint32_t *stream_size) {
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  H264EncIn *h264EncIn = NULL;
+  H264EncOut *h264EncOut = NULL;
+  VP8EncIn *vp8EncIn = NULL;
+  u8 *pOutBufTmp = NULL;
+  int ret = 0;
+
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    int encRet;
+    h264EncIn = &h264_params->video_in;
+    h264EncOut = &h264_params->video_out;
+    pOutBufTmp = (u8 *)h264EncIn->pOutBuf;
+    encRet = H264EncStrmStart(h->inst, h264EncIn, h264EncOut);
+    *stream_size = h264EncOut->streamSize;
+
+    ret = (encRet == H264ENC_OK) ? 0 : DAEMON_ERR_ENC_INTERNAL;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    vp8EncIn = &vp8_params->vp8_enc_in;
+    pOutBufTmp = (u8 *)vp8EncIn->pOutBuf;
+#ifdef OUTPUT_VP8_HEADER
+    IvfHeader(pOutBufTmp, vp8_params->vp8_config.width,
+              vp8_params->vp8_config.height,
+              vp8_params->vp8_config.frameRateNum,
+              vp8_params->vp8_config.frameRateDenom, 0);
+    *stream_size = IVF_HDR_BYTES + IVF_FRM_BYTES;
+#else
+    *stream_size = 0;
+#endif
+    ret = 0;
+  }
+  memset(pOutBufTmp + *stream_size, 0,
+         (*stream_size + 7) / 8 * 8 - *stream_size);
+  *stream_size = (*stream_size + 7) / 8 * 8;  // vc8000nanoe need 8 allign
+  return ret;
+}
+
+/**
+ * @brief encoder_encode_h1(), encoder encode.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @param uint32_t* codingType: coding type.
+ * @return int: api return value.
+ */
+int encoder_encode_h1(v4l2_enc_inst *h, uint32_t *stream_size,
+                      uint32_t *codingType) {
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  H264EncIn *h264EncIn = NULL;
+  H264EncOut *h264EncOut = NULL;
+  VP8EncIn *vp8EncIn = NULL;
+  VP8EncOut *vp8EncOut = NULL;
+  int ret = 0;
+  int encRet;
+#ifdef OUTPUT_VP8_HEADER
+  u8 *pOutBufTmp = NULL;
+  uint32_t payload_size = 0;
+#endif
+
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    h264EncIn = &h264_params->video_in;
+    h264EncOut = &h264_params->video_out;
+    h264EncIn->pOutBuf += *stream_size / 4;
+    h264EncIn->busOutBuf += *stream_size;
+    h264EncIn->outBufSize -= *stream_size;
+    if (h264EncIn->busOutBuf % 8 != 0) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Input address not alligned to 8
");
+    }
+    encRet = H264EncStrmEncode(h->inst, h264EncIn, h264EncOut, NULL, NULL, NULL);
+    *stream_size += h264EncOut->streamSize;
+    if ((h264EncOut->codingType == H264ENC_INTRA_FRAME) ||
+        ((h264EncIn->codingType == H264ENC_INTRA_FRAME) &&
+         (h264_params->video_coding_ctrl.gdrDuration > 0))) {
+      params->intraPeriodCnt = 0;
+    }
+    if (h264_params->video_out.codingType != H264ENC_NOTCODED_FRAME) {
+      params->intraPeriodCnt++;
+    }
+    *codingType = h264EncIn->codingType;
+    if (encRet == H264ENC_FRAME_READY) ret = DAEMON_ENC_FRAME_READY;
+    else ret = DAEMON_ERR_ENC_INTERNAL;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    vp8EncIn = &vp8_params->vp8_enc_in;
+    vp8EncOut = &vp8_params->vp8_enc_out;
+#ifdef OUTPUT_VP8_HEADER
+    pOutBufTmp = (u8 *)vp8EncIn->pOutBuf;
+#endif
+    vp8EncIn->pOutBuf += *stream_size / 4;
+    vp8EncIn->busOutBuf += *stream_size;
+    vp8EncIn->outBufSize -= *stream_size;
+    if (vp8EncIn->busOutBuf % 8 != 0) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Input address not alligned to 8
");
+    }
+    encRet = VP8EncStrmEncode(h->inst, vp8EncIn, vp8EncOut);
+    for (int itmp = 0; itmp < 9; itmp++) {
+      if (itmp > 0 && vp8EncOut->streamSize[itmp] > 0)
+        memcpy(vp8EncIn->pOutBuf, vp8EncOut->pOutBuf[itmp],
+               vp8EncOut->streamSize[itmp]);
+      vp8EncIn->pOutBuf =
+          (uint32_t *)((u8 *)vp8EncIn->pOutBuf + vp8EncOut->streamSize[itmp]);
+      *stream_size += vp8EncOut->streamSize[itmp];
+#ifdef OUTPUT_VP8_HEADER
+      payload_size += vp8EncOut->streamSize[itmp];
+#endif
+    }
+    if ((vp8EncIn->codingType == VP8ENC_INTRA_FRAME ||
+        vp8EncOut->codingType == VP8ENC_INTRA_FRAME) &&
+        (vp8_params->vp8_rate_ctrl.intraPictureRate))
+            params->intraPeriodCnt = 0;
+
+    if (vp8EncOut->codingType != VP8ENC_NOTCODED_FRAME)
+        params->intraPeriodCnt++;
+    *codingType = vp8EncIn->codingType;
+#ifdef OUTPUT_VP8_HEADER
+    IvfFrame(pOutBufTmp + IVF_HDR_BYTES, payload_size, params->frameCntTotal);
+    memmove(pOutBufTmp + IVF_HDR_BYTES + IVF_FRM_BYTES,
+            pOutBufTmp + *stream_size - payload_size, payload_size);
+    *stream_size -= *stream_size - payload_size - IVF_HDR_BYTES - IVF_FRM_BYTES;
+    params->frameCntTotal++;
+#endif
+    if (encRet == VP8ENC_FRAME_READY) ret = DAEMON_ENC_FRAME_READY;
+    else ret = DAEMON_ERR_ENC_INTERNAL;
+  }
+  return ret;
+}
+
+/**
+ * @brief encoder_find_next_pic_h1(), find buffer and gop structure of next
+ * picture.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param BUFFER** p_buffer: buffer to encode
+ * @param uint32_t* list_num: buffer id in buffer list.
+ * @return int: api return value.
+ */
+int encoder_find_next_pic_h1(v4l2_enc_inst *h, BUFFER **p_buffer,
+                             uint32_t *list_num) {
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+  h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  *p_buffer = bufferlist_get_buffer(h->bufferlist_reorder);
+  *list_num = 0;
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    /* Select frame type */
+    if ((h264_params->video_rate_ctrl.gopLen != 0) &&
+        (params->intraPeriodCnt >= h264_params->video_rate_ctrl.gopLen)) {
+      h264_params->video_in.codingType = H264ENC_INTRA_FRAME;
+      h->next_pic_type = (int)H264ENC_INTRA_FRAME;
+    } else {
+      h264_params->video_in.codingType = H264ENC_PREDICTED_FRAME;
+      h264_params->video_in.ipf = H264ENC_REFERENCE_AND_REFRESH;
+      h264_params->video_in.ltrf = H264ENC_REFERENCE;
+      h->next_pic_type = (int)H264ENC_PREDICTED_FRAME;
+    }
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+      if (vp8_params->vp8_rate_ctrl.intraPictureRate &&
+          params->intraPeriodCnt >= vp8_params->vp8_rate_ctrl.intraPictureRate) {
+          vp8_params->vp8_enc_in.codingType = VP8ENC_INTRA_FRAME;
+          h->next_pic_type = (int)VP8ENC_INTRA_FRAME;
+      } else {
+          vp8_params->vp8_enc_in.codingType = VP8ENC_PREDICTED_FRAME;
+          vp8_params->vp8_enc_in.ipf = VP8ENC_REFERENCE_AND_REFRESH;
+          h->next_pic_type = (int)VP8ENC_PREDICTED_FRAME;
+      }
+  }
+  return 0;
+}
+
+/**
+ * @brief reset_enc_h1(), reset encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+void reset_enc_h1(v4l2_enc_inst *h)
+{
+    return;
+}
+
+/**
+* @brief encoder_end_h1(), stream end, write eos.
+* @param v4l2_enc_inst* h: encoder instance.
+* @param uint32_t* stream_size: srteam size.
+* @return int: api return value.
+*/
+int encoder_end_h1(v4l2_enc_inst *h, uint32_t *stream_size) {
+  h1_enc_params *params = (h1_enc_params *)h->enc_params;
+  h1_h264_enc_params *h264_params = &params->param.h264;
+  //    h1_vp8_enc_params *vp8_params = &params->param.vp8;
+
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    H264EncRet ret;
+    ret = H264EncStrmEnd(h->inst, &h264_params->video_in,
+                         &h264_params->video_out);
+    if (ret != H264ENC_OK) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncStrmEnd() failed. vsi_ret=%d
",
+                 ret);
+      return (int)ret;
+    }
+    return (int)ret;
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+    return 0;  // no eos
+  }
+  return 0;
+}
+
+/**
+ * @brief encoder_close_h1(), close encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+int encoder_close_h1(v4l2_enc_inst *h) {
+  int ret = 0;
+  if (h->inst != NULL) {
+    if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+      if ((ret = H264EncRelease(h->inst)) != H264ENC_OK) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "H264EncRelease() failed. vsi_ret=%d
",
+                   ret);
+      }
+    } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_VP8) {
+      if ((ret = VP8EncRelease(h->inst)) != VP8ENC_OK) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "VP8EncRelease() failed. vsi_ret=%d
",
+                   ret);
+      }
+    }
+  }
+
+  if (h->bufferlist_input) bufferlist_flush(h->bufferlist_input);
+  if (h->bufferlist_output) bufferlist_flush(h->bufferlist_output);
+  if (h->bufferlist_reorder) bufferlist_flush(h->bufferlist_reorder);
+  return ret;
+}
+
+/**
+ * @brief encoder_get_attr_h1(), get encoder attributes.
+ * @param v4l2_daemon_codec_fmt fmt: codec format.
+ * @return
+ */
+void encoder_get_attr_h1(v4l2_daemon_codec_fmt fmt, enc_inst_attr *attr) {
+  ASSERT(attr);
+
+  attr->param_size = sizeof(h1_enc_params);
+}
diff --git a/v4l2_vsi_daemon/src/vsi_enc_video_h1.h b/v4l2_vsi_daemon/src/vsi_enc_video_h1.h
new file mode 100755
index 0000000..9ef7792
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_video_h1.h
@@ -0,0 +1,132 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef VSI_ENC_VIDEO_H2_H
+#define VSI_ENC_VIDEO_H2_H
+#include "vsi_enc.h"
+
+/**
+ * @file vsi_enc_video_h1.h
+ * @brief V4L2 Daemon video process header file.
+ * @version 0.10- Initial version
+ */
+
+/**
+ * @brief encoder_check_codec_format_h1(), before encode, confirm if hw support
+ * this format.
+ * @param v4l2_enc_inst* h, encoder instance.
+ * @return int, 0 is supported, -1 is unsupported.
+ */
+int encoder_check_codec_format_h1(v4l2_enc_inst* h);
+
+/**
+ * @brief encoder_init_h1(), init H1 data structures.
+ * @param v4l2_enc_inst* h, encoder instance.
+ * @return .
+ */
+void encoder_init_h1(v4l2_enc_inst* h);
+
+/**
+ * @brief encoder_get_attr_h1(), get encoder attributes.
+ * @param v4l2_enc_inst fmt: codec format.
+ * @return
+ */
+void encoder_get_attr_h1(v4l2_daemon_codec_fmt fmt, enc_inst_attr* attr);
+
+/**
+ * @brief encoder_get_input_h1(), write message from V4l2 parameter to encoder
+ * instance.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if init gop config of encIn.
+ * @return void.
+ */
+void encoder_get_input_h1(v4l2_enc_inst* h, v4l2_daemon_enc_params* enc_params,
+                          int32_t if_config);
+
+/**
+ * @brief encoder_set_parameter_h1(), set encoder parameters.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if configure the encoder.
+ * @return int: api return value.
+ */
+int encoder_set_parameter_h1(v4l2_enc_inst* h,
+                             v4l2_daemon_enc_params* enc_params,
+                             int32_t if_config);
+
+/**
+ * @brief encoder_start_h1(), start encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @return int: api return value.
+ */
+int encoder_start_h1(v4l2_enc_inst* h, uint32_t* stream_size);
+
+/**
+ * @brief encoder_encode_h1(), encoder encode.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @param uint32_t* codingType: coding type.
+ * @return int: api return value.
+ */
+int encoder_encode_h1(v4l2_enc_inst* h, uint32_t* stream_size,
+                      uint32_t* codingType);
+
+/**
+ * @brief encoder_find_next_pic_h1(), find buffer and gop structure of next
+ * picture.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param BUFFER** p_buffer: buffer to encode
+ * @param uint32_t* list_num: buffer id in buffer list.
+ * @return int: api return value.
+ */
+int encoder_find_next_pic_h1(v4l2_enc_inst* h, BUFFER** p_buffer,
+                             uint32_t* list_num);
+
+/**
+ * @brief reset_enc_h1(), reset encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+void reset_enc_h1(v4l2_enc_inst *h);
+
+/**
+* @brief encoder_end_h1(), stream end, write eos.
+* @param v4l2_enc_inst* h: encoder instance.
+* @param uint32_t* stream_size: srteam size.
+* @return int: api return value.
+*/
+int encoder_end_h1(v4l2_enc_inst* h, uint32_t* stream_size);
+
+/**
+ * @brief encoder_close_h1(), close encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+int encoder_close_h1(v4l2_enc_inst* h);
+
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_video_h1_priv.h b/v4l2_vsi_daemon/src/vsi_enc_video_h1_priv.h
new file mode 100755
index 0000000..e9e844c
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_video_h1_priv.h
@@ -0,0 +1,70 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef __VSI_ENC_VIDEO_H2_PRIV_H__
+#define __VSI_ENC_VIDEO_H2_PRIV_H__
+#include "ewl.h"
+#include "h264encapi.h"
+#include "vp8encapi.h"
+
+typedef struct {
+  H264EncIn video_in;
+  H264EncOut video_out;
+
+  H264EncConfig video_config;
+  H264EncRateCtrl video_rate_ctrl;
+  H264EncCodingCtrl video_coding_ctrl;
+  H264EncPreProcessingCfg video_prep;
+} h1_h264_enc_params;
+
+typedef struct {
+  VP8EncIn vp8_enc_in;
+  VP8EncOut vp8_enc_out;
+
+  VP8EncConfig vp8_config;
+  VP8EncRateCtrl vp8_rate_ctrl;
+  VP8EncCodingCtrl vp8_coding_ctrl;
+  VP8EncPreProcessingCfg vp8_prep;
+} h1_vp8_enc_params;
+
+typedef struct {
+  union {
+    h1_h264_enc_params h264;
+    h1_vp8_enc_params vp8;
+  } param;
+
+  int32_t intraPeriodCnt;
+  uint64_t frameCntTotal;
+
+  int (*init_encoder)(v4l2_enc_inst *h, v4l2_daemon_enc_params *params);
+  int (*set_rate_ctrl)(v4l2_enc_inst *h, v4l2_daemon_enc_params *params);
+  int (*set_pre_process)(v4l2_enc_inst *h, v4l2_daemon_enc_params *params);
+  int (*set_coding_ctrl)(v4l2_enc_inst *h, v4l2_daemon_enc_params *params);
+  int (*set_vui)(v4l2_enc_inst *h, v4l2_daemon_enc_params *params);
+
+} h1_enc_params;
+
+#endif /*__VSI_ENC_VIDEO_H2_PRIV_H__*/
diff --git a/v4l2_vsi_daemon/src/vsi_enc_video_h2.c b/v4l2_vsi_daemon/src/vsi_enc_video_h2.c
new file mode 100755
index 0000000..5f130db
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_video_h2.c
@@ -0,0 +1,2470 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_enc_video.c
+ * @brief V4L2 Daemon video process header file.
+ * @version 0.10- Initial version
+ */
+#include <math.h>
+
+#include "buffer_list.h"
+#include "fifo.h"
+#include "vsi_daemon_debug.h"
+#include "vsi_enc.h"
+#include "vsi_enc_img_h2.h"
+#include "vsi_enc_img_h2_priv.h"
+#include "vsi_enc_video_h2.h"
+#include "vsi_enc_video_h2_priv.h"
+
+//#include "rate_control_picture.h"
+
+#define LEAST_MONITOR_FRAME 3
+#define MOVING_AVERAGE_FRAMES 120
+#define MAX_GOP_LEN 8
+
+#define VCENC_MIN_ENC_WIDTH 132  // confirm with ZhangKe, 132x128
+#define VCENC_MAX_ENC_WIDTH 8192
+#define VCENC_MIN_ENC_HEIGHT 128
+#define VCENC_MAX_ENC_HEIGHT 8192
+#define VCENC_MAX_ENC_HEIGHT_EXT 8640
+// No limits of MAX_MBS_PER_PIC
+
+i32 VCEncSetVuiColorDescription(
+    VCEncInst inst, u32 vuiVideoSignalTypePresentFlag, u32 vuiVideoFormat,
+    u32 vuiColorDescripPresentFlag, u32 vuiColorPrimaries,
+    u32 vuiTransferCharacteristics, u32 vuiMatrixCoefficients);
+/**
+ * @brief Below are the default GOP configures. From left to right is:
+          Type POC QPoffset  QPfactor  num_ref_pics ref_pics  used_by_cur
+ */
+int8_t *RpsDefault_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.4     0      1        -1         1", NULL,
+};
+int8_t *RpsDefault_H264_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.4     0      1        -1         1", NULL,
+};
+
+int8_t *RpsDefault_GOPSize_2[] = {
+    "Frame1:  P    2   0        0.6     0      1        -2         1",
+    "Frame2:  B    1   0        0.5     0      2        -1 1       1 1", NULL,
+};
+
+int8_t *RpsDefault_GOPSize_3[] = {
+    "Frame1:  P    3   0        0.5     0      1        -3         1   ",
+    "Frame2:  B    1   0        0.442     0      2        -1 2       1 1 ",
+    "Frame3:  B    2   0        0.442   0      2        -1 1       1 1 ", NULL,
+};
+
+int8_t *RpsDefault_GOPSize_4[] = {
+    "Frame1:  P    4   0        0.5     0      1        -4         1   ",
+    "Frame2:  B    1   0        0.442   0      2        -1 3       1 1 ",
+    "Frame3:  B    2   0        0.442   0      2        -2 2       1 1 ",
+    "Frame4:  B    3   0        0.442   0      2        -3 1       1 1 ",
+    NULL,
+};
+
+int8_t *RpsDefault_GOPSize_5[] = {
+    "Frame1:  P    5   0        0.442   0      1        -5         1   ",
+    "Frame2:  B    1   0        0.3536  0      2        -1 4       1 1 ",
+    "Frame3:  B    2   0        0.3536  0      2        -2 3       1 1 ",
+    "Frame4:  B    3   0        0.3536  0      2        -3 2       1 1 ",
+    "Frame5:  B    4   0        0.3536  0      2        -4 1       1 1 ",
+    NULL,
+};
+
+int8_t *RpsDefault_GOPSize_6[] = {
+    "Frame1:  P    6   0        0.442   0      1        -6         1   ",
+    "Frame2:  B    1   0        0.3536  0      2        -1 5       1 1 ",
+    "Frame3:  B    2   0        0.3536  0      2        -2 4       1 1 ",
+    "Frame4:  B    3   0        0.3536  0      2        -3 3       1 1 ",
+    "Frame5:  B    4   0        0.3536  0      2        -4 2       1 1 ",
+    "Frame6:  B    5   0        0.3536  0      2        -5 1       1 1 ",
+    NULL,
+};
+
+int8_t *RpsDefault_GOPSize_7[] = {
+    "Frame1:  P    7   0        0.442   0      1        -7         1   ",
+    "Frame2:  B    1   0        0.3536  0      2        -1 6       1 1 ",
+    "Frame3:  B    2   0        0.3536  0      2        -2 5       1 1 ",
+    "Frame4:  B    3   0        0.3536  0      2        -3 4       1 1 ",
+    "Frame5:  B    4   0        0.3536  0      2        -4 3       1 1 ",
+    "Frame6:  B    5   0        0.3536  0      2        -5 2       1 1 ",
+    "Frame7:  B    6   0        0.3536  0      2        -6 1       1 1 ",
+    NULL,
+};
+
+int8_t *RpsDefault_GOPSize_8[] = {
+    "Frame1:  P    8   0        0.442   0      1        -8         1   ",
+    "Frame2:  B    1   0        0.221  0      2        -1 7       1 1 ",
+    "Frame3:  B    2   0        0.221  0      2        -2 6       1 1 ",
+    "Frame4:  B    3   0        0.221  0      2        -3 5       1 1 ",
+    "Frame5:  B    4   0        0.221  0      2        -4 4       1 1 ",
+    "Frame6:  B    5   0        0.221  0      2        -5 3       1 1 ",
+    "Frame7:  B    6   0        0.221  0      2        -6 2       1 1 ",
+    "Frame8:  B    7   0        0.221  0      2        -7 1       1 1",
+    NULL,
+};
+
+int8_t *RpsDefault_Interlace_GOPSize_1[] = {
+    "Frame1:  P    1   0        0.8       0   2           -1 -2     0 1", NULL,
+};
+
+int8_t *RpsLowdelayDefault_GOPSize_1[] = {
+    "Frame1:  B    1   0        0.65      0     2       -1 -2         1 1",
+    NULL,
+};
+
+int8_t *RpsLowdelayDefault_GOPSize_2[] = {
+    "Frame1:  B    1   0        0.4624    0     2       -1 -3         1 1",
+    "Frame2:  B    2   0        0.578     0     2       -1 -2         1 1",
+    NULL,
+};
+
+int8_t *RpsLowdelayDefault_GOPSize_3[] = {
+    "Frame1:  B    1   0        0.4624    0     2       -1 -4         1 1",
+    "Frame2:  B    2   0        0.4624    0     2       -1 -2         1 1",
+    "Frame3:  B    3   0        0.578     0     2       -1 -3         1 1",
+    NULL,
+};
+
+int8_t *RpsLowdelayDefault_GOPSize_4[] = {
+    "Frame1:  B    1   0        0.4624    0     2       -1 -5         1 1",
+    "Frame2:  B    2   0        0.4624    0     2       -1 -2         1 1",
+    "Frame3:  B    3   0        0.4624    0     2       -1 -3         1 1",
+    "Frame4:  B    4   0        0.578     0     2       -1 -4         1 1",
+    NULL,
+};
+
+int8_t *RpsPass2_GOPSize_4[] = {
+    "Frame1:  B    4   0        0.5      0     2       -4 -8      1 1",
+    "Frame2:  B    2   0        0.3536   0     2       -2 2       1 1",
+    "Frame3:  B    1   0        0.5      0     3       -1 1 3     1 1 0",
+    "Frame4:  B    3   0        0.5      0     3       -1 -3 1    1 0 1",
+    NULL,
+};
+
+int8_t *RpsPass2_GOPSize_8[] = {
+    "Frame1:  B    8   0        0.442    0  2           -8 -16    1 1",
+    "Frame2:  B    4   0        0.3536   0  2           -4 4      1 1",
+    "Frame3:  B    2   0        0.3536   0  3           -2 2 6    1 1 0",
+    "Frame4:  B    1   0        0.68     0  4           -1 1 3 7  1 1 0 0",
+    "Frame5:  B    3   0        0.68     0  4           -1 -3 1 5 1 0 1 0",
+    "Frame6:  B    6   0        0.3536   0  3           -2 -6 2   1 0 1",
+    "Frame7:  B    5   0        0.68     0  4           -1 -5 1 3 1 0 1 0",
+    "Frame8:  B    7   0        0.68     0  3           -1 -7 1   1 0 1",
+    NULL,
+};
+
+int8_t *RpsPass2_GOPSize_2[] = {
+    "Frame1:  B    2   0        0.6     0      2        -2 -4      1 1",
+    "Frame2:  B    1   0        0.68    0      2        -1 1       1 1", NULL,
+};
+
+/**
+ * @brief init_cmdl(), init command line parameters.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param VCEncIn* encIn: encoder input parameters.
+ * @return void.
+ */
+static void init_cmdl(v4l2_enc_inst *h, VCEncIn *encIn) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+
+  memset(&params->cml, 0, sizeof(params->cml));
+  params->cml.bFrameQpDelta = 0;
+  params->cml.codecFormat = 0;
+  params->cml.interlacedFrame = 0;
+  params->cml.intraPicRate = 30;
+  params->cml.gdrDuration = 0;
+  params->cml.pass = 0;
+  params->cml.gopSize = encIn->gopSize;
+  params->cml.ltrInterval = -1;
+}
+
+/**
+ * @brief nextToken(), string parse.
+ * @param int8_t *str: input string.
+ * @return int8_t*.
+ */
+static int8_t *nextToken(const char *str) {
+  int8_t *p = strchr(str, ' ');
+  if (p) {
+    while (*p == ' ') p++;
+    if (*p == ' ') p = NULL;
+  }
+  return p;
+}
+
+/**
+ * @brief ParseGopConfigString(), string parse.
+ * @param int8_t *line: input string line.
+ * @param VCEncGopConfig *gopCfg: gop config.
+ * @param int32_t frame_idx: frame idx.
+ * @param int32_t gopSize: gop size.
+ * @return int32_t: 0 successful, other unsuccessful.
+ */
+static int32_t ParseGopConfigString(const char *line, VCEncGopConfig *gopCfg,
+                                    int32_t frame_idx, int32_t gopSize) {
+  if (!line) return -1;
+
+  // format: FrameN Type POC QPoffset QPfactor  num_ref_pics ref_pics
+  // used_by_cur
+  int32_t frameN, poc, num_ref_pics, i;
+  int8_t type;
+  VCEncGopPicConfig *cfg = NULL;
+  VCEncGopPicSpecialConfig *scfg = NULL;
+
+  // frame idx
+  sscanf(line, "Frame%d", &frameN);
+  if ((frameN != (frame_idx + 1)) && (frameN != 0)) return -1;
+
+  if (frameN > gopSize) return 0;
+
+  if (0 == frameN) {
+    // format: FrameN Type  QPoffset  QPfactor   TemporalId  num_ref_pics
+    // ref_pics  used_by_cur  LTR    Offset   Interval
+    scfg = &(gopCfg->pGopPicSpecialCfg[gopCfg->special_size++]);
+
+    // frame type
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%c", &type);
+    if (type == 'I' || type == 'i')
+      scfg->codingType = VCENC_INTRA_FRAME;
+    else if (type == 'P' || type == 'p')
+      scfg->codingType = VCENC_PREDICTED_FRAME;
+    else if (type == 'B' || type == 'b')
+      scfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+    else
+      scfg->codingType = FRAME_TYPE_RESERVED;
+
+    // qp offset
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &(scfg->QpOffset));
+
+    // qp factor
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%lf", &(scfg->QpFactor));
+    scfg->QpFactor = sqrt(scfg->QpFactor);
+
+    // temporalId factor
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &(scfg->temporalId));
+
+    // num_ref_pics
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &num_ref_pics);
+    if (num_ref_pics < 0 || num_ref_pics > VCENC_MAX_REF_FRAMES) /* NUMREFPICS_RESERVED -1 */
+    {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "GOP Config: Error, num_ref_pic can not be more than %d 
",
+                 VCENC_MAX_REF_FRAMES);
+      return -1;
+    }
+    scfg->numRefPics = num_ref_pics;
+
+    if ((scfg->codingType == VCENC_INTRA_FRAME) && (0 == num_ref_pics))
+      num_ref_pics = 1;
+    // ref_pics
+    for (i = 0; i < num_ref_pics; i++) {
+      line = nextToken(line);
+      if (!line) return -1;
+      if ((strncmp(line, "L", 1) == 0) || (strncmp(line, "l", 1) == 0)) {
+        sscanf(line, "%c%d", &type, &(scfg->refPics[i].ref_pic));
+        scfg->refPics[i].ref_pic =
+            LONG_TERM_REF_ID2DELTAPOC(scfg->refPics[i].ref_pic - 1);
+      } else {
+        sscanf(line, "%d", &(scfg->refPics[i].ref_pic));
+      }
+    }
+    if (i < num_ref_pics) return -1;
+
+    // used_by_cur
+    for (i = 0; i < num_ref_pics; i++) {
+      line = nextToken(line);
+      if (!line) return -1;
+      sscanf(line, "%u", &(scfg->refPics[i].used_by_cur));
+    }
+    if (i < num_ref_pics) return -1;
+
+    // LTR
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &scfg->i32Ltr);
+    if (VCENC_MAX_LT_REF_FRAMES < scfg->i32Ltr) return -1;
+
+    // Offset
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &scfg->i32Offset);
+
+    // Interval
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &scfg->i32Interval);
+
+    if (0 != scfg->i32Ltr) {
+      gopCfg->u32LTR_idx[gopCfg->ltrcnt] =
+          LONG_TERM_REF_ID2DELTAPOC(scfg->i32Ltr - 1);
+      gopCfg->ltrcnt++;
+      if (VCENC_MAX_LT_REF_FRAMES < gopCfg->ltrcnt) return -1;
+    }
+
+    // short_change
+    scfg->i32short_change = 0;
+    if (0 == scfg->i32Ltr) {
+      /* not long-term ref */
+      scfg->i32short_change = 1;
+      for (i = 0; i < num_ref_pics; i++) {
+        if (IS_LONG_TERM_REF_DELTAPOC(scfg->refPics[i].ref_pic) &&
+            (0 != scfg->refPics[i].used_by_cur)) {
+          scfg->i32short_change = 0;
+          break;
+        }
+      }
+    }
+  } else {
+    // format: FrameN Type  POC  QPoffset    QPfactor   TemporalId  num_ref_pics
+    // ref_pics  used_by_cur
+    cfg = &(gopCfg->pGopPicCfg[gopCfg->size++]);
+
+    // frame type
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%c", &type);
+    if (type == 'P' || type == 'p')
+      cfg->codingType = VCENC_PREDICTED_FRAME;
+    else if (type == 'B' || type == 'b')
+      cfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+    else
+      return -1;
+
+    // poc
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &poc);
+    if (poc < 1 || poc > gopSize) return -1;
+    cfg->poc = poc;
+
+    // qp offset
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &(cfg->QpOffset));
+
+    // qp factor
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%lf", &(cfg->QpFactor));
+    // sqrt(QpFactor) is used in calculating lambda
+    cfg->QpFactor = sqrt(cfg->QpFactor);
+
+    // temporalId factor
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &(cfg->temporalId));
+
+    // num_ref_pics
+    line = nextToken(line);
+    if (!line) return -1;
+    sscanf(line, "%d", &num_ref_pics);
+    if (num_ref_pics < 0 || num_ref_pics > VCENC_MAX_REF_FRAMES) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "GOP Config: Error, num_ref_pic can not be more than %d 
",
+                 VCENC_MAX_REF_FRAMES);
+      return -1;
+    }
+
+    // ref_pics
+    for (i = 0; i < num_ref_pics; i++) {
+      line = nextToken(line);
+      if (!line) return -1;
+      if ((strncmp(line, "L", 1) == 0) || (strncmp(line, "l", 1) == 0)) {
+        sscanf(line, "%c%d", &type, &(cfg->refPics[i].ref_pic));
+        cfg->refPics[i].ref_pic =
+            LONG_TERM_REF_ID2DELTAPOC(cfg->refPics[i].ref_pic - 1);
+      } else {
+        sscanf(line, "%d", &(cfg->refPics[i].ref_pic));
+      }
+    }
+    if (i < num_ref_pics) return -1;
+
+    // used_by_cur
+    for (i = 0; i < num_ref_pics; i++) {
+      line = nextToken(line);
+      if (!line) return -1;
+      sscanf(line, "%u", &(cfg->refPics[i].used_by_cur));
+    }
+    if (i < num_ref_pics) return -1;
+
+    cfg->numRefPics = num_ref_pics;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief ParseGopConfigFile(), parse gop config file.
+ * @param int32_t gopSize: gop size.
+ * @param int8_t *fname: input file name.
+ * @param VCEncGopConfig *gopCfg: gop config.
+ * @return int32_t: 0 successful, other unsuccessful.
+ */
+static int32_t ParseGopConfigFile(int32_t gopSize, int8_t *fname,
+                                  VCEncGopConfig *gopCfg) {
+#define MAX_LINE_LENGTH 1024
+  int32_t frame_idx = 0, line_idx = 0, addTmp;
+  int8_t achParserBuffer[MAX_LINE_LENGTH];
+  FILE *fIn = fopen(fname, "r");
+  if (fIn == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "GOP Config: Error, Can Not Open File %s
",
+               fname);
+    return -1;
+  }
+
+  while (0 == feof(fIn)) {
+    if (feof(fIn)) break;
+    line_idx++;
+    achParserBuffer[0] = ' ';
+    // Read one line
+    int8_t *line = fgets((char *)achParserBuffer, MAX_LINE_LENGTH, fIn);
+    if (!line) break;
+    // handle line end
+    int8_t *s = strpbrk(line, "#
");
+    if (s) *s = ' ';
+
+    addTmp = 1;
+    line = strstr(line, "Frame");
+    if (line) {
+      if (0 == strncmp(line, "Frame0", 6)) addTmp = 0;
+
+      if (ParseGopConfigString(line, gopCfg, frame_idx, gopSize) < 0) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid gop configure!
");
+        break;
+      }
+
+      frame_idx += addTmp;
+    }
+  }
+
+  fclose(fIn);
+  if (frame_idx != gopSize) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "GOP Config: Error, Parsing File %s Failed at Line %d
", fname,
+               line_idx);
+    return -1;
+  }
+  return 0;
+}
+
+/**
+ * @brief HEVCReadGopConfig(), parse gop config.
+ * @param int8_t *fname: input file name.
+ * @param int8_t **config: input config string.
+ * @param VCEncGopConfig *gopCfg: gop config.
+ * @param int32_t gopSize: gop size.
+ * @param uint8_t *gopCfgOffset: gop config offset.
+ * @return int32_t: 0 successful, other unsuccessful.
+ */
+static int32_t HEVCReadGopConfig(int8_t *fname, int8_t **config,
+                                 VCEncGopConfig *gopCfg, int32_t gopSize,
+                                 uint8_t *gopCfgOffset) {
+  int32_t ret = -1;
+
+  if (gopCfg->size >= MAX_GOP_PIC_CONFIG_NUM) return -1;
+
+  if (gopCfgOffset) gopCfgOffset[gopSize] = gopCfg->size;
+
+  if (config) {
+    int32_t id = 0;
+    while (config[id]) {
+      ParseGopConfigString(config[id], gopCfg, id, gopSize);
+      id++;
+    }
+    ret = 0;
+  }
+  return ret;
+}
+
+/**
+ * @brief VCEncInitGopConfigs(), parse gop config.
+ * @param int32_t gopSize: gop size.
+ * @param commandLine_local_s *cml: input command line compatible with api.
+ * @param VCEncGopConfig *gopCfg: gop config.
+ * @param uint8_t *gopCfgOffset: gop config offset.
+ * @param bool bPass2: if pass2.
+ * @return int32_t: 0 successful, other unsuccessful.
+ */
+static int32_t VCEncInitGopConfigs(int32_t gopSize, commandLine_local_s *cml,
+                                   VCEncGopConfig *gopCfg,
+                                   uint8_t *gopCfgOffset, bool bPass2) {
+  int32_t i, pre_load_num;
+  int8_t *fname = cml->gopCfg;
+  int8_t **default_configs[8] = {
+      cml->gopLowdelay ? RpsLowdelayDefault_GOPSize_1
+                       : (cml->codecFormat ? RpsDefault_H264_GOPSize_1
+                                           : RpsDefault_GOPSize_1),
+      cml->gopLowdelay ? RpsLowdelayDefault_GOPSize_2 : RpsDefault_GOPSize_2,
+      cml->gopLowdelay ? RpsLowdelayDefault_GOPSize_3 : RpsDefault_GOPSize_3,
+      cml->gopLowdelay ? RpsLowdelayDefault_GOPSize_4 : RpsDefault_GOPSize_4,
+      RpsDefault_GOPSize_5, RpsDefault_GOPSize_6, RpsDefault_GOPSize_7,
+      RpsDefault_GOPSize_8};
+
+  if (gopSize < 0 || gopSize > MAX_GOP_SIZE) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "GOP Config: Error, Invalid GOP Size
");
+    return -1;
+  }
+
+  if (bPass2) {
+    default_configs[1] = RpsPass2_GOPSize_2;
+    default_configs[3] = RpsPass2_GOPSize_4;
+    default_configs[7] = RpsPass2_GOPSize_8;
+  }
+
+  // Handle Interlace
+  if (cml->interlacedFrame && gopSize == 1) {
+    default_configs[0] = RpsDefault_Interlace_GOPSize_1;
+  }
+
+// GOP size in rps array for gopSize=N
+// N<=4:      GOP1, ..., GOPN
+// 4<N<=8:   GOP1, GOP2, GOP3, GOP4, GOPN
+// N > 8:       GOP1, GOPN
+// Adaptive:  GOP1, GOP2, GOP3, GOP4, GOP6, GOP8
+#if 0
+  if (gopSize > 8)
+    pre_load_num = 1;
+  else if (gopSize>=4 || gopSize==0)
+    pre_load_num = 4;
+  else
+#endif
+  pre_load_num = gopSize;
+
+  if (pre_load_num == 0) pre_load_num = 4;
+
+  gopCfg->special_size = 0;
+  gopCfg->ltrcnt = 0;
+
+  for (i = 1; i <= pre_load_num; i++) {
+    if (HEVCReadGopConfig(gopSize == i ? fname : NULL, default_configs[i - 1],
+                          gopCfg, i, gopCfgOffset))
+      return -1;
+  }
+  // HANTRO_LOG(HANTRO_LEVEL_INFO, "1 gop size=%d
",gopCfg->size);
+  if (gopSize == 0) {
+    // gop6
+    if (HEVCReadGopConfig(NULL, default_configs[5], gopCfg, 6, gopCfgOffset))
+      return -1;
+    // HANTRO_LOG(HANTRO_LEVEL_INFO, "2 gop size=%d
",gopCfg->size);
+    // gop8
+    if (HEVCReadGopConfig(NULL, default_configs[7], gopCfg, 8, gopCfgOffset))
+      return -1;
+    // HANTRO_LOG(HANTRO_LEVEL_INFO, "3 gop size=%d
",gopCfg->size);
+  } else if (gopSize > 4) {
+    // gopSize
+    if (HEVCReadGopConfig(fname, default_configs[gopSize - 1], gopCfg, gopSize,
+                          gopCfgOffset))
+      return -1;
+    // HANTRO_LOG(HANTRO_LEVEL_INFO, "4 gop size=%d
",gopCfg->size);
+  }
+
+  if ((-1 != cml->ltrInterval) && (gopCfg->special_size == 0)) {
+    if (cml->gopSize != 1) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "GOP Config: Error, when using --LTR configure option, the "
+                 "gopsize alse should be set to 1!
");
+      return -1;
+    }
+    gopCfg->pGopPicSpecialCfg[0].poc = 0;
+    gopCfg->pGopPicSpecialCfg[0].QpOffset = cml->longTermQpDelta;
+    gopCfg->pGopPicSpecialCfg[0].QpFactor = QPFACTOR_RESERVED;
+    gopCfg->pGopPicSpecialCfg[0].temporalId = TEMPORALID_RESERVED;
+    gopCfg->pGopPicSpecialCfg[0].codingType = FRAME_TYPE_RESERVED;
+    gopCfg->pGopPicSpecialCfg[0].numRefPics = NUMREFPICS_RESERVED;
+    gopCfg->pGopPicSpecialCfg[0].i32Ltr = 1;
+    gopCfg->pGopPicSpecialCfg[0].i32Offset = 0;
+    gopCfg->pGopPicSpecialCfg[0].i32Interval = cml->ltrInterval;
+    gopCfg->pGopPicSpecialCfg[0].i32short_change = 0;
+    gopCfg->u32LTR_idx[0] = LONG_TERM_REF_ID2DELTAPOC(0);
+
+    gopCfg->pGopPicSpecialCfg[1].poc = 0;
+    gopCfg->pGopPicSpecialCfg[1].QpOffset = QPOFFSET_RESERVED;
+    gopCfg->pGopPicSpecialCfg[1].QpFactor = QPFACTOR_RESERVED;
+    gopCfg->pGopPicSpecialCfg[1].temporalId = TEMPORALID_RESERVED;
+    gopCfg->pGopPicSpecialCfg[1].codingType = FRAME_TYPE_RESERVED;
+    gopCfg->pGopPicSpecialCfg[1].numRefPics = 2;
+    gopCfg->pGopPicSpecialCfg[1].refPics[0].ref_pic = -1;
+    gopCfg->pGopPicSpecialCfg[1].refPics[0].used_by_cur = 1;
+    gopCfg->pGopPicSpecialCfg[1].refPics[1].ref_pic =
+        LONG_TERM_REF_ID2DELTAPOC(0);
+    gopCfg->pGopPicSpecialCfg[1].refPics[1].used_by_cur = 1;
+    gopCfg->pGopPicSpecialCfg[1].i32Ltr = 0;
+    gopCfg->pGopPicSpecialCfg[1].i32Offset = cml->longTermGapOffset;
+    gopCfg->pGopPicSpecialCfg[1].i32Interval = cml->longTermGap;
+    gopCfg->pGopPicSpecialCfg[1].i32short_change = 0;
+
+    gopCfg->special_size = 0;
+    gopCfg->ltrcnt = 0;
+  }
+
+  if (0)
+    for (i = 0; i < (gopSize == 0 ? gopCfg->size : gopCfgOffset[gopSize]);
+         i++) {
+      // when use long-term, change P to B in default configs (used for last
+      // gop)
+      VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[i]);
+      if (cfg->codingType == VCENC_PREDICTED_FRAME)
+        cfg->codingType = VCENC_BIDIR_PREDICTED_FRAME;
+    }
+
+  // Compatible with old bFrameQpDelta setting
+  if (cml->bFrameQpDelta >= 0 && fname == NULL) {
+    for (i = 0; i < gopCfg->size; i++) {
+      VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[i]);
+      if (cfg->codingType == VCENC_BIDIR_PREDICTED_FRAME)
+        cfg->QpOffset = cml->bFrameQpDelta;
+    }
+  }
+  // HANTRO_LOG(HANTRO_LEVEL_INFO, "5 gop size=%d
",gopCfg->size);
+
+  // lowDelay auto detection
+  VCEncGopPicConfig *cfgStart = &(gopCfg->pGopPicCfg[gopCfgOffset[gopSize]]);
+  if (gopSize == 1) {
+    cml->gopLowdelay = 1;
+  } else if ((gopSize > 1) && (cml->gopLowdelay == 0)) {
+    cml->gopLowdelay = 1;
+    for (i = 1; i < gopSize; i++) {
+      if (cfgStart[i].poc < cfgStart[i - 1].poc) {
+        cml->gopLowdelay = 0;
+        break;
+      }
+    }
+  }
+  // HANTRO_LOG(HANTRO_LEVEL_INFO, "6 gop size=%d
",gopCfg->size);
+
+  {
+    int32_t i32LtrPoc[VCENC_MAX_LT_REF_FRAMES];
+
+    for (i = 0; i < VCENC_MAX_LT_REF_FRAMES; i++) i32LtrPoc[i] = -1;
+    for (i = 0; i < gopCfg->special_size; i++) {
+      if (gopCfg->pGopPicSpecialCfg[i].i32Ltr > VCENC_MAX_LT_REF_FRAMES) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                   "GOP Config: Error, Invalid long-term index
");
+        return -1;
+      }
+      if (gopCfg->pGopPicSpecialCfg[i].i32Ltr > 0)
+        i32LtrPoc[i] = gopCfg->pGopPicSpecialCfg[i].i32Ltr - 1;
+    }
+
+    //      gopCfg->ltrcnt = 1; //force ltrcnt = 1
+    //      i32LtrPoc[0] = 0;   //idr is ltr
+
+    for (i = 0; i < gopCfg->ltrcnt; i++) {
+      if ((0 != i32LtrPoc[0]) || (-1 == i32LtrPoc[i]) ||
+          ((i > 0) && i32LtrPoc[i] != (i32LtrPoc[i - 1] + 1))) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                   "GOP Config: Error, Invalid long-term index
");
+        return -1;
+      }
+    }
+  }
+  // HANTRO_LOG(HANTRO_LEVEL_INFO, "7 gop size=%d
",gopCfg->size);
+
+  // For lowDelay, Handle the first few frames that miss reference frame
+  if (cml->gopLowdelay) {
+    int32_t nGop;
+    int32_t idx = 0;
+    int32_t maxErrFrame = 0;
+    VCEncGopPicConfig *cfg;
+
+    // Find the max frame number that will miss its reference frame defined in
+    // rps
+    while ((idx - maxErrFrame) < gopSize) {
+      nGop = (idx / gopSize) * gopSize;
+      cfg = &(cfgStart[idx % gopSize]);
+
+      for (i = 0; i < cfg->numRefPics; i++) {
+        // POC of this reference frame
+        int32_t refPoc = cfg->refPics[i].ref_pic + cfg->poc + nGop;
+        if (refPoc < 0) {
+          maxErrFrame = idx + 1;
+        }
+      }
+      idx++;
+    }
+
+    // Try to config a new rps for each "error" frame by modifying its original
+    // rps
+    for (idx = 0; idx < maxErrFrame; idx++) {
+      int32_t j, iRef, nRefsUsedByCur, nPoc;
+      VCEncGopPicConfig *cfgCopy;
+
+      if (gopCfg->size >= MAX_GOP_PIC_CONFIG_NUM) break;
+
+      // Add to array end
+      cfg = &(gopCfg->pGopPicCfg[gopCfg->size]);
+      cfgCopy = &(cfgStart[idx % gopSize]);
+      memcpy(cfg, cfgCopy, sizeof(VCEncGopPicConfig));
+      gopCfg->size++;
+
+      // Copy reference pictures
+      nRefsUsedByCur = iRef = 0;
+      nPoc = cfgCopy->poc + ((idx / gopSize) * gopSize);
+      for (i = 0; i < cfgCopy->numRefPics; i++) {
+        int32_t newRef = 1;
+        int32_t used_by_cur = cfgCopy->refPics[i].used_by_cur;
+        int32_t ref_pic = cfgCopy->refPics[i].ref_pic;
+        // Clip the reference POC
+        if ((cfgCopy->refPics[i].ref_pic + nPoc) < 0) ref_pic = 0 - (nPoc);
+
+        // Check if already have this reference
+        for (j = 0; j < iRef; j++) {
+          if (cfg->refPics[j].ref_pic == ref_pic) {
+            newRef = 0;
+            if (used_by_cur) cfg->refPics[j].used_by_cur = used_by_cur;
+            break;
+          }
+        }
+
+        // Copy this reference
+        if (newRef) {
+          cfg->refPics[iRef].ref_pic = ref_pic;
+          cfg->refPics[iRef].used_by_cur = used_by_cur;
+          iRef++;
+        }
+      }
+      cfg->numRefPics = iRef;
+      // If only one reference frame, set P type.
+      for (i = 0; i < cfg->numRefPics; i++) {
+        if (cfg->refPics[i].used_by_cur) nRefsUsedByCur++;
+      }
+      if (nRefsUsedByCur == 1) cfg->codingType = VCENC_PREDICTED_FRAME;
+    }
+  }
+// HANTRO_LOG(HANTRO_LEVEL_INFO, "8 gop size=%d
",gopCfg->size);
+#if 0
+      //print for debug
+      int32_t idx;
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "====== REF PICTURE SETS from %s ======
",fname ? fname : "DEFAULT");
+      for (idx = 0; idx < gopCfg->size; idx ++)
+      {
+        int32_t i;
+        VCEncGopPicConfig *cfg = &(gopCfg->pGopPicCfg[idx]);
+        char type = cfg->codingType==VCENC_PREDICTED_FRAME ? 'P' : cfg->codingType == VCENC_INTRA_FRAME ? 'I' : 'B';
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, " FRAME%2d:  %c %d %d %f %d", idx, type, cfg->poc, cfg->QpOffset, cfg->QpFactor, cfg->numRefPics);
+        for (i = 0; i < cfg->numRefPics; i ++)
+          HANTRO_LOG(HANTRO_LEVEL_DEBUG, " %d", cfg->refPics[i].ref_pic);
+        for (i = 0; i < cfg->numRefPics; i ++)
+          HANTRO_LOG(HANTRO_LEVEL_DEBUG, " %d", cfg->refPics[i].used_by_cur);
+        HANTRO_LOG(HANTRO_LEVEL_DEBUG, "
");
+      }
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "===========================================
");
+#endif
+  return 0;
+}
+
+/**
+ * @brief init_gop_config(), init gop config.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param VCEncIn* encIn: encoder input parameters.
+ * @param int32_t intraPicRate: intra picture rate.
+ * @return int: error number.
+ */
+static int32_t init_gop_config(v4l2_enc_inst *h, int32_t intraPicRate) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+  memset(params->gopCfgOffset, 0, sizeof(params->gopCfgOffset));
+  memset(params->gopPicCfg, 0, sizeof(params->gopPicCfg));
+  encIn->gopConfig.idr_interval = intraPicRate;
+  if (VCEncInitGopConfigs(encIn->gopSize, &params->cml, &encIn->gopConfig,
+                          params->gopCfgOffset, HANTRO_FALSE) != 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "error when config gop configs for 2 pass.
");
+    return -18;  // this is not defined in api, indicate gop init error.
+  }
+  memcpy(encIn->gopConfig.gopCfgOffset, params->gopCfgOffset,
+         sizeof(params->gopCfgOffset));
+  return 0;
+}
+
+static VCEncLevel getLevelHevc(i32 levelIdx)
+{
+  switch (levelIdx)
+  {
+    /*Hevc*/
+    case 0:
+      return VCENC_HEVC_LEVEL_1;
+    case 1:
+      return VCENC_HEVC_LEVEL_2;
+    case 2:
+      return VCENC_HEVC_LEVEL_2_1;
+    case 3:
+      return VCENC_HEVC_LEVEL_3;
+    case 4:
+      return VCENC_HEVC_LEVEL_3_1;
+    case 5:
+      return VCENC_HEVC_LEVEL_4;
+    case 6:
+      return VCENC_HEVC_LEVEL_4_1;
+    case 7:
+      return VCENC_HEVC_LEVEL_5;
+    case 8:
+      return VCENC_HEVC_LEVEL_5_1;
+    case 9:
+      return VCENC_HEVC_LEVEL_5_2;
+    case 10:
+      return VCENC_HEVC_LEVEL_6;
+    case 11:
+      return VCENC_HEVC_LEVEL_6_1;
+    default:
+      return VCENC_HEVC_LEVEL_6_2;
+  }
+}
+
+static VCEncLevel getLevelH264(i32 levelIdx)
+{
+  switch (levelIdx)
+  {
+    case 0:
+      return VCENC_H264_LEVEL_1;
+    case 1:
+      return VCENC_H264_LEVEL_1_b;
+    case 2:
+      return VCENC_H264_LEVEL_1_1;
+    case 3:
+      return VCENC_H264_LEVEL_1_2;
+    case 4:
+      return VCENC_H264_LEVEL_1_3;
+    case 5:
+      return VCENC_H264_LEVEL_2;
+    case 6:
+      return VCENC_H264_LEVEL_2_1;
+    case 7:
+      return VCENC_H264_LEVEL_2_2;
+    case 8:
+      return VCENC_H264_LEVEL_3;
+    case 9:
+      return VCENC_H264_LEVEL_3_1;
+    case 10:
+      return VCENC_H264_LEVEL_3_2;
+    case 11:
+      return VCENC_H264_LEVEL_4;
+    case 12:
+      return VCENC_H264_LEVEL_4_1;
+    case 13:
+      return VCENC_H264_LEVEL_4_2;
+    case 14:
+      return VCENC_H264_LEVEL_5;
+    case 15:
+      return VCENC_H264_LEVEL_5_1;
+    case 16:
+      return VCENC_H264_LEVEL_5_2;
+    case 17:
+      return VCENC_H264_LEVEL_6;
+    case 18:
+      return VCENC_H264_LEVEL_6_1;
+    default:
+      return VCENC_H264_LEVEL_6_2;
+  }
+}
+
+static i32 getlevelIdxHevc(VCEncLevel level)
+{
+  switch (level)
+  {
+    case VCENC_HEVC_LEVEL_1:
+      return 0;
+    case VCENC_HEVC_LEVEL_2:
+      return 1;
+    case VCENC_HEVC_LEVEL_2_1:
+      return 2;
+    case VCENC_HEVC_LEVEL_3:
+      return 3;
+    case VCENC_HEVC_LEVEL_3_1:
+      return 4;
+    case VCENC_HEVC_LEVEL_4:
+      return 5;
+    case VCENC_HEVC_LEVEL_4_1:
+      return 6;
+    case VCENC_HEVC_LEVEL_5:
+      return 7;
+    case VCENC_HEVC_LEVEL_5_1:
+      return 8;
+    case VCENC_HEVC_LEVEL_5_2:
+      return 9;
+    case VCENC_HEVC_LEVEL_6:
+      return 10;
+    case VCENC_HEVC_LEVEL_6_1:
+      return 11;
+    case VCENC_HEVC_LEVEL_6_2:
+      return 12;
+    default:
+      ASSERT(0);
+  }
+  return 0;
+}
+static i32 getlevelIdxH264(VCEncLevel level)
+{
+  switch (level)
+  {
+    case VCENC_H264_LEVEL_1:
+      return 0;
+    case VCENC_H264_LEVEL_1_b:
+      return 1;
+    case VCENC_H264_LEVEL_1_1:
+      return 2;
+    case VCENC_H264_LEVEL_1_2:
+      return 3;
+    case VCENC_H264_LEVEL_1_3:
+      return 4;
+    case VCENC_H264_LEVEL_2:
+      return 5;
+    case VCENC_H264_LEVEL_2_1:
+      return 6;
+    case VCENC_H264_LEVEL_2_2:
+      return 7;
+    case VCENC_H264_LEVEL_3:
+      return 8;
+    case VCENC_H264_LEVEL_3_1:
+      return 9;
+    case VCENC_H264_LEVEL_3_2:
+      return 10;
+    case VCENC_H264_LEVEL_4:
+      return 11;
+    case VCENC_H264_LEVEL_4_1:
+      return 12;
+    case VCENC_H264_LEVEL_4_2:
+      return 13;
+    case VCENC_H264_LEVEL_5:
+      return 14;
+    case VCENC_H264_LEVEL_5_1:
+      return 15;
+    case VCENC_H264_LEVEL_5_2:
+      return 16;
+    case VCENC_H264_LEVEL_6:
+      return 17;
+    case VCENC_H264_LEVEL_6_1:
+      return 18;
+    case VCENC_H264_LEVEL_6_2:
+      return 19;
+    default:
+      ASSERT(0);
+  }
+  return 0;
+}
+
+static VCEncLevel getLevel(v4l2_daemon_codec_fmt codecFormat, i32 levelIdx)
+{
+  switch(codecFormat)
+  {
+    case V4L2_DAEMON_CODEC_ENC_HEVC:
+      return getLevelHevc( levelIdx );
+
+    case V4L2_DAEMON_CODEC_ENC_H264:
+      return getLevelH264( levelIdx );
+
+    case V4L2_DAEMON_CODEC_ENC_AV1:
+      return 1;
+
+    case V4L2_DAEMON_CODEC_ENC_VP9:
+      return 1;
+
+    default:
+      ASSERT(0);
+  }
+  return -1;
+}
+
+/**
+ * @brief InitPicConfig(), init encIn.
+ * @param VCEncIn *pEncIn: input parameters.
+ * @return void.
+ */
+static void InitPicConfig(VCEncIn *pEncIn) {
+  int32_t i, j, k, i32Poc;
+  int32_t i32MaxpicOrderCntLsb = 1 << 16;
+
+  ASSERT(pEncIn != NULL);
+
+  pEncIn->gopCurrPicConfig.codingType = FRAME_TYPE_RESERVED;
+  pEncIn->gopCurrPicConfig.numRefPics = NUMREFPICS_RESERVED;
+  pEncIn->gopCurrPicConfig.poc = -1;
+  pEncIn->gopCurrPicConfig.QpFactor = QPFACTOR_RESERVED;
+  pEncIn->gopCurrPicConfig.QpOffset = QPOFFSET_RESERVED;
+  pEncIn->gopCurrPicConfig.temporalId = TEMPORALID_RESERVED;
+  pEncIn->i8SpecialRpsIdx = -1;
+  for (k = 0; k < VCENC_MAX_REF_FRAMES; k++) {
+    pEncIn->gopCurrPicConfig.refPics[k].ref_pic = INVALITED_POC;
+    pEncIn->gopCurrPicConfig.refPics[k].used_by_cur = 0;
+  }
+
+  for (k = 0; k < VCENC_MAX_LT_REF_FRAMES; k++)
+    pEncIn->long_term_ref_pic[k] = INVALITED_POC;
+
+  pEncIn->bIsPeriodUsingLTR = false;
+  pEncIn->bIsPeriodUpdateLTR = false;
+
+  for (i = 0; i < pEncIn->gopConfig.special_size; i++) {
+    if (pEncIn->gopConfig.pGopPicSpecialCfg[i].i32Interval <= 0) continue;
+
+    if (pEncIn->gopConfig.pGopPicSpecialCfg[i].i32Ltr == 0)
+      pEncIn->bIsPeriodUsingLTR = true;
+    else {
+      pEncIn->bIsPeriodUpdateLTR = true;
+
+      for (k = 0;
+           k < (int32_t)pEncIn->gopConfig.pGopPicSpecialCfg[i].numRefPics;
+           k++) {
+        int32_t i32LTRIdx =
+            pEncIn->gopConfig.pGopPicSpecialCfg[i].refPics[k].ref_pic;
+        if ((IS_LONG_TERM_REF_DELTAPOC(i32LTRIdx)) &&
+            ((pEncIn->gopConfig.pGopPicSpecialCfg[i].i32Ltr - 1) ==
+             LONG_TERM_REF_DELTAPOC2ID(i32LTRIdx))) {
+          pEncIn->bIsPeriodUsingLTR = true;
+        }
+      }
+    }
+  }
+
+  memset(pEncIn->bLTR_need_update, 0,
+         sizeof(uint32_t) * VCENC_MAX_LT_REF_FRAMES);
+  pEncIn->bIsIDR = true;
+
+  i32Poc = 0;
+  /* check current picture encoded as LTR*/
+  pEncIn->u8IdxEncodedAsLTR = 0;
+  for (j = 0; j < pEncIn->gopConfig.special_size; j++) {
+    if (pEncIn->bIsPeriodUsingLTR == false) break;
+
+    if ((pEncIn->gopConfig.pGopPicSpecialCfg[j].i32Interval <= 0) ||
+        (pEncIn->gopConfig.pGopPicSpecialCfg[j].i32Ltr == 0))
+      continue;
+
+    i32Poc = i32Poc - pEncIn->gopConfig.pGopPicSpecialCfg[j].i32Offset;
+
+    if (i32Poc < 0) {
+      i32Poc += i32MaxpicOrderCntLsb;
+      if (i32Poc > (i32MaxpicOrderCntLsb >> 1)) i32Poc = -1;
+    }
+
+    if ((i32Poc >= 0) &&
+        (i32Poc % pEncIn->gopConfig.pGopPicSpecialCfg[j].i32Interval == 0)) {
+      /* more than one LTR at the same frame position */
+      if (0 != pEncIn->u8IdxEncodedAsLTR) {
+        // reuse the same POC LTR
+        pEncIn->bLTR_need_update[pEncIn->gopConfig.pGopPicSpecialCfg[j].i32Ltr -
+                                 1] = true;
+        continue;
+      }
+
+      pEncIn->gopCurrPicConfig.codingType =
+          ((int32_t)pEncIn->gopConfig.pGopPicSpecialCfg[j].codingType ==
+           FRAME_TYPE_RESERVED)
+              ? pEncIn->gopCurrPicConfig.codingType
+              : pEncIn->gopConfig.pGopPicSpecialCfg[j].codingType;
+      pEncIn->gopCurrPicConfig.numRefPics =
+          ((int32_t)pEncIn->gopConfig.pGopPicSpecialCfg[j].numRefPics ==
+           NUMREFPICS_RESERVED)
+              ? pEncIn->gopCurrPicConfig.numRefPics
+              : pEncIn->gopConfig.pGopPicSpecialCfg[j].numRefPics;
+      pEncIn->gopCurrPicConfig.QpFactor =
+          (pEncIn->gopConfig.pGopPicSpecialCfg[j].QpFactor == QPFACTOR_RESERVED)
+              ? pEncIn->gopCurrPicConfig.QpFactor
+              : pEncIn->gopConfig.pGopPicSpecialCfg[j].QpFactor;
+      pEncIn->gopCurrPicConfig.QpOffset =
+          (pEncIn->gopConfig.pGopPicSpecialCfg[j].QpOffset == QPOFFSET_RESERVED)
+              ? pEncIn->gopCurrPicConfig.QpOffset
+              : pEncIn->gopConfig.pGopPicSpecialCfg[j].QpOffset;
+      pEncIn->gopCurrPicConfig.temporalId =
+          (pEncIn->gopConfig.pGopPicSpecialCfg[j].temporalId ==
+           TEMPORALID_RESERVED)
+              ? pEncIn->gopCurrPicConfig.temporalId
+              : pEncIn->gopConfig.pGopPicSpecialCfg[j].temporalId;
+
+      if (((int32_t)pEncIn->gopConfig.pGopPicSpecialCfg[j].numRefPics !=
+           NUMREFPICS_RESERVED)) {
+        for (k = 0; k < (int32_t)pEncIn->gopCurrPicConfig.numRefPics; k++) {
+          pEncIn->gopCurrPicConfig.refPics[k].ref_pic =
+              pEncIn->gopConfig.pGopPicSpecialCfg[j].refPics[k].ref_pic;
+          pEncIn->gopCurrPicConfig.refPics[k].used_by_cur =
+              pEncIn->gopConfig.pGopPicSpecialCfg[j].refPics[k].used_by_cur;
+        }
+      }
+
+      pEncIn->u8IdxEncodedAsLTR = pEncIn->gopConfig.pGopPicSpecialCfg[j].i32Ltr;
+      pEncIn->bLTR_need_update[pEncIn->u8IdxEncodedAsLTR - 1] = true;
+    }
+  }
+}
+
+/**
+ * @brief getAlignedPicSizebyFormat(), get picture size for input format.
+ * @param VCEncPictureType type: input picture format.
+ * @param uint32_t width: width of input picture.
+ * @param uint32_t height: height of input picture.
+ * @param uint32_t alignment: alignment of input picture.
+ * @param uint32_t *luma_Size: output luma size.
+ * @param uint32_t *chroma_Size: output chroma size.
+ * @param uint32_t *picture_Size: output picture(luma+chroma) size.
+ * @return void.
+ */
+static void getAlignedPicSizebyFormat(VCEncPictureType type, uint32_t width,
+                                      uint32_t height, uint32_t alignment,
+                                      uint32_t *luma_Size,
+                                      uint32_t *chroma_Size,
+                                      uint32_t *picture_Size) {
+  uint32_t luma_stride = 0, chroma_stride = 0;
+  uint32_t lumaSize = 0, chromaSize = 0, pictureSize = 0;
+
+  VCEncGetAlignedStride(width, type, &luma_stride, &chroma_stride, alignment);
+  switch (type) {
+    case VCENC_YUV420_PLANAR:
+      lumaSize = luma_stride * height;
+      chromaSize = chroma_stride * height / 2 * 2;
+      break;
+    case VCENC_YUV420_SEMIPLANAR:
+    case VCENC_YUV420_SEMIPLANAR_VU:
+      lumaSize = luma_stride * height;
+      chromaSize = chroma_stride * height / 2;
+      break;
+    case VCENC_YUV422_INTERLEAVED_YUYV:
+    case VCENC_YUV422_INTERLEAVED_UYVY:
+    case VCENC_RGB565:
+    case VCENC_BGR565:
+    case VCENC_RGB555:
+    case VCENC_BGR555:
+    case VCENC_RGB444:
+    case VCENC_BGR444:
+    case VCENC_RGB888:
+    case VCENC_BGR888:
+    case VCENC_RGB101010:
+    case VCENC_BGR101010:
+      lumaSize = luma_stride * height;
+      chromaSize = 0;
+      break;
+    case VCENC_YUV420_PLANAR_10BIT_I010:
+      lumaSize = luma_stride * height;
+      chromaSize = chroma_stride * height / 2 * 2;
+      break;
+    case VCENC_YUV420_PLANAR_10BIT_P010:
+      lumaSize = luma_stride * height;
+      chromaSize = chroma_stride * height / 2;
+      break;
+    case VCENC_YUV420_PLANAR_10BIT_PACKED_PLANAR:
+      lumaSize = luma_stride * 10 / 8 * height;
+      chromaSize = chroma_stride * 10 / 8 * height / 2 * 2;
+      break;
+    case VCENC_YUV420_10BIT_PACKED_Y0L2:
+      lumaSize = luma_stride * 2 * 2 * height / 2;
+      chromaSize = 0;
+      break;
+    case VCENC_YUV420_PLANAR_8BIT_DAHUA_HEVC:
+      lumaSize = luma_stride * ((height + 32 - 1) & (~(32 - 1)));
+      chromaSize = lumaSize / 2;
+      break;
+    case VCENC_YUV420_PLANAR_8BIT_DAHUA_H264:
+      lumaSize = luma_stride * height * 2 * 12 / 8;
+      chromaSize = 0;
+      break;
+    case VCENC_YUV420_SEMIPLANAR_8BIT_FB:
+    case VCENC_YUV420_SEMIPLANAR_VU_8BIT_FB:
+      lumaSize = luma_stride * ((height + 3) / 4);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    case VCENC_YUV420_PLANAR_10BIT_P010_FB:
+      lumaSize = luma_stride * ((height + 3) / 4);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    case VCENC_YUV420_SEMIPLANAR_101010:
+      lumaSize = luma_stride * height;
+      chromaSize = chroma_stride * height / 2;
+      break;
+    case VCENC_YUV420_8BIT_TILE_64_4:
+    case VCENC_YUV420_UV_8BIT_TILE_64_4:
+      lumaSize = luma_stride * ((height + 3) / 4);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    case VCENC_YUV420_10BIT_TILE_32_4:
+      lumaSize = luma_stride * ((height + 3) / 4);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    case VCENC_YUV420_10BIT_TILE_48_4:
+    case VCENC_YUV420_VU_10BIT_TILE_48_4:
+      lumaSize = luma_stride * ((height + 3) / 4);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    case VCENC_YUV420_8BIT_TILE_128_2:
+    case VCENC_YUV420_UV_8BIT_TILE_128_2:
+      lumaSize = luma_stride * ((height + 1) / 2);
+      chromaSize = chroma_stride * (((height / 2) + 1) / 2);
+      break;
+    case VCENC_YUV420_10BIT_TILE_96_2:
+    case VCENC_YUV420_VU_10BIT_TILE_96_2:
+      lumaSize = luma_stride * ((height + 1) / 2);
+      chromaSize = chroma_stride * (((height / 2) + 1) / 2);
+      break;
+    case VCENC_YUV420_8BIT_TILE_8_8:
+      lumaSize = luma_stride * ((height + 7) / 8);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    case VCENC_YUV420_10BIT_TILE_8_8:
+      lumaSize = luma_stride * ((height + 7) / 8);
+      chromaSize = chroma_stride * (((height / 2) + 3) / 4);
+      break;
+    default:
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "not support this format
");
+      chromaSize = lumaSize = 0;
+      break;
+  }
+
+  pictureSize = lumaSize + chromaSize;
+  if (luma_Size != NULL) *luma_Size = lumaSize;
+  if (chroma_Size != NULL) *chroma_Size = chromaSize;
+  if (picture_Size != NULL) *picture_Size = pictureSize;
+}
+
+/**
+ * @brief get_config_from_cmd_h2(), write message from V4l2 parameter to
+ * VCEncConfig pointer.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return void.
+ */
+static int get_config_from_cmd_h2(v4l2_enc_inst *h,
+                                  v4l2_daemon_enc_params *enc_params) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+  VCEncConfig *cfg = &params->video_config;
+
+  if (enc_params->general.rotation && enc_params->general.rotation != 3) {
+    cfg->width = enc_params->general.height;
+    cfg->height = enc_params->general.width;
+  } else {
+    cfg->width = enc_params->general.width;
+    cfg->height = enc_params->general.height;
+  }
+
+  if (cfg->width < VCENC_MIN_ENC_WIDTH || (cfg->width & 0x1) != 0 ||
+      cfg->height < VCENC_MIN_ENC_HEIGHT || (cfg->height & 0x1) != 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+               cfg->width, cfg->height);
+    return -1;
+  }
+
+  if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) {
+    if (cfg->width > h->configure_t.max_width_h264 ||
+        cfg->height > VCENC_MAX_ENC_HEIGHT) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+                 cfg->width, cfg->height);
+      return -1;
+    }
+  } else if (h->codec_fmt == V4L2_DAEMON_CODEC_ENC_HEVC) {
+    if (cfg->width > h->configure_t.max_width_hevc ||
+        cfg->height > VCENC_MAX_ENC_HEIGHT) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "Invalid parameters width=%d, height=%d
",
+                 cfg->width, cfg->height);
+      return -1;
+    }
+  }
+
+  cfg->frameRateDenom = enc_params->general.outputRateDenom;
+  cfg->frameRateNum = enc_params->general.outputRateNumer;
+
+  if ((cfg->frameRateNum == 0 ||
+       cfg->frameRateDenom ==
+           0) || /* special allowal of 1000/1001, 0.99 fps by customer request
+                    */
+      (cfg->frameRateDenom > cfg->frameRateNum &&
+       !(cfg->frameRateDenom == 1001 && cfg->frameRateNum == 1000))) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Framerate is not set properly, set to default (30fps).
");
+    cfg->frameRateDenom = 1;
+    cfg->frameRateNum = 30;
+  }
+
+  /* intra tools in sps and pps */
+  cfg->strongIntraSmoothing =
+      enc_params->specific.enc_h26x_cmd.strong_intra_smoothing_enabled_flag;
+  cfg->streamType = (enc_params->specific.enc_h26x_cmd.byteStream)
+                        ? VCENC_BYTE_STREAM
+                        : VCENC_NAL_UNIT_STREAM;
+
+  cfg->level = (IS_H264(enc_params->general.codecFormat) ? VCENC_H264_LEVEL_5_1
+                                                         : VCENC_HEVC_LEVEL_6);
+  if (enc_params->specific.enc_h26x_cmd.avclevel != DEFAULTLEVEL &&
+      IS_H264(enc_params->general.codecFormat))
+    cfg->level = (VCEncLevel)enc_params->specific.enc_h26x_cmd.avclevel;
+  else if (enc_params->specific.enc_h26x_cmd.hevclevel != DEFAULTLEVEL &&
+           IS_HEVC(enc_params->general.codecFormat))
+    cfg->level = (VCEncLevel)enc_params->specific.enc_h26x_cmd.hevclevel;
+
+  int32_t levelIdx = 0;
+  if(IS_HEVC(enc_params->general.codecFormat)) {
+      levelIdx = getlevelIdxHevc(cfg->level);
+  }
+  else if(IS_H264(enc_params->general.codecFormat)) {
+      levelIdx = getlevelIdxH264(cfg->level);
+  }
+
+  cfg->tier = VCENC_HEVC_MAIN_TIER;
+  if (enc_params->specific.enc_h26x_cmd.tier != -1)
+    cfg->tier = (VCEncTier)enc_params->specific.enc_h26x_cmd.tier;
+
+  cfg->profile =
+      (IS_H264(enc_params->general.codecFormat) ? VCENC_H264_HIGH_PROFILE
+                                                : VCENC_HEVC_MAIN_PROFILE);
+  if (enc_params->specific.enc_h26x_cmd.profile != -1 &&
+      enc_params->specific.enc_h26x_cmd.profile != 0)
+    cfg->profile = (VCEncProfile)enc_params->specific.enc_h26x_cmd.profile;
+  if (IS_H264(enc_params->general.codecFormat)) {
+    if ((int32_t)cfg->profile >= VCENC_HEVC_MAIN_PROFILE &&
+        cfg->profile < VCENC_HEVC_MAIN_10_PROFILE)
+      cfg->profile = VCENC_H264_HIGH_PROFILE;
+  } else {
+    if (cfg->profile >= VCENC_H264_BASE_PROFILE &&
+        cfg->profile <= VCENC_H264_HIGH_PROFILE)
+      cfg->profile = VCENC_HEVC_MAIN_PROFILE;
+  }
+  if(is_input_level_ilegal(h->codec_fmt, cfg->width, cfg->height,
+        cfg->frameRateNum, cfg->frameRateDenom, levelIdx)) {
+      levelIdx = calculate_level(h->codec_fmt, cfg->width, cfg->height,
+                                cfg->frameRateNum, cfg->frameRateDenom, enc_params->general.bitPerSecond, cfg->profile);
+      cfg->level = getLevel(h->codec_fmt, levelIdx);
+      send_warning_orphan_msg(h->instance_id, WARN_LEVEL);
+  }
+
+  cfg->codecFormat = enc_params->general.codecFormat;
+  cfg->bitDepthLuma = 8;
+  if (enc_params->specific.enc_h26x_cmd.bitDepthLuma != -1)
+    cfg->bitDepthLuma = enc_params->specific.enc_h26x_cmd.bitDepthLuma;
+  cfg->bitDepthChroma = 8;
+  if (enc_params->specific.enc_h26x_cmd.bitDepthChroma != -1)
+    cfg->bitDepthChroma = enc_params->specific.enc_h26x_cmd.bitDepthChroma;
+  if ((enc_params->specific.enc_h26x_cmd.interlacedFrame &&
+       enc_params->specific.enc_h26x_cmd.gopSize != 1) ||
+      IS_H264(enc_params->general.codecFormat)) {
+    // HANTRO_LOG(HANTRO_LEVEL_INFO, "OpenEncoder: treat interlace to
+    // progressive for gopSize!=1 case.
");
+    enc_params->specific.enc_h26x_cmd.interlacedFrame = 0;
+  }
+  cfg->maxTLayers = 1;  // default maxTLayer
+  /* Find the max number of reference frame */
+  if (enc_params->specific.enc_h26x_cmd.intraPicRate == 1) {
+    cfg->refFrameAmount = 1; //workaround for gst parser.
+  } else {
+    uint32_t maxRefPics = 0;
+    uint32_t maxTemporalId = 0;
+    int32_t idx;
+    for (idx = 0; idx < encIn->gopConfig.size; idx++) {
+      VCEncGopPicConfig *cfg = &(encIn->gopConfig.pGopPicCfg[idx]);
+      if (cfg->codingType != VCENC_INTRA_FRAME) {
+        if (maxRefPics < cfg->numRefPics) maxRefPics = cfg->numRefPics;
+
+        if (maxTemporalId < cfg->temporalId) maxTemporalId = cfg->temporalId;
+      }
+    }
+    cfg->refFrameAmount = maxRefPics +
+                          enc_params->specific.enc_h26x_cmd.interlacedFrame +
+                          encIn->gopConfig.ltrcnt;
+    cfg->maxTLayers = maxTemporalId + 1;
+  }
+
+  cfg->compressor = enc_params->specific.enc_h26x_cmd.compressor;
+  cfg->interlacedFrame = enc_params->specific.enc_h26x_cmd.interlacedFrame;
+  cfg->enableOutputCuInfo =
+      (enc_params->specific.enc_h26x_cmd.enableOutputCuInfo > 0) ? 1 : 0;
+  // cfg->rdoLevel = CLIP3(1, 3, cml->rdoLevel) - 1;
+  cfg->rdoLevel = 1;
+  cfg->verbose = 0;  // enc_params->generel.verbose;
+  // cfg->exp_of_input_alignment = enc_params->general.exp_of_input_alignment;
+  // cfg->exp_of_ref_alignment = cml->exp_of_ref_alignment;
+  // cfg->exp_of_ref_ch_alignment = cml->exp_of_ref_ch_alignment;
+  cfg->exteralReconAlloc = 0;
+  cfg->P010RefEnable = enc_params->specific.enc_h26x_cmd.P010RefEnable;
+  cfg->enableSsim = enc_params->specific.enc_h26x_cmd.ssim;
+  cfg->ctbRcMode = (enc_params->specific.enc_h26x_cmd.ctbRc != -1)
+                       ? enc_params->specific.enc_h26x_cmd.ctbRc
+                       : 0;
+  cfg->parallelCoreNum = enc_params->specific.enc_h26x_cmd.parallelCoreNum;
+  cfg->pass = (enc_params->specific.enc_h26x_cmd.lookaheadDepth ? 2 : 0);
+  cfg->bPass1AdaptiveGop = (enc_params->specific.enc_h26x_cmd.gopSize == 0);
+  cfg->picOrderCntType = enc_params->specific.enc_h26x_cmd.picOrderCntType;
+  cfg->dumpRegister = 0;
+  cfg->rasterscan = 0;
+  cfg->log2MaxPicOrderCntLsb =
+      enc_params->specific.enc_h26x_cmd.log2MaxPicOrderCntLsb;
+  cfg->log2MaxFrameNum = enc_params->specific.enc_h26x_cmd.log2MaxFrameNum;
+  cfg->lookaheadDepth = enc_params->specific.enc_h26x_cmd.lookaheadDepth;
+  cfg->extDSRatio = (enc_params->specific.enc_h26x_cmd.lookaheadDepth &&
+                             enc_params->specific.enc_h26x_cmd.halfDsInput
+                         ? 1
+                         : 0);
+  cfg->cuInfoVersion = enc_params->specific.enc_h26x_cmd.cuInfoVersion;
+  if (enc_params->specific.enc_h26x_cmd.parallelCoreNum > 1 &&
+      cfg->width * cfg->height < 256 * 256) {
+    HANTRO_LOG(HANTRO_LEVEL_INFO,
+               "Disable multicore for small resolution (< 255*255).
");
+    cfg->parallelCoreNum = enc_params->specific.enc_h26x_cmd.parallelCoreNum =
+        1;
+  }
+#if defined(NXP)
+#else
+  cfg->writeReconToDDR = 1;
+#endif
+  return 0;
+}
+
+/**
+ * @brief get_rate_control_from_cmd_h2(), write message from V4l2 parameter to
+ * VCEncRateCtrl pointer.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param void* rcCfg: rate control parameters.
+ * @return void.
+ */
+static void get_rate_control_from_cmd_h2(v4l2_enc_inst *h,
+                                         v4l2_daemon_enc_params *enc_params) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncRateCtrl *rcCfg = &params->video_rate_ctrl;
+  VCEncConfig *cfg = &params->video_config;
+
+  if (enc_params->specific.enc_h26x_cmd.qpHdr != -1)
+    rcCfg->qpHdr = enc_params->specific.enc_h26x_cmd.qpHdr;
+  else
+    rcCfg->qpHdr = -1;
+  if (!h->next_pic_type &&
+      enc_params->specific.enc_h26x_cmd.qpHdrI_h26x != -1) {  // I
+    rcCfg->qpHdr = rcCfg->fixedIntraQp =
+        enc_params->specific.enc_h26x_cmd.qpHdrI_h26x;
+  } else if (h->next_pic_type &&
+             enc_params->specific.enc_h26x_cmd.qpHdrP_h26x != -1) {  // P
+    rcCfg->qpHdr = enc_params->specific.enc_h26x_cmd.qpHdrP_h26x;
+  }
+  if ((enc_params->specific.enc_h26x_cmd.qpMin_h26x >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMin_h26x <= 51))
+    rcCfg->qpMinPB = enc_params->specific.enc_h26x_cmd.qpMin_h26x;
+  else
+    rcCfg->qpMinPB = 0;
+  if ((enc_params->specific.enc_h26x_cmd.qpMax_h26x >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMax_h26x <= 51))
+    rcCfg->qpMaxPB = enc_params->specific.enc_h26x_cmd.qpMax_h26x;
+  else
+    rcCfg->qpMaxPB = 51;
+  if ((enc_params->specific.enc_h26x_cmd.qpMinI >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMinI <= 51))
+    rcCfg->qpMinI = enc_params->specific.enc_h26x_cmd.qpMinI;
+  else
+    rcCfg->qpMinI = 0;
+  if ((enc_params->specific.enc_h26x_cmd.qpMaxI >= 0) &&
+      (enc_params->specific.enc_h26x_cmd.qpMaxI <= 51))
+    rcCfg->qpMaxI = enc_params->specific.enc_h26x_cmd.qpMaxI;
+  else
+    rcCfg->qpMaxI = 51;
+  if (enc_params->specific.enc_h26x_cmd.picSkip != -1)
+    rcCfg->pictureSkip = enc_params->specific.enc_h26x_cmd.picSkip;
+  else
+    rcCfg->pictureSkip = 0;
+  if (enc_params->specific.enc_h26x_cmd.picRc != -1)
+    rcCfg->pictureRc = enc_params->specific.enc_h26x_cmd.picRc;
+  else
+    rcCfg->pictureRc = 0;
+  if (enc_params->specific.enc_h26x_cmd.ctbRc != -1) {
+    if (enc_params->specific.enc_h26x_cmd.ctbRc == 4 ||
+        enc_params->specific.enc_h26x_cmd.ctbRc == 6) {
+      rcCfg->ctbRc = enc_params->specific.enc_h26x_cmd.ctbRc - 3;
+      rcCfg->ctbRcQpDeltaReverse = 1;
+    } else {
+      rcCfg->ctbRc = enc_params->specific.enc_h26x_cmd.ctbRc;
+      rcCfg->ctbRcQpDeltaReverse = 0;
+    }
+  } else {
+    rcCfg->ctbRc = enc_params->specific.enc_h26x_cmd.ctbRc;
+    rcCfg->ctbRcQpDeltaReverse = 0;
+  }
+  if (enc_params->specific.enc_h26x_cmd.blockRCSize != -1)
+    rcCfg->blockRCSize = enc_params->specific.enc_h26x_cmd.blockRCSize;
+  else
+    rcCfg->blockRCSize = 0;
+  rcCfg->rcQpDeltaRange = 10;
+  if (enc_params->specific.enc_h26x_cmd.rcQpDeltaRange != -1)
+    rcCfg->rcQpDeltaRange = enc_params->specific.enc_h26x_cmd.rcQpDeltaRange;
+  rcCfg->rcBaseMBComplexity = 15;
+  if (enc_params->specific.enc_h26x_cmd.rcBaseMBComplexity != -1)
+    rcCfg->rcBaseMBComplexity =
+        enc_params->specific.enc_h26x_cmd.rcBaseMBComplexity;
+  if (enc_params->specific.enc_h26x_cmd.picQpDeltaMax != -1)
+    rcCfg->picQpDeltaMax = enc_params->specific.enc_h26x_cmd.picQpDeltaMax;
+  if (enc_params->specific.enc_h26x_cmd.picQpDeltaMin != -1)
+    rcCfg->picQpDeltaMin = enc_params->specific.enc_h26x_cmd.picQpDeltaMin;
+  if (enc_params->general.bitPerSecond != -1)
+    rcCfg->bitPerSecond = enc_params->general.bitPerSecond;
+  if (enc_params->specific.enc_h26x_cmd.bitVarRangeI != -1)
+    rcCfg->bitVarRangeI = enc_params->specific.enc_h26x_cmd.bitVarRangeI;
+  if (enc_params->specific.enc_h26x_cmd.bitVarRangeP != -1)
+    rcCfg->bitVarRangeP = enc_params->specific.enc_h26x_cmd.bitVarRangeP;
+  if (enc_params->specific.enc_h26x_cmd.bitVarRangeB != -1)
+    rcCfg->bitVarRangeB = enc_params->specific.enc_h26x_cmd.bitVarRangeB;
+  if (enc_params->specific.enc_h26x_cmd.tolMovingBitRate != -1)
+    rcCfg->tolMovingBitRate =
+        enc_params->specific.enc_h26x_cmd.tolMovingBitRate;
+  if (enc_params->specific.enc_h26x_cmd.tolCtbRcInter != -1)
+    rcCfg->tolCtbRcInter = enc_params->specific.enc_h26x_cmd.tolCtbRcInter;
+  if (enc_params->specific.enc_h26x_cmd.tolCtbRcIntra != -1)
+    rcCfg->tolCtbRcIntra = enc_params->specific.enc_h26x_cmd.tolCtbRcIntra;
+  if (enc_params->specific.enc_h26x_cmd.ctbRcRowQpStep != -1)
+    rcCfg->ctbRcRowQpStep = enc_params->specific.enc_h26x_cmd.ctbRcRowQpStep;
+  rcCfg->longTermQpDelta = enc_params->specific.enc_h26x_cmd.longTermQpDelta;
+  if (enc_params->specific.enc_h26x_cmd.monitorFrames != -1)
+    rcCfg->monitorFrames = enc_params->specific.enc_h26x_cmd.monitorFrames;
+  else {
+    rcCfg->monitorFrames = (enc_params->general.outputRateNumer +
+                            enc_params->general.outputRateDenom - 1) /
+                           enc_params->general.outputRateDenom;
+    enc_params->specific.enc_h26x_cmd.monitorFrames =
+        (enc_params->general.outputRateNumer +
+         enc_params->general.outputRateDenom - 1) /
+        enc_params->general.outputRateDenom;
+  }
+  if (rcCfg->monitorFrames > MOVING_AVERAGE_FRAMES)
+    rcCfg->monitorFrames = MOVING_AVERAGE_FRAMES;
+  if (rcCfg->monitorFrames < 10) {
+    rcCfg->monitorFrames = (enc_params->general.outputRateNumer >
+                            enc_params->general.outputRateDenom)
+                               ? 10
+                               : LEAST_MONITOR_FRAME;
+  }
+  if (enc_params->specific.enc_h26x_cmd.hrdConformance != -1)
+    rcCfg->hrd = enc_params->specific.enc_h26x_cmd.hrdConformance;
+  if (enc_params->specific.enc_h26x_cmd.picRc == 0) rcCfg->hrd = 0;
+  if (enc_params->specific.enc_h26x_cmd.cpbSize != -1)
+    rcCfg->hrdCpbSize = enc_params->specific.enc_h26x_cmd.cpbSize;
+  else {//cpbSize default value.
+    int32_t levelIdx;
+    if(IS_HEVC(enc_params->general.codecFormat))
+      levelIdx = getlevelIdxHevc(cfg->level);
+    else
+      levelIdx = getlevelIdxH264(cfg->level);
+    rcCfg->hrdCpbSize = getMaxCpbSize(h->codec_fmt, levelIdx);
+  }
+
+  if (enc_params->specific.enc_h26x_cmd.bitrateWindow != -1)
+    rcCfg->bitrateWindow = enc_params->specific.enc_h26x_cmd.bitrateWindow;
+  else
+    rcCfg->bitrateWindow = 150;
+  if (enc_params->specific.enc_h26x_cmd.intraQpDelta != -1)
+    rcCfg->intraQpDelta = enc_params->specific.enc_h26x_cmd.intraQpDelta;
+  if (enc_params->specific.enc_h26x_cmd.vbr != -1)
+    rcCfg->vbr = enc_params->specific.enc_h26x_cmd.vbr;
+  rcCfg->fixedIntraQp = enc_params->specific.enc_h26x_cmd.fixedIntraQp;
+  rcCfg->smoothPsnrInGOP = enc_params->specific.enc_h26x_cmd.smoothPsnrInGOP;
+  rcCfg->u32StaticSceneIbitPercent =
+      enc_params->specific.enc_h26x_cmd.u32StaticSceneIbitPercent;
+  rcCfg->crf = -1;  // not support now.
+#if defined(NXP)
+#else
+  rcCfg->frameRateNum = enc_params->general.outputRateNumer;
+  rcCfg->frameRateDenom = enc_params->general.outputRateDenom;
+  if (rcCfg->frameRateNum == 0 || rcCfg->frameRateDenom == 0) {
+    rcCfg->frameRateNum = 30;
+    rcCfg->frameRateDenom = 1;
+  }
+#endif
+  if (rcCfg->hrd == 1 && rcCfg->pictureRc == 1) {  // cbr mode
+    h->cbr_last_bitrate = enc_params->general.bitPerSecond;
+  }
+}
+
+/**
+ * @brief get_pre_process_from_cmd_h2(), write message from V4l2 parameter to
+ * void pointer.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @return void.
+ */
+static void get_pre_process_from_cmd_h2(v4l2_enc_inst *h,
+                                        v4l2_daemon_enc_params *enc_params) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncPreProcessingCfg *preProcCfg = &params->video_prep;
+
+  preProcCfg->inputType = enc_params->general.inputFormat;
+  preProcCfg->inputType = (VCEncPictureType)enc_params->general.inputFormat;
+  preProcCfg->rotation = (VCEncPictureRotation)enc_params->general.rotation;
+  preProcCfg->mirror = (VCEncPictureMirror)enc_params->general.mirror;
+  preProcCfg->origWidth = enc_params->general.lumWidthSrc;
+  preProcCfg->origHeight = enc_params->general.lumHeightSrc;
+  if (enc_params->specific.enc_h26x_cmd.interlacedFrame)
+    preProcCfg->origHeight /= 2;
+  if (enc_params->general.horOffsetSrc != -1)
+    preProcCfg->xOffset = enc_params->general.horOffsetSrc;
+  if (enc_params->general.verOffsetSrc != -1)
+    preProcCfg->yOffset = enc_params->general.verOffsetSrc;
+  if (enc_params->general.colorConversion != -1)
+    preProcCfg->colorConversion.type =
+        (VCEncColorConversionType)enc_params->general.colorConversion;
+  if (preProcCfg->colorConversion.type == VCENC_RGBTOYUV_USER_DEFINED) {
+    preProcCfg->colorConversion.coeffA = 20000;
+    preProcCfg->colorConversion.coeffB = 44000;
+    preProcCfg->colorConversion.coeffC = 5000;
+    preProcCfg->colorConversion.coeffE = 35000;
+    preProcCfg->colorConversion.coeffF = 38000;
+    preProcCfg->colorConversion.coeffG = 35000;
+    preProcCfg->colorConversion.coeffH = 38000;
+    preProcCfg->colorConversion.LumaOffset = 0;
+  }
+  if (enc_params->general.rotation && enc_params->general.rotation != 3) {
+    preProcCfg->scaledWidth = enc_params->general.scaledHeight;
+    preProcCfg->scaledHeight = enc_params->general.scaledWidth;
+  } else {
+    preProcCfg->scaledWidth = enc_params->general.scaledWidth;
+    preProcCfg->scaledHeight = enc_params->general.scaledHeight;
+  }
+  if (enc_params->general.scaledWidth * enc_params->general.scaledHeight > 0)
+    preProcCfg->scaledOutput = 1;
+  preProcCfg->constChromaEn = enc_params->specific.enc_h26x_cmd.constChromaEn;
+  if (enc_params->specific.enc_h26x_cmd.constCb != -1)
+    preProcCfg->constCb = enc_params->specific.enc_h26x_cmd.constCb;
+  if (enc_params->specific.enc_h26x_cmd.constCr != -1)
+    preProcCfg->constCr = enc_params->specific.enc_h26x_cmd.constCr;
+// ChangeToCustomizedFormat(cml,&preProcCfg);
+#if defined(NXP)
+#else
+
+#ifndef MAX_OVERLAY_NUM
+#define MAX_OVERLAY_NUM 8
+#endif
+  for (int i = 0; i < MAX_OVERLAY_NUM; i++) {
+    preProcCfg->overlayArea[i].xoffset = 0;
+    preProcCfg->overlayArea[i].cropXoffset = 0;
+    preProcCfg->overlayArea[i].yoffset = 0;
+    preProcCfg->overlayArea[i].cropYoffset = 0;
+    preProcCfg->overlayArea[i].width = 0;
+    preProcCfg->overlayArea[i].cropWidth = 0;
+    preProcCfg->overlayArea[i].height = 0;
+    preProcCfg->overlayArea[i].cropHeight = 0;
+    preProcCfg->overlayArea[i].format = 0;
+    preProcCfg->overlayArea[i].alpha = 0;
+    preProcCfg->overlayArea[i].enable = 0;
+    preProcCfg->overlayArea[i].Ystride = 0;
+    preProcCfg->overlayArea[i].UVstride = 0;
+    preProcCfg->overlayArea[i].bitmapY = 0;
+    preProcCfg->overlayArea[i].bitmapU = 0;
+    preProcCfg->overlayArea[i].bitmapV = 0;
+  }
+#endif
+}
+
+int32_t check_area(v4l2_enc_inst *hinst, VCEncPictureArea *area, int32_t width, int32_t height,
+                   int32_t max_cu_size, int type) {
+  int32_t w = (width + max_cu_size - 1) / max_cu_size;
+  int32_t h = (height + max_cu_size - 1) / max_cu_size;
+
+  if ((area->left < (uint32_t)w) && (area->right < (uint32_t)w) &&
+      (area->top < (uint32_t)h) && (area->bottom < (uint32_t)h))
+    return 0;
+
+  if (type == 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "ROI area check error.
");
+    send_warning_orphan_msg(hinst->instance_id, WARN_ROIREGION);
+  } else  {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "IPCM area check error.
");
+    send_warning_orphan_msg(hinst->instance_id, WARN_IPCMREGION);
+  }
+  return -1;
+}
+
+/**
+ * @brief get_coding_control_from_cmd_h2(), write message from V4l2 parameter to
+ * void pointer.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return void.
+ */
+static void get_coding_control_from_cmd_h2(v4l2_enc_inst *h,
+                                           v4l2_daemon_enc_params *enc_params) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncCodingCtrl *codingCfg = &params->video_coding_ctrl;
+
+  if (enc_params->specific.enc_h26x_cmd.sliceSize != -1)
+    codingCfg->sliceSize = enc_params->specific.enc_h26x_cmd.sliceSize;
+  if (enc_params->specific.enc_h26x_cmd.enableCabac != -1)
+    codingCfg->enableCabac = enc_params->specific.enc_h26x_cmd.enableCabac;
+  if (enc_params->specific.enc_h26x_cmd.cabacInitFlag != -1)
+    codingCfg->cabacInitFlag = enc_params->specific.enc_h26x_cmd.cabacInitFlag;
+  codingCfg->videoFullRange = 0;
+  if (enc_params->specific.enc_h26x_cmd.videoRange != -1)
+    codingCfg->videoFullRange = enc_params->specific.enc_h26x_cmd.videoRange;
+  codingCfg->disableDeblockingFilter =
+      (enc_params->specific.enc_h26x_cmd.disableDeblocking != 0);
+  codingCfg->tc_Offset = enc_params->specific.enc_h26x_cmd.tc_Offset;
+  codingCfg->beta_Offset = enc_params->specific.enc_h26x_cmd.beta_Offset;
+  codingCfg->enableSao = enc_params->specific.enc_h26x_cmd.enableSao;
+  codingCfg->enableDeblockOverride =
+      enc_params->specific.enc_h26x_cmd.enableDeblockOverride;
+  codingCfg->deblockOverride =
+      enc_params->specific.enc_h26x_cmd.deblockOverride;
+  if (enc_params->specific.enc_h26x_cmd.sei)
+    codingCfg->seiMessages = 1;
+  else
+    codingCfg->seiMessages = 0;
+  codingCfg->gdrDuration = enc_params->specific.enc_h26x_cmd.gdrDuration;
+  codingCfg->fieldOrder = enc_params->specific.enc_h26x_cmd.fieldOrder;
+  codingCfg->cirStart = enc_params->specific.enc_h26x_cmd.cirStart;
+  codingCfg->cirInterval = enc_params->specific.enc_h26x_cmd.cirInterval;
+  if (codingCfg->gdrDuration == 0) {
+    codingCfg->intraArea.top = enc_params->specific.enc_h26x_cmd.intraAreaTop;
+    codingCfg->intraArea.left = enc_params->specific.enc_h26x_cmd.intraAreaLeft;
+    codingCfg->intraArea.bottom =
+        enc_params->specific.enc_h26x_cmd.intraAreaBottom;
+    codingCfg->intraArea.right =
+        enc_params->specific.enc_h26x_cmd.intraAreaRight;
+    codingCfg->intraArea.enable =
+        enc_params->specific.enc_h26x_cmd.intraAreaEnable;
+  } else {
+    codingCfg->intraArea.enable = 0;  // intraArea will be used by GDR, customer
+                                      // can not use intraArea when GDR is
+                                      // enabled.
+  }
+
+  int32_t max_cu_size = IS_H264(enc_params->general.codecFormat) ? 16 : 64;
+  int32_t encode_width = enc_params->general.width;
+  int32_t encode_height = enc_params->general.height;
+
+  codingCfg->pcm_loop_filter_disabled_flag =
+      enc_params->specific.enc_h26x_cmd.pcm_loop_filter_disabled_flag;
+  codingCfg->ipcm1Area.top = enc_params->specific.enc_h26x_cmd.ipcmAreaTop[0];
+  codingCfg->ipcm1Area.left = enc_params->specific.enc_h26x_cmd.ipcmAreaLeft[0];
+  codingCfg->ipcm1Area.bottom =
+      enc_params->specific.enc_h26x_cmd.ipcmAreaBottom[0];
+  codingCfg->ipcm1Area.right =
+      enc_params->specific.enc_h26x_cmd.ipcmAreaRight[0];
+  codingCfg->ipcm1Area.enable =
+      enc_params->specific.enc_h26x_cmd.ipcmAreaEnable[0];
+  if (check_area(h, &codingCfg->ipcm1Area, encode_width, encode_height,
+                 max_cu_size, 1) != 0) {
+    codingCfg->ipcm1Area.enable = 0;
+  }
+
+  codingCfg->ipcm2Area.top = enc_params->specific.enc_h26x_cmd.ipcmAreaTop[1];
+  codingCfg->ipcm2Area.left = enc_params->specific.enc_h26x_cmd.ipcmAreaLeft[1];
+  codingCfg->ipcm2Area.bottom =
+      enc_params->specific.enc_h26x_cmd.ipcmAreaBottom[1];
+  codingCfg->ipcm2Area.right =
+      enc_params->specific.enc_h26x_cmd.ipcmAreaRight[1];
+  codingCfg->ipcm2Area.enable =
+      enc_params->specific.enc_h26x_cmd.ipcmAreaEnable[1];
+  if (check_area(h, &codingCfg->ipcm2Area, encode_width, encode_height,
+                 max_cu_size, 1) != 0) {
+    codingCfg->ipcm2Area.enable = 0;
+  }
+
+  codingCfg->ipcmMapEnable = enc_params->specific.enc_h26x_cmd.ipcmMapEnable;
+  codingCfg->pcm_enabled_flag =
+      (codingCfg->ipcm1Area.enable || codingCfg->ipcm2Area.enable ||
+       codingCfg->ipcmMapEnable);
+
+  if (codingCfg->gdrDuration == 0) {
+    codingCfg->roi1Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[0];
+    codingCfg->roi1Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[0];
+    codingCfg->roi1Area.bottom =
+        enc_params->specific.enc_h26x_cmd.roiAreaBottom[0];
+    codingCfg->roi1Area.right =
+        enc_params->specific.enc_h26x_cmd.roiAreaRight[0];
+    codingCfg->roi1Area.enable =
+        enc_params->specific.enc_h26x_cmd.roiAreaEnable[0];
+    codingCfg->roi1DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[0];
+    codingCfg->roi1Qp = enc_params->specific.enc_h26x_cmd.roiQp[0];
+    if (check_area(h, &codingCfg->roi1Area, encode_width, encode_height,
+                   max_cu_size, 0) != 0 ||
+        (codingCfg->roi1Qp < 0 && codingCfg->roi1DeltaQp == 0)) {
+      codingCfg->roi1Area.enable = 0;
+    }
+#if 0  // hard code for test
+        codingCfg->roi1Area.top = 0;
+        codingCfg->roi1Area.left = 0;
+        codingCfg->roi1Area.bottom = 3;
+        codingCfg->roi1Area.right = 3;
+        codingCfg->roi1Area.enable = 1;
+        codingCfg->roi1DeltaQp = -5;
+        codingCfg->roi1Qp = 10;
+#endif
+  } else {
+    codingCfg->roi1Area.enable = 0;
+  }
+
+  codingCfg->roi2Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[1];
+  codingCfg->roi2Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[1];
+  codingCfg->roi2Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[1];
+  codingCfg->roi2Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[1];
+  codingCfg->roi2Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[1];
+  codingCfg->roi2DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[1];
+  codingCfg->roi2Qp = enc_params->specific.enc_h26x_cmd.roiQp[1];
+  if (check_area(h, &codingCfg->roi2Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi2Qp < 0 && codingCfg->roi2DeltaQp == 0)) {
+    codingCfg->roi2Area.enable = 0;
+  }
+
+  codingCfg->roi3Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[2];
+  codingCfg->roi3Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[2];
+  codingCfg->roi3Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[2];
+  codingCfg->roi3Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[2];
+  codingCfg->roi3Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[2];
+  codingCfg->roi3DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[2];
+  codingCfg->roi3Qp = enc_params->specific.enc_h26x_cmd.roiQp[2];
+  if (check_area(h, &codingCfg->roi3Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi3Qp < 0 && codingCfg->roi3DeltaQp == 0)) {
+    codingCfg->roi3Area.enable = 0;
+  }
+
+  codingCfg->roi4Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[3];
+  codingCfg->roi4Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[3];
+  codingCfg->roi4Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[3];
+  codingCfg->roi4Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[3];
+  codingCfg->roi4Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[3];
+  codingCfg->roi4DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[3];
+  codingCfg->roi4Qp = enc_params->specific.enc_h26x_cmd.roiQp[3];
+  if (check_area(h, &codingCfg->roi4Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi4Qp < 0 && codingCfg->roi4DeltaQp == 0)) {
+    codingCfg->roi4Area.enable = 0;
+  }
+
+  codingCfg->roi5Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[4];
+  codingCfg->roi5Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[4];
+  codingCfg->roi5Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[4];
+  codingCfg->roi5Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[4];
+  codingCfg->roi5Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[4];
+  codingCfg->roi5DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[4];
+  codingCfg->roi5Qp = enc_params->specific.enc_h26x_cmd.roiQp[4];
+  if (check_area(h, &codingCfg->roi5Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi5Qp < 0 && codingCfg->roi5DeltaQp == 0)) {
+    codingCfg->roi5Area.enable = 0;
+  }
+
+  codingCfg->roi6Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[5];
+  codingCfg->roi6Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[5];
+  codingCfg->roi6Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[5];
+  codingCfg->roi6Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[5];
+  codingCfg->roi6Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[5];
+  codingCfg->roi6DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[5];
+  codingCfg->roi6Qp = enc_params->specific.enc_h26x_cmd.roiQp[5];
+  if (check_area(h, &codingCfg->roi6Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi6Qp < 0 && codingCfg->roi6DeltaQp == 0)) {
+    codingCfg->roi6Area.enable = 0;
+  }
+
+  codingCfg->roi7Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[6];
+  codingCfg->roi7Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[6];
+  codingCfg->roi7Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[6];
+  codingCfg->roi7Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[6];
+  codingCfg->roi7Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[6];
+  codingCfg->roi7DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[6];
+  codingCfg->roi7Qp = enc_params->specific.enc_h26x_cmd.roiQp[6];
+  if (check_area(h, &codingCfg->roi7Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi7Qp < 0 && codingCfg->roi7DeltaQp == 0)) {
+    codingCfg->roi7Area.enable = 0;
+  }
+
+  codingCfg->roi8Area.top = enc_params->specific.enc_h26x_cmd.roiAreaTop[7];
+  codingCfg->roi8Area.left = enc_params->specific.enc_h26x_cmd.roiAreaLeft[7];
+  codingCfg->roi8Area.bottom =
+      enc_params->specific.enc_h26x_cmd.roiAreaBottom[7];
+  codingCfg->roi8Area.right = enc_params->specific.enc_h26x_cmd.roiAreaRight[7];
+  codingCfg->roi8Area.enable =
+      enc_params->specific.enc_h26x_cmd.roiAreaEnable[7];
+  codingCfg->roi8DeltaQp = enc_params->specific.enc_h26x_cmd.roiDeltaQp[7];
+  codingCfg->roi8Qp = enc_params->specific.enc_h26x_cmd.roiQp[7];
+  if (check_area(h, &codingCfg->roi8Area, encode_width, encode_height,
+                 max_cu_size, 0) != 0 ||
+      (codingCfg->roi8Qp < 0 && codingCfg->roi8DeltaQp == 0)) {
+    codingCfg->roi8Area.enable = 0;
+  }
+
+  if (codingCfg->cirInterval)
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "  CIR: %d %d
", codingCfg->cirStart,
+               codingCfg->cirInterval);
+  if (codingCfg->intraArea.enable)
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "  IntraArea: %dx%d-%dx%d
",
+               codingCfg->intraArea.left, codingCfg->intraArea.top,
+               codingCfg->intraArea.right, codingCfg->intraArea.bottom);
+  if (codingCfg->ipcm1Area.enable)
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "  IPCM1Area: %dx%d-%dx%d
",
+               codingCfg->ipcm1Area.left, codingCfg->ipcm1Area.top,
+               codingCfg->ipcm1Area.right, codingCfg->ipcm1Area.bottom);
+  if (codingCfg->ipcm2Area.enable)
+    HANTRO_LOG(HANTRO_LEVEL_INFO, "  IPCM2Area: %dx%d-%dx%d
",
+               codingCfg->ipcm2Area.left, codingCfg->ipcm2Area.top,
+               codingCfg->ipcm2Area.right, codingCfg->ipcm2Area.bottom);
+  if (codingCfg->roi1Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 1: %s %d %dx%d-%dx%d
",
+        codingCfg->roi1Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi1Qp >= 0 ? codingCfg->roi1Qp : codingCfg->roi1DeltaQp,
+        codingCfg->roi1Area.left, codingCfg->roi1Area.top,
+        codingCfg->roi1Area.right, codingCfg->roi1Area.bottom);
+  if (codingCfg->roi2Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 2: %s %d %dx%d-%dx%d
",
+        codingCfg->roi2Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi2Qp >= 0 ? codingCfg->roi2Qp : codingCfg->roi2DeltaQp,
+        codingCfg->roi2Area.left, codingCfg->roi2Area.top,
+        codingCfg->roi2Area.right, codingCfg->roi2Area.bottom);
+  if (codingCfg->roi3Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 3: %s %d %dx%d-%dx%d
",
+        codingCfg->roi3Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi3Qp >= 0 ? codingCfg->roi3Qp : codingCfg->roi3DeltaQp,
+        codingCfg->roi3Area.left, codingCfg->roi3Area.top,
+        codingCfg->roi3Area.right, codingCfg->roi3Area.bottom);
+  if (codingCfg->roi4Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 4: %s %d %dx%d-%dx%d
",
+        codingCfg->roi4Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi4Qp >= 0 ? codingCfg->roi4Qp : codingCfg->roi4DeltaQp,
+        codingCfg->roi4Area.left, codingCfg->roi4Area.top,
+        codingCfg->roi4Area.right, codingCfg->roi4Area.bottom);
+  if (codingCfg->roi5Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 5: %s %d %dx%d-%dx%d
",
+        codingCfg->roi5Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi5Qp >= 0 ? codingCfg->roi5Qp : codingCfg->roi5DeltaQp,
+        codingCfg->roi5Area.left, codingCfg->roi5Area.top,
+        codingCfg->roi5Area.right, codingCfg->roi5Area.bottom);
+  if (codingCfg->roi6Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 6: %s %d %dx%d-%dx%d
",
+        codingCfg->roi6Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi6Qp >= 0 ? codingCfg->roi6Qp : codingCfg->roi6DeltaQp,
+        codingCfg->roi6Area.left, codingCfg->roi6Area.top,
+        codingCfg->roi6Area.right, codingCfg->roi6Area.bottom);
+  if (codingCfg->roi7Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 7: %s %d %dx%d-%dx%d
",
+        codingCfg->roi7Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi7Qp >= 0 ? codingCfg->roi7Qp : codingCfg->roi7DeltaQp,
+        codingCfg->roi7Area.left, codingCfg->roi7Area.top,
+        codingCfg->roi7Area.right, codingCfg->roi7Area.bottom);
+  if (codingCfg->roi8Area.enable)
+    HANTRO_LOG(
+        HANTRO_LEVEL_INFO, "  ROI 8: %s %d %dx%d-%dx%d
",
+        codingCfg->roi8Qp >= 0 ? "QP" : "QP Delta",
+        codingCfg->roi8Qp >= 0 ? codingCfg->roi8Qp : codingCfg->roi8DeltaQp,
+        codingCfg->roi8Area.left, codingCfg->roi8Area.top,
+        codingCfg->roi8Area.right, codingCfg->roi8Area.bottom);
+  codingCfg->roiMapDeltaQpEnable =
+      enc_params->specific.enc_h26x_cmd.roiMapDeltaQpEnable;
+  codingCfg->roiMapDeltaQpBlockUnit =
+      enc_params->specific.enc_h26x_cmd.roiMapDeltaQpBlockUnit;
+  codingCfg->RoimapCuCtrl_ver = enc_params->specific.enc_h26x_cmd.RoiCuCtrlVer;
+  codingCfg->RoiQpDelta_ver = enc_params->specific.enc_h26x_cmd.RoiQpDeltaVer;
+  /* SKIP map */
+  codingCfg->skipMapEnable = enc_params->specific.enc_h26x_cmd.skipMapEnable;
+  codingCfg->enableScalingList =
+      enc_params->specific.enc_h26x_cmd.enableScalingList;
+  codingCfg->chroma_qp_offset =
+      enc_params->specific.enc_h26x_cmd.chromaQpOffset;
+  /* HDR10 */
+  codingCfg->Hdr10Display.hdr10_display_enable =
+      enc_params->specific.enc_h26x_cmd.hdr10_display_enable;
+  if (enc_params->specific.enc_h26x_cmd.hdr10_display_enable) {
+    codingCfg->Hdr10Display.hdr10_dx0 =
+        enc_params->specific.enc_h26x_cmd.hdr10_dx0;
+    codingCfg->Hdr10Display.hdr10_dy0 =
+        enc_params->specific.enc_h26x_cmd.hdr10_dy0;
+    codingCfg->Hdr10Display.hdr10_dx1 =
+        enc_params->specific.enc_h26x_cmd.hdr10_dx1;
+    codingCfg->Hdr10Display.hdr10_dy1 =
+        enc_params->specific.enc_h26x_cmd.hdr10_dy1;
+    codingCfg->Hdr10Display.hdr10_dx2 =
+        enc_params->specific.enc_h26x_cmd.hdr10_dx2;
+    codingCfg->Hdr10Display.hdr10_dy2 =
+        enc_params->specific.enc_h26x_cmd.hdr10_dy2;
+    codingCfg->Hdr10Display.hdr10_wx =
+        enc_params->specific.enc_h26x_cmd.hdr10_wx;
+    codingCfg->Hdr10Display.hdr10_wy =
+        enc_params->specific.enc_h26x_cmd.hdr10_wy;
+    codingCfg->Hdr10Display.hdr10_maxluma =
+        enc_params->specific.enc_h26x_cmd.hdr10_maxluma;
+    codingCfg->Hdr10Display.hdr10_minluma =
+        enc_params->specific.enc_h26x_cmd.hdr10_minluma;
+  }
+  codingCfg->Hdr10LightLevel.hdr10_lightlevel_enable =
+      enc_params->specific.enc_h26x_cmd.hdr10_lightlevel_enable;
+  if (enc_params->specific.enc_h26x_cmd.hdr10_lightlevel_enable) {
+    codingCfg->Hdr10LightLevel.hdr10_maxlight =
+        enc_params->specific.enc_h26x_cmd.hdr10_maxlight;
+    codingCfg->Hdr10LightLevel.hdr10_avglight =
+        enc_params->specific.enc_h26x_cmd.hdr10_avglight;
+  }
+  codingCfg->RpsInSliceHeader =
+      enc_params->specific.enc_h26x_cmd.RpsInSliceHeader;
+}
+
+/**
+ * @brief get_color_description_from_cmd_h2(), empty function.
+ * @param void.
+ * @return void.
+ */
+static void get_color_description_from_cmd_h2(void) {
+  // no need to get, just follow the code format.
+}
+
+/**
+ * @brief encoder_init_h2(), init H2 data structures.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return .
+ */
+void encoder_init_h2(v4l2_enc_inst *h) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+
+#if 1
+  // do nothing, as the memory has been set to 0 when create encoder instance.
+  (void)params;
+#else
+  for (int i = 0; i < MAX_GOP_SIZE + 1; i++) params->gopCfgOffset[i] = 0;
+
+  memset(params->gopPicCfg, 0,
+         sizeof(VCEncGopPicConfig) * MAX_GOP_PIC_CONFIG_NUM);
+  memset(&params->video_in, 0, sizeof(VCEncIn));
+#endif
+}
+
+/**
+ * @brief encoder_check_codec_format_h2(), before encode, confirm if hw support
+ * this format.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int, 0 is supported, -1 is unsupported.
+ */
+int encoder_check_codec_format_h2(v4l2_enc_inst *h) {
+  int core_num = 0;
+
+  EWLHwConfig_t configure_t;
+#if (defined(NXP) && !defined(USE_H1))  // nxp v2
+  core_num = EWLGetCoreNum();
+  ASSERT(core_num != 0);
+
+  for (int i = 0; i < core_num; i++) {
+    configure_t = EWLReadAsicConfig(i);
+    h->configure_t.has_h264 |= configure_t.h264Enabled;
+    h->configure_t.has_hevc |= configure_t.hevcEnabled;
+    h->configure_t.has_jpeg |= configure_t.jpegEnabled;
+    if (h->configure_t.has_h264) {
+      h->configure_t.max_width_h264 = configure_t.maxEncodedWidthH264;
+    }
+    if (h->configure_t.has_hevc) {
+      h->configure_t.max_width_hevc = configure_t.maxEncodedWidthHEVC;
+    }
+    if (h->configure_t.has_jpeg) {
+      h->configure_t.max_width_jpeg = configure_t.maxEncodedWidthJPEG;
+    }
+  }
+#elif (!defined(NXP) && !defined(USE_H1))  // current v2
+  core_num = EWLGetCoreNum(NULL);
+  ASSERT(core_num != 0);
+
+  for (int i = 0; i < core_num; i++) {
+    configure_t = EWLReadAsicConfig(i, NULL);
+    h->configure_t.has_h264 |= configure_t.h264Enabled;
+    h->configure_t.has_hevc |= configure_t.hevcEnabled;
+    h->configure_t.has_jpeg |= configure_t.jpegEnabled;
+    if (h->configure_t.has_h264) {
+      h->configure_t.max_width_h264 = configure_t.maxEncodedWidthH264;
+    }
+    if (h->configure_t.has_hevc) {
+      h->configure_t.max_width_hevc = configure_t.maxEncodedWidthHEVC;
+    }
+    if (h->configure_t.has_jpeg) {
+      h->configure_t.max_width_jpeg = configure_t.maxEncodedWidthJPEG;
+    }
+  }
+#endif
+  if ((h->codec_fmt == V4L2_DAEMON_CODEC_ENC_HEVC) &&
+      (h->configure_t.has_hevc == 1))
+    return 0;
+  else if ((h->codec_fmt == V4L2_DAEMON_CODEC_ENC_H264) &&
+           (h->configure_t.has_h264 == 1))
+    return 0;
+  else
+    return -1;
+}
+
+/**
+ * @brief encoder_get_input_h2(), write message from V4l2 parameter to VCEncIn
+ * pointer.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if init gop config of encIn.
+ * @return void.
+ */
+void encoder_get_input_h2(v4l2_enc_inst *h, v4l2_daemon_enc_params *enc_params,
+                          int32_t if_config) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+  //    VCEncOut *encOut = &params->video_out;
+  uint32_t size_lum = 0;
+  uint32_t size_ch = 0;
+
+  getAlignedPicSizebyFormat(
+      enc_params->general.inputFormat, enc_params->general.lumWidthSrc,
+      enc_params->general.lumHeightSrc, 0, &size_lum, &size_ch, NULL);
+#ifndef USE_HW
+  encIn->busLuma =
+      (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busLuma,
+                                  enc_params->io_buffer.busLumaSize);
+  if (enc_params->io_buffer.busChromaU != 0)
+    encIn->busChromaU =
+        (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busChromaU,
+                                    enc_params->io_buffer.busChromaUSize);
+  else
+    encIn->busChromaU = encIn->busLuma + size_lum;
+
+  if (enc_params->io_buffer.busChromaV != 0)
+    encIn->busChromaV =
+        (ptr_t)mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busChromaV,
+                                    enc_params->io_buffer.busChromaVSize);
+  else
+    encIn->busChromaV = encIn->busChromaU + size_ch / 2;
+#else
+  encIn->busLuma = enc_params->io_buffer.busLuma;
+  if (enc_params->io_buffer.busChromaU != 0)
+    encIn->busChromaU = enc_params->io_buffer.busChromaU;
+  else
+    encIn->busChromaU = encIn->busLuma + size_lum;
+  if (enc_params->io_buffer.busChromaV != 0)
+    encIn->busChromaV = enc_params->io_buffer.busChromaV;
+  else
+    encIn->busChromaV = encIn->busChromaU + size_ch / 2;
+#endif
+
+  h->saveOriOutBuf = encIn->pOutBuf[0] =
+      mmap_phy_addr_daemon(mmap_fd, enc_params->io_buffer.busOutBuf,
+                           enc_params->io_buffer.outBufSize);
+
+#ifdef USE_HW
+  encIn->busOutBuf[0] = enc_params->io_buffer.busOutBuf;
+#else
+  encIn->busOutBuf[0] = (ptr_t)encIn->pOutBuf[0];
+#endif
+  encIn->outBufSize[0] = enc_params->io_buffer.outBufSize;
+
+  encIn->gopSize = enc_params->specific.enc_h26x_cmd.gopSize;
+  encIn->gopConfig.pGopPicCfg = params->gopPicCfg;
+  encIn->gopConfig.pGopPicSpecialCfg = params->gopPicSpecialCfg;
+  encIn->gopConfig.firstPic = enc_params->general.firstPic;
+  encIn->gopConfig.lastPic = enc_params->general.lastPic;
+  encIn->gopConfig.outputRateDenom = enc_params->general.outputRateDenom;
+  encIn->gopConfig.outputRateNumer = enc_params->general.outputRateNumer;
+  encIn->gopConfig.inputRateDenom = enc_params->general.inputRateDenom;
+  encIn->gopConfig.inputRateNumer = enc_params->general.inputRateNumer;
+
+  encIn->vui_timing_info_enable = 1;
+
+  if (encIn->codingType == VCENC_INTRA_FRAME && !if_config)
+    encIn->resendVPS = encIn->resendSPS = encIn->resendPPS =
+        1;  // default enabe this value
+  else
+    encIn->resendVPS = encIn->resendSPS = encIn->resendPPS = 0;
+
+  if (if_config) {
+    InitPicConfig(encIn);
+  }
+  if (enc_params->general.outputRateDenom != 0)
+    encIn->timeIncrement = enc_params->general.outputRateDenom;
+  else
+    encIn->timeIncrement = 1;
+  if (enc_params->specific.enc_h26x_cmd.force_idr) {
+    encIn->codingType = VCENC_INTRA_FRAME;
+    encIn->bIsIDR = 1;
+    h->next_pic_type = (int)VCENC_INTRA_FRAME;
+  }
+}
+
+/**
+ * @brief encoder_set_parameter_h2(), set encoder parameters.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if configure the VCEncConfig.
+ * @return int: api return value.
+ */
+int encoder_set_parameter_h2(v4l2_enc_inst *h,
+                             v4l2_daemon_enc_params *enc_params,
+                             int32_t if_config) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+  //    VCEncOut *encOut = &params->video_out;
+  int ret;
+
+  encoder_get_input_h2(h, enc_params, if_config);
+  init_cmdl(h, encIn);
+
+  /* Encoder setup: init instance.*/
+  if (if_config == 1) {
+    ret = init_gop_config(h, enc_params->specific.enc_h26x_cmd.intraPicRate);
+    if (ret != 0) return DAEMON_ERR_ENC_PARA;
+
+    if (get_config_from_cmd_h2(h, enc_params) == -1)
+      return DAEMON_ERR_ENC_NOT_SUPPORT;
+#if defined(NXP)
+    ret = VCEncInit(&params->video_config, &h->inst);
+#else
+    ret = VCEncInit(&params->video_config, &h->inst, NULL);
+#endif
+    if (ret != VCENC_OK) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncInit() failed. vsi_ret=%d
", ret);
+      return DAEMON_ERR_ENC_INTERNAL;
+    }
+  }
+
+  if (if_config == 1) h->total_frames = 0;
+
+  /* Encoder setup: rate control */
+  if ((if_config == 1) || (enc_params->specific.enc_h26x_cmd.picRc == 0) ||
+      (enc_params->specific.enc_h26x_cmd.hrdConformance != 1 &&
+       if_config != 1)) {
+    if ((ret = VCEncGetRateCtrl(h->inst, &params->video_rate_ctrl)) !=
+        VCENC_OK) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncGetRateCtrl error.
");
+      return DAEMON_ERR_ENC_INTERNAL;
+    }
+    get_rate_control_from_cmd_h2(h, enc_params);
+    if ((ret = VCEncSetRateCtrl(h->inst, &params->video_rate_ctrl)) !=
+        VCENC_OK) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncSetRateCtrl error.
");
+      return DAEMON_ERR_ENC_INTERNAL;
+    }
+  }
+
+  /*Check if the cbr bit rate is changed.*/
+  check_if_cbr_bitrate_changed(h, enc_params);
+
+  /*Encoder setup: PreP setup */
+  if ((ret = VCEncGetPreProcessing(h->inst, &params->video_prep)) != VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncGetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+  get_pre_process_from_cmd_h2(h, enc_params);
+  if ((ret = VCEncSetPreProcessing(h->inst, &params->video_prep)) != VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncSetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  /* Encoder setup: coding control */
+  if ((ret = VCEncGetCodingCtrl(h->inst, &params->video_coding_ctrl)) !=
+      VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncGetCodingCtrl error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+  get_coding_control_from_cmd_h2(h, enc_params);
+  if ((ret = VCEncSetCodingCtrl(h->inst, &params->video_coding_ctrl)) !=
+      VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncSetPreProcessing error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  get_color_description_from_cmd_h2();
+  if ((ret = VCEncSetVuiColorDescription(
+           h->inst,
+           enc_params->specific.enc_h26x_cmd.vuiVideoSignalTypePresentFlag,
+           enc_params->specific.enc_h26x_cmd.vuiVideoFormat,
+           enc_params->specific.enc_h26x_cmd.vuiColorDescripPresentFlag,
+           enc_params->specific.enc_h26x_cmd.vuiColorPrimaries,
+           enc_params->specific.enc_h26x_cmd.vuiTransferCharacteristics,
+           enc_params->specific.enc_h26x_cmd.vuiMatrixCoefficients)) !=
+      VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncSetVuiColorDescription error.
");
+    return DAEMON_ERR_ENC_INTERNAL;
+  }
+
+  return 0;
+}
+
+/**
+ * @brief encoder_start_h2(), start encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @return int: api return value.
+ */
+int encoder_start_h2(v4l2_enc_inst *h, uint32_t *stream_size) {
+  VCEncRet encRet;
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+  VCEncOut *encOut = &params->video_out;
+  int ret = 0;
+
+  encRet = VCEncStrmStart(h->inst, encIn, encOut);
+  if (encRet != VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncStrmStart() failed, ret=%d
", encRet);
+    ret = DAEMON_ERR_ENC_INTERNAL;
+  }
+  *stream_size = encOut->streamSize;
+  return ret;
+}
+
+/**
+ * @brief encoder_encode_h2(), start encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @param uint32_t* codingType: coding type.
+ * @return int: api return value.
+ */
+int encoder_encode_h2(v4l2_enc_inst *h, uint32_t *stream_size,
+                      uint32_t *codingType) {
+  VCEncRet encRet;
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+  VCEncOut *encOut = &params->video_out;
+  int ret = 0;
+
+  encIn->pOutBuf[0] = (uint32_t *)((uint8_t *)encIn->pOutBuf[0] + *stream_size);
+  encIn->busOutBuf[0] += *stream_size;
+  encIn->outBufSize[0] -= *stream_size;
+
+  encRet = VCEncStrmEncodeExt(h->inst, encIn, NULL, encOut, NULL, NULL, 0);
+  if (encRet != VCENC_FRAME_READY && encRet != VCENC_FRAME_ENQUEUE) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncStrmEncodeExt() failed, ret=%d
",
+               encRet);
+    ret = DAEMON_ERR_ENC_INTERNAL;
+  }
+  *stream_size += encOut->streamSize;
+  *codingType = encIn->codingType;
+  if (encRet == VCENC_FRAME_READY) ret = DAEMON_ENC_FRAME_READY;
+  else if (encRet == VCENC_FRAME_ENQUEUE) ret = DAEMON_ENC_FRAME_ENQUEUE;
+  else ret = DAEMON_ERR_ENC_INTERNAL;
+  return ret;
+}
+
+/**
+ * @brief encoder_find_next_pic_h2(), find buffer and gop structure of next
+ * picture.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param BUFFER** p_buffer: buffer to encode
+ * @param uint32_t* buf_id: buffer id in buffer list.
+ * @return int: api return value.
+ */
+int encoder_find_next_pic_h2(v4l2_enc_inst *h, BUFFER **p_buffer,
+                             uint32_t *buf_id) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+
+  if (h->bufferlist_reorder->size >= encIn->gopSize) {
+    h->next_pic_type = VCEncFindNextPic(
+        h->inst, encIn, encIn->gopSize,
+        (const uint8_t *)(&encIn->gopConfig.gopCfgOffset), false);
+    *p_buffer =
+        bufferlist_find_buffer(h->bufferlist_reorder, encIn->picture_cnt,
+                               buf_id);  // match picture_cnt
+  }
+  return 0;
+}
+
+/**
+ * @brief reset_enc_h2(), reset encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+void reset_enc_h2(v4l2_enc_inst *h) {
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+  VCEncIn *encIn = &params->video_in;
+
+  //when get reset command, reset picture_cnt
+  encIn->picture_cnt = 0;
+}
+
+/**
+ * @brief encoder_end_h2(), stream end, write eos.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @return int: api return value.
+ */
+int encoder_end_h2(v4l2_enc_inst *h, uint32_t *stream_size) {
+  VCEncRet ret;
+  h2_enc_params *params = (h2_enc_params *)h->enc_params;
+
+  ret = VCEncStrmEnd(h->inst, &params->video_in, &params->video_out);
+  if (ret != VCENC_OK) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "VCEncStrmEnd() failed, ret=%d
", ret);
+  }
+  *stream_size = params->video_out.streamSize;
+  return (int)ret;
+}
+
+/**
+ * @brief encoder_close_h2(), close encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+int encoder_close_h2(v4l2_enc_inst *h) {
+  VCEncRet ret = 0;
+
+  if (h->inst != NULL) {
+    ret = VCEncRelease(h->inst);
+    if (ret != VCENC_OK) {
+      HANTRO_LOG(HANTRO_LEVEL_INFO, "VCEncRelease failed, ret=%d
", ret);
+    }
+  }
+
+  if (h->bufferlist_input) bufferlist_flush(h->bufferlist_input);
+  if (h->bufferlist_output) bufferlist_flush(h->bufferlist_output);
+  if (h->bufferlist_reorder) bufferlist_flush(h->bufferlist_reorder);
+  return (int)ret;
+}
+
+/**
+ * @brief encoder_get_attr_h2(), get encoder attributes.
+ * @param v4l2_daemon_codec_fmt fmt: codec format.
+ * @return
+ */
+void encoder_get_attr_h2(v4l2_daemon_codec_fmt fmt, enc_inst_attr *attr) {
+  ASSERT(attr);
+
+  if (fmt == V4L2_DAEMON_CODEC_ENC_JPEG) {
+#ifndef NXP
+    attr->param_size = sizeof(jpeg_enc_params);
+#else
+    attr->param_size = 0;
+#endif
+  } else {
+    attr->param_size = sizeof(h2_enc_params);
+  }
+}
diff --git a/v4l2_vsi_daemon/src/vsi_enc_video_h2.h b/v4l2_vsi_daemon/src/vsi_enc_video_h2.h
new file mode 100755
index 0000000..686a91c
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_video_h2.h
@@ -0,0 +1,131 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef VSI_ENC_VIDEO_H2_H
+#define VSI_ENC_VIDEO_H2_H
+#include "vsi_enc.h"
+/**
+ * @file vsi_enc_video_h2.h
+ * @brief V4L2 Daemon video process header file.
+ * @version 0.10- Initial version
+ */
+
+/**
+ * @brief encoder_check_codec_format_h2(), before encode, confirm if hw support
+ * this format.
+ * @param v4l2_enc_inst* h, encoder instance.
+ * @return int, 0 is supported, -1 is unsupported.
+ */
+int encoder_check_codec_format_h2(v4l2_enc_inst* h);
+
+/**
+ * @brief encoder_init_h2(), init H2 data structures.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return .
+ */
+void encoder_init_h2(v4l2_enc_inst* h);
+
+/**
+ * @brief encoder_get_attr_h2(), get encoder attributes.
+ * @param v4l2_enc_inst fmt: codec format.
+ * @return
+ */
+void encoder_get_attr_h2(v4l2_daemon_codec_fmt fmt, enc_inst_attr* attr);
+
+/**
+ * @brief encoder_get_input_h2(), write message from V4l2 parameter to VCEncIn
+ * pointer.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if init gop config of encIn.
+ * @return void.
+ */
+void encoder_get_input_h2(v4l2_enc_inst* h, v4l2_daemon_enc_params* enc_params,
+                          int32_t if_config);
+
+/**
+ * @brief encoder_set_parameter_h2(), set encoder parameters.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param v4l2_daemon_enc_params* enc_params: encoder parameters.
+ * @param int32_t if_config: if configure the VCEncConfig.
+ * @return int: api return value.
+ */
+int encoder_set_parameter_h2(v4l2_enc_inst* h,
+                             v4l2_daemon_enc_params* enc_params,
+                             int32_t if_config);
+
+/**
+ * @brief encoder_start_h2(), start encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @return int: api return value.
+ */
+int encoder_start_h2(v4l2_enc_inst* h, uint32_t* stream_size);
+
+/**
+ * @brief encoder_encode_h2(), start encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param uint32_t* stream_size: srteam size.
+ * @param uint32_t* codingType: coding type.
+ * @return int: api return value.
+ */
+int encoder_encode_h2(v4l2_enc_inst* h, uint32_t* stream_size,
+                      uint32_t* codingType);
+
+/**
+ * @brief encoder_find_next_pic_h2(), find buffer and gop structure of next
+ * picture.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @param BUFFER** p_buffer: buffer to encode
+ * @param uint32_t* list_num: buffer id in buffer list.
+ * @return int: api return value.
+ */
+int encoder_find_next_pic_h2(v4l2_enc_inst* h, BUFFER** p_buffer,
+                             uint32_t* list_num);
+
+/**
+ * @brief reset_enc_h2(), reset encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+void reset_enc_h2(v4l2_enc_inst *h);
+
+/**
+* @brief encoder_end_h2(), stream end, write eos.
+* @param v4l2_enc_inst* h: encoder instance.
+* @param uint32_t* stream_size: srteam size.
+* @return int: api return value.
+*/
+int encoder_end_h2(v4l2_enc_inst* h, uint32_t* stream_size);
+
+/**
+ * @brief encoder_close_h2(), close encoder.
+ * @param v4l2_enc_inst* h: encoder instance.
+ * @return int: api return value.
+ */
+int encoder_close_h2(v4l2_enc_inst* h);
+
+#endif
diff --git a/v4l2_vsi_daemon/src/vsi_enc_video_h2_priv.h b/v4l2_vsi_daemon/src/vsi_enc_video_h2_priv.h
new file mode 100755
index 0000000..8e91a26
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_enc_video_h2_priv.h
@@ -0,0 +1,68 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+#ifndef __VSI_ENC_VIDEO_H2_PRIV_H__
+#define __VSI_ENC_VIDEO_H2_PRIV_H__
+
+#include "ewl.h"
+#include "hevcencapi.h"
+
+typedef struct {
+  int8_t *gopCfg;
+  uint32_t gopLowdelay;
+  int32_t codecFormat; /* enable H264 encoding instead of HEVC */
+  int32_t interlacedFrame;
+  uint32_t longTermGap;
+  uint32_t longTermGapOffset;
+  uint32_t ltrInterval;
+  int32_t intraPicRate; /* IDR interval */
+  int32_t bFrameQpDelta;
+  uint32_t ctuPerCol;
+  uint32_t ctuPerRow;
+  uint32_t gopSize;
+  int32_t longTermQpDelta;
+  uint32_t pass;
+  int32_t gdrDuration;
+} commandLine_local_s;
+
+typedef struct {
+  VCEncIn video_in;
+  VCEncExtParaIn video_ext_in;
+  VCEncOut video_out;
+
+  VCEncConfig video_config;
+  VCEncRateCtrl video_rate_ctrl;
+  VCEncCodingCtrl video_coding_ctrl;
+  VCEncPreProcessingCfg video_prep;
+
+  uint8_t gopCfgOffset[MAX_GOP_SIZE + 1];
+  VCEncGopPicConfig gopPicCfg[MAX_GOP_PIC_CONFIG_NUM];
+  // VCEncGopPicConfig gopPicCfgPass2[MAX_GOP_PIC_CONFIG_NUM];
+  VCEncGopPicSpecialConfig gopPicSpecialCfg[MAX_GOP_SPIC_CONFIG_NUM];
+  commandLine_local_s cml;
+} h2_enc_params;
+
+#endif /*__VSI_ENC_VIDEO_H2_PRIV_H__*/
diff --git a/v4l2_vsi_daemon/src/vsi_main.c b/v4l2_vsi_daemon/src/vsi_main.c
new file mode 100755
index 0000000..01b62ed
--- /dev/null
+++ b/v4l2_vsi_daemon/src/vsi_main.c
@@ -0,0 +1,641 @@
+/****************************************************************************
+*
+*    Copyright 2019 - 2020 VeriSilicon Inc. All Rights Reserved.
+*
+*    Permission is hereby granted, free of charge, to any person obtaining
+*    a copy of this software and associated documentation files (the
+*    'Software'), to deal in the Software without restriction, including
+*    without limitation the rights to use, copy, modify, merge, publish,
+*    distribute, sub license, and/or sell copies of the Software, and to
+*    permit persons to whom the Software is furnished to do so, subject
+*    to the following conditions:
+*
+*    The above copyright notice and this permission notice (including the
+*    next paragraph) shall be included in all copies or substantial
+*    portions of the Software.
+*
+*    THE SOFTWARE IS PROVIDED 'AS IS', WITHOUT WARRANTY OF ANY KIND,
+*    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+*    MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT.
+*    IN NO EVENT SHALL VIVANTE AND/OR ITS SUPPLIERS BE LIABLE FOR ANY
+*    CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
+*    TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE
+*    SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
+*
+*****************************************************************************/
+
+/**
+ * @file vsi_main.c
+ * @brief V4L2 Daemon main file.
+ * @version 0.10- Initial version
+ */
+#include <fcntl.h>
+#include <pthread.h>
+#include <stddef.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <sys/ioctl.h>
+#include <sys/shm.h>
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <unistd.h>
+#include <errno.h>
+#include <signal.h>
+
+#include "daemon_instance.h"
+#include "hash_table.h"
+
+typedef struct zombie_inst{
+  v4l2_daemon_inst *pinst;
+  struct timespec starttime;
+  struct zombie_inst *next;
+} zombie_inst;
+
+FILE *vsidaemonstdlog = NULL;
+static HashTable ht;
+static pthread_t maintid;
+static jmp_buf mainsigbuf;
+static zombie_inst *hzinst = NULL;
+/**
+ * @brief Worker thread of the encoder/decoder, it parse the command that
+ received from V4L2 driver and
+          process the state of the encoder/decoder. When encoder/decoder errors
+ happens or ends without errors, thread will exit.
+          There may be several threads for muti-instance.
+ * @param[in] arg The thread parameters that passed by pthread_create.
+ * @return NULL point if the thread exits.
+ */
+void *worker_threads(void *arg);
+
+/**
+ * @brief Initial the instance_id and other member, the semphore, the
+ * bufferlist, the fifo instance and create the worker thread.
+ * @param[in] h point    The daemon instance that in the HashTable.
+ * @param[in] v4l2_msg point       The msg that received from the V4L2 driver.
+ * @return 0 means instance initial successfully, otherwise unsuccessfully.
+ */
+static int32_t inst_init(v4l2_daemon_inst *h, vsi_v4l2_msg *v4l2_msg);
+
+/**
+ * @brief Destory worker instance, set the members of the instance to invalid
+ * value, destroy the semphore, bufferlist, etc.
+ * @param[in] h    The daemon instance that in the HashTable.
+ * @return 0 means destroy successfully, otherwise unsuccessfully.
+ */
+int32_t inst_destroy(v4l2_daemon_inst *h);
+static void destroy_heap(struct object_heap *heap,
+                         void (*func)(struct object_heap *heap,
+                                      struct object_base *object));
+
+static void check_instance(v4l2_daemon_inst *cur_inst_p) {
+  if (cur_inst_p == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "check_instance: got NULL instance, it should be malloced.
");
+    ASSERT(0);
+  } else if (cur_inst_p->instance_id == 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR,
+               "check_instance: got 0 instance_id, it should not happend.
");
+    ASSERT(0);
+  }
+}
+
+static void signalhandler(int signo) {
+  v4l2_daemon_inst *inst_p;
+  pthread_t tid = pthread_self();
+  HANTRO_LOG(HANTRO_LEVEL_ERROR, "%s : sig: %d(%s), thread: %lX 
",
+             __FUNCTION__, signo, strsignal(signo), pthread_self());
+
+  if ((inst_p = hash_table_find_bytid(&ht, tid)) != NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "%s: catch exception for ctx %lx !!!!!
",
+               __FUNCTION__, inst_p->instance_id);
+    if (inst_p->flag & (1 << INST_CATCH_EXCEPTION)) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "%s: repeatedly catch exception for ctx %lx !!!!!",
+        __FUNCTION__, inst_p->instance_id);
+      inst_p->flag |= (1 << INST_FATAL_ERROR);
+    } else
+      siglongjmp(inst_p->sigbuf, 1);
+  } else if (tid == maintid) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "%s: catch exception for main!!!!!
",
+               __FUNCTION__);
+    siglongjmp(mainsigbuf, 1);
+  } else {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "%s: unexpected thread id !!!!!
",
+               __FUNCTION__);
+    siglongjmp(mainsigbuf, 1);
+  }
+
+  return;
+}
+
+static int register_sighandler(void) {
+  int i;
+  static const int siglist[] = {
+      SIGHUP, SIGINT,  SIGILL,  SIGABRT, SIGBUS,
+      SIGFPE, SIGSEGV, SIGTERM, SIGTSTP, SIGTTIN,
+  };
+  for (i = 0; i < sizeof(siglist) / sizeof(siglist[0]); i++) {
+    if (signal(siglist[i], signalhandler) == SIG_ERR) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR, "fail to register signal %d.
",
+                 siglist[i]);
+      return -1;
+    }
+  }
+  return 0;
+}
+
+static int get_codec_info(struct vsi_v4l2_dev_info *hwinfo) {
+#ifdef HAS_VSI_ENC
+  if (vsi_enc_get_codec_format(hwinfo) == -1) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "No valid encoder.
");
+    hwinfo->encformat = 0;
+  }
+#endif
+  if (vsi_dec_get_codec_format(hwinfo) == -1) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "No valid decoder.
");
+    hwinfo->decformat = 0;
+  }
+
+  return 0;
+}
+
+static int add_zombieinst(v4l2_daemon_inst *pinst, struct timespec *pstarttime)
+{
+    zombie_inst *pz = malloc(sizeof(zombie_inst));
+
+    if (!pz)
+        return -1;
+    pz->next = NULL;
+    pz->pinst = pinst;
+    pz->starttime = *pstarttime;    
+    if (hzinst == NULL)
+        hzinst = pz;
+    else {
+        pz->next = hzinst->next;
+        hzinst->next = pz;
+    }
+    return 0;
+}
+
+static int zombie_timeout(struct timespec *before)
+{
+    struct timespec after;
+    int64_t elapse;
+
+    clock_gettime(CLOCK_REALTIME, &after);
+    elapse = ((int64_t)after.tv_sec - (int64_t)before->tv_sec) * (int64_t)1000000000
+         + ((int64_t)after.tv_nsec - (int64_t)before->tv_nsec);
+    return (elapse >= (int64_t)1000000000); //over 1 sec
+}
+
+static void check_zombieinst(void)
+{
+    zombie_inst *pz = hzinst, *pn, *prev = NULL;
+    int ret, done;
+
+    while (pz) {
+        done = 0;
+        pn = pz->next;        
+        ret = sem_trywait(&pz->pinst->sem_done);
+        if (ret == 0)
+            done = 1;
+        else if (zombie_timeout(&pz->starttime)) {
+            kill(pz->pinst->tid, SIGKILL);
+            done = 1;
+        }
+        if (done) {
+            HANTRO_LOG(HANTRO_LEVEL_WARNING, "release zombie inst %lx with %d
", pz->pinst->instance_id, ret);
+            inst_destroy(pz->pinst);        
+            free(pz->pinst);
+            free(pz);
+            if (prev == NULL)
+                hzinst = pz = pn;
+            else
+                prev->next = pz = pn;
+        } else {
+            prev = pz;
+            pz = pn;
+        }
+    }
+}
+
+static void removeall_zombieinst(void)
+{
+    zombie_inst *pz = hzinst, *pn;
+    while (pz) {
+        pn = pz->next;
+        HANTRO_LOG(HANTRO_LEVEL_WARNING, "release zombie inst %lx in tail
", pz->pinst->instance_id);
+        kill(pz->pinst->tid, SIGKILL);
+        if (!(pz->pinst->flag & (1 << INST_FATAL_ERROR)))
+            inst_destroy(pz->pinst);
+        free(pz->pinst);
+        free(pz);
+        pz = pn;
+    }
+    hzinst = NULL;
+}
+
+/**
+ * @brief Main thread.
+ * @return an int value.
+ * @note The log file will be generated if macro LOG_OUTPUT is defined, by
+ default this is not be defined.
+         One device named /dev/v4l2 is used for communication between daemon and
+ V4L2 driver, another device named /dev/mem is used for mmap,
+         before workers begin to work, these should be opened. The global
+ variables named pipe_fd and mmap_fd are the handles, respectively.
+         In order to support mult-instance and increase efficiency, a hash table
+ is introduced. The structure of the daemon instance is
+         a member of the hash table structure HashTable. Note that the maximum
+ instances is defined by MAX_STREAMS, which is 10, and this can
+         be increased or decreased. If a valid instance id(not 0) is received,
+ it will look up the instance id in the hash table, if found,
+         this is not a new instance id, it has been created already, if not
+ found, this may be a new instance id, it will insert this new instance
+         id to the hash table and initial this new instance, a new worker is
+ created. Note that the valid instance id value is from 1 to MAX_STREAMS.
+         After a valid instance id is received, it will get the pointer of the
+ daemon instance. Then send the command to the worker. If the command
+         it that received from V4L2 is stream off or command stop, the main
+ thread will wait for the semphore that the worker post and destroy the
+         daemon instance. Note that the main thead of daemon never returns.
+ */
+int32_t main(int32_t argc, char **argv) {
+#if 0
+    //deamon process flow.
+    pid_t pc;
+    pc = fork();
+    if(pc < 0 )
+    {
+        printf("error fork.
");
+        exit(1);
+    }
+    else if(pc > 0)
+    {
+        exit(1);//exit parent process.
+    }
+    /*else if(pc == 0)
+    {
+        setsid(); // escape control.
+        chdir("/");
+        umask(0);
+        for(int32_t i = 0; i <= getdtablesize(); i++)
+        {
+            close(i);
+        }
+    }*/
+#endif
+  int ret;
+  int seterrhdl = 1;
+  struct timespec semtime;
+
+  open_log("./v4l2_daemon.log");
+  output_log(LOG_DEBUG, 0, "This is v4l2 daemon log file");
+  char *level = NULL;
+  char *daemon_logpath;
+  level = getenv("HANTRO_LOG_LEVEL");
+  if (NULL != level) {
+    hantro_log_level = atoi(level);
+  }
+  if (0 == hantro_log_level) {
+    hantro_log_level = 3;
+  }
+  daemon_logpath = getenv("DAEMON_LOGPATH");
+  if (daemon_logpath != NULL)
+    vsidaemonstdlog = freopen(daemon_logpath, "w", stdout);
+
+  vsi_v4l2_cmd vsi_v4l2_cmd_p;
+  int32_t v4l2_msg_size = sizeof(vsi_v4l2_msg);
+  struct vsi_v4l2_dev_info hwinfo = {0};
+  get_codec_info(&hwinfo);
+
+  v4l2_daemon_inst *cur_inst_p;
+  hash_table_init(&ht);
+  maintid = pthread_self();
+  HANTRO_LOG(HANTRO_LEVEL_INFO, "main thread id = %lx
", maintid);
+  ret = register_sighandler();
+  if (ret < 0) return -1;
+
+  pipe_fd = open_v4l2_device();
+  mmap_fd = pipe_fd;
+  // need to inform kernel driver hw config here
+  ioctl(pipe_fd, VSI_IOCTL_CMD_INITDEV, &hwinfo);
+
+  while (1) {
+    ret = 0;
+    if (seterrhdl) {
+      ret = sigsetjmp(mainsigbuf, 1);
+      seterrhdl = 0;
+      if (ret) {
+        HANTRO_LOG(HANTRO_LEVEL_ERROR, "sigsetjmp failed, error %d.
", ret);
+        break;
+      }
+    }
+
+    check_zombieinst();
+    /*  get message.  */
+    ret = receive_from_v4l2(pipe_fd, &vsi_v4l2_cmd_p.msg, v4l2_msg_size);
+    if (ret <= 0) {
+      if (ret == -EBADF) goto exit;
+      continue;
+    }
+
+    if (vsi_v4l2_cmd_p.msg.inst_id != 0) {
+      /* get a valid command */
+      /* find instance accordingly. */
+      if (hash_table_find(&ht, vsi_v4l2_cmd_p.msg.inst_id, &cur_inst_p) != 0) {
+        /* not find, maybe a new inst */
+        if (hash_table_insert(&ht, vsi_v4l2_cmd_p.msg.inst_id) != 0) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                     "instance not found, but insert unsuccessful.
");
+          ASSERT(0);  // insert unsuccessful.
+        }
+
+        /* create instance */
+        if (hash_table_find(&ht, vsi_v4l2_cmd_p.msg.inst_id, &cur_inst_p) != 0) {
+          HANTRO_LOG(HANTRO_LEVEL_ERROR, "instance not found after create.
");
+          ASSERT(0);
+        }
+        if (inst_init(cur_inst_p, &vsi_v4l2_cmd_p.msg) < 0) {
+          hash_table_remove(&ht, vsi_v4l2_cmd_p.msg.inst_id, 1);
+          vsi_v4l2_cmd_p.msg.size = 0;
+          send_ack_to_v4l2(pipe_fd, &vsi_v4l2_cmd_p.msg,
+                           sizeof(struct vsi_v4l2_msg_hdr));  // ack an ok;
+          send_fatalerror_orphan_msg(vsi_v4l2_cmd_p.msg.inst_id, DAEMON_ERR_INST_CREATE);
+          continue;
+        }
+      }
+
+      check_instance(cur_inst_p);
+
+      /*  send command to worker. */
+      if (cur_inst_p->flag & (1 << INST_FATAL_ERROR)) {
+        if (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_STREAMOFF
+          || vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_DESTROY_DEC
+          || vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_EXIT) {
+          kill(cur_inst_p->tid, SIGKILL);
+          //inst_destroy is not reliable in this condition
+          hash_table_remove(&ht, vsi_v4l2_cmd_p.msg.inst_id, 1);
+        }
+        vsi_v4l2_cmd_p.msg.size = 0;
+        vsi_v4l2_cmd_p.msg.error = DAEMON_ERR_DEC_FATAL_ERROR;
+        send_ack_to_v4l2(pipe_fd, &vsi_v4l2_cmd_p.msg, sizeof(struct vsi_v4l2_msg_hdr));
+        if (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_EXIT)
+          goto exit;
+      } else {
+        send_cmd_to_worker(cur_inst_p, &vsi_v4l2_cmd_p.msg);
+
+        /* if get STREAMOFF, wait worker's semphore, and destory inst.*/
+        if ((vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_STREAMOFF)
+            //                || (vsi_v4l2_cmd_p.msg.cmd_id ==
+            //                V4L2_DAEMON_VIDIOC_STREAMOFF_CAPTURE)
+            || (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_DESTROY_DEC) ||
+            (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_EXIT)) {
+          if ((cur_inst_p->func.in_source_change == NULL) ||
+              cur_inst_p->func.in_source_change(cur_inst_p->codec) == 0) {
+            clock_gettime(CLOCK_REALTIME, &semtime);
+            semtime.tv_nsec += 50000000;	//20ms should be enough for normal exit
+            ret = sem_timedwait(&cur_inst_p->sem_done, &semtime);
+            if (ret != 0) {
+                HANTRO_LOG(HANTRO_LEVEL_WARNING, "wait %lx exit timeout
", cur_inst_p->instance_id);
+                if (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_EXIT) {
+                  kill(cur_inst_p->tid, SIGKILL);
+                  inst_destroy(cur_inst_p);
+                  hash_table_remove(&ht, vsi_v4l2_cmd_p.msg.inst_id, 1);
+                } else {
+                  hash_table_remove(&ht, vsi_v4l2_cmd_p.msg.inst_id, 0); //make it zombie
+                  if (add_zombieinst(cur_inst_p, &semtime)) {
+                      inst_destroy(cur_inst_p);
+                      free(cur_inst_p);
+                  }
+                }
+            } else {
+              inst_destroy(cur_inst_p);
+              hash_table_remove(&ht, vsi_v4l2_cmd_p.msg.inst_id, 1);
+            }
+            if (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_EXIT) {
+              goto exit;
+            }
+          }
+        }
+      }
+    } else if (vsi_v4l2_cmd_p.msg.cmd_id == V4L2_DAEMON_VIDIOC_EXIT) {
+      vsi_v4l2_cmd_p.msg.size = 0;
+      // send_ack_to_v4l2(pipe_fd, &vsi_v4l2_cmd_p.msg, sizeof(struct
+      // vsi_v4l2_msg_hdr));//ack an ok;
+      goto exit;
+    }
+
+    vsi_v4l2_cmd_p.msg.inst_id = 0;  // make sure this value is read from pipe.
+  }
+exit:
+  removeall_zombieinst();
+  if (vsidaemonstdlog) fclose(vsidaemonstdlog);
+  return 0;
+}
+
+void *worker_threads(void *arg) {
+  int ret = 0;
+  v4l2_daemon_inst *h = (v4l2_daemon_inst *)arg;
+  vsi_v4l2_cmd *v4l2_cmd = NULL;
+  unsigned long inst_id = NO_RESPONSE_SEQID;
+  int32_t proc_result = 0;
+
+  ret = sigsetjmp(h->sigbuf, 1);
+  if (ret != 0) {
+    // send error msg to driver
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, " %lx catch exception 
", inst_id);
+    if (h->instance_id != NO_RESPONSE_SEQID) {
+      send_fatalerror_orphan_msg(h->instance_id, DAEMON_ERR_SIGNAL_CONFIG);
+    }
+    h->flag |= (1 << INST_CATCH_EXCEPTION);
+    goto label_worker_done;
+  }
+
+  /*loop machine*/
+  do {
+    /* fetch new msg */
+    FifoPop(h->fifo_inst, (FifoObject *)&v4l2_cmd, FIFO_EXCEPTION_DISABLE);
+    if (inst_id == NO_RESPONSE_SEQID) {
+      inst_id = v4l2_cmd->msg.inst_id;
+    } else if (inst_id != v4l2_cmd->msg.inst_id) {
+      HANTRO_LOG(HANTRO_LEVEL_ERROR,
+                 "cmd and thread seqid mismatch 0x%lx-0x%lx.
",
+                 v4l2_cmd->msg.inst_id, inst_id);
+    }
+    h->pop_cnt++;
+    HANTRO_LOG(HANTRO_LEVEL_LOG,
+               "worker_threads inst[%ld]: codec_fmt %d, cmd id %d
",
+               h->instance_id, v4l2_cmd->msg.codec_fmt, v4l2_cmd->msg.cmd_id);
+
+    /* process msg */
+    proc_result = 0;
+    if (h->func.proc) {
+      proc_result = h->func.proc(h->codec, &v4l2_cmd->msg);
+    }
+
+    object_heap_free(&h->cmds, (object_base_p)v4l2_cmd);
+
+    if (proc_result) {
+      HANTRO_LOG(HANTRO_LEVEL_DEBUG, "Instance [%ld] codec finished all jobs
",
+                 h->instance_id);
+      break;
+    }
+
+  } while (1);
+
+label_worker_done:
+  sem_post(&h->sem_done);
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "worker_threads finish, instance id %lx
",
+             h->instance_id);
+
+  return NULL;
+}
+
+static void inst_set_format(v4l2_daemon_inst *h) {
+  switch (h->codec_fmt) {
+#ifdef HAS_VSI_ENC
+    case V4L2_DAEMON_CODEC_ENC_HEVC:
+    case V4L2_DAEMON_CODEC_ENC_H264:
+    case V4L2_DAEMON_CODEC_ENC_AV1:
+    case V4L2_DAEMON_CODEC_ENC_VP8:
+    case V4L2_DAEMON_CODEC_ENC_VP9:
+    case V4L2_DAEMON_CODEC_ENC_MPEG2:
+    case V4L2_DAEMON_CODEC_ENC_JPEG:
+      h->codec_mode = DAEMON_MODE_ENCODER;
+      h->func.create = vsi_create_encoder;
+      break;
+#endif
+
+    case V4L2_DAEMON_CODEC_DEC_HEVC:
+    case V4L2_DAEMON_CODEC_DEC_H264:
+    case V4L2_DAEMON_CODEC_DEC_JPEG:
+    case V4L2_DAEMON_CODEC_DEC_VP9:
+    case V4L2_DAEMON_CODEC_DEC_MPEG2:
+    case V4L2_DAEMON_CODEC_DEC_MPEG4:
+    case V4L2_DAEMON_CODEC_DEC_VP8:
+    case V4L2_DAEMON_CODEC_DEC_H263:
+    case V4L2_DAEMON_CODEC_DEC_VC1_G:
+    case V4L2_DAEMON_CODEC_DEC_VC1_L:
+    case V4L2_DAEMON_CODEC_DEC_RV:
+    case V4L2_DAEMON_CODEC_DEC_AVS2:
+    case V4L2_DAEMON_CODEC_DEC_XVID:
+      h->codec_mode = DAEMON_MODE_DECODER;
+      h->func.create = vsi_create_decoder;
+      break;
+
+    case V4L2_DAEMON_CODEC_UNKNOW_TYPE:
+    default:
+      h->codec_mode = DAEMON_MODE_UNKNOWN;
+      h->func.create = NULL;
+      ASSERT(0);
+      break;
+  }
+}
+
+static int32_t inst_init(v4l2_daemon_inst *h, vsi_v4l2_msg *v4l2_msg) {
+  int ret = 0;
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "inst_init begin
");
+  ASSERT(h != NULL);
+  memset(h, 0, sizeof(v4l2_daemon_inst));
+
+  h->tid = 0;
+  h->pop_cnt = 0;
+  h->instance_id = v4l2_msg->inst_id;
+  h->sequence_id = v4l2_msg->seq_id;
+  h->codec_fmt = v4l2_msg->codec_fmt;
+
+  inst_set_format(h);
+  if (h->func.create == NULL) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "Unknown codec format.
");
+    return -1;
+  }
+
+  if (object_heap_init(&(h->cmds), sizeof(vsi_v4l2_cmd),
+                       ENC_HEVC_H264_ID_OFFSET)) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "object_heap_init error.
");
+    return -1;
+  }
+
+  sem_init(&h->sem_done, 0, 0);
+  FifoInit(MAX_FIFO_CAPACITY, &h->fifo_inst);
+
+  h->codec = h->func.create(h);
+
+  ret = pthread_attr_init(&h->attr);
+  if (ret != 0) {
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "pthread_attr_init fail, ret=%d
", ret);
+    ret = -1;
+    goto errout;
+  }
+
+  ret = pthread_create(&h->tid, &h->attr, &worker_threads, h);
+  if (ret != 0) {
+    pthread_attr_destroy(&h->attr);
+    HANTRO_LOG(HANTRO_LEVEL_ERROR, "pthread_create fail, ret=%d
", ret);
+    ret = -1;
+    goto errout;
+  }
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "inst_init %lx end
", h->tid);
+  return 0;
+
+errout:
+  if (h->codec) h->func.destroy(h->codec);
+
+  if (h->fifo_inst != NULL) FifoRelease(h->fifo_inst);
+  destroy_heap(&(h->cmds), object_heap_free);
+  sem_destroy(&h->sem_done);
+  return ret;
+}
+
+static void destroy_heap(struct object_heap *heap,
+                         void (*func)(struct object_heap *heap,
+                                      struct object_base *object)) {
+  struct object_base *object;
+  object_heap_iterator iter;
+
+  object = object_heap_first(heap, &iter);
+
+  while (object) {
+    if (func) func(heap, object);
+
+    object = object_heap_next(heap, &iter);
+  }
+
+  object_heap_destroy(heap);
+}
+
+int inst_destroy(v4l2_daemon_inst *h) {
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "inst_destroy begin
");
+
+  if (h->tid != 0) {
+    pthread_join(h->tid, NULL);
+    pthread_attr_destroy(&h->attr);
+  } else {
+    HANTRO_LOG(HANTRO_LEVEL_DEBUG, "h->tid is %d 
", (uint32_t)h->tid);
+  }
+
+  /* codec destroy */
+  if (h->codec) {
+    if (!(h->flag & (1 << INST_CATCH_EXCEPTION)))
+      h->func.destroy(h->codec);
+    else
+      HANTRO_LOG(HANTRO_LEVEL_WARNING, "inst %lx exit itself before destroy. 
", h->instance_id);
+    free(h->codec);
+    h->codec = NULL;
+  }
+
+  sem_destroy(&h->sem_done);
+
+  if (h->fifo_inst != NULL) {
+    FifoRelease(h->fifo_inst);
+  } else {
+    HANTRO_LOG(HANTRO_LEVEL_DEBUG, "h->fifo_inst is NULL. 
");
+  }
+
+  // object_heap_destroy(&(h->cmds));
+  destroy_heap(&(h->cmds), object_heap_free);
+  memset(h, 0, sizeof(v4l2_daemon_inst));
+  HANTRO_LOG(HANTRO_LEVEL_DEBUG, "inst_destroy finish
");
+  return 0;
+}
