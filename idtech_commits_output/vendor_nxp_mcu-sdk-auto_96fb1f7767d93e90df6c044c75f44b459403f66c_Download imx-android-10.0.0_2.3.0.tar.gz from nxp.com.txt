96fb1f7 jenkins 2020-07-17

Download imx-android-10.0.0_2.3.0.tar.gz from nxp.com

Change-Id: I1e6d84e626ef8f76d89145a17ca7e4133d930274

diff --git a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_Flash.h b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_Flash.h
index 287add1..7053be2 100644
--- a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_Flash.h
+++ b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_Flash.h
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2013-2017 ARM Limited. All rights reserved.
+ * Copyright (c) 2013-2018 ARM Limited. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -15,13 +15,15 @@
  * See the License for the specific language governing permissions and
  * limitations under the License.
  *
- * $Date:        2. Feb 2017
- * $Revision:    V2.1
+ * $Date:        19. Apr 2018
+ * $Revision:    V2.2
  *
  * Project:      Flash Driver definitions
  */
 
 /* History:
+ *  Version 2.2
+ *    Padding bytes added to ARM_FLASH_INFO
  *  Version 2.1
  *    ARM_FLASH_STATUS made volatile
  *  Version 2.0
@@ -47,7 +49,7 @@ extern "C"
 
 #include "Driver_Common.h"
 
-#define ARM_FLASH_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,1)  /* API version */
+#define ARM_FLASH_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(2,2)  /* API version */
 
 
 #define _ARM_Driver_Flash_(n)      Driver_Flash##n
@@ -74,6 +76,7 @@ typedef struct _ARM_FLASH_INFO {
   uint32_t          page_size;          ///< Optimal programming page size in bytes
   uint32_t          program_unit;       ///< Smallest programmable unit in bytes
   uint8_t           erased_value;       ///< Contents of erased memory (usually 0xFF)
+  uint8_t           reserved[3];        ///< Reserved (must be zero)
 } const ARM_FLASH_INFO;
 
 
diff --git a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_I2C.h b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_I2C.h
index c883472..b9ba9d0 100644
--- a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_I2C.h
+++ b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_I2C.h
@@ -100,10 +100,10 @@ typedef volatile struct _ARM_I2C_STATUS {
 /****** I2C Event *****/
 #define ARM_I2C_EVENT_TRANSFER_DONE       (1UL << 0)  ///< Master/Slave Transmit/Receive finished
 #define ARM_I2C_EVENT_TRANSFER_INCOMPLETE (1UL << 1)  ///< Master/Slave Transmit/Receive incomplete transfer
-#define ARM_I2C_EVENT_SLAVE_TRANSMIT      (1UL << 2)  ///< Slave Transmit operation requested
-#define ARM_I2C_EVENT_SLAVE_RECEIVE       (1UL << 3)  ///< Slave Receive operation requested
+#define ARM_I2C_EVENT_SLAVE_TRANSMIT      (1UL << 2)  ///< Addressed as Slave Transmitter but transmit operation is not set.
+#define ARM_I2C_EVENT_SLAVE_RECEIVE       (1UL << 3)  ///< Addressed as Slave Receiver but receive operation is not set.
 #define ARM_I2C_EVENT_ADDRESS_NACK        (1UL << 4)  ///< Address not acknowledged from Slave
-#define ARM_I2C_EVENT_GENERAL_CALL        (1UL << 5)  ///< General Call indication
+#define ARM_I2C_EVENT_GENERAL_CALL        (1UL << 5)  ///< Slave addressed with general call address
 #define ARM_I2C_EVENT_ARBITRATION_LOST    (1UL << 6)  ///< Master lost arbitration
 #define ARM_I2C_EVENT_BUS_ERROR           (1UL << 7)  ///< Bus error detected (START/STOP at illegal position)
 #define ARM_I2C_EVENT_BUS_CLEAR           (1UL << 8)  ///< Bus clear finished
diff --git a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_SAI.h b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_SAI.h
index 56e11af..bff3b95 100644
--- a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_SAI.h
+++ b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_SAI.h
@@ -93,7 +93,7 @@ extern "C"
 /*----- SAI Control Codes:Configuration Parameters: Companding -----*/
 #define ARM_SAI_COMPANDING_Pos           20
 #define ARM_SAI_COMPANDING_Msk          (3U << ARM_SAI_COMPANDING_Pos)
-#define ARM_SAI_COMPANDING_NONE         (0U << ARM_SAI_COMPANDING_Pos)          ///< No compading (default)
+#define ARM_SAI_COMPANDING_NONE         (0U << ARM_SAI_COMPANDING_Pos)          ///< No companding (default)
 #define ARM_SAI_COMPANDING_A_LAW        (2U << ARM_SAI_COMPANDING_Pos)          ///< A-Law companding
 #define ARM_SAI_COMPANDING_U_LAW        (3U << ARM_SAI_COMPANDING_Pos)          ///< u-Law companding
 
diff --git a/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_WiFi.h b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_WiFi.h
new file mode 100644
index 0000000..69a5013
--- /dev/null
+++ b/SDK_MEK-MIMX8QM/CMSIS/Driver/Include/Driver_WiFi.h
@@ -0,0 +1,659 @@
+/*
+ * Copyright (c) 2019 Arm Limited. All rights reserved.
+ *
+ * SPDX-License-Identifier: Apache-2.0
+ *
+ * Licensed under the Apache License, Version 2.0 (the License); you may
+ * not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an AS IS BASIS, WITHOUT
+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * $Date:        31. May 2019
+ * $Revision:    V1.0
+ *
+ * Project:      WiFi (Wireless Fidelity Interface) Driver definitions
+ */
+
+/* History:
+ *  Version 1.0
+ *    Initial release
+ */
+
+#ifndef DRIVER_WIFI_H_
+#define DRIVER_WIFI_H_
+
+#ifdef  __cplusplus
+extern "C"
+{
+#endif
+
+#include "Driver_Common.h"
+
+#define ARM_WIFI_API_VERSION ARM_DRIVER_VERSION_MAJOR_MINOR(1,0)  /* API version */
+
+#define _ARM_Driver_WiFi_(n)      Driver_WiFi##n
+#define  ARM_Driver_WiFi_(n) _ARM_Driver_WiFi_(n)
+
+
+/****** WiFi SetOption/GetOption Function Option Codes *****/
+#define ARM_WIFI_BSSID                      1U          ///< Station/AP Set/Get BSSID of AP to connect or of AP;        data = &bssid,    len =  6, uint8_t[6]
+#define ARM_WIFI_TX_POWER                   2U          ///< Station/AP Set/Get transmit power;                         data = &power,    len =  4, uint32_t: 0 .. 20 [dBm]
+#define ARM_WIFI_LP_TIMER                   3U          ///< Station    Set/Get low-power deep-sleep time;              data = &time,     len =  4, uint32_t [seconds]: 0 = disable (default)
+#define ARM_WIFI_DTIM                       4U          ///< Station/AP Set/Get DTIM interval;                          data = &dtim,     len =  4, uint32_t [beacons]
+#define ARM_WIFI_BEACON                     5U          ///<         AP Set/Get beacon interval;                        data = &interval, len =  4, uint32_t [ms]
+#define ARM_WIFI_MAC                        6U          ///< Station/AP Set/Get MAC;                                    data = &mac,      len =  6, uint8_t[6]
+#define ARM_WIFI_IP                         7U          ///< Station/AP Set/Get IPv4 static/assigned address;           data = &ip,       len =  4, uint8_t[4]
+#define ARM_WIFI_IP_SUBNET_MASK             8U          ///< Station/AP Set/Get IPv4 subnet mask;                       data = &mask,     len =  4, uint8_t[4]
+#define ARM_WIFI_IP_GATEWAY                 9U          ///< Station/AP Set/Get IPv4 gateway address;                   data = &ip,       len =  4, uint8_t[4]
+#define ARM_WIFI_IP_DNS1                    10U         ///< Station/AP Set/Get IPv4 primary   DNS address;             data = &ip,       len =  4, uint8_t[4]
+#define ARM_WIFI_IP_DNS2                    11U         ///< Station/AP Set/Get IPv4 secondary DNS address;             data = &ip,       len =  4, uint8_t[4]
+#define ARM_WIFI_IP_DHCP                    12U         ///< Station/AP Set/Get IPv4 DHCP client/server enable/disable; data = &dhcp,     len =  4, uint32_t: 0 = disable, non-zero = enable (default)
+#define ARM_WIFI_IP_DHCP_POOL_BEGIN         13U         ///<         AP Set/Get IPv4 DHCP pool begin address;           data = &ip,       len =  4, uint8_t[4]
+#define ARM_WIFI_IP_DHCP_POOL_END           14U         ///<         AP Set/Get IPv4 DHCP pool end address;             data = &ip,       len =  4, uint8_t[4]
+#define ARM_WIFI_IP_DHCP_LEASE_TIME         15U         ///<         AP Set/Get IPv4 DHCP lease time;                   data = &time,     len =  4, uint32_t [seconds]
+#define ARM_WIFI_IP6_GLOBAL                 16U         ///< Station/AP Set/Get IPv6 global address;                    data = &ip6,      len = 16, uint8_t[16]
+#define ARM_WIFI_IP6_LINK_LOCAL             17U         ///< Station/AP Set/Get IPv6 link local address;                data = &ip6,      len = 16, uint8_t[16]
+#define ARM_WIFI_IP6_SUBNET_PREFIX_LEN      18U         ///< Station/AP Set/Get IPv6 subnet prefix length;              data = &len,      len =  4, uint32_t: 1 .. 127
+#define ARM_WIFI_IP6_GATEWAY                19U         ///< Station/AP Set/Get IPv6 gateway address;                   data = &ip6,      len = 16, uint8_t[16]
+#define ARM_WIFI_IP6_DNS1                   20U         ///< Station/AP Set/Get IPv6 primary   DNS address;             data = &ip6,      len = 16, uint8_t[16]
+#define ARM_WIFI_IP6_DNS2                   21U         ///< Station/AP Set/Get IPv6 secondary DNS address;             data = &ip6,      len = 16, uint8_t[16]
+#define ARM_WIFI_IP6_DHCP_MODE              22U         ///< Station/AP Set/Get IPv6 DHCPv6 client mode;                data = &mode,     len =  4, uint32_t: ARM_WIFI_IP6_DHCP_xxx (default Off)
+
+/****** WiFi Security Type *****/
+#define ARM_WIFI_SECURITY_OPEN              0U          ///< Open
+#define ARM_WIFI_SECURITY_WEP               1U          ///< Wired Equivalent Privacy (WEP) with Pre-Sheared Key (PSK)
+#define ARM_WIFI_SECURITY_WPA               2U          ///< WiFi Protected Access (WPA) with PSK
+#define ARM_WIFI_SECURITY_WPA2              3U          ///< WiFi Protected Access II (WPA2) with PSK
+#define ARM_WIFI_SECURITY_UNKNOWN           255U        ///< Unknown
+
+/****** WiFi Protected Setup (WPS) Method *****/
+#define ARM_WIFI_WPS_METHOD_NONE            0U          ///< Not used
+#define ARM_WIFI_WPS_METHOD_PBC             1U          ///< Push Button Configuration
+#define ARM_WIFI_WPS_METHOD_PIN             2U          ///< PIN
+
+/****** WiFi IPv6 Dynamic Host Configuration Protocol (DHCP) Mode *****/
+#define ARM_WIFI_IP6_DHCP_OFF               0U          ///< Static Host Configuration (default)
+#define ARM_WIFI_IP6_DHCP_STATELESS         1U          ///< Dynamic Host Configuration stateless DHCPv6
+#define ARM_WIFI_IP6_DHCP_STATEFULL         2U          ///< Dynamic Host Configuration statefull DHCPv6
+
+/****** WiFi Event *****/
+#define ARM_WIFI_EVENT_AP_CONNECT          (1UL << 0)   ///< Access Point: Station has connected;           arg = &mac, mac (uint8_t[6])
+#define ARM_WIFI_EVENT_AP_DISCONNECT       (1UL << 1)   ///< Access Point: Station has disconnected;        arg = &mac, mac (uint8_t[6])
+#define ARM_WIFI_EVENT_ETH_RX_FRAME        (1UL << 4)   ///< Ethernet Frame Received (in bypass mode only); arg = interface (0 = Station, 1 = Access Point)
+
+
+/**
+rief WiFi Configuration
+*/
+typedef struct {
+  const char   *ssid;                                   ///< Pointer to Service Set Identifier (SSID) null-terminated string
+  const char   *pass;                                   ///< Pointer to Password null-terminated string
+        uint8_t security;                               ///< Security type (ARM_WIFI_SECURITY_xxx)
+        uint8_t ch;                                     ///< WiFi Channel (0 = auto, otherwise = exact channel)
+        uint8_t reserved;                               ///< Reserved
+        uint8_t wps_method;                             ///< WiFi Protected Setup (WPS) method (ARM_WIFI_WPS_METHOD_xxx)
+  const char   *wps_pin;                                ///< Pointer to WiFi Protected Setup (WPS) PIN null-terminated string
+} ARM_WIFI_CONFIG_t;
+
+/**
+rief WiFi Scan Information
+*/
+typedef struct {
+  char    ssid[32+1];                                   ///< Service Set Identifier (SSID) null-terminated string
+  uint8_t bssid[6];                                     ///< Basic Service Set Identifier (BSSID)
+  uint8_t security;                                     ///< Security type (ARM_WIFI_SECURITY_xxx)
+  uint8_t ch;                                           ///< WiFi Channel
+  uint8_t rssi;                                         ///< Received Signal Strength Indicator
+} ARM_WIFI_SCAN_INFO_t;
+
+/**
+rief WiFi Network Information
+*/
+typedef struct {
+  char    ssid[32+1];                                   ///< Service Set Identifier (SSID) null-terminated string
+  char    pass[64+1];                                   ///< Password null-terminated string
+  uint8_t security;                                     ///< Security type (ARM_WIFI_SECURITY_xxx)
+  uint8_t ch;                                           ///< WiFi Channel
+  uint8_t rssi;                                         ///< Received Signal Strength Indicator
+} ARM_WIFI_NET_INFO_t;
+
+/****** Socket Address Family definitions *****/
+#define ARM_SOCKET_AF_INET                  1           ///< IPv4
+#define ARM_SOCKET_AF_INET6                 2           ///< IPv6
+
+/****** Socket Type definitions *****/
+#define ARM_SOCKET_SOCK_STREAM              1           ///< Stream socket
+#define ARM_SOCKET_SOCK_DGRAM               2           ///< Datagram socket
+
+/****** Socket Protocol definitions *****/
+#define ARM_SOCKET_IPPROTO_TCP              1           ///< TCP
+#define ARM_SOCKET_IPPROTO_UDP              2           ///< UDP
+
+/****** Socket Option definitions *****/
+#define ARM_SOCKET_IO_FIONBIO               1           ///< Non-blocking I/O (Set only, default = 0); opt_val = &nbio, opt_len = sizeof(nbio), nbio (integer): 0=blocking, non-blocking otherwise
+#define ARM_SOCKET_SO_RCVTIMEO              2           ///< Receive timeout in ms (default = 0); opt_val = &timeout, opt_len = sizeof(timeout)
+#define ARM_SOCKET_SO_SNDTIMEO              3           ///< Send timeout in ms (default = 0); opt_val = &timeout, opt_len = sizeof(timeout)
+#define ARM_SOCKET_SO_KEEPALIVE             4           ///< Keep-alive messages (default = 0); opt_val = &keepalive, opt_len = sizeof(keepalive), keepalive (integer): 0=disabled, enabled otherwise
+#define ARM_SOCKET_SO_TYPE                  5           ///< Socket Type (Get only); opt_val = &socket_type, opt_len = sizeof(socket_type), socket_type (integer): ARM_SOCKET_SOCK_xxx
+
+/****** Socket Function return codes *****/
+#define ARM_SOCKET_ERROR                   (-1)         ///< Unspecified error
+#define ARM_SOCKET_ESOCK                   (-2)         ///< Invalid socket
+#define ARM_SOCKET_EINVAL                  (-3)         ///< Invalid argument
+#define ARM_SOCKET_ENOTSUP                 (-4)         ///< Operation not supported
+#define ARM_SOCKET_ENOMEM                  (-5)         ///< Not enough memory
+#define ARM_SOCKET_EAGAIN                  (-6)         ///< Operation would block or timed out
+#define ARM_SOCKET_EINPROGRESS             (-7)         ///< Operation in progress
+#define ARM_SOCKET_ETIMEDOUT               (-8)         ///< Operation timed out
+#define ARM_SOCKET_EISCONN                 (-9)         ///< Socket is connected
+#define ARM_SOCKET_ENOTCONN                (-10)        ///< Socket is not connected
+#define ARM_SOCKET_ECONNREFUSED            (-11)        ///< Connection rejected by the peer
+#define ARM_SOCKET_ECONNRESET              (-12)        ///< Connection reset by the peer
+#define ARM_SOCKET_ECONNABORTED            (-13)        ///< Connection aborted locally
+#define ARM_SOCKET_EALREADY                (-14)        ///< Connection already in progress
+#define ARM_SOCKET_EADDRINUSE              (-15)        ///< Address in use
+#define ARM_SOCKET_EHOSTNOTFOUND           (-16)        ///< Host not found
+
+
+// Function documentation
+/**
+  n            ARM_DRIVER_VERSION ARM_WIFI_GetVersion (void)
+  rief         Get driver version.
+  eturn        ef ARM_DRIVER_VERSION
+*/
+/**
+  n            ARM_WIFI_CAPABILITIES ARM_WIFI_GetCapabilities (void)
+  rief         Get driver capabilities.
+  eturn        ef ARM_WIFI_CAPABILITIES
+*/
+/**
+  n            int32_t ARM_WIFI_Initialize (ARM_WIFI_SignalEvent_t cb_event)
+  rief         Initialize WiFi Module.
+  \param[in]     cb_event Pointer to ef ARM_WIFI_SignalEvent_t
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+*/
+/**
+  n            int32_t ARM_WIFI_Uninitialize (void)
+  rief         De-initialize WiFi Module.
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+*/
+/**
+  n            int32_t ARM_WIFI_PowerControl (ARM_POWER_STATE state)
+  rief         Control WiFi Module Power.
+  \param[in]     state     Power state
+                   - ef ARM_POWER_OFF                : Power off: no operation possible
+                   - ef ARM_POWER_LOW                : Low-power mode: sleep or deep-sleep depending on ef ARM_WIFI_LP_TIMER option set
+                   - ef ARM_POWER_FULL               : Power on: full operation at maximum performance
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid state)
+*/
+/**
+  n            int32_t ARM_WIFI_GetModuleInfo (char *module_info, uint32_t max_len)
+  rief         Get Module information.
+  \param[out]    module_info Pointer to character buffer were info string will be returned
+  \param[in]     max_len     Maximum length of string to return (including null terminator)
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (NULL module_info pointer or max_len equals to 0)
+*/
+/**
+  n            int32_t ARM_WIFI_SetOption (uint32_t interface, uint32_t option, const void *data, uint32_t len)
+  rief         Set WiFi Module Options.
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  \param[in]     option    Option to set
+  \param[in]     data      Pointer to data relevant to selected option
+  \param[in]     len       Length of data (in bytes)
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface, NULL data pointer or len less than option specifies)
+*/
+/**
+  n            int32_t ARM_WIFI_GetOption (uint32_t interface, uint32_t option, void *data, uint32_t *len)
+  rief         Get WiFi Module Options.
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  \param[in]     option    Option to get
+  \param[out]    data      Pointer to memory where data for selected option will be returned
+  \param[in,out] len       Pointer to length of data (input/output)
+                   - input: maximum length of data that can be returned (in bytes)
+                   - output: length of returned data (in bytes)
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface, NULL data or len pointer, or *len less than option specifies)
+*/
+/**
+  n            int32_t ARM_WIFI_Scan (ARM_WIFI_SCAN_INFO_t scan_info[], uint32_t max_num)
+  rief         Scan for available networks in range.
+  \param[out]    scan_info Pointer to array of ARM_WIFI_SCAN_INFO_t structures where available Scan Information will be returned
+  \param[in]     max_num   Maximum number of Network Information structures to return
+  eturn        number of ARM_WIFI_SCAN_INFO_t structures returned or error code
+                   - value >= 0                        : Number of ARM_WIFI_SCAN_INFO_t structures returned
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (NULL scan_info pointer or max_num equal to 0)
+*/
+/**
+  n            int32_t ARM_WIFI_Activate (uint32_t interface, ARM_WIFI_CONFIG_t *config)
+  rief         Activate interface (Connect to a wireless network or activate an access point).
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  \param[in]     config    Pointer to ARM_WIFI_CONFIG_t structure where Configuration parameters are located
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_TIMEOUT     : Timeout occurred
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported (security type, channel autodetect or WPS not supported)
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface, NULL config pointer or invalid configuration)
+*/
+/**
+  n            int32_t ARM_WIFI_Deactivate (uint32_t interface)
+  rief         Deactivate interface (Disconnect from a wireless network or deactivate an access point).
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface)
+*/
+/**
+  n            uint32_t ARM_WIFI_IsConnected (void)
+  rief         Get station connection status.
+  eturn        station connection status
+                   - value != 0: Station connected
+                   - value = 0: Station not connected
+*/
+/**
+  n            int32_t ARM_WIFI_GetNetInfo (ARM_WIFI_NET_INFO_t *net_info)
+  rief         Get station Network Information.
+  \param[out]    net_info  Pointer to ARM_WIFI_NET_INFO_t structure where station Network Information will be returned
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed (station not connected)
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface or NULL net_info pointer)
+*/
+/**
+  n            int32_t ARM_WIFI_BypassControl (uint32_t interface, uint32_t mode)
+  rief         Enable or disable bypass (pass-through) mode. Transmit and receive Ethernet frames (IP layer bypassed and WiFi/Ethernet translation).
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  \param[in]     mode
+                   - value = 1: all packets bypass internal IP stack
+                   - value = 0: all packets processed by internal IP stack
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface or mode)
+*/
+/**
+  n            int32_t ARM_WIFI_EthSendFrame (uint32_t interface, const uint8_t *frame, uint32_t len)
+  rief         Send Ethernet frame (in bypass mode only).
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  \param[in]     frame    Pointer to frame buffer with data to send
+  \param[in]     len      Frame buffer length in bytes
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_BUSY        : Driver is busy
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface or NULL frame pointer)
+*/
+/**
+  n            int32_t ARM_WIFI_EthReadFrame (uint32_t interface, uint8_t *frame, uint32_t len)
+  rief         Read data of received Ethernet frame (in bypass mode only).
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  \param[in]     frame    Pointer to frame buffer for data to read into
+  \param[in]     len      Frame buffer length in bytes
+  eturn        number of data bytes read or error code
+                   - value >= 0                        : Number of data bytes read
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (invalid interface or NULL frame pointer)
+*/
+/**
+  n            uint32_t ARM_WIFI_EthGetRxFrameSize (uint32_t interface)
+  rief         Get size of received Ethernet frame (in bypass mode only).
+  \param[in]     interface Interface (0 = Station, 1 = Access Point)
+  eturn        number of bytes in received frame
+*/
+/**
+  n            int32_t ARM_WIFI_SocketCreate (int32_t af, int32_t type, int32_t protocol)
+  rief         Create a communication socket.
+  \param[in]     af       Address family
+  \param[in]     type     Socket type
+  \param[in]     protocol Socket protocol
+  eturn        status information
+                   - Socket identification number (>=0)
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument
+                   - ef ARM_SOCKET_ENOTSUP           : Operation not supported
+                   - ef ARM_SOCKET_ENOMEM            : Not enough memory
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketBind (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port)
+  rief         Assign a local address to a socket.
+  \param[in]     socket   Socket identification number
+  \param[in]     ip       Pointer to local IP address
+  \param[in]     ip_len   Length of 'ip' address in bytes
+  \param[in]     port     Local port number
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (address or socket already bound)
+                   - ef ARM_SOCKET_EADDRINUSE        : Address already in use
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketListen (int32_t socket, int32_t backlog)
+  rief         Listen for socket connections.
+  \param[in]     socket   Socket identification number
+  \param[in]     backlog  Number of connection requests that can be queued
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (socket not bound)
+                   - ef ARM_SOCKET_ENOTSUP           : Operation not supported
+                   - ef ARM_SOCKET_EISCONN           : Socket is already connected
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketAccept (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port)
+  rief         Accept a new connection on a socket.
+  \param[in]     socket   Socket identification number
+  \param[out]    ip       Pointer to buffer where address of connecting socket shall be returned (NULL for none)
+  \param[in,out] ip_len   Pointer to length of 'ip' (or NULL if 'ip' is NULL)
+                   - length of supplied 'ip' on input
+                   - length of stored 'ip' on output
+  \param[out]    port     Pointer to buffer where port of connecting socket shall be returned (NULL for none)
+  eturn        status information
+                   - socket identification number of accepted socket (>=0)
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (socket not in listen mode)
+                   - ef ARM_SOCKET_ENOTSUP           : Operation not supported (socket type does not support accepting connections)
+                   - ef ARM_SOCKET_ECONNRESET        : Connection reset by the peer
+                   - ef ARM_SOCKET_ECONNABORTED      : Connection aborted locally
+                   - ef ARM_SOCKET_EAGAIN            : Operation would block or timed out (may be called again)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketConnect (int32_t socket, const uint8_t *ip, uint32_t ip_len, uint16_t port)
+  rief         Connect a socket to a remote host.
+  \param[in]     socket   Socket identification number
+  \param[in]     ip       Pointer to remote IP address
+  \param[in]     ip_len   Length of 'ip' address in bytes
+  \param[in]     port     Remote port number
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument
+                   - ef ARM_SOCKET_EALREADY          : Connection already in progress
+                   - ef ARM_SOCKET_EINPROGRESS       : Operation in progress
+                   - ef ARM_SOCKET_EISCONN           : Socket is connected
+                   - ef ARM_SOCKET_ECONNREFUSED      : Connection rejected by the peer
+                   - ef ARM_SOCKET_ECONNABORTED      : Connection aborted locally
+                   - ef ARM_SOCKET_EADDRINUSE        : Address already in use
+                   - ef ARM_SOCKET_ETIMEDOUT         : Operation timed out
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketRecv (int32_t socket, void *buf, uint32_t len)
+  rief         Receive data on a connected socket.
+  \param[in]     socket   Socket identification number
+  \param[out]    buf      Pointer to buffer where data should be stored
+  \param[in]     len      Length of buffer (in bytes)
+  eturn        status information
+                   - number of bytes received (>0)
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (pointer to buffer or length)
+                   - ef ARM_SOCKET_ENOTCONN          : Socket is not connected
+                   - ef ARM_SOCKET_ECONNRESET        : Connection reset by the peer
+                   - ef ARM_SOCKET_ECONNABORTED      : Connection aborted locally
+                   - ef ARM_SOCKET_EAGAIN            : Operation would block or timed out (may be called again)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketRecvFrom (int32_t socket, void *buf, uint32_t len, uint8_t *ip, uint32_t *ip_len, uint16_t *port)
+  rief         Receive data on a socket.
+  \param[in]     socket   Socket identification number
+  \param[out]    buf      Pointer to buffer where data should be stored
+  \param[in]     len      Length of buffer (in bytes)
+  \param[out]    ip       Pointer to buffer where remote source address shall be returned (NULL for none)
+  \param[in,out] ip_len   Pointer to length of 'ip' (or NULL if 'ip' is NULL)
+                   - length of supplied 'ip' on input
+                   - length of stored 'ip' on output
+  \param[out]    port     Pointer to buffer where remote source port shall be returned (NULL for none)
+  eturn        status information
+                   - number of bytes received (>0)
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (pointer to buffer or length)
+                   - ef ARM_SOCKET_ENOTCONN          : Socket is not connected
+                   - ef ARM_SOCKET_ECONNRESET        : Connection reset by the peer
+                   - ef ARM_SOCKET_ECONNABORTED      : Connection aborted locally
+                   - ef ARM_SOCKET_EAGAIN            : Operation would block or timed out (may be called again)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketSend (int32_t socket, const void *buf, uint32_t len)
+  rief         Send data on a connected socket.
+  \param[in]     socket   Socket identification number
+  \param[in]     buf      Pointer to buffer containing data to send
+  \param[in]     len      Length of data (in bytes)
+  eturn        status information
+                   - number of bytes sent (>0)
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (pointer to buffer or length)
+                   - ef ARM_SOCKET_ENOTCONN          : Socket is not connected
+                   - ef ARM_SOCKET_ECONNRESET        : Connection reset by the peer
+                   - ef ARM_SOCKET_ECONNABORTED      : Connection aborted locally
+                   - ef ARM_SOCKET_EAGAIN            : Operation would block or timed out (may be called again)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketSendTo (int32_t socket, const void *buf, uint32_t len, const uint8_t *ip, uint32_t ip_len, uint16_t port)
+  rief         Send data on a socket.
+  \param[in]     socket   Socket identification number
+  \param[in]     buf      Pointer to buffer containing data to send
+  \param[in]     len      Length of data (in bytes)
+  \param[in]     ip       Pointer to remote destination IP address
+  \param[in]     ip_len   Length of 'ip' address in bytes
+  \param[in]     port     Remote destination port number
+  eturn        status information
+                   - number of bytes sent (>0)
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (pointer to buffer or length)
+                   - ef ARM_SOCKET_ENOTCONN          : Socket is not connected
+                   - ef ARM_SOCKET_ECONNRESET        : Connection reset by the peer
+                   - ef ARM_SOCKET_ECONNABORTED      : Connection aborted locally
+                   - ef ARM_SOCKET_EAGAIN            : Operation would block or timed out (may be called again)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketGetSockName (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port)
+  rief         Retrieve local IP address and port of a socket.
+  \param[in]     socket   Socket identification number
+  \param[out]    ip       Pointer to buffer where local address shall be returned (NULL for none)
+  \param[in,out] ip_len   Pointer to length of 'ip' (or NULL if 'ip' is NULL)
+                   - length of supplied 'ip' on input
+                   - length of stored 'ip' on output
+  \param[out]    port     Pointer to buffer where local port shall be returned (NULL for none)
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (pointer to buffer or length)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketGetPeerName (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port)
+  rief         Retrieve remote IP address and port of a socket
+  \param[in]     socket   Socket identification number
+  \param[out]    ip       Pointer to buffer where remote address shall be returned (NULL for none)
+  \param[in,out] ip_len   Pointer to length of 'ip' (or NULL if 'ip' is NULL)
+                   - length of supplied 'ip' on input
+                   - length of stored 'ip' on output
+  \param[out]    port     Pointer to buffer where remote port shall be returned (NULL for none)
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument (pointer to buffer or length)
+                   - ef ARM_SOCKET_ENOTCONN          : Socket is not connected
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketGetOpt (int32_t socket, int32_t opt_id, void *opt_val, uint32_t *opt_len)
+  rief         Get socket option.
+  \param[in]     socket   Socket identification number
+  \param[in]     opt_id   Option identifier
+  \param[out]    opt_val  Pointer to the buffer that will receive the option value
+  \param[in,out] opt_len  Pointer to length of the option value
+                   - length of buffer on input
+                   - length of data on output
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument
+                   - ef ARM_SOCKET_ENOTSUP           : Operation not supported
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketSetOpt (int32_t socket, int32_t opt_id, const void *opt_val, uint32_t opt_len)
+  rief         Set socket option.
+  \param[in]     socket   Socket identification number
+  \param[in]     opt_id   Option identifier
+  \param[in]     opt_val  Pointer to the option value
+  \param[in]     opt_len  Length of the option value in bytes
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument
+                   - ef ARM_SOCKET_ENOTSUP           : Operation not supported
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketClose (int32_t socket)
+  rief         Close and release a socket.
+  \param[in]     socket   Socket identification number
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_ESOCK             : Invalid socket
+                   - ef ARM_SOCKET_EAGAIN            : Operation would block (may be called again)
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_SocketGetHostByName (const char *name, int32_t af, uint8_t *ip, uint32_t *ip_len)
+  rief         Retrieve host IP address from host name.
+  \param[in]     name     Host name
+  \param[in]     af       Address family
+  \param[out]    ip       Pointer to buffer where resolved IP address shall be returned
+  \param[in,out] ip_len   Pointer to length of 'ip'
+                   - length of supplied 'ip' on input
+                   - length of stored 'ip' on output
+  eturn        status information
+                   - 0                                 : Operation successful
+                   - ef ARM_SOCKET_EINVAL            : Invalid argument
+                   - ef ARM_SOCKET_ENOTSUP           : Operation not supported
+                   - ef ARM_SOCKET_ETIMEDOUT         : Operation timed out
+                   - ef ARM_SOCKET_EHOSTNOTFOUND     : Host not found
+                   - ef ARM_SOCKET_ERROR             : Unspecified error
+*/
+/**
+  n            int32_t ARM_WIFI_Ping (const uint8_t *ip, uint32_t ip_len)
+  rief         Probe remote host with Ping command.
+  \param[in]     ip       Pointer to remote host IP address
+  \param[in]     ip_len   Length of 'ip' address in bytes
+  eturn        execution status
+                   - ef ARM_DRIVER_OK                : Operation successful
+                   - ef ARM_DRIVER_ERROR             : Operation failed
+                   - ef ARM_DRIVER_ERROR_TIMEOUT     : Timeout occurred
+                   - ef ARM_DRIVER_ERROR_UNSUPPORTED : Operation not supported
+                   - ef ARM_DRIVER_ERROR_PARAMETER   : Parameter error (NULL ip pointer or ip_len different than 4 or 16)
+*/
+/**
+  n            void ARM_WIFI_SignalEvent (uint32_t event, void *arg)
+  rief         Signal WiFi Events.
+  \param[in]     event    ef wifi_event notification mask
+  \param[in]     arg      Pointer to argument of signaled event
+  eturn        none
+*/
+
+typedef void (*ARM_WIFI_SignalEvent_t) (uint32_t event, void *arg); ///< Pointer to ef ARM_WIFI_SignalEvent : Signal WiFi Event.
+
+
+/**
+rief WiFi Driver Capabilities.
+*/
+typedef struct {
+  uint32_t station               : 1;   ///< Station
+  uint32_t ap                    : 1;   ///< Access Point
+  uint32_t station_ap            : 1;   ///< Concurrent Station and Access Point
+  uint32_t wps_station           : 1;   ///< WiFi Protected Setup (WPS) for Station
+  uint32_t wps_ap                : 1;   ///< WiFi Protected Setup (WPS) for Access Point
+  uint32_t event_ap_connect      : 1;   ///< Access Point: event generated on Station connect
+  uint32_t event_ap_disconnect   : 1;   ///< Access Point: event generated on Station disconnect
+  uint32_t event_eth_rx_frame    : 1;   ///< Event generated on Ethernet frame reception in bypass mode
+  uint32_t bypass_mode           : 1;   ///< Bypass or pass-through mode (Ethernet interface)
+  uint32_t ip                    : 1;   ///< IP (UDP/TCP) (Socket interface)
+  uint32_t ip6                   : 1;   ///< IPv6 (Socket interface)
+  uint32_t ping                  : 1;   ///< Ping (ICMP)
+  uint32_t reserved              : 20;  ///< Reserved (must be zero)
+} ARM_WIFI_CAPABILITIES;
+
+/**
+rief Access structure of the WiFi Driver.
+*/
+typedef struct {
+  ARM_DRIVER_VERSION    (*GetVersion)                  (void);
+  ARM_WIFI_CAPABILITIES (*GetCapabilities)             (void);
+  int32_t               (*Initialize)                  (ARM_WIFI_SignalEvent_t cb_event);
+  int32_t               (*Uninitialize)                (void);
+  int32_t               (*PowerControl)                (ARM_POWER_STATE state);
+  int32_t               (*GetModuleInfo)               (char *module_info, uint32_t max_len);
+  int32_t               (*SetOption)                   (uint32_t interface, uint32_t option, const void *data, uint32_t  len);
+  int32_t               (*GetOption)                   (uint32_t interface, uint32_t option,       void *data, uint32_t *len);
+  int32_t               (*Scan)                        (ARM_WIFI_SCAN_INFO_t scan_info[], uint32_t max_num);
+  int32_t               (*Activate)                    (uint32_t interface, const ARM_WIFI_CONFIG_t *config);
+  int32_t               (*Deactivate)                  (uint32_t interface);
+  uint32_t              (*IsConnected)                 (void);
+  int32_t               (*GetNetInfo)                  (ARM_WIFI_NET_INFO_t *net_info);
+  int32_t               (*BypassControl)               (uint32_t interface, uint32_t mode);
+  int32_t               (*EthSendFrame)                (uint32_t interface, const uint8_t *frame, uint32_t len);
+  int32_t               (*EthReadFrame)                (uint32_t interface,       uint8_t *frame, uint32_t len);
+  uint32_t              (*EthGetRxFrameSize)           (uint32_t interface);
+  int32_t               (*SocketCreate)                (int32_t af, int32_t type, int32_t protocol);
+  int32_t               (*SocketBind)                  (int32_t socket, const uint8_t *ip, uint32_t  ip_len, uint16_t  port);
+  int32_t               (*SocketListen)                (int32_t socket, int32_t backlog);
+  int32_t               (*SocketAccept)                (int32_t socket,       uint8_t *ip, uint32_t *ip_len, uint16_t *port);
+  int32_t               (*SocketConnect)               (int32_t socket, const uint8_t *ip, uint32_t  ip_len, uint16_t  port);
+  int32_t               (*SocketRecv)                  (int32_t socket, void *buf, uint32_t len);
+  int32_t               (*SocketRecvFrom)              (int32_t socket, void *buf, uint32_t len, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
+  int32_t               (*SocketSend)                  (int32_t socket, const void *buf, uint32_t len);
+  int32_t               (*SocketSendTo)                (int32_t socket, const void *buf, uint32_t len, const uint8_t *ip, uint32_t ip_len, uint16_t port);
+  int32_t               (*SocketGetSockName)           (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
+  int32_t               (*SocketGetPeerName)           (int32_t socket, uint8_t *ip, uint32_t *ip_len, uint16_t *port);
+  int32_t               (*SocketGetOpt)                (int32_t socket, int32_t opt_id,       void *opt_val, uint32_t *opt_len);
+  int32_t               (*SocketSetOpt)                (int32_t socket, int32_t opt_id, const void *opt_val, uint32_t  opt_len);
+  int32_t               (*SocketClose)                 (int32_t socket);
+  int32_t               (*SocketGetHostByName)         (const char *name, int32_t af, uint8_t *ip, uint32_t *ip_len);
+  int32_t               (*Ping)                        (const uint8_t *ip, uint32_t ip_len);
+} const ARM_DRIVER_WIFI;
+
+#ifdef  __cplusplus
+}
+#endif
+
+#endif /* DRIVER_WIFI_H_ */
diff --git a/SDK_MEK-MIMX8QM/CMSIS/Include/arm_common_tables.h b/SDK_MEK-MIMX8QM/CMSIS/Include/arm_common_tables.h
index dfea746..6a4337f 100644
--- a/SDK_MEK-MIMX8QM/CMSIS/Include/arm_common_tables.h
+++ b/SDK_MEK-MIMX8QM/CMSIS/Include/arm_common_tables.h
@@ -31,91 +31,348 @@
 
 #include "arm_math.h"
 
-extern const uint16_t armBitRevTable[1024];
-extern const q15_t armRecipTableQ15[64];
-extern const q31_t armRecipTableQ31[64];
-extern const float32_t twiddleCoef_16[32];
-extern const float32_t twiddleCoef_32[64];
-extern const float32_t twiddleCoef_64[128];
-extern const float32_t twiddleCoef_128[256];
-extern const float32_t twiddleCoef_256[512];
-extern const float32_t twiddleCoef_512[1024];
-extern const float32_t twiddleCoef_1024[2048];
-extern const float32_t twiddleCoef_2048[4096];
-extern const float32_t twiddleCoef_4096[8192];
-#define twiddleCoef twiddleCoef_4096
-extern const q31_t twiddleCoef_16_q31[24];
-extern const q31_t twiddleCoef_32_q31[48];
-extern const q31_t twiddleCoef_64_q31[96];
-extern const q31_t twiddleCoef_128_q31[192];
-extern const q31_t twiddleCoef_256_q31[384];
-extern const q31_t twiddleCoef_512_q31[768];
-extern const q31_t twiddleCoef_1024_q31[1536];
-extern const q31_t twiddleCoef_2048_q31[3072];
-extern const q31_t twiddleCoef_4096_q31[6144];
-extern const q15_t twiddleCoef_16_q15[24];
-extern const q15_t twiddleCoef_32_q15[48];
-extern const q15_t twiddleCoef_64_q15[96];
-extern const q15_t twiddleCoef_128_q15[192];
-extern const q15_t twiddleCoef_256_q15[384];
-extern const q15_t twiddleCoef_512_q15[768];
-extern const q15_t twiddleCoef_1024_q15[1536];
-extern const q15_t twiddleCoef_2048_q15[3072];
-extern const q15_t twiddleCoef_4096_q15[6144];
-extern const float32_t twiddleCoef_rfft_32[32];
-extern const float32_t twiddleCoef_rfft_64[64];
-extern const float32_t twiddleCoef_rfft_128[128];
-extern const float32_t twiddleCoef_rfft_256[256];
-extern const float32_t twiddleCoef_rfft_512[512];
-extern const float32_t twiddleCoef_rfft_1024[1024];
-extern const float32_t twiddleCoef_rfft_2048[2048];
-extern const float32_t twiddleCoef_rfft_4096[4096];
-
-/* floating-point bit reversal tables */
-#define ARMBITREVINDEXTABLE_16_TABLE_LENGTH ((uint16_t)20)
-#define ARMBITREVINDEXTABLE_32_TABLE_LENGTH ((uint16_t)48)
-#define ARMBITREVINDEXTABLE_64_TABLE_LENGTH ((uint16_t)56)
-#define ARMBITREVINDEXTABLE_128_TABLE_LENGTH ((uint16_t)208)
-#define ARMBITREVINDEXTABLE_256_TABLE_LENGTH ((uint16_t)440)
-#define ARMBITREVINDEXTABLE_512_TABLE_LENGTH ((uint16_t)448)
-#define ARMBITREVINDEXTABLE_1024_TABLE_LENGTH ((uint16_t)1800)
-#define ARMBITREVINDEXTABLE_2048_TABLE_LENGTH ((uint16_t)3808)
-#define ARMBITREVINDEXTABLE_4096_TABLE_LENGTH ((uint16_t)4032)
-
-extern const uint16_t armBitRevIndexTable16[ARMBITREVINDEXTABLE_16_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable32[ARMBITREVINDEXTABLE_32_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable64[ARMBITREVINDEXTABLE_64_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable128[ARMBITREVINDEXTABLE_128_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable256[ARMBITREVINDEXTABLE_256_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable512[ARMBITREVINDEXTABLE_512_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable1024[ARMBITREVINDEXTABLE_1024_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable2048[ARMBITREVINDEXTABLE_2048_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable4096[ARMBITREVINDEXTABLE_4096_TABLE_LENGTH];
-
-/* fixed-point bit reversal tables */
-#define ARMBITREVINDEXTABLE_FIXED_16_TABLE_LENGTH ((uint16_t)12)
-#define ARMBITREVINDEXTABLE_FIXED_32_TABLE_LENGTH ((uint16_t)24)
-#define ARMBITREVINDEXTABLE_FIXED_64_TABLE_LENGTH ((uint16_t)56)
-#define ARMBITREVINDEXTABLE_FIXED_128_TABLE_LENGTH ((uint16_t)112)
-#define ARMBITREVINDEXTABLE_FIXED_256_TABLE_LENGTH ((uint16_t)240)
-#define ARMBITREVINDEXTABLE_FIXED_512_TABLE_LENGTH ((uint16_t)480)
-#define ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH ((uint16_t)992)
-#define ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH ((uint16_t)1984)
-#define ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH ((uint16_t)4032)
-
-extern const uint16_t armBitRevIndexTable_fixed_16[ARMBITREVINDEXTABLE_FIXED_16_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_32[ARMBITREVINDEXTABLE_FIXED_32_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_64[ARMBITREVINDEXTABLE_FIXED_64_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_128[ARMBITREVINDEXTABLE_FIXED_128_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_256[ARMBITREVINDEXTABLE_FIXED_256_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_512[ARMBITREVINDEXTABLE_FIXED_512_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_1024[ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_2048[ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH];
-extern const uint16_t armBitRevIndexTable_fixed_4096[ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH];
-
-/* Tables for Fast Math Sine and Cosine */
-extern const float32_t sinTable_f32[FAST_MATH_TABLE_SIZE + 1];
-extern const q31_t sinTable_q31[FAST_MATH_TABLE_SIZE + 1];
-extern const q15_t sinTable_q15[FAST_MATH_TABLE_SIZE + 1];
+#if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_FFT_ALLOW_TABLES) 
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREV_1024)
+    extern const uint16_t armBitRevTable[1024];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_16)
+    extern const float32_t twiddleCoef_16[32];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_32)
+    extern const float32_t twiddleCoef_32[64];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_64)
+    extern const float32_t twiddleCoef_64[128];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_128)
+    extern const float32_t twiddleCoef_128[256];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_256)
+    extern const float32_t twiddleCoef_256[512];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_512)
+    extern const float32_t twiddleCoef_512[1024];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_1024)
+    extern const float32_t twiddleCoef_1024[2048];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_2048)
+    extern const float32_t twiddleCoef_2048[4096];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_F32_4096)
+    extern const float32_t twiddleCoef_4096[8192];
+    #define twiddleCoef twiddleCoef_4096
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_16)
+    extern const q31_t twiddleCoef_16_q31[24];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_32)
+    extern const q31_t twiddleCoef_32_q31[48];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_64)
+    extern const q31_t twiddleCoef_64_q31[96];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_128)
+    extern const q31_t twiddleCoef_128_q31[192];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_256)
+    extern const q31_t twiddleCoef_256_q31[384];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_512)
+    extern const q31_t twiddleCoef_512_q31[768];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_1024)
+    extern const q31_t twiddleCoef_1024_q31[1536];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_2048)
+    extern const q31_t twiddleCoef_2048_q31[3072];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q31_4096)
+    extern const q31_t twiddleCoef_4096_q31[6144];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_16)
+    extern const q15_t twiddleCoef_16_q15[24];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_32)
+    extern const q15_t twiddleCoef_32_q15[48];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_64)
+    extern const q15_t twiddleCoef_64_q15[96];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_128)
+    extern const q15_t twiddleCoef_128_q15[192];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_256)
+    extern const q15_t twiddleCoef_256_q15[384];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_512)
+    extern const q15_t twiddleCoef_512_q15[768];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_1024)
+    extern const q15_t twiddleCoef_1024_q15[1536];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_2048)
+    extern const q15_t twiddleCoef_2048_q15[3072];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_Q15_4096)
+    extern const q15_t twiddleCoef_4096_q15[6144];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_32)
+    extern const float32_t twiddleCoef_rfft_32[32];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_64)
+    extern const float32_t twiddleCoef_rfft_64[64];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_128)
+    extern const float32_t twiddleCoef_rfft_128[128];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_256)
+    extern const float32_t twiddleCoef_rfft_256[256];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_512)
+    extern const float32_t twiddleCoef_rfft_512[512];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_1024)
+    extern const float32_t twiddleCoef_rfft_1024[1024];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_2048)
+    extern const float32_t twiddleCoef_rfft_2048[2048];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_TWIDDLECOEF_RFFT_F32_4096)
+    extern const float32_t twiddleCoef_rfft_4096[4096];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  /* floating-point bit reversal tables */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_16)
+    #define ARMBITREVINDEXTABLE_16_TABLE_LENGTH ((uint16_t)20)
+    extern const uint16_t armBitRevIndexTable16[ARMBITREVINDEXTABLE_16_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_32)
+    #define ARMBITREVINDEXTABLE_32_TABLE_LENGTH ((uint16_t)48)
+    extern const uint16_t armBitRevIndexTable32[ARMBITREVINDEXTABLE_32_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_64)
+    #define ARMBITREVINDEXTABLE_64_TABLE_LENGTH ((uint16_t)56)
+    extern const uint16_t armBitRevIndexTable64[ARMBITREVINDEXTABLE_64_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_128)
+    #define ARMBITREVINDEXTABLE_128_TABLE_LENGTH ((uint16_t)208)
+    extern const uint16_t armBitRevIndexTable128[ARMBITREVINDEXTABLE_128_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_256)
+    #define ARMBITREVINDEXTABLE_256_TABLE_LENGTH ((uint16_t)440)
+    extern const uint16_t armBitRevIndexTable256[ARMBITREVINDEXTABLE_256_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_512)
+    #define ARMBITREVINDEXTABLE_512_TABLE_LENGTH ((uint16_t)448)
+    extern const uint16_t armBitRevIndexTable512[ARMBITREVINDEXTABLE_512_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_1024)
+    #define ARMBITREVINDEXTABLE_1024_TABLE_LENGTH ((uint16_t)1800)
+    extern const uint16_t armBitRevIndexTable1024[ARMBITREVINDEXTABLE_1024_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_2048)
+    #define ARMBITREVINDEXTABLE_2048_TABLE_LENGTH ((uint16_t)3808)
+    extern const uint16_t armBitRevIndexTable2048[ARMBITREVINDEXTABLE_2048_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FLT_4096)
+    #define ARMBITREVINDEXTABLE_4096_TABLE_LENGTH ((uint16_t)4032)
+    extern const uint16_t armBitRevIndexTable4096[ARMBITREVINDEXTABLE_4096_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  
+  /* fixed-point bit reversal tables */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_16)
+    #define ARMBITREVINDEXTABLE_FIXED_16_TABLE_LENGTH ((uint16_t)12)
+    extern const uint16_t armBitRevIndexTable_fixed_16[ARMBITREVINDEXTABLE_FIXED_16_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_32)
+    #define ARMBITREVINDEXTABLE_FIXED_32_TABLE_LENGTH ((uint16_t)24)
+    extern const uint16_t armBitRevIndexTable_fixed_32[ARMBITREVINDEXTABLE_FIXED_32_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_64)
+    #define ARMBITREVINDEXTABLE_FIXED_64_TABLE_LENGTH ((uint16_t)56)
+    extern const uint16_t armBitRevIndexTable_fixed_64[ARMBITREVINDEXTABLE_FIXED_64_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_128)
+    #define ARMBITREVINDEXTABLE_FIXED_128_TABLE_LENGTH ((uint16_t)112)
+    extern const uint16_t armBitRevIndexTable_fixed_128[ARMBITREVINDEXTABLE_FIXED_128_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_256)
+    #define ARMBITREVINDEXTABLE_FIXED_256_TABLE_LENGTH ((uint16_t)240)
+    extern const uint16_t armBitRevIndexTable_fixed_256[ARMBITREVINDEXTABLE_FIXED_256_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_512)
+    #define ARMBITREVINDEXTABLE_FIXED_512_TABLE_LENGTH ((uint16_t)480)
+    extern const uint16_t armBitRevIndexTable_fixed_512[ARMBITREVINDEXTABLE_FIXED_512_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_1024)
+    #define ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH ((uint16_t)992)
+    extern const uint16_t armBitRevIndexTable_fixed_1024[ARMBITREVINDEXTABLE_FIXED_1024_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_2048)
+    #define ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH ((uint16_t)1984)
+    extern const uint16_t armBitRevIndexTable_fixed_2048[ARMBITREVINDEXTABLE_FIXED_2048_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_BITREVIDX_FXT_4096)
+    #define ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH ((uint16_t)4032)
+    extern const uint16_t armBitRevIndexTable_fixed_4096[ARMBITREVINDEXTABLE_FIXED_4096_TABLE_LENGTH];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) */
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_REALCOEF_F32)
+    extern const float32_t realCoefA[8192];
+    extern const float32_t realCoefB[8192];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_REALCOEF_Q31)
+    extern const q31_t realCoefAQ31[8192];
+    extern const q31_t realCoefBQ31[8192];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_REALCOEF_Q15)
+    extern const q15_t realCoefAQ15[8192];
+    extern const q15_t realCoefBQ15[8192];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_F32_128)
+    extern const float32_t Weights_128[256];
+    extern const float32_t cos_factors_128[128];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_F32_512)
+    extern const float32_t Weights_512[1024];
+    extern const float32_t cos_factors_512[512];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_F32_2048)
+    extern const float32_t Weights_2048[4096];
+    extern const float32_t cos_factors_2048[2048];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_F32_8192)
+    extern const float32_t Weights_8192[16384];
+    extern const float32_t cos_factors_8192[8192];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q15_128)
+    extern const q15_t WeightsQ15_128[256];
+    extern const q15_t cos_factorsQ15_128[128];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q15_512)
+    extern const q15_t WeightsQ15_512[1024];
+    extern const q15_t cos_factorsQ15_512[512];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q15_2048)
+    extern const q15_t WeightsQ15_2048[4096];
+    extern const q15_t cos_factorsQ15_2048[2048];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q15_8192)
+    extern const q15_t WeightsQ15_8192[16384];
+    extern const q15_t cos_factorsQ15_8192[8192];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q31_128)  
+    extern const q31_t WeightsQ31_128[256];
+    extern const q31_t cos_factorsQ31_128[128];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q31_512) 
+    extern const q31_t WeightsQ31_512[1024];
+    extern const q31_t cos_factorsQ31_512[512];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q31_2048) 
+    extern const q31_t WeightsQ31_2048[4096];
+    extern const q31_t cos_factorsQ31_2048[2048];
+  #endif
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FFT_TABLES) || defined(ARM_TABLE_DCT4_Q31_8192) 
+    extern const q31_t WeightsQ31_8192[16384];
+    extern const q31_t cos_factorsQ31_8192[8192];
+  #endif
+    
+#endif /* if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_FFT_TABLES) */
+
+#if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_FAST_ALLOW_TABLES)
+
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FAST_TABLES) || defined(ARM_TABLE_RECIP_Q15)
+    extern const q15_t armRecipTableQ15[64];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) defined(ARM_ALL_FAST_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FAST_TABLES) || defined(ARM_TABLE_RECIP_Q31)
+    extern const q31_t armRecipTableQ31[64];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) defined(ARM_ALL_FAST_TABLES) */
+  
+  /* Tables for Fast Math Sine and Cosine */
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FAST_TABLES) || defined(ARM_TABLE_SIN_F32)
+    extern const float32_t sinTable_f32[FAST_MATH_TABLE_SIZE + 1];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) defined(ARM_ALL_FAST_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FAST_TABLES) || defined(ARM_TABLE_SIN_Q31)
+    extern const q31_t sinTable_q31[FAST_MATH_TABLE_SIZE + 1];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) defined(ARM_ALL_FAST_TABLES) */
+  
+  #if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_ALL_FAST_TABLES) || defined(ARM_TABLE_SIN_Q15)
+    extern const q15_t sinTable_q15[FAST_MATH_TABLE_SIZE + 1];
+  #endif /* !defined(ARM_DSP_CONFIG_TABLES) defined(ARM_ALL_FAST_TABLES) */
+
+#endif /* if !defined(ARM_DSP_CONFIG_TABLES) || defined(ARM_FAST_TABLES) */
 
 #endif /*  ARM_COMMON_TABLES_H */
diff --git a/SDK_MEK-MIMX8QM/CMSIS/Include/arm_math.h b/SDK_MEK-MIMX8QM/CMSIS/Include/arm_math.h
index 62f87be..eb37f82 100644
--- a/SDK_MEK-MIMX8QM/CMSIS/Include/arm_math.h
+++ b/SDK_MEK-MIMX8QM/CMSIS/Include/arm_math.h
@@ -1,11 +1,11 @@
 /******************************************************************************
  * @file     arm_math.h
- * @brief    Public header file for CMSIS DSP LibraryU
- * @version  V1.5.3
- * @date     10. January 2018
+ * @brief    Public header file for CMSIS DSP Library
+ * @version  V1.6.0
+ * @date     18. March 2019
  ******************************************************************************/
 /*
- * Copyright (c) 2010-2018 Arm Limited or its affiliates. All rights reserved.
+ * Copyright (c) 2010-2019 Arm Limited or its affiliates. All rights reserved.
  *
  * SPDX-License-Identifier: Apache-2.0
  *
@@ -37,7 +37,7 @@
    * - Complex math functions
    * - Filters
    * - Matrix functions
-   * - Transforms
+   * - Transform functions
    * - Motor control functions
    * - Statistical functions
    * - Support functions
@@ -73,11 +73,7 @@
    * The library functions are declared in the public file <code>arm_math.h</code> which is placed in the <code>Include</code> folder.
    * Simply include this file and link the appropriate library in the application and begin calling the library functions. The Library supports single
    * public header file <code> arm_math.h</code> for Cortex-M cores with little endian and big endian. Same header file will be used for floating point unit(FPU) variants.
-   * Define the appropriate preprocessor macro ARM_MATH_CM7 or ARM_MATH_CM4 or ARM_MATH_CM3 or
-   * ARM_MATH_CM0 or ARM_MATH_CM0PLUS depending on the target processor in the application.
-   * For Armv8-M cores define preprocessor macro ARM_MATH_ARMV8MBL or ARM_MATH_ARMV8MML.
-   * Set preprocessor macro __DSP_PRESENT if Armv8-M Mainline core supports DSP instructions.
-   * 
+   *
    *
    * Examples
    * --------
@@ -93,7 +89,7 @@
    * Building the Library
    * ------------
    *
-   * The library installer contains a project file to rebuild libraries on MDK toolchain in the <code>CMSIS\DSP_Lib\Source\ARM</code> folder.
+   * The library installer contains a project file to rebuild libraries on MDK toolchain in the <code>CMSIS\DSP\Projects\ARM</code> folder.
    * - arm_cortexM_math.uvprojx
    *
    *
@@ -104,10 +100,6 @@
    *
    * Each library project have different preprocessor macros.
    *
-   * - UNALIGNED_SUPPORT_DISABLE:
-   *
-   * Define macro UNALIGNED_SUPPORT_DISABLE, If the silicon does not support unaligned memory access
-   *
    * - ARM_MATH_BIG_ENDIAN:
    *
    * Define macro ARM_MATH_BIG_ENDIAN to build the library for big endian targets. By default library builds for little endian targets.
@@ -120,46 +112,41 @@
    *
    * Define macro ARM_MATH_ROUNDING for rounding on support functions
    *
-   * - ARM_MATH_CMx:
-   *
-   * Define macro ARM_MATH_CM4 for building the library on Cortex-M4 target, ARM_MATH_CM3 for building library on Cortex-M3 target
-   * and ARM_MATH_CM0 for building library on Cortex-M0 target, ARM_MATH_CM0PLUS for building library on Cortex-M0+ target, and
-   * ARM_MATH_CM7 for building the library on cortex-M7.
+   * - ARM_MATH_LOOPUNROLL:
    *
-   * - ARM_MATH_ARMV8MxL:
+   * Define macro ARM_MATH_LOOPUNROLL to enable manual loop unrolling in DSP functions
    *
-   * Define macro ARM_MATH_ARMV8MBL for building the library on Armv8-M Baseline target, ARM_MATH_ARMV8MML for building library
-   * on Armv8-M Mainline target.
+   * - ARM_MATH_NEON:
    *
-   * - __FPU_PRESENT:
+   * Define macro ARM_MATH_NEON to enable Neon versions of the DSP functions.
+   * It is not enabled by default when Neon is available because performances are 
+   * dependent on the compiler and target architecture.
    *
-   * Initialize macro __FPU_PRESENT = 1 when building on FPU supported Targets. Enable this macro for floating point libraries.
+   * - ARM_MATH_NEON_EXPERIMENTAL:
    *
-   * - __DSP_PRESENT:
-   *
-   * Initialize macro __DSP_PRESENT = 1 when Armv8-M Mainline core supports DSP instructions.
+   * Define macro ARM_MATH_NEON_EXPERIMENTAL to enable experimental Neon versions of 
+   * of some DSP functions. Experimental Neon versions currently do not have better
+   * performances than the scalar versions.
    *
    * <hr>
    * CMSIS-DSP in ARM::CMSIS Pack
    * -----------------------------
    *
    * The following files relevant to CMSIS-DSP are present in the <b>ARM::CMSIS</b> Pack directories:
-   * |File/Folder                   |Content                                                                 |
-   * |------------------------------|------------------------------------------------------------------------|
-   * | CMSIS\Documentation\DSP  | This documentation                                                     |
-   * | CMSIS\DSP_Lib             | Software license agreement (license.txt)                               |
-   * | CMSIS\DSP_Lib\Examples   | Example projects demonstrating the usage of the library functions      |
-   * | CMSIS\DSP_Lib\Source     | Source files for rebuilding the library                                |
+   * |File/Folder                      |Content                                                                 |
+   * |---------------------------------|------------------------------------------------------------------------|
+   * | CMSIS\Documentation\DSP     | This documentation                                                     |
+   * | CMSIS\DSP\DSP_Lib_TestSuite | DSP_Lib test suite                                                     |
+   * | CMSIS\DSP\Examples          | Example projects demonstrating the usage of the library functions      |
+   * | CMSIS\DSP\Include           | DSP_Lib include files                                                  |
+   * | CMSIS\DSP\Lib               | DSP_Lib binaries                                                       |
+   * | CMSIS\DSP\Projects          | Projects to rebuild DSP_Lib binaries                                   |
+   * | CMSIS\DSP\Source            | DSP_Lib source files                                                   |
    *
    * <hr>
    * Revision History of CMSIS-DSP
    * ------------
    * Please refer to ef ChangeLog_pg.
-   *
-   * Copyright Notice
-   * ------------
-   *
-   * Copyright (C) 2010-2015 Arm Limited. All rights reserved.
    */
 
 
@@ -220,8 +207,8 @@
  * There is an associated initialization function for each type of matrix
  * data structure.
  * The initialization function sets the values of the internal structure fields.
- * Refer to the function <code>arm_mat_init_f32()</code>, <code>arm_mat_init_q31()</code>
- * and <code>arm_mat_init_q15()</code> for floating-point, Q31 and Q15 types,  respectively.
+ * Refer to ef arm_mat_init_f32(), ef arm_mat_init_q31() and ef arm_mat_init_q15()
+ * for floating-point, Q31 and Q15 types,  respectively.
  *
  * \par
  * Use of the initialization function is optional. However, if initialization function is used
@@ -272,6 +259,7 @@
 /**
  * @defgroup groupStats Statistics Functions
  */
+
 /**
  * @defgroup groupSupport Support Functions
  */
@@ -286,6 +274,8 @@
 /**
  * @defgroup groupExamples Examples
  */
+
+
 #ifndef _ARM_MATH_H
 #define _ARM_MATH_H
 
@@ -295,10 +285,10 @@
 #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
 
 #elif defined ( __GNUC__ )
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wsign-conversion"
-#pragma GCC diagnostic ignored "-Wconversion"
-#pragma GCC diagnostic ignored "-Wunused-parameter"
+  #pragma GCC diagnostic push
+  #pragma GCC diagnostic ignored "-Wsign-conversion"
+  #pragma GCC diagnostic ignored "-Wconversion"
+  #pragma GCC diagnostic ignored "-Wunused-parameter"
 
 #elif defined ( __ICCARM__ )
 
@@ -308,45 +298,40 @@
 
 #elif defined ( __TASKING__ )
 
+#elif defined ( _MSC_VER )
+
 #else
   #error Unknown compiler
 #endif
 
 
-#define __CMSIS_GENERIC         /* disable NVIC and Systick functions */
-
-#if defined(ARM_MATH_CM7)
-  #include "core_cm7.h"
-  #define ARM_MATH_DSP
-#elif defined (ARM_MATH_CM4)
-  #include "core_cm4.h"
-  #define ARM_MATH_DSP
-#elif defined (ARM_MATH_CM33)
-  #include "core_cm33.h"
-  #define ARM_MATH_DSP
-#elif defined (ARM_MATH_CM3)
-  #include "core_cm3.h"
-#elif defined (ARM_MATH_CM0)
-  #include "core_cm0.h"
-  #define ARM_MATH_CM0_FAMILY
-#elif defined (ARM_MATH_CM0PLUS)
-  #include "core_cm0plus.h"
-  #define ARM_MATH_CM0_FAMILY
-#elif defined (ARM_MATH_ARMV8MBL)
-  #include "core_armv8mbl.h"
-  #define ARM_MATH_CM0_FAMILY
-#elif defined (ARM_MATH_ARMV8MML)
-  #include "core_armv8mml.h"
-  #if (defined (__DSP_PRESENT) && (__DSP_PRESENT == 1))
-    #define ARM_MATH_DSP
-  #endif
+/* Included for instrinsics definitions */
+#if !defined ( _MSC_VER )
+#include "cmsis_compiler.h"
 #else
-  #error "Define according the used Cortex core ARM_MATH_CM7, ARM_MATH_CM4, ARM_MATH_CM3, ARM_MATH_CM0PLUS, ARM_MATH_CM0, ARM_MATH_ARMV8MBL, ARM_MATH_ARMV8MML"
+#include <stdint.h>
+#define __STATIC_FORCEINLINE static __forceinline
+#define __ALIGNED(x) __declspec(align(x))
+#define LOW_OPTIMIZATION_ENTER
+#define LOW_OPTIMIZATION_EXIT
+#define IAR_ONLY_LOW_OPTIMIZATION_ENTER 
+#define IAR_ONLY_LOW_OPTIMIZATION_EXIT
 #endif
 
-#undef  __CMSIS_GENERIC         /* enable NVIC and Systick functions */
 #include "string.h"
 #include "math.h"
+#include "float.h"
+
+/* evaluate ARM DSP feature */
+#if (defined (__ARM_FEATURE_DSP) && (__ARM_FEATURE_DSP == 1))
+  #define ARM_MATH_DSP                   1
+#endif
+
+#if defined(__ARM_NEON)
+#include <arm_neon.h>
+#endif
+
+
 #ifdef   __cplusplus
 extern "C"
 {
@@ -382,18 +367,6 @@ extern "C"
   /* -1 to +1 is divided into 360 values so total spacing is (2/360) */
 #define INPUT_SPACING         0xB60B61
 
-  /**
-   * @brief Macro for Unaligned Support
-   */
-#ifndef UNALIGNED_SUPPORT_DISABLE
-    #define ALIGN4
-#else
-  #if defined  (__GNUC__)
-    #define ALIGN4 __attribute__((aligned(4)))
-  #else
-    #define ALIGN4 __align(4)
-  #endif
-#endif   /* #ifndef UNALIGNED_SUPPORT_DISABLE */
 
   /**
    * @brief Error status returned by some functions in the library.
@@ -401,13 +374,13 @@ extern "C"
 
   typedef enum
   {
-    ARM_MATH_SUCCESS = 0,                /**< No error */
+    ARM_MATH_SUCCESS        =  0,        /**< No error */
     ARM_MATH_ARGUMENT_ERROR = -1,        /**< One or more arguments are incorrect */
-    ARM_MATH_LENGTH_ERROR = -2,          /**< Length of data buffer is incorrect */
-    ARM_MATH_SIZE_MISMATCH = -3,         /**< Size of matrices is not compatible with the operation. */
-    ARM_MATH_NANINF = -4,                /**< Not-a-number (NaN) or infinity is generated */
-    ARM_MATH_SINGULAR = -5,              /**< Generated by matrix inversion if the input matrix is singular and cannot be inverted. */
-    ARM_MATH_TEST_FAILURE = -6           /**< Test Failed  */
+    ARM_MATH_LENGTH_ERROR   = -2,        /**< Length of data buffer is incorrect */
+    ARM_MATH_SIZE_MISMATCH  = -3,        /**< Size of matrices is not compatible with the operation */
+    ARM_MATH_NANINF         = -4,        /**< Not-a-number (NaN) or infinity is generated */
+    ARM_MATH_SINGULAR       = -5,        /**< Input matrix is singular and cannot be inverted */
+    ARM_MATH_TEST_FAILURE   = -6         /**< Test Failed */
   } arm_status;
 
   /**
@@ -440,87 +413,261 @@ extern "C"
    */
   typedef double float64_t;
 
-  /**
-   * @brief definition to read/write two 16 bit values.
-   */
+
+/**
+  @brief definition to read/write two 16 bit values.
+  @deprecated
+ */
 #if   defined ( __CC_ARM )
   #define __SIMD32_TYPE int32_t __packed
-  #define CMSIS_UNUSED __attribute__((unused))
-  #define CMSIS_INLINE __attribute__((always_inline))
-
 #elif defined ( __ARMCC_VERSION ) && ( __ARMCC_VERSION >= 6010050 )
   #define __SIMD32_TYPE int32_t
-  #define CMSIS_UNUSED __attribute__((unused))
-  #define CMSIS_INLINE __attribute__((always_inline))
-
 #elif defined ( __GNUC__ )
   #define __SIMD32_TYPE int32_t
-  #define CMSIS_UNUSED __attribute__((unused))
-  #define CMSIS_INLINE __attribute__((always_inline))
-
 #elif defined ( __ICCARM__ )
   #define __SIMD32_TYPE int32_t __packed
-  #define CMSIS_UNUSED
-  #define CMSIS_INLINE
-
 #elif defined ( __TI_ARM__ )
   #define __SIMD32_TYPE int32_t
-  #define CMSIS_UNUSED __attribute__((unused))
-  #define CMSIS_INLINE
-
 #elif defined ( __CSMC__ )
   #define __SIMD32_TYPE int32_t
-  #define CMSIS_UNUSED
-  #define CMSIS_INLINE
-
 #elif defined ( __TASKING__ )
-  #define __SIMD32_TYPE __unaligned int32_t
-  #define CMSIS_UNUSED
-  #define CMSIS_INLINE
-
+  #define __SIMD32_TYPE __un(aligned) int32_t
+#elif defined(_MSC_VER )
+  #define __SIMD32_TYPE int32_t
 #else
   #error Unknown compiler
 #endif
 
 #define __SIMD32(addr)        (*(__SIMD32_TYPE **) & (addr))
-#define __SIMD32_CONST(addr)  ((__SIMD32_TYPE *)(addr))
-#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE *)  (addr))
-#define __SIMD64(addr)        (*(int64_t **) & (addr))
+#define __SIMD32_CONST(addr)  ( (__SIMD32_TYPE * )   (addr))
+#define _SIMD32_OFFSET(addr)  (*(__SIMD32_TYPE * )   (addr))
+#define __SIMD64(addr)        (*(      int64_t **) & (addr))
 
-#if !defined (ARM_MATH_DSP)
+/* SIMD replacement */
+
+
+/**
+  @brief         Read 2 Q15 from Q15 pointer.
+  @param[in]     pQ15      points to input value
+  @return        Q31 value
+ */
+__STATIC_FORCEINLINE q31_t read_q15x2 (
+  q15_t * pQ15)
+{
+  q31_t val;
+
+  memcpy (&val, pQ15, 4);
+
+  return (val);
+}
+
+/**
+  @brief         Read 2 Q15 from Q15 pointer and increment pointer afterwards.
+  @param[in]     pQ15      points to input value
+  @return        Q31 value
+ */
+__STATIC_FORCEINLINE q31_t read_q15x2_ia (
+  q15_t ** pQ15)
+{
+  q31_t val;
+
+  memcpy (&val, *pQ15, 4);
+  *pQ15 += 2;
+
+  return (val);
+}
+
+/**
+  @brief         Read 2 Q15 from Q15 pointer and decrement pointer afterwards.
+  @param[in]     pQ15      points to input value
+  @return        Q31 value
+ */
+__STATIC_FORCEINLINE q31_t read_q15x2_da (
+  q15_t ** pQ15)
+{
+  q31_t val;
+
+  memcpy (&val, *pQ15, 4);
+  *pQ15 -= 2;
+
+  return (val);
+}
+
+/**
+  @brief         Write 2 Q15 to Q15 pointer and increment pointer afterwards.
+  @param[in]     pQ15      points to input value
+  @param[in]     value     Q31 value
+  @return        none
+ */
+__STATIC_FORCEINLINE void write_q15x2_ia (
+  q15_t ** pQ15,
+  q31_t    value)
+{
+  q31_t val = value;
+
+  memcpy (*pQ15, &val, 4);
+  *pQ15 += 2;
+}
+
+/**
+  @brief         Write 2 Q15 to Q15 pointer.
+  @param[in]     pQ15      points to input value
+  @param[in]     value     Q31 value
+  @return        none
+ */
+__STATIC_FORCEINLINE void write_q15x2 (
+  q15_t * pQ15,
+  q31_t   value)
+{
+  q31_t val = value;
+
+  memcpy (pQ15, &val, 4);
+}
+
+
+/**
+  @brief         Read 4 Q7 from Q7 pointer and increment pointer afterwards.
+  @param[in]     pQ7       points to input value
+  @return        Q31 value
+ */
+__STATIC_FORCEINLINE q31_t read_q7x4_ia (
+  q7_t ** pQ7)
+{
+  q31_t val;
+
+  memcpy (&val, *pQ7, 4);
+  *pQ7 += 4;
+
+  return (val);
+}
+
+/**
+  @brief         Read 4 Q7 from Q7 pointer and decrement pointer afterwards.
+  @param[in]     pQ7       points to input value
+  @return        Q31 value
+ */
+__STATIC_FORCEINLINE q31_t read_q7x4_da (
+  q7_t ** pQ7)
+{
+  q31_t val;
+
+  memcpy (&val, *pQ7, 4);
+  *pQ7 -= 4;
+
+  return (val);
+}
+
+/**
+  @brief         Write 4 Q7 to Q7 pointer and increment pointer afterwards.
+  @param[in]     pQ7       points to input value
+  @param[in]     value     Q31 value
+  @return        none
+ */
+__STATIC_FORCEINLINE void write_q7x4_ia (
+  q7_t ** pQ7,
+  q31_t   value)
+{
+  q31_t val = value;
+
+  memcpy (*pQ7, &val, 4);
+  *pQ7 += 4;
+}
+
+/*
+
+Normally those kind of definitions are in a compiler file
+in Core or Core_A.
+
+But for MSVC compiler it is a bit special. The goal is very specific
+to CMSIS-DSP and only to allow the use of this library from other
+systems like Python or Matlab.
+
+MSVC is not going to be used to cross-compile to ARM. So, having a MSVC
+compiler file in Core or Core_A would not make sense.
+
+*/
+#if defined ( _MSC_VER )
+    __STATIC_FORCEINLINE uint8_t __CLZ(uint32_t data)
+    {
+      if (data == 0U) { return 32U; }
+
+      uint32_t count = 0U;
+      uint32_t mask = 0x80000000U;
+
+      while ((data & mask) == 0U)
+      {
+        count += 1U;
+        mask = mask >> 1U;
+      }
+      return count;
+    }
+
+  __STATIC_FORCEINLINE int32_t __SSAT(int32_t val, uint32_t sat)
+  {
+    if ((sat >= 1U) && (sat <= 32U))
+    {
+      const int32_t max = (int32_t)((1U << (sat - 1U)) - 1U);
+      const int32_t min = -1 - max ;
+      if (val > max)
+      {
+        return max;
+      }
+      else if (val < min)
+      {
+        return min;
+      }
+    }
+    return val;
+  }
+
+  __STATIC_FORCEINLINE uint32_t __USAT(int32_t val, uint32_t sat)
+  {
+    if (sat <= 31U)
+    {
+      const uint32_t max = ((1U << sat) - 1U);
+      if (val > (int32_t)max)
+      {
+        return max;
+      }
+      else if (val < 0)
+      {
+        return 0U;
+      }
+    }
+    return (uint32_t)val;
+  }
+#endif
+
+#ifndef ARM_MATH_DSP
   /**
    * @brief definition to pack two 16 bit values.
    */
-#define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
-                                    (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
-#define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
-                                    (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
-
-#endif /* !defined (ARM_MATH_DSP) */
+  #define __PKHBT(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0x0000FFFF) | \
+                                      (((int32_t)(ARG2) << ARG3) & (int32_t)0xFFFF0000)  )
+  #define __PKHTB(ARG1, ARG2, ARG3) ( (((int32_t)(ARG1) <<    0) & (int32_t)0xFFFF0000) | \
+                                      (((int32_t)(ARG2) >> ARG3) & (int32_t)0x0000FFFF)  )
+#endif
 
    /**
    * @brief definition to pack four 8 bit values.
    */
 #ifndef ARM_MATH_BIG_ENDIAN
-
-#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
-                                (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
-                                (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
-                                (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
+  #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v0) <<  0) & (int32_t)0x000000FF) | \
+                                  (((int32_t)(v1) <<  8) & (int32_t)0x0000FF00) | \
+                                  (((int32_t)(v2) << 16) & (int32_t)0x00FF0000) | \
+                                  (((int32_t)(v3) << 24) & (int32_t)0xFF000000)  )
 #else
-
-#define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
-                                (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
-                                (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
-                                (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
-
+  #define __PACKq7(v0,v1,v2,v3) ( (((int32_t)(v3) <<  0) & (int32_t)0x000000FF) | \
+                                  (((int32_t)(v2) <<  8) & (int32_t)0x0000FF00) | \
+                                  (((int32_t)(v1) << 16) & (int32_t)0x00FF0000) | \
+                                  (((int32_t)(v0) << 24) & (int32_t)0xFF000000)  )
 #endif
 
 
   /**
    * @brief Clips Q63 to Q31 values.
    */
-  CMSIS_INLINE __STATIC_INLINE q31_t clip_q63_to_q31(
+  __STATIC_FORCEINLINE q31_t clip_q63_to_q31(
   q63_t x)
   {
     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
@@ -530,7 +677,7 @@ extern "C"
   /**
    * @brief Clips Q63 to Q15 values.
    */
-  CMSIS_INLINE __STATIC_INLINE q15_t clip_q63_to_q15(
+  __STATIC_FORCEINLINE q15_t clip_q63_to_q15(
   q63_t x)
   {
     return ((q31_t) (x >> 32) != ((q31_t) x >> 31)) ?
@@ -540,7 +687,7 @@ extern "C"
   /**
    * @brief Clips Q31 to Q7 values.
    */
-  CMSIS_INLINE __STATIC_INLINE q7_t clip_q31_to_q7(
+  __STATIC_FORCEINLINE q7_t clip_q31_to_q7(
   q31_t x)
   {
     return ((q31_t) (x >> 24) != ((q31_t) x >> 23)) ?
@@ -550,7 +697,7 @@ extern "C"
   /**
    * @brief Clips Q31 to Q15 values.
    */
-  CMSIS_INLINE __STATIC_INLINE q15_t clip_q31_to_q15(
+  __STATIC_FORCEINLINE q15_t clip_q31_to_q15(
   q31_t x)
   {
     return ((q31_t) (x >> 16) != ((q31_t) x >> 15)) ?
@@ -560,23 +707,21 @@ extern "C"
   /**
    * @brief Multiplies 32 X 64 and returns 32 bit result in 2.30 format.
    */
-
-  CMSIS_INLINE __STATIC_INLINE q63_t mult32x64(
+  __STATIC_FORCEINLINE q63_t mult32x64(
   q63_t x,
   q31_t y)
   {
     return ((((q63_t) (x & 0x00000000FFFFFFFF) * y) >> 32) +
-            (((q63_t) (x >> 32) * y)));
+            (((q63_t) (x >> 32)                * y)      )  );
   }
 
   /**
    * @brief Function to Calculates 1/in (reciprocal) value of Q31 Data type.
    */
-
-  CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q31(
-  q31_t in,
-  q31_t * dst,
-  q31_t * pRecipTable)
+  __STATIC_FORCEINLINE uint32_t arm_recip_q31(
+        q31_t in,
+        q31_t * dst,
+  const q31_t * pRecipTable)
   {
     q31_t out;
     uint32_t tempVal;
@@ -624,10 +769,10 @@ extern "C"
   /**
    * @brief Function to Calculates 1/in (reciprocal) value of Q15 Data type.
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t arm_recip_q15(
-  q15_t in,
-  q15_t * dst,
-  q15_t * pRecipTable)
+  __STATIC_FORCEINLINE uint32_t arm_recip_q15(
+        q15_t in,
+        q15_t * dst,
+  const q15_t * pRecipTable)
   {
     q15_t out = 0;
     uint32_t tempVal = 0;
@@ -671,16 +816,55 @@ extern "C"
     return (signBits + 1);
   }
 
+#if defined(ARM_MATH_NEON)
+
+static inline float32x4_t __arm_vec_sqrt_f32_neon(float32x4_t  x)
+{
+    float32x4_t x1 = vmaxq_f32(x, vdupq_n_f32(FLT_MIN));
+    float32x4_t e = vrsqrteq_f32(x1);
+    e = vmulq_f32(vrsqrtsq_f32(vmulq_f32(x1, e), e), e);
+    e = vmulq_f32(vrsqrtsq_f32(vmulq_f32(x1, e), e), e);
+    return vmulq_f32(x, e);
+}
+
+static inline int16x8_t __arm_vec_sqrt_q15_neon(int16x8_t vec)
+{
+    float32x4_t tempF;
+    int32x4_t tempHI,tempLO;
+
+    tempLO = vmovl_s16(vget_low_s16(vec));
+    tempF = vcvtq_n_f32_s32(tempLO,15);
+    tempF = __arm_vec_sqrt_f32_neon(tempF);
+    tempLO = vcvtq_n_s32_f32(tempF,15);
+
+    tempHI = vmovl_s16(vget_high_s16(vec));
+    tempF = vcvtq_n_f32_s32(tempHI,15);
+    tempF = __arm_vec_sqrt_f32_neon(tempF);
+    tempHI = vcvtq_n_s32_f32(tempF,15);
+
+    return(vcombine_s16(vqmovn_s32(tempLO),vqmovn_s32(tempHI)));
+}
+
+static inline int32x4_t __arm_vec_sqrt_q31_neon(int32x4_t vec)
+{
+  float32x4_t temp;
+
+  temp = vcvtq_n_f32_s32(vec,31);
+  temp = __arm_vec_sqrt_f32_neon(temp);
+  return(vcvtq_n_s32_f32(temp,31));
+}
+
+#endif
 
 /*
- * @brief C custom defined intrinsic function for M3 and M0 processors
+ * @brief C custom defined intrinsic functions
  */
 #if !defined (ARM_MATH_DSP)
 
   /*
-   * @brief C custom defined QADD8 for M3 and M0 processors
+   * @brief C custom defined QADD8
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __QADD8(
+  __STATIC_FORCEINLINE uint32_t __QADD8(
   uint32_t x,
   uint32_t y)
   {
@@ -696,9 +880,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QSUB8 for M3 and M0 processors
+   * @brief C custom defined QSUB8
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB8(
+  __STATIC_FORCEINLINE uint32_t __QSUB8(
   uint32_t x,
   uint32_t y)
   {
@@ -714,9 +898,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QADD16 for M3 and M0 processors
+   * @brief C custom defined QADD16
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __QADD16(
+  __STATIC_FORCEINLINE uint32_t __QADD16(
   uint32_t x,
   uint32_t y)
   {
@@ -731,9 +915,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SHADD16 for M3 and M0 processors
+   * @brief C custom defined SHADD16
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SHADD16(
+  __STATIC_FORCEINLINE uint32_t __SHADD16(
   uint32_t x,
   uint32_t y)
   {
@@ -747,9 +931,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QSUB16 for M3 and M0 processors
+   * @brief C custom defined QSUB16
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __QSUB16(
+  __STATIC_FORCEINLINE uint32_t __QSUB16(
   uint32_t x,
   uint32_t y)
   {
@@ -763,9 +947,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SHSUB16 for M3 and M0 processors
+   * @brief C custom defined SHSUB16
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SHSUB16(
+  __STATIC_FORCEINLINE uint32_t __SHSUB16(
   uint32_t x,
   uint32_t y)
   {
@@ -779,9 +963,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QASX for M3 and M0 processors
+   * @brief C custom defined QASX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __QASX(
+  __STATIC_FORCEINLINE uint32_t __QASX(
   uint32_t x,
   uint32_t y)
   {
@@ -795,9 +979,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SHASX for M3 and M0 processors
+   * @brief C custom defined SHASX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SHASX(
+  __STATIC_FORCEINLINE uint32_t __SHASX(
   uint32_t x,
   uint32_t y)
   {
@@ -811,9 +995,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QSAX for M3 and M0 processors
+   * @brief C custom defined QSAX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __QSAX(
+  __STATIC_FORCEINLINE uint32_t __QSAX(
   uint32_t x,
   uint32_t y)
   {
@@ -827,9 +1011,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SHSAX for M3 and M0 processors
+   * @brief C custom defined SHSAX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SHSAX(
+  __STATIC_FORCEINLINE uint32_t __SHSAX(
   uint32_t x,
   uint32_t y)
   {
@@ -843,9 +1027,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMUSDX for M3 and M0 processors
+   * @brief C custom defined SMUSDX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSDX(
+  __STATIC_FORCEINLINE uint32_t __SMUSDX(
   uint32_t x,
   uint32_t y)
   {
@@ -854,9 +1038,9 @@ extern "C"
   }
 
   /*
-   * @brief C custom defined SMUADX for M3 and M0 processors
+   * @brief C custom defined SMUADX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUADX(
+  __STATIC_FORCEINLINE uint32_t __SMUADX(
   uint32_t x,
   uint32_t y)
   {
@@ -866,9 +1050,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QADD for M3 and M0 processors
+   * @brief C custom defined QADD
    */
-  CMSIS_INLINE __STATIC_INLINE int32_t __QADD(
+  __STATIC_FORCEINLINE int32_t __QADD(
   int32_t x,
   int32_t y)
   {
@@ -877,9 +1061,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined QSUB for M3 and M0 processors
+   * @brief C custom defined QSUB
    */
-  CMSIS_INLINE __STATIC_INLINE int32_t __QSUB(
+  __STATIC_FORCEINLINE int32_t __QSUB(
   int32_t x,
   int32_t y)
   {
@@ -888,9 +1072,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMLAD for M3 and M0 processors
+   * @brief C custom defined SMLAD
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMLAD(
+  __STATIC_FORCEINLINE uint32_t __SMLAD(
   uint32_t x,
   uint32_t y,
   uint32_t sum)
@@ -902,9 +1086,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMLADX for M3 and M0 processors
+   * @brief C custom defined SMLADX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMLADX(
+  __STATIC_FORCEINLINE uint32_t __SMLADX(
   uint32_t x,
   uint32_t y,
   uint32_t sum)
@@ -916,9 +1100,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMLSDX for M3 and M0 processors
+   * @brief C custom defined SMLSDX
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMLSDX(
+  __STATIC_FORCEINLINE uint32_t __SMLSDX(
   uint32_t x,
   uint32_t y,
   uint32_t sum)
@@ -930,9 +1114,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMLALD for M3 and M0 processors
+   * @brief C custom defined SMLALD
    */
-  CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALD(
+  __STATIC_FORCEINLINE uint64_t __SMLALD(
   uint32_t x,
   uint32_t y,
   uint64_t sum)
@@ -945,9 +1129,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMLALDX for M3 and M0 processors
+   * @brief C custom defined SMLALDX
    */
-  CMSIS_INLINE __STATIC_INLINE uint64_t __SMLALDX(
+  __STATIC_FORCEINLINE uint64_t __SMLALDX(
   uint32_t x,
   uint32_t y,
   uint64_t sum)
@@ -960,9 +1144,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMUAD for M3 and M0 processors
+   * @brief C custom defined SMUAD
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUAD(
+  __STATIC_FORCEINLINE uint32_t __SMUAD(
   uint32_t x,
   uint32_t y)
   {
@@ -972,9 +1156,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SMUSD for M3 and M0 processors
+   * @brief C custom defined SMUSD
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SMUSD(
+  __STATIC_FORCEINLINE uint32_t __SMUSD(
   uint32_t x,
   uint32_t y)
   {
@@ -984,9 +1168,9 @@ extern "C"
 
 
   /*
-   * @brief C custom defined SXTB16 for M3 and M0 processors
+   * @brief C custom defined SXTB16
    */
-  CMSIS_INLINE __STATIC_INLINE uint32_t __SXTB16(
+  __STATIC_FORCEINLINE uint32_t __SXTB16(
   uint32_t x)
   {
     return ((uint32_t)(((((q31_t)x << 24) >> 24) & (q31_t)0x0000FFFF) |
@@ -994,9 +1178,9 @@ extern "C"
   }
 
   /*
-   * @brief C custom defined SMMLA for M3 and M0 processors
+   * @brief C custom defined SMMLA
    */
-  CMSIS_INLINE __STATIC_INLINE int32_t __SMMLA(
+  __STATIC_FORCEINLINE int32_t __SMMLA(
   int32_t x,
   int32_t y,
   int32_t sum)
@@ -1012,9 +1196,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numTaps;        /**< number of filter coefficients in the filter. */
-    q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
+          uint16_t numTaps;        /**< number of filter coefficients in the filter. */
+          q7_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    const q7_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
   } arm_fir_instance_q7;
 
   /**
@@ -1022,9 +1206,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
-    q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
+          uint16_t numTaps;         /**< number of filter coefficients in the filter. */
+          q15_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    const q15_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
   } arm_fir_instance_q15;
 
   /**
@@ -1032,9 +1216,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numTaps;         /**< number of filter coefficients in the filter. */
-    q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
+          uint16_t numTaps;         /**< number of filter coefficients in the filter. */
+          q31_t *pState;            /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    const q31_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps. */
   } arm_fir_instance_q31;
 
   /**
@@ -1042,12 +1226,11 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numTaps;     /**< number of filter coefficients in the filter. */
-    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
+          uint16_t numTaps;     /**< number of filter coefficients in the filter. */
+          float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+    const float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
   } arm_fir_instance_f32;
 
-
   /**
    * @brief Processing function for the Q7 FIR filter.
    * @param[in]  S          points to an instance of the Q7 FIR filter structure.
@@ -1057,10 +1240,9 @@ extern "C"
    */
   void arm_fir_q7(
   const arm_fir_instance_q7 * S,
-  q7_t * pSrc,
-  q7_t * pDst,
-  uint32_t blockSize);
-
+  const q7_t * pSrc,
+        q7_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the Q7 FIR filter.
@@ -1071,12 +1253,11 @@ extern "C"
    * @param[in]     blockSize  number of samples that are processed.
    */
   void arm_fir_init_q7(
-  arm_fir_instance_q7 * S,
-  uint16_t numTaps,
-  q7_t * pCoeffs,
-  q7_t * pState,
-  uint32_t blockSize);
-
+        arm_fir_instance_q7 * S,
+        uint16_t numTaps,
+  const q7_t * pCoeffs,
+        q7_t * pState,
+        uint32_t blockSize);
 
   /**
    * @brief Processing function for the Q15 FIR filter.
@@ -1087,13 +1268,12 @@ extern "C"
    */
   void arm_fir_q15(
   const arm_fir_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
-
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
   /**
-   * @brief Processing function for the fast Q15 FIR filter for Cortex-M3 and Cortex-M4.
+   * @brief Processing function for the fast Q15 FIR filter (fast version).
    * @param[in]  S          points to an instance of the Q15 FIR filter structure.
    * @param[in]  pSrc       points to the block of input data.
    * @param[out] pDst       points to the block of output data.
@@ -1101,10 +1281,9 @@ extern "C"
    */
   void arm_fir_fast_q15(
   const arm_fir_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
-
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the Q15 FIR filter.
@@ -1113,16 +1292,16 @@ extern "C"
    * @param[in]     pCoeffs    points to the filter coefficients.
    * @param[in]     pState     points to the state buffer.
    * @param[in]     blockSize  number of samples that are processed at a time.
-   * @return The function returns ARM_MATH_SUCCESS if initialization was successful or ARM_MATH_ARGUMENT_ERROR if
-   * <code>numTaps</code> is not a supported value.
+   * @return     The function returns either
+   * <code>ARM_MATH_SUCCESS</code> if initialization was successful or
+   * <code>ARM_MATH_ARGUMENT_ERROR</code> if <code>numTaps</code> is not a supported value.
    */
   arm_status arm_fir_init_q15(
-  arm_fir_instance_q15 * S,
-  uint16_t numTaps,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  uint32_t blockSize);
-
+        arm_fir_instance_q15 * S,
+        uint16_t numTaps,
+  const q15_t * pCoeffs,
+        q15_t * pState,
+        uint32_t blockSize);
 
   /**
    * @brief Processing function for the Q31 FIR filter.
@@ -1133,24 +1312,22 @@ extern "C"
    */
   void arm_fir_q31(
   const arm_fir_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
-
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
   /**
-   * @brief Processing function for the fast Q31 FIR filter for Cortex-M3 and Cortex-M4.
-   * @param[in]  S          points to an instance of the Q31 FIR structure.
+   * @brief Processing function for the fast Q31 FIR filter (fast version).
+   * @param[in]  S          points to an instance of the Q31 FIR filter structure.
    * @param[in]  pSrc       points to the block of input data.
    * @param[out] pDst       points to the block of output data.
    * @param[in]  blockSize  number of samples to process.
    */
   void arm_fir_fast_q31(
   const arm_fir_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
-
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the Q31 FIR filter.
@@ -1161,12 +1338,11 @@ extern "C"
    * @param[in]     blockSize  number of samples that are processed at a time.
    */
   void arm_fir_init_q31(
-  arm_fir_instance_q31 * S,
-  uint16_t numTaps,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  uint32_t blockSize);
-
+        arm_fir_instance_q31 * S,
+        uint16_t numTaps,
+  const q31_t * pCoeffs,
+        q31_t * pState,
+        uint32_t blockSize);
 
   /**
    * @brief Processing function for the floating-point FIR filter.
@@ -1177,10 +1353,9 @@ extern "C"
    */
   void arm_fir_f32(
   const arm_fir_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
-
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the floating-point FIR filter.
@@ -1191,22 +1366,21 @@ extern "C"
    * @param[in]     blockSize  number of samples that are processed at a time.
    */
   void arm_fir_init_f32(
-  arm_fir_instance_f32 * S,
-  uint16_t numTaps,
-  float32_t * pCoeffs,
-  float32_t * pState,
-  uint32_t blockSize);
-
+        arm_fir_instance_f32 * S,
+        uint16_t numTaps,
+  const float32_t * pCoeffs,
+        float32_t * pState,
+        uint32_t blockSize);
 
   /**
    * @brief Instance structure for the Q15 Biquad cascade filter.
    */
   typedef struct
   {
-    int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    q15_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
-    q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
-    int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
+          int8_t numStages;        /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          q15_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
+    const q15_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
+          int8_t postShift;        /**< Additional shift, in bits, applied to each output sample. */
   } arm_biquad_casd_df1_inst_q15;
 
   /**
@@ -1214,10 +1388,10 @@ extern "C"
    */
   typedef struct
   {
-    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
-    q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
-    uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
+          uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          q31_t *pState;           /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
+    const q31_t *pCoeffs;          /**< Points to the array of coefficients.  The array is of length 5*numStages. */
+          uint8_t postShift;       /**< Additional shift, in bits, applied to each output sample. */
   } arm_biquad_casd_df1_inst_q31;
 
   /**
@@ -1225,12 +1399,11 @@ extern "C"
    */
   typedef struct
   {
-    uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    float32_t *pState;       /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
-    float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*numStages. */
+          uint32_t numStages;      /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          float32_t *pState;       /**< Points to the array of state coefficients.  The array is of length 4*numStages. */
+    const float32_t *pCoeffs;      /**< Points to the array of coefficients.  The array is of length 5*numStages. */
   } arm_biquad_casd_df1_inst_f32;
 
-
   /**
    * @brief Processing function for the Q15 Biquad cascade filter.
    * @param[in]  S          points to an instance of the Q15 Biquad cascade structure.
@@ -1240,10 +1413,9 @@ extern "C"
    */
   void arm_biquad_cascade_df1_q15(
   const arm_biquad_casd_df1_inst_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
-
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the Q15 Biquad cascade filter.
@@ -1254,12 +1426,11 @@ extern "C"
    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format
    */
   void arm_biquad_cascade_df1_init_q15(
-  arm_biquad_casd_df1_inst_q15 * S,
-  uint8_t numStages,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  int8_t postShift);
-
+        arm_biquad_casd_df1_inst_q15 * S,
+        uint8_t numStages,
+  const q15_t * pCoeffs,
+        q15_t * pState,
+        int8_t postShift);
 
   /**
    * @brief Fast but less precise processing function for the Q15 Biquad cascade filter for Cortex-M3 and Cortex-M4.
@@ -1270,10 +1441,9 @@ extern "C"
    */
   void arm_biquad_cascade_df1_fast_q15(
   const arm_biquad_casd_df1_inst_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
-
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief Processing function for the Q31 Biquad cascade filter
@@ -1284,10 +1454,9 @@ extern "C"
    */
   void arm_biquad_cascade_df1_q31(
   const arm_biquad_casd_df1_inst_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
-
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief Fast but less precise processing function for the Q31 Biquad cascade filter for Cortex-M3 and Cortex-M4.
@@ -1298,10 +1467,9 @@ extern "C"
    */
   void arm_biquad_cascade_df1_fast_q31(
   const arm_biquad_casd_df1_inst_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
-
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the Q31 Biquad cascade filter.
@@ -1312,12 +1480,11 @@ extern "C"
    * @param[in]     postShift  Shift to be applied to the output. Varies according to the coefficients format
    */
   void arm_biquad_cascade_df1_init_q31(
-  arm_biquad_casd_df1_inst_q31 * S,
-  uint8_t numStages,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  int8_t postShift);
-
+        arm_biquad_casd_df1_inst_q31 * S,
+        uint8_t numStages,
+  const q31_t * pCoeffs,
+        q31_t * pState,
+        int8_t postShift);
 
   /**
    * @brief Processing function for the floating-point Biquad cascade filter.
@@ -1328,10 +1495,9 @@ extern "C"
    */
   void arm_biquad_cascade_df1_f32(
   const arm_biquad_casd_df1_inst_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
-
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief  Initialization function for the floating-point Biquad cascade filter.
@@ -1341,11 +1507,10 @@ extern "C"
    * @param[in]     pState     points to the state buffer.
    */
   void arm_biquad_cascade_df1_init_f32(
-  arm_biquad_casd_df1_inst_f32 * S,
-  uint8_t numStages,
-  float32_t * pCoeffs,
-  float32_t * pState);
-
+        arm_biquad_casd_df1_inst_f32 * S,
+        uint8_t numStages,
+  const float32_t * pCoeffs,
+        float32_t * pState);
 
   /**
    * @brief Instance structure for the floating-point matrix structure.
@@ -1388,7 +1553,6 @@ extern "C"
     q31_t *pData;         /**< points to the data of the matrix. */
   } arm_matrix_instance_q31;
 
-
   /**
    * @brief Floating-point matrix addition.
    * @param[in]  pSrcA  points to the first input matrix structure
@@ -1397,11 +1561,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_add_f32(
+arm_status arm_mat_add_f32(
   const arm_matrix_instance_f32 * pSrcA,
   const arm_matrix_instance_f32 * pSrcB,
-  arm_matrix_instance_f32 * pDst);
-
+        arm_matrix_instance_f32 * pDst);
 
   /**
    * @brief Q15 matrix addition.
@@ -1411,11 +1574,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_add_q15(
+arm_status arm_mat_add_q15(
   const arm_matrix_instance_q15 * pSrcA,
   const arm_matrix_instance_q15 * pSrcB,
-  arm_matrix_instance_q15 * pDst);
-
+        arm_matrix_instance_q15 * pDst);
 
   /**
    * @brief Q31 matrix addition.
@@ -1425,11 +1587,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_add_q31(
+arm_status arm_mat_add_q31(
   const arm_matrix_instance_q31 * pSrcA,
   const arm_matrix_instance_q31 * pSrcB,
-  arm_matrix_instance_q31 * pDst);
-
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief Floating-point, complex, matrix multiplication.
@@ -1439,11 +1600,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_cmplx_mult_f32(
+arm_status arm_mat_cmplx_mult_f32(
   const arm_matrix_instance_f32 * pSrcA,
   const arm_matrix_instance_f32 * pSrcB,
-  arm_matrix_instance_f32 * pDst);
-
+        arm_matrix_instance_f32 * pDst);
 
   /**
    * @brief Q15, complex,  matrix multiplication.
@@ -1453,12 +1613,11 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_cmplx_mult_q15(
+arm_status arm_mat_cmplx_mult_q15(
   const arm_matrix_instance_q15 * pSrcA,
   const arm_matrix_instance_q15 * pSrcB,
-  arm_matrix_instance_q15 * pDst,
-  q15_t * pScratch);
-
+        arm_matrix_instance_q15 * pDst,
+        q15_t * pScratch);
 
   /**
    * @brief Q31, complex, matrix multiplication.
@@ -1468,11 +1627,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_cmplx_mult_q31(
+arm_status arm_mat_cmplx_mult_q31(
   const arm_matrix_instance_q31 * pSrcA,
   const arm_matrix_instance_q31 * pSrcB,
-  arm_matrix_instance_q31 * pDst);
-
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief Floating-point matrix transpose.
@@ -1481,10 +1639,9 @@ extern "C"
    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_trans_f32(
+arm_status arm_mat_trans_f32(
   const arm_matrix_instance_f32 * pSrc,
-  arm_matrix_instance_f32 * pDst);
-
+        arm_matrix_instance_f32 * pDst);
 
   /**
    * @brief Q15 matrix transpose.
@@ -1493,10 +1650,9 @@ extern "C"
    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_trans_q15(
+arm_status arm_mat_trans_q15(
   const arm_matrix_instance_q15 * pSrc,
-  arm_matrix_instance_q15 * pDst);
-
+        arm_matrix_instance_q15 * pDst);
 
   /**
    * @brief Q31 matrix transpose.
@@ -1505,10 +1661,9 @@ extern "C"
    * @return    The function returns either  <code>ARM_MATH_SIZE_MISMATCH</code>
    * or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_trans_q31(
+arm_status arm_mat_trans_q31(
   const arm_matrix_instance_q31 * pSrc,
-  arm_matrix_instance_q31 * pDst);
-
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief Floating-point matrix multiplication
@@ -1518,11 +1673,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_mult_f32(
+arm_status arm_mat_mult_f32(
   const arm_matrix_instance_f32 * pSrcA,
   const arm_matrix_instance_f32 * pSrcB,
-  arm_matrix_instance_f32 * pDst);
-
+        arm_matrix_instance_f32 * pDst);
 
   /**
    * @brief Q15 matrix multiplication
@@ -1533,12 +1687,11 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_mult_q15(
+arm_status arm_mat_mult_q15(
   const arm_matrix_instance_q15 * pSrcA,
   const arm_matrix_instance_q15 * pSrcB,
-  arm_matrix_instance_q15 * pDst,
-  q15_t * pState);
-
+        arm_matrix_instance_q15 * pDst,
+        q15_t * pState);
 
   /**
    * @brief Q15 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
@@ -1549,12 +1702,11 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_mult_fast_q15(
+arm_status arm_mat_mult_fast_q15(
   const arm_matrix_instance_q15 * pSrcA,
   const arm_matrix_instance_q15 * pSrcB,
-  arm_matrix_instance_q15 * pDst,
-  q15_t * pState);
-
+        arm_matrix_instance_q15 * pDst,
+        q15_t * pState);
 
   /**
    * @brief Q31 matrix multiplication
@@ -1564,11 +1716,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_mult_q31(
+arm_status arm_mat_mult_q31(
   const arm_matrix_instance_q31 * pSrcA,
   const arm_matrix_instance_q31 * pSrcB,
-  arm_matrix_instance_q31 * pDst);
-
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief Q31 matrix multiplication (fast variant) for Cortex-M3 and Cortex-M4
@@ -1578,11 +1729,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_mult_fast_q31(
+arm_status arm_mat_mult_fast_q31(
   const arm_matrix_instance_q31 * pSrcA,
   const arm_matrix_instance_q31 * pSrcB,
-  arm_matrix_instance_q31 * pDst);
-
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief Floating-point matrix subtraction
@@ -1592,11 +1742,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_sub_f32(
+arm_status arm_mat_sub_f32(
   const arm_matrix_instance_f32 * pSrcA,
   const arm_matrix_instance_f32 * pSrcB,
-  arm_matrix_instance_f32 * pDst);
-
+        arm_matrix_instance_f32 * pDst);
 
   /**
    * @brief Q15 matrix subtraction
@@ -1606,11 +1755,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_sub_q15(
+arm_status arm_mat_sub_q15(
   const arm_matrix_instance_q15 * pSrcA,
   const arm_matrix_instance_q15 * pSrcB,
-  arm_matrix_instance_q15 * pDst);
-
+        arm_matrix_instance_q15 * pDst);
 
   /**
    * @brief Q31 matrix subtraction
@@ -1620,11 +1768,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_sub_q31(
+arm_status arm_mat_sub_q31(
   const arm_matrix_instance_q31 * pSrcA,
   const arm_matrix_instance_q31 * pSrcB,
-  arm_matrix_instance_q31 * pDst);
-
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief Floating-point matrix scaling.
@@ -1634,11 +1781,10 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_scale_f32(
+arm_status arm_mat_scale_f32(
   const arm_matrix_instance_f32 * pSrc,
-  float32_t scale,
-  arm_matrix_instance_f32 * pDst);
-
+        float32_t scale,
+        arm_matrix_instance_f32 * pDst);
 
   /**
    * @brief Q15 matrix scaling.
@@ -1649,12 +1795,11 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_scale_q15(
+arm_status arm_mat_scale_q15(
   const arm_matrix_instance_q15 * pSrc,
-  q15_t scaleFract,
-  int32_t shift,
-  arm_matrix_instance_q15 * pDst);
-
+        q15_t scaleFract,
+        int32_t shift,
+        arm_matrix_instance_q15 * pDst);
 
   /**
    * @brief Q31 matrix scaling.
@@ -1665,12 +1810,11 @@ extern "C"
    * @return     The function returns either
    * <code>ARM_MATH_SIZE_MISMATCH</code> or <code>ARM_MATH_SUCCESS</code> based on the outcome of size checking.
    */
-  arm_status arm_mat_scale_q31(
+arm_status arm_mat_scale_q31(
   const arm_matrix_instance_q31 * pSrc,
-  q31_t scaleFract,
-  int32_t shift,
-  arm_matrix_instance_q31 * pDst);
-
+        q31_t scaleFract,
+        int32_t shift,
+        arm_matrix_instance_q31 * pDst);
 
   /**
    * @brief  Q31 matrix initialization.
@@ -1679,12 +1823,11 @@ extern "C"
    * @param[in]     nColumns  number of columns in the matrix.
    * @param[in]     pData     points to the matrix data array.
    */
-  void arm_mat_init_q31(
-  arm_matrix_instance_q31 * S,
-  uint16_t nRows,
-  uint16_t nColumns,
-  q31_t * pData);
-
+void arm_mat_init_q31(
+        arm_matrix_instance_q31 * S,
+        uint16_t nRows,
+        uint16_t nColumns,
+        q31_t * pData);
 
   /**
    * @brief  Q15 matrix initialization.
@@ -1693,12 +1836,11 @@ extern "C"
    * @param[in]     nColumns  number of columns in the matrix.
    * @param[in]     pData     points to the matrix data array.
    */
-  void arm_mat_init_q15(
-  arm_matrix_instance_q15 * S,
-  uint16_t nRows,
-  uint16_t nColumns,
-  q15_t * pData);
-
+void arm_mat_init_q15(
+        arm_matrix_instance_q15 * S,
+        uint16_t nRows,
+        uint16_t nColumns,
+        q15_t * pData);
 
   /**
    * @brief  Floating-point matrix initialization.
@@ -1707,12 +1849,11 @@ extern "C"
    * @param[in]     nColumns  number of columns in the matrix.
    * @param[in]     pData     points to the matrix data array.
    */
-  void arm_mat_init_f32(
-  arm_matrix_instance_f32 * S,
-  uint16_t nRows,
-  uint16_t nColumns,
-  float32_t * pData);
-
+void arm_mat_init_f32(
+        arm_matrix_instance_f32 * S,
+        uint16_t nRows,
+        uint16_t nColumns,
+        float32_t * pData);
 
 
   /**
@@ -1720,17 +1861,17 @@ extern "C"
    */
   typedef struct
   {
-    q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
+          q15_t A0;           /**< The derived gain, A0 = Kp + Ki + Kd . */
 #if !defined (ARM_MATH_DSP)
-    q15_t A1;
-    q15_t A2;
+          q15_t A1;
+          q15_t A2;
 #else
-    q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
+          q31_t A1;           /**< The derived gain A1 = -Kp - 2Kd | Kd.*/
 #endif
-    q15_t state[3];     /**< The state array of length 3. */
-    q15_t Kp;           /**< The proportional gain. */
-    q15_t Ki;           /**< The integral gain. */
-    q15_t Kd;           /**< The derivative gain. */
+          q15_t state[3];     /**< The state array of length 3. */
+          q15_t Kp;           /**< The proportional gain. */
+          q15_t Ki;           /**< The integral gain. */
+          q15_t Kd;           /**< The derivative gain. */
   } arm_pid_instance_q15;
 
   /**
@@ -1738,13 +1879,13 @@ extern "C"
    */
   typedef struct
   {
-    q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
-    q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
-    q31_t A2;            /**< The derived gain, A2 = Kd . */
-    q31_t state[3];      /**< The state array of length 3. */
-    q31_t Kp;            /**< The proportional gain. */
-    q31_t Ki;            /**< The integral gain. */
-    q31_t Kd;            /**< The derivative gain. */
+          q31_t A0;            /**< The derived gain, A0 = Kp + Ki + Kd . */
+          q31_t A1;            /**< The derived gain, A1 = -Kp - 2Kd. */
+          q31_t A2;            /**< The derived gain, A2 = Kd . */
+          q31_t state[3];      /**< The state array of length 3. */
+          q31_t Kp;            /**< The proportional gain. */
+          q31_t Ki;            /**< The integral gain. */
+          q31_t Kd;            /**< The derivative gain. */
   } arm_pid_instance_q31;
 
   /**
@@ -1752,13 +1893,13 @@ extern "C"
    */
   typedef struct
   {
-    float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
-    float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
-    float32_t A2;          /**< The derived gain, A2 = Kd . */
-    float32_t state[3];    /**< The state array of length 3. */
-    float32_t Kp;          /**< The proportional gain. */
-    float32_t Ki;          /**< The integral gain. */
-    float32_t Kd;          /**< The derivative gain. */
+          float32_t A0;          /**< The derived gain, A0 = Kp + Ki + Kd . */
+          float32_t A1;          /**< The derived gain, A1 = -Kp - 2Kd. */
+          float32_t A2;          /**< The derived gain, A2 = Kd . */
+          float32_t state[3];    /**< The state array of length 3. */
+          float32_t Kp;          /**< The proportional gain. */
+          float32_t Ki;          /**< The integral gain. */
+          float32_t Kd;          /**< The derivative gain. */
   } arm_pid_instance_f32;
 
 
@@ -1769,8 +1910,8 @@ extern "C"
    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
    */
   void arm_pid_init_f32(
-  arm_pid_instance_f32 * S,
-  int32_t resetStateFlag);
+        arm_pid_instance_f32 * S,
+        int32_t resetStateFlag);
 
 
   /**
@@ -1778,7 +1919,7 @@ extern "C"
    * @param[in,out] S  is an instance of the floating-point PID Control structure
    */
   void arm_pid_reset_f32(
-  arm_pid_instance_f32 * S);
+        arm_pid_instance_f32 * S);
 
 
   /**
@@ -1787,8 +1928,8 @@ extern "C"
    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
    */
   void arm_pid_init_q31(
-  arm_pid_instance_q31 * S,
-  int32_t resetStateFlag);
+        arm_pid_instance_q31 * S,
+        int32_t resetStateFlag);
 
 
   /**
@@ -1797,7 +1938,7 @@ extern "C"
    */
 
   void arm_pid_reset_q31(
-  arm_pid_instance_q31 * S);
+        arm_pid_instance_q31 * S);
 
 
   /**
@@ -1806,8 +1947,8 @@ extern "C"
    * @param[in]     resetStateFlag  flag to reset the state. 0 = no change in state 1 = reset the state.
    */
   void arm_pid_init_q15(
-  arm_pid_instance_q15 * S,
-  int32_t resetStateFlag);
+        arm_pid_instance_q15 * S,
+        int32_t resetStateFlag);
 
 
   /**
@@ -1815,7 +1956,7 @@ extern "C"
    * @param[in,out] S  points to an instance of the q15 PID Control structure
    */
   void arm_pid_reset_q15(
-  arm_pid_instance_q15 * S);
+        arm_pid_instance_q15 * S);
 
 
   /**
@@ -1823,10 +1964,10 @@ extern "C"
    */
   typedef struct
   {
-    uint32_t nValues;           /**< nValues */
-    float32_t x1;               /**< x1 */
-    float32_t xSpacing;         /**< xSpacing */
-    float32_t *pYData;          /**< pointer to the table of Y values */
+          uint32_t nValues;           /**< nValues */
+          float32_t x1;               /**< x1 */
+          float32_t xSpacing;         /**< xSpacing */
+          float32_t *pYData;          /**< pointer to the table of Y values */
   } arm_linear_interp_instance_f32;
 
   /**
@@ -1834,9 +1975,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numRows;   /**< number of rows in the data table. */
-    uint16_t numCols;   /**< number of columns in the data table. */
-    float32_t *pData;   /**< points to the data table. */
+          uint16_t numRows;   /**< number of rows in the data table. */
+          uint16_t numCols;   /**< number of columns in the data table. */
+          float32_t *pData;   /**< points to the data table. */
   } arm_bilinear_interp_instance_f32;
 
    /**
@@ -1844,9 +1985,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numRows;   /**< number of rows in the data table. */
-    uint16_t numCols;   /**< number of columns in the data table. */
-    q31_t *pData;       /**< points to the data table. */
+          uint16_t numRows;   /**< number of rows in the data table. */
+          uint16_t numCols;   /**< number of columns in the data table. */
+          q31_t *pData;       /**< points to the data table. */
   } arm_bilinear_interp_instance_q31;
 
    /**
@@ -1854,9 +1995,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numRows;   /**< number of rows in the data table. */
-    uint16_t numCols;   /**< number of columns in the data table. */
-    q15_t *pData;       /**< points to the data table. */
+          uint16_t numRows;   /**< number of rows in the data table. */
+          uint16_t numCols;   /**< number of columns in the data table. */
+          q15_t *pData;       /**< points to the data table. */
   } arm_bilinear_interp_instance_q15;
 
    /**
@@ -1864,9 +2005,9 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t numRows;   /**< number of rows in the data table. */
-    uint16_t numCols;   /**< number of columns in the data table. */
-    q7_t *pData;        /**< points to the data table. */
+          uint16_t numRows;   /**< number of rows in the data table. */
+          uint16_t numCols;   /**< number of columns in the data table. */
+          q7_t *pData;        /**< points to the data table. */
   } arm_bilinear_interp_instance_q7;
 
 
@@ -1878,10 +2019,10 @@ extern "C"
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_mult_q7(
-  q7_t * pSrcA,
-  q7_t * pSrcB,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrcA,
+  const q7_t * pSrcB,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -1892,10 +2033,10 @@ extern "C"
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_mult_q15(
-  q15_t * pSrcA,
-  q15_t * pSrcB,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrcA,
+  const q15_t * pSrcB,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -1906,10 +2047,10 @@ extern "C"
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_mult_q31(
-  q31_t * pSrcA,
-  q31_t * pSrcB,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrcA,
+  const q31_t * pSrcB,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -1920,10 +2061,10 @@ extern "C"
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_mult_f32(
-  float32_t * pSrcA,
-  float32_t * pSrcB,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrcA,
+  const float32_t * pSrcB,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -1931,26 +2072,26 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t fftLen;                 /**< length of the FFT. */
-    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
-    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
-    q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
-    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
-    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+          uint16_t fftLen;                 /**< length of the FFT. */
+          uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+          uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    const q15_t *pTwiddle;                 /**< points to the Sin twiddle factor table. */
+    const uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+          uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+          uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
   } arm_cfft_radix2_instance_q15;
 
 /* Deprecated */
   arm_status arm_cfft_radix2_init_q15(
-  arm_cfft_radix2_instance_q15 * S,
-  uint16_t fftLen,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        arm_cfft_radix2_instance_q15 * S,
+        uint16_t fftLen,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
 /* Deprecated */
   void arm_cfft_radix2_q15(
   const arm_cfft_radix2_instance_q15 * S,
-  q15_t * pSrc);
+        q15_t * pSrc);
 
 
   /**
@@ -1958,292 +2099,309 @@ extern "C"
    */
   typedef struct
   {
-    uint16_t fftLen;                 /**< length of the FFT. */
-    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
-    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
-    q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
-    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
-    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+          uint16_t fftLen;                 /**< length of the FFT. */
+          uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+          uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    const q15_t *pTwiddle;                 /**< points to the twiddle factor table. */
+    const uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+          uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+          uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
   } arm_cfft_radix4_instance_q15;
 
 /* Deprecated */
   arm_status arm_cfft_radix4_init_q15(
-  arm_cfft_radix4_instance_q15 * S,
-  uint16_t fftLen,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        arm_cfft_radix4_instance_q15 * S,
+        uint16_t fftLen,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
 /* Deprecated */
   void arm_cfft_radix4_q15(
   const arm_cfft_radix4_instance_q15 * S,
-  q15_t * pSrc);
+        q15_t * pSrc);
 
   /**
    * @brief Instance structure for the Radix-2 Q31 CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                 /**< length of the FFT. */
-    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
-    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
-    q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
-    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
-    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+          uint16_t fftLen;                 /**< length of the FFT. */
+          uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+          uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    const q31_t *pTwiddle;                 /**< points to the Twiddle factor table. */
+    const uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+          uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+          uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
   } arm_cfft_radix2_instance_q31;
 
 /* Deprecated */
   arm_status arm_cfft_radix2_init_q31(
-  arm_cfft_radix2_instance_q31 * S,
-  uint16_t fftLen,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        arm_cfft_radix2_instance_q31 * S,
+        uint16_t fftLen,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
 /* Deprecated */
   void arm_cfft_radix2_q31(
   const arm_cfft_radix2_instance_q31 * S,
-  q31_t * pSrc);
+        q31_t * pSrc);
 
   /**
    * @brief Instance structure for the Q31 CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                 /**< length of the FFT. */
-    uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
-    uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
-    q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
-    uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
-    uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+          uint16_t fftLen;                 /**< length of the FFT. */
+          uint8_t ifftFlag;                /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+          uint8_t bitReverseFlag;          /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    const q31_t *pTwiddle;                 /**< points to the twiddle factor table. */
+    const uint16_t *pBitRevTable;          /**< points to the bit reversal table. */
+          uint16_t twidCoefModifier;       /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+          uint16_t bitRevFactor;           /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
   } arm_cfft_radix4_instance_q31;
 
 /* Deprecated */
   void arm_cfft_radix4_q31(
   const arm_cfft_radix4_instance_q31 * S,
-  q31_t * pSrc);
+        q31_t * pSrc);
 
 /* Deprecated */
   arm_status arm_cfft_radix4_init_q31(
-  arm_cfft_radix4_instance_q31 * S,
-  uint16_t fftLen,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        arm_cfft_radix4_instance_q31 * S,
+        uint16_t fftLen,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
   /**
    * @brief Instance structure for the floating-point CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                   /**< length of the FFT. */
-    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
-    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
-    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
-    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
-    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
-    float32_t onebyfftLen;             /**< value of 1/fftLen. */
+          uint16_t fftLen;                   /**< length of the FFT. */
+          uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+          uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    const float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
+    const uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
+          uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+          uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+          float32_t onebyfftLen;             /**< value of 1/fftLen. */
   } arm_cfft_radix2_instance_f32;
 
 /* Deprecated */
   arm_status arm_cfft_radix2_init_f32(
-  arm_cfft_radix2_instance_f32 * S,
-  uint16_t fftLen,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        arm_cfft_radix2_instance_f32 * S,
+        uint16_t fftLen,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
 /* Deprecated */
   void arm_cfft_radix2_f32(
   const arm_cfft_radix2_instance_f32 * S,
-  float32_t * pSrc);
+        float32_t * pSrc);
 
   /**
    * @brief Instance structure for the floating-point CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                   /**< length of the FFT. */
-    uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
-    uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
-    float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
-    uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
-    uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
-    float32_t onebyfftLen;             /**< value of 1/fftLen. */
+          uint16_t fftLen;                   /**< length of the FFT. */
+          uint8_t ifftFlag;                  /**< flag that selects forward (ifftFlag=0) or inverse (ifftFlag=1) transform. */
+          uint8_t bitReverseFlag;            /**< flag that enables (bitReverseFlag=1) or disables (bitReverseFlag=0) bit reversal of output. */
+    const float32_t *pTwiddle;               /**< points to the Twiddle factor table. */
+    const uint16_t *pBitRevTable;            /**< points to the bit reversal table. */
+          uint16_t twidCoefModifier;         /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+          uint16_t bitRevFactor;             /**< bit reversal modifier that supports different size FFTs with the same bit reversal table. */
+          float32_t onebyfftLen;             /**< value of 1/fftLen. */
   } arm_cfft_radix4_instance_f32;
 
 /* Deprecated */
   arm_status arm_cfft_radix4_init_f32(
-  arm_cfft_radix4_instance_f32 * S,
-  uint16_t fftLen,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        arm_cfft_radix4_instance_f32 * S,
+        uint16_t fftLen,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
 /* Deprecated */
   void arm_cfft_radix4_f32(
   const arm_cfft_radix4_instance_f32 * S,
-  float32_t * pSrc);
+        float32_t * pSrc);
 
   /**
    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                   /**< length of the FFT. */
+          uint16_t fftLen;                   /**< length of the FFT. */
     const q15_t *pTwiddle;             /**< points to the Twiddle factor table. */
     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
-    uint16_t bitRevLength;             /**< bit reversal table length. */
+          uint16_t bitRevLength;             /**< bit reversal table length. */
   } arm_cfft_instance_q15;
 
 void arm_cfft_q15(
     const arm_cfft_instance_q15 * S,
-    q15_t * p1,
-    uint8_t ifftFlag,
-    uint8_t bitReverseFlag);
+          q15_t * p1,
+          uint8_t ifftFlag,
+          uint8_t bitReverseFlag);
 
   /**
    * @brief Instance structure for the fixed-point CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                   /**< length of the FFT. */
+          uint16_t fftLen;                   /**< length of the FFT. */
     const q31_t *pTwiddle;             /**< points to the Twiddle factor table. */
     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
-    uint16_t bitRevLength;             /**< bit reversal table length. */
+          uint16_t bitRevLength;             /**< bit reversal table length. */
   } arm_cfft_instance_q31;
 
 void arm_cfft_q31(
     const arm_cfft_instance_q31 * S,
-    q31_t * p1,
-    uint8_t ifftFlag,
-    uint8_t bitReverseFlag);
+          q31_t * p1,
+          uint8_t ifftFlag,
+          uint8_t bitReverseFlag);
 
   /**
    * @brief Instance structure for the floating-point CFFT/CIFFT function.
    */
   typedef struct
   {
-    uint16_t fftLen;                   /**< length of the FFT. */
+          uint16_t fftLen;                   /**< length of the FFT. */
     const float32_t *pTwiddle;         /**< points to the Twiddle factor table. */
     const uint16_t *pBitRevTable;      /**< points to the bit reversal table. */
-    uint16_t bitRevLength;             /**< bit reversal table length. */
+          uint16_t bitRevLength;             /**< bit reversal table length. */
   } arm_cfft_instance_f32;
 
   void arm_cfft_f32(
   const arm_cfft_instance_f32 * S,
-  float32_t * p1,
-  uint8_t ifftFlag,
-  uint8_t bitReverseFlag);
+        float32_t * p1,
+        uint8_t ifftFlag,
+        uint8_t bitReverseFlag);
 
   /**
    * @brief Instance structure for the Q15 RFFT/RIFFT function.
    */
   typedef struct
   {
-    uint32_t fftLenReal;                      /**< length of the real FFT. */
-    uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
-    uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
-    uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
-    q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
+          uint32_t fftLenReal;                      /**< length of the real FFT. */
+          uint8_t ifftFlagR;                        /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
+          uint8_t bitReverseFlagR;                  /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
+          uint32_t twidCoefRModifier;               /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    const q15_t *pTwiddleAReal;                     /**< points to the real twiddle factor table. */
+    const q15_t *pTwiddleBReal;                     /**< points to the imag twiddle factor table. */
     const arm_cfft_instance_q15 *pCfft;       /**< points to the complex FFT instance. */
   } arm_rfft_instance_q15;
 
   arm_status arm_rfft_init_q15(
-  arm_rfft_instance_q15 * S,
-  uint32_t fftLenReal,
-  uint32_t ifftFlagR,
-  uint32_t bitReverseFlag);
+        arm_rfft_instance_q15 * S,
+        uint32_t fftLenReal,
+        uint32_t ifftFlagR,
+        uint32_t bitReverseFlag);
 
   void arm_rfft_q15(
   const arm_rfft_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst);
+        q15_t * pSrc,
+        q15_t * pDst);
 
   /**
    * @brief Instance structure for the Q31 RFFT/RIFFT function.
    */
   typedef struct
   {
-    uint32_t fftLenReal;                        /**< length of the real FFT. */
-    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
-    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
-    uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
-    q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
+          uint32_t fftLenReal;                        /**< length of the real FFT. */
+          uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
+          uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
+          uint32_t twidCoefRModifier;                 /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    const q31_t *pTwiddleAReal;                       /**< points to the real twiddle factor table. */
+    const q31_t *pTwiddleBReal;                       /**< points to the imag twiddle factor table. */
     const arm_cfft_instance_q31 *pCfft;         /**< points to the complex FFT instance. */
   } arm_rfft_instance_q31;
 
   arm_status arm_rfft_init_q31(
-  arm_rfft_instance_q31 * S,
-  uint32_t fftLenReal,
-  uint32_t ifftFlagR,
-  uint32_t bitReverseFlag);
+        arm_rfft_instance_q31 * S,
+        uint32_t fftLenReal,
+        uint32_t ifftFlagR,
+        uint32_t bitReverseFlag);
 
   void arm_rfft_q31(
   const arm_rfft_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst);
+        q31_t * pSrc,
+        q31_t * pDst);
 
   /**
    * @brief Instance structure for the floating-point RFFT/RIFFT function.
    */
   typedef struct
   {
-    uint32_t fftLenReal;                        /**< length of the real FFT. */
-    uint16_t fftLenBy2;                         /**< length of the complex FFT. */
-    uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
-    uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
-    uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
-    float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
-    float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
-    arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
+          uint32_t fftLenReal;                        /**< length of the real FFT. */
+          uint16_t fftLenBy2;                         /**< length of the complex FFT. */
+          uint8_t ifftFlagR;                          /**< flag that selects forward (ifftFlagR=0) or inverse (ifftFlagR=1) transform. */
+          uint8_t bitReverseFlagR;                    /**< flag that enables (bitReverseFlagR=1) or disables (bitReverseFlagR=0) bit reversal of output. */
+          uint32_t twidCoefRModifier;                     /**< twiddle coefficient modifier that supports different size FFTs with the same twiddle factor table. */
+    const float32_t *pTwiddleAReal;                   /**< points to the real twiddle factor table. */
+    const float32_t *pTwiddleBReal;                   /**< points to the imag twiddle factor table. */
+          arm_cfft_radix4_instance_f32 *pCfft;        /**< points to the complex FFT instance. */
   } arm_rfft_instance_f32;
 
   arm_status arm_rfft_init_f32(
-  arm_rfft_instance_f32 * S,
-  arm_cfft_radix4_instance_f32 * S_CFFT,
-  uint32_t fftLenReal,
-  uint32_t ifftFlagR,
-  uint32_t bitReverseFlag);
+        arm_rfft_instance_f32 * S,
+        arm_cfft_radix4_instance_f32 * S_CFFT,
+        uint32_t fftLenReal,
+        uint32_t ifftFlagR,
+        uint32_t bitReverseFlag);
 
   void arm_rfft_f32(
   const arm_rfft_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst);
+        float32_t * pSrc,
+        float32_t * pDst);
 
   /**
    * @brief Instance structure for the floating-point RFFT/RIFFT function.
    */
 typedef struct
   {
-    arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
-    uint16_t fftLenRFFT;             /**< length of the real sequence */
-    float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
+          arm_cfft_instance_f32 Sint;      /**< Internal CFFT structure. */
+          uint16_t fftLenRFFT;             /**< length of the real sequence */
+    const float32_t * pTwiddleRFFT;        /**< Twiddle factors real stage  */
   } arm_rfft_fast_instance_f32 ;
 
 arm_status arm_rfft_fast_init_f32 (
-   arm_rfft_fast_instance_f32 * S,
-   uint16_t fftLen);
+         arm_rfft_fast_instance_f32 * S,
+         uint16_t fftLen);
+
+arm_status arm_rfft_32_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_64_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_128_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_256_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_512_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_1024_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_2048_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
+
+arm_status arm_rfft_4096_fast_init_f32 ( arm_rfft_fast_instance_f32 * S );
 
-void arm_rfft_fast_f32(
-  arm_rfft_fast_instance_f32 * S,
-  float32_t * p, float32_t * pOut,
-  uint8_t ifftFlag);
+
+  void arm_rfft_fast_f32(
+        arm_rfft_fast_instance_f32 * S,
+        float32_t * p, float32_t * pOut,
+        uint8_t ifftFlag);
 
   /**
    * @brief Instance structure for the floating-point DCT4/IDCT4 function.
    */
   typedef struct
   {
-    uint16_t N;                          /**< length of the DCT4. */
-    uint16_t Nby2;                       /**< half of the length of the DCT4. */
-    float32_t normalize;                 /**< normalizing factor. */
-    float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
-    float32_t *pCosFactor;               /**< points to the cosFactor table. */
-    arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
-    arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
+          uint16_t N;                          /**< length of the DCT4. */
+          uint16_t Nby2;                       /**< half of the length of the DCT4. */
+          float32_t normalize;                 /**< normalizing factor. */
+    const float32_t *pTwiddle;                 /**< points to the twiddle factor table. */
+    const float32_t *pCosFactor;               /**< points to the cosFactor table. */
+          arm_rfft_instance_f32 *pRfft;        /**< points to the real FFT instance. */
+          arm_cfft_radix4_instance_f32 *pCfft; /**< points to the complex FFT instance. */
   } arm_dct4_instance_f32;
 
 
@@ -2258,12 +2416,12 @@ void arm_rfft_fast_f32(
    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>fftLenReal</code> is not a supported transform length.
    */
   arm_status arm_dct4_init_f32(
-  arm_dct4_instance_f32 * S,
-  arm_rfft_instance_f32 * S_RFFT,
-  arm_cfft_radix4_instance_f32 * S_CFFT,
-  uint16_t N,
-  uint16_t Nby2,
-  float32_t normalize);
+        arm_dct4_instance_f32 * S,
+        arm_rfft_instance_f32 * S_RFFT,
+        arm_cfft_radix4_instance_f32 * S_CFFT,
+        uint16_t N,
+        uint16_t Nby2,
+        float32_t normalize);
 
 
   /**
@@ -2274,8 +2432,8 @@ void arm_rfft_fast_f32(
    */
   void arm_dct4_f32(
   const arm_dct4_instance_f32 * S,
-  float32_t * pState,
-  float32_t * pInlineBuffer);
+        float32_t * pState,
+        float32_t * pInlineBuffer);
 
 
   /**
@@ -2283,13 +2441,13 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t N;                          /**< length of the DCT4. */
-    uint16_t Nby2;                       /**< half of the length of the DCT4. */
-    q31_t normalize;                     /**< normalizing factor. */
-    q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
-    q31_t *pCosFactor;                   /**< points to the cosFactor table. */
-    arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
-    arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
+          uint16_t N;                          /**< length of the DCT4. */
+          uint16_t Nby2;                       /**< half of the length of the DCT4. */
+          q31_t normalize;                     /**< normalizing factor. */
+    const q31_t *pTwiddle;                     /**< points to the twiddle factor table. */
+    const q31_t *pCosFactor;                   /**< points to the cosFactor table. */
+          arm_rfft_instance_q31 *pRfft;        /**< points to the real FFT instance. */
+          arm_cfft_radix4_instance_q31 *pCfft; /**< points to the complex FFT instance. */
   } arm_dct4_instance_q31;
 
 
@@ -2304,12 +2462,12 @@ void arm_rfft_fast_f32(
    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
    */
   arm_status arm_dct4_init_q31(
-  arm_dct4_instance_q31 * S,
-  arm_rfft_instance_q31 * S_RFFT,
-  arm_cfft_radix4_instance_q31 * S_CFFT,
-  uint16_t N,
-  uint16_t Nby2,
-  q31_t normalize);
+        arm_dct4_instance_q31 * S,
+        arm_rfft_instance_q31 * S_RFFT,
+        arm_cfft_radix4_instance_q31 * S_CFFT,
+        uint16_t N,
+        uint16_t Nby2,
+        q31_t normalize);
 
 
   /**
@@ -2320,8 +2478,8 @@ void arm_rfft_fast_f32(
    */
   void arm_dct4_q31(
   const arm_dct4_instance_q31 * S,
-  q31_t * pState,
-  q31_t * pInlineBuffer);
+        q31_t * pState,
+        q31_t * pInlineBuffer);
 
 
   /**
@@ -2329,13 +2487,13 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t N;                          /**< length of the DCT4. */
-    uint16_t Nby2;                       /**< half of the length of the DCT4. */
-    q15_t normalize;                     /**< normalizing factor. */
-    q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
-    q15_t *pCosFactor;                   /**< points to the cosFactor table. */
-    arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
-    arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
+          uint16_t N;                          /**< length of the DCT4. */
+          uint16_t Nby2;                       /**< half of the length of the DCT4. */
+          q15_t normalize;                     /**< normalizing factor. */
+    const q15_t *pTwiddle;                     /**< points to the twiddle factor table. */
+    const q15_t *pCosFactor;                   /**< points to the cosFactor table. */
+          arm_rfft_instance_q15 *pRfft;        /**< points to the real FFT instance. */
+          arm_cfft_radix4_instance_q15 *pCfft; /**< points to the complex FFT instance. */
   } arm_dct4_instance_q15;
 
 
@@ -2350,12 +2508,12 @@ void arm_rfft_fast_f32(
    * @return      arm_status function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_ARGUMENT_ERROR if <code>N</code> is not a supported transform length.
    */
   arm_status arm_dct4_init_q15(
-  arm_dct4_instance_q15 * S,
-  arm_rfft_instance_q15 * S_RFFT,
-  arm_cfft_radix4_instance_q15 * S_CFFT,
-  uint16_t N,
-  uint16_t Nby2,
-  q15_t normalize);
+        arm_dct4_instance_q15 * S,
+        arm_rfft_instance_q15 * S_RFFT,
+        arm_cfft_radix4_instance_q15 * S_CFFT,
+        uint16_t N,
+        uint16_t Nby2,
+        q15_t normalize);
 
 
   /**
@@ -2366,8 +2524,8 @@ void arm_rfft_fast_f32(
    */
   void arm_dct4_q15(
   const arm_dct4_instance_q15 * S,
-  q15_t * pState,
-  q15_t * pInlineBuffer);
+        q15_t * pState,
+        q15_t * pInlineBuffer);
 
 
   /**
@@ -2378,10 +2536,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_add_f32(
-  float32_t * pSrcA,
-  float32_t * pSrcB,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrcA,
+  const float32_t * pSrcB,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2392,10 +2550,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_add_q7(
-  q7_t * pSrcA,
-  q7_t * pSrcB,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrcA,
+  const q7_t * pSrcB,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2406,10 +2564,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_add_q15(
-  q15_t * pSrcA,
-  q15_t * pSrcB,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrcA,
+  const q15_t * pSrcB,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2420,10 +2578,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_add_q31(
-  q31_t * pSrcA,
-  q31_t * pSrcB,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrcA,
+  const q31_t * pSrcB,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2434,10 +2592,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_sub_f32(
-  float32_t * pSrcA,
-  float32_t * pSrcB,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrcA,
+  const float32_t * pSrcB,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2448,10 +2606,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_sub_q7(
-  q7_t * pSrcA,
-  q7_t * pSrcB,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrcA,
+  const q7_t * pSrcB,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2462,10 +2620,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_sub_q15(
-  q15_t * pSrcA,
-  q15_t * pSrcB,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrcA,
+  const q15_t * pSrcB,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2476,10 +2634,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_sub_q31(
-  q31_t * pSrcA,
-  q31_t * pSrcB,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrcA,
+  const q31_t * pSrcB,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2490,10 +2648,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_scale_f32(
-  float32_t * pSrc,
-  float32_t scale,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t scale,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2505,11 +2663,11 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize   number of samples in the vector
    */
   void arm_scale_q7(
-  q7_t * pSrc,
-  q7_t scaleFract,
-  int8_t shift,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrc,
+        q7_t scaleFract,
+        int8_t shift,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2521,11 +2679,11 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize   number of samples in the vector
    */
   void arm_scale_q15(
-  q15_t * pSrc,
-  q15_t scaleFract,
-  int8_t shift,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t scaleFract,
+        int8_t shift,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2537,11 +2695,11 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize   number of samples in the vector
    */
   void arm_scale_q31(
-  q31_t * pSrc,
-  q31_t scaleFract,
-  int8_t shift,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t scaleFract,
+        int8_t shift,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2551,9 +2709,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_abs_q7(
-  q7_t * pSrc,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrc,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2563,9 +2721,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_abs_f32(
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2575,9 +2733,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_abs_q15(
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2587,9 +2745,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in each vector
    */
   void arm_abs_q31(
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2600,10 +2758,10 @@ void arm_rfft_fast_f32(
    * @param[out] result     output result returned here
    */
   void arm_dot_prod_f32(
-  float32_t * pSrcA,
-  float32_t * pSrcB,
-  uint32_t blockSize,
-  float32_t * result);
+  const float32_t * pSrcA,
+  const float32_t * pSrcB,
+        uint32_t blockSize,
+        float32_t * result);
 
 
   /**
@@ -2614,10 +2772,10 @@ void arm_rfft_fast_f32(
    * @param[out] result     output result returned here
    */
   void arm_dot_prod_q7(
-  q7_t * pSrcA,
-  q7_t * pSrcB,
-  uint32_t blockSize,
-  q31_t * result);
+  const q7_t * pSrcA,
+  const q7_t * pSrcB,
+        uint32_t blockSize,
+        q31_t * result);
 
 
   /**
@@ -2628,10 +2786,10 @@ void arm_rfft_fast_f32(
    * @param[out] result     output result returned here
    */
   void arm_dot_prod_q15(
-  q15_t * pSrcA,
-  q15_t * pSrcB,
-  uint32_t blockSize,
-  q63_t * result);
+  const q15_t * pSrcA,
+  const q15_t * pSrcB,
+        uint32_t blockSize,
+        q63_t * result);
 
 
   /**
@@ -2642,10 +2800,10 @@ void arm_rfft_fast_f32(
    * @param[out] result     output result returned here
    */
   void arm_dot_prod_q31(
-  q31_t * pSrcA,
-  q31_t * pSrcB,
-  uint32_t blockSize,
-  q63_t * result);
+  const q31_t * pSrcA,
+  const q31_t * pSrcB,
+        uint32_t blockSize,
+        q63_t * result);
 
 
   /**
@@ -2656,10 +2814,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_shift_q7(
-  q7_t * pSrc,
-  int8_t shiftBits,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrc,
+        int8_t shiftBits,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2670,10 +2828,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_shift_q15(
-  q15_t * pSrc,
-  int8_t shiftBits,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        int8_t shiftBits,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2684,10 +2842,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_shift_q31(
-  q31_t * pSrc,
-  int8_t shiftBits,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        int8_t shiftBits,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2698,10 +2856,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_offset_f32(
-  float32_t * pSrc,
-  float32_t offset,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t offset,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2712,10 +2870,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_offset_q7(
-  q7_t * pSrc,
-  q7_t offset,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrc,
+        q7_t offset,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2726,10 +2884,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_offset_q15(
-  q15_t * pSrc,
-  q15_t offset,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t offset,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2740,10 +2898,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_offset_q31(
-  q31_t * pSrc,
-  q31_t offset,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t offset,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2753,9 +2911,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_negate_f32(
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2765,9 +2923,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_negate_q7(
-  q7_t * pSrc,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrc,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2777,9 +2935,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_negate_q15(
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2789,9 +2947,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples in the vector
    */
   void arm_negate_q31(
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2801,9 +2959,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_copy_f32(
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2813,9 +2971,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_copy_q7(
-  q7_t * pSrc,
-  q7_t * pDst,
-  uint32_t blockSize);
+  const q7_t * pSrc,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2825,9 +2983,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_copy_q15(
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2837,9 +2995,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_copy_q31(
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2849,9 +3007,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_fill_f32(
-  float32_t value,
-  float32_t * pDst,
-  uint32_t blockSize);
+        float32_t value,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2861,9 +3019,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_fill_q7(
-  q7_t value,
-  q7_t * pDst,
-  uint32_t blockSize);
+        q7_t value,
+        q7_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2873,9 +3031,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_fill_q15(
-  q15_t value,
-  q15_t * pDst,
-  uint32_t blockSize);
+        q15_t value,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -2885,9 +3043,9 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process
    */
   void arm_fill_q31(
-  q31_t value,
-  q31_t * pDst,
-  uint32_t blockSize);
+        q31_t value,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
 /**
@@ -2899,11 +3057,11 @@ void arm_rfft_fast_f32(
  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1.
  */
   void arm_conv_f32(
-  float32_t * pSrcA,
-  uint32_t srcALen,
-  float32_t * pSrcB,
-  uint32_t srcBLen,
-  float32_t * pDst);
+  const float32_t * pSrcA,
+        uint32_t srcALen,
+  const float32_t * pSrcB,
+        uint32_t srcBLen,
+        float32_t * pDst);
 
 
   /**
@@ -2917,13 +3075,13 @@ void arm_rfft_fast_f32(
    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
    */
   void arm_conv_opt_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
 /**
@@ -2935,11 +3093,11 @@ void arm_rfft_fast_f32(
  * @param[out] pDst     points to the location where the output result is written.  Length srcALen+srcBLen-1.
  */
   void arm_conv_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst);
 
 
   /**
@@ -2951,11 +3109,11 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
    */
   void arm_conv_fast_q15(
-          q15_t * pSrcA,
-          uint32_t srcALen,
-          q15_t * pSrcB,
-          uint32_t srcBLen,
-          q15_t * pDst);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst);
 
 
   /**
@@ -2969,13 +3127,13 @@ void arm_rfft_fast_f32(
    * @param[in]  pScratch2  points to scratch buffer of size min(srcALen, srcBLen).
    */
   void arm_conv_fast_opt_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
   /**
@@ -2987,11 +3145,11 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
    */
   void arm_conv_q31(
-  q31_t * pSrcA,
-  uint32_t srcALen,
-  q31_t * pSrcB,
-  uint32_t srcBLen,
-  q31_t * pDst);
+  const q31_t * pSrcA,
+        uint32_t srcALen,
+  const q31_t * pSrcB,
+        uint32_t srcBLen,
+        q31_t * pDst);
 
 
   /**
@@ -3003,11 +3161,11 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
    */
   void arm_conv_fast_q31(
-  q31_t * pSrcA,
-  uint32_t srcALen,
-  q31_t * pSrcB,
-  uint32_t srcBLen,
-  q31_t * pDst);
+  const q31_t * pSrcA,
+        uint32_t srcALen,
+  const q31_t * pSrcB,
+        uint32_t srcBLen,
+        q31_t * pDst);
 
 
     /**
@@ -3021,13 +3179,13 @@ void arm_rfft_fast_f32(
    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
    */
   void arm_conv_opt_q7(
-  q7_t * pSrcA,
-  uint32_t srcALen,
-  q7_t * pSrcB,
-  uint32_t srcBLen,
-  q7_t * pDst,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q7_t * pSrcA,
+        uint32_t srcALen,
+  const q7_t * pSrcB,
+        uint32_t srcBLen,
+        q7_t * pDst,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
   /**
@@ -3039,11 +3197,11 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length srcALen+srcBLen-1.
    */
   void arm_conv_q7(
-  q7_t * pSrcA,
-  uint32_t srcALen,
-  q7_t * pSrcB,
-  uint32_t srcBLen,
-  q7_t * pDst);
+  const q7_t * pSrcA,
+        uint32_t srcALen,
+  const q7_t * pSrcB,
+        uint32_t srcBLen,
+        q7_t * pDst);
 
 
   /**
@@ -3058,13 +3216,13 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_f32(
-  float32_t * pSrcA,
-  uint32_t srcALen,
-  float32_t * pSrcB,
-  uint32_t srcBLen,
-  float32_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints);
+  const float32_t * pSrcA,
+        uint32_t srcALen,
+  const float32_t * pSrcB,
+        uint32_t srcBLen,
+        float32_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints);
 
 
   /**
@@ -3081,15 +3239,15 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_opt_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
   /**
@@ -3104,13 +3262,13 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints);
 
 
   /**
@@ -3125,13 +3283,13 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_fast_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints);
 
 
   /**
@@ -3148,15 +3306,15 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_fast_opt_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
   /**
@@ -3171,13 +3329,13 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_q31(
-  q31_t * pSrcA,
-  uint32_t srcALen,
-  q31_t * pSrcB,
-  uint32_t srcBLen,
-  q31_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints);
+  const q31_t * pSrcA,
+        uint32_t srcALen,
+  const q31_t * pSrcB,
+        uint32_t srcBLen,
+        q31_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints);
 
 
   /**
@@ -3192,13 +3350,13 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_fast_q31(
-  q31_t * pSrcA,
-  uint32_t srcALen,
-  q31_t * pSrcB,
-  uint32_t srcBLen,
-  q31_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints);
+  const q31_t * pSrcA,
+        uint32_t srcALen,
+  const q31_t * pSrcB,
+        uint32_t srcBLen,
+        q31_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints);
 
 
   /**
@@ -3215,15 +3373,15 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_opt_q7(
-  q7_t * pSrcA,
-  uint32_t srcALen,
-  q7_t * pSrcB,
-  uint32_t srcBLen,
-  q7_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q7_t * pSrcA,
+        uint32_t srcALen,
+  const q7_t * pSrcB,
+        uint32_t srcBLen,
+        q7_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
 /**
@@ -3238,13 +3396,13 @@ void arm_rfft_fast_f32(
    * @return  Returns either ARM_MATH_SUCCESS if the function completed correctly or ARM_MATH_ARGUMENT_ERROR if the requested subset is not in the range [0 srcALen+srcBLen-2].
    */
   arm_status arm_conv_partial_q7(
-  q7_t * pSrcA,
-  uint32_t srcALen,
-  q7_t * pSrcB,
-  uint32_t srcBLen,
-  q7_t * pDst,
-  uint32_t firstIndex,
-  uint32_t numPoints);
+  const q7_t * pSrcA,
+        uint32_t srcALen,
+  const q7_t * pSrcB,
+        uint32_t srcBLen,
+        q7_t * pDst,
+        uint32_t firstIndex,
+        uint32_t numPoints);
 
 
   /**
@@ -3252,10 +3410,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t M;                  /**< decimation factor. */
-    uint16_t numTaps;           /**< number of coefficients in the filter. */
-    q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
-    q15_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          uint8_t M;                  /**< decimation factor. */
+          uint16_t numTaps;           /**< number of coefficients in the filter. */
+    const q15_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
+          q15_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
   } arm_fir_decimate_instance_q15;
 
   /**
@@ -3263,56 +3421,57 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t M;                  /**< decimation factor. */
-    uint16_t numTaps;           /**< number of coefficients in the filter. */
-    q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
-    q31_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          uint8_t M;                  /**< decimation factor. */
+          uint16_t numTaps;           /**< number of coefficients in the filter. */
+    const q31_t *pCoeffs;             /**< points to the coefficient array. The array is of length numTaps.*/
+          q31_t *pState;              /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
   } arm_fir_decimate_instance_q31;
 
-  /**
-   * @brief Instance structure for the floating-point FIR decimator.
-   */
-  typedef struct
+/**
+  @brief Instance structure for floating-point FIR decimator.
+ */
+typedef struct
   {
-    uint8_t M;                  /**< decimation factor. */
-    uint16_t numTaps;           /**< number of coefficients in the filter. */
-    float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTaps.*/
-    float32_t *pState;          /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          uint8_t M;                  /**< decimation factor. */
+          uint16_t numTaps;           /**< number of coefficients in the filter. */
+    const float32_t *pCoeffs;         /**< points to the coefficient array. The array is of length numTaps.*/
+          float32_t *pState;          /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
   } arm_fir_decimate_instance_f32;
 
 
-  /**
-   * @brief Processing function for the floating-point FIR decimator.
-   * @param[in]  S          points to an instance of the floating-point FIR decimator structure.
-   * @param[in]  pSrc       points to the block of input data.
-   * @param[out] pDst       points to the block of output data
-   * @param[in]  blockSize  number of input samples to process per call.
-   */
-  void arm_fir_decimate_f32(
+/**
+  @brief         Processing function for floating-point FIR decimator.
+  @param[in]     S         points to an instance of the floating-point FIR decimator structure
+  @param[in]     pSrc      points to the block of input data
+  @param[out]    pDst      points to the block of output data
+  @param[in]     blockSize number of samples to process
+ */
+void arm_fir_decimate_f32(
   const arm_fir_decimate_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
-  /**
-   * @brief  Initialization function for the floating-point FIR decimator.
-   * @param[in,out] S          points to an instance of the floating-point FIR decimator structure.
-   * @param[in]     numTaps    number of coefficients in the filter.
-   * @param[in]     M          decimation factor.
-   * @param[in]     pCoeffs    points to the filter coefficients.
-   * @param[in]     pState     points to the state buffer.
-   * @param[in]     blockSize  number of input samples to process per call.
-   * @return    The function returns ARM_MATH_SUCCESS if initialization is successful or ARM_MATH_LENGTH_ERROR if
-   * <code>blockSize</code> is not a multiple of <code>M</code>.
-   */
-  arm_status arm_fir_decimate_init_f32(
-  arm_fir_decimate_instance_f32 * S,
-  uint16_t numTaps,
-  uint8_t M,
-  float32_t * pCoeffs,
-  float32_t * pState,
-  uint32_t blockSize);
+/**
+  @brief         Initialization function for the floating-point FIR decimator.
+  @param[in,out] S          points to an instance of the floating-point FIR decimator structure
+  @param[in]     numTaps    number of coefficients in the filter
+  @param[in]     M          decimation factor
+  @param[in]     pCoeffs    points to the filter coefficients
+  @param[in]     pState     points to the state buffer
+  @param[in]     blockSize  number of input samples to process per call
+  @return        execution status
+                   - ef ARM_MATH_SUCCESS      : Operation successful
+                   - ef ARM_MATH_LENGTH_ERROR : <code>blockSize</code> is not a multiple of <code>M</code>
+ */
+arm_status arm_fir_decimate_init_f32(
+        arm_fir_decimate_instance_f32 * S,
+        uint16_t numTaps,
+        uint8_t M,
+  const float32_t * pCoeffs,
+        float32_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3324,9 +3483,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_decimate_q15(
   const arm_fir_decimate_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3338,9 +3497,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_decimate_fast_q15(
   const arm_fir_decimate_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3355,12 +3514,12 @@ void arm_rfft_fast_f32(
    * <code>blockSize</code> is not a multiple of <code>M</code>.
    */
   arm_status arm_fir_decimate_init_q15(
-  arm_fir_decimate_instance_q15 * S,
-  uint16_t numTaps,
-  uint8_t M,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  uint32_t blockSize);
+        arm_fir_decimate_instance_q15 * S,
+        uint16_t numTaps,
+        uint8_t M,
+  const q15_t * pCoeffs,
+        q15_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3372,9 +3531,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_decimate_q31(
   const arm_fir_decimate_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
   /**
    * @brief Processing function for the Q31 FIR decimator (fast variant) for Cortex-M3 and Cortex-M4.
@@ -3384,10 +3543,10 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of input samples to process per call.
    */
   void arm_fir_decimate_fast_q31(
-  arm_fir_decimate_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const arm_fir_decimate_instance_q31 * S,
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3402,12 +3561,12 @@ void arm_rfft_fast_f32(
    * <code>blockSize</code> is not a multiple of <code>M</code>.
    */
   arm_status arm_fir_decimate_init_q31(
-  arm_fir_decimate_instance_q31 * S,
-  uint16_t numTaps,
-  uint8_t M,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  uint32_t blockSize);
+        arm_fir_decimate_instance_q31 * S,
+        uint16_t numTaps,
+        uint8_t M,
+  const q31_t * pCoeffs,
+        q31_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3415,10 +3574,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t L;                      /**< upsample factor. */
-    uint16_t phaseLength;           /**< length of each polyphase filter component. */
-    q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
-    q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
+        uint8_t L;                      /**< upsample factor. */
+        uint16_t phaseLength;           /**< length of each polyphase filter component. */
+  const q15_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
+        q15_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
   } arm_fir_interpolate_instance_q15;
 
   /**
@@ -3426,10 +3585,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t L;                      /**< upsample factor. */
-    uint16_t phaseLength;           /**< length of each polyphase filter component. */
-    q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
-    q31_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
+        uint8_t L;                      /**< upsample factor. */
+        uint16_t phaseLength;           /**< length of each polyphase filter component. */
+  const q31_t *pCoeffs;                 /**< points to the coefficient array. The array is of length L*phaseLength. */
+        q31_t *pState;                  /**< points to the state variable array. The array is of length blockSize+phaseLength-1. */
   } arm_fir_interpolate_instance_q31;
 
   /**
@@ -3437,10 +3596,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t L;                     /**< upsample factor. */
-    uint16_t phaseLength;          /**< length of each polyphase filter component. */
-    float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*phaseLength. */
-    float32_t *pState;             /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
+        uint8_t L;                     /**< upsample factor. */
+        uint16_t phaseLength;          /**< length of each polyphase filter component. */
+  const float32_t *pCoeffs;            /**< points to the coefficient array. The array is of length L*phaseLength. */
+        float32_t *pState;             /**< points to the state variable array. The array is of length phaseLength+numTaps-1. */
   } arm_fir_interpolate_instance_f32;
 
 
@@ -3453,9 +3612,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_interpolate_q15(
   const arm_fir_interpolate_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3470,12 +3629,12 @@ void arm_rfft_fast_f32(
    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
    */
   arm_status arm_fir_interpolate_init_q15(
-  arm_fir_interpolate_instance_q15 * S,
-  uint8_t L,
-  uint16_t numTaps,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  uint32_t blockSize);
+        arm_fir_interpolate_instance_q15 * S,
+        uint8_t L,
+        uint16_t numTaps,
+  const q15_t * pCoeffs,
+        q15_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3487,9 +3646,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_interpolate_q31(
   const arm_fir_interpolate_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3504,12 +3663,12 @@ void arm_rfft_fast_f32(
    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
    */
   arm_status arm_fir_interpolate_init_q31(
-  arm_fir_interpolate_instance_q31 * S,
-  uint8_t L,
-  uint16_t numTaps,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  uint32_t blockSize);
+        arm_fir_interpolate_instance_q31 * S,
+        uint8_t L,
+        uint16_t numTaps,
+  const q31_t * pCoeffs,
+        q31_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3521,9 +3680,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_interpolate_f32(
   const arm_fir_interpolate_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3538,12 +3697,12 @@ void arm_rfft_fast_f32(
    * the filter length <code>numTaps</code> is not a multiple of the interpolation factor <code>L</code>.
    */
   arm_status arm_fir_interpolate_init_f32(
-  arm_fir_interpolate_instance_f32 * S,
-  uint8_t L,
-  uint16_t numTaps,
-  float32_t * pCoeffs,
-  float32_t * pState,
-  uint32_t blockSize);
+        arm_fir_interpolate_instance_f32 * S,
+        uint8_t L,
+        uint16_t numTaps,
+  const float32_t * pCoeffs,
+        float32_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3551,10 +3710,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
-    q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
-    uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
+          uint8_t numStages;       /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          q63_t *pState;           /**< points to the array of state coefficients.  The array is of length 4*numStages. */
+    const q31_t *pCoeffs;          /**< points to the array of coefficients.  The array is of length 5*numStages. */
+          uint8_t postShift;       /**< additional shift, in bits, applied to each output sample. */
   } arm_biquad_cas_df1_32x64_ins_q31;
 
 
@@ -3566,9 +3725,9 @@ void arm_rfft_fast_f32(
    */
   void arm_biquad_cas_df1_32x64_q31(
   const arm_biquad_cas_df1_32x64_ins_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+        q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3579,11 +3738,11 @@ void arm_rfft_fast_f32(
    * @param[in]     postShift  shift to be applied to the output. Varies according to the coefficients format
    */
   void arm_biquad_cas_df1_32x64_init_q31(
-  arm_biquad_cas_df1_32x64_ins_q31 * S,
-  uint8_t numStages,
-  q31_t * pCoeffs,
-  q63_t * pState,
-  uint8_t postShift);
+        arm_biquad_cas_df1_32x64_ins_q31 * S,
+        uint8_t numStages,
+  const q31_t * pCoeffs,
+        q63_t * pState,
+        uint8_t postShift);
 
 
   /**
@@ -3591,9 +3750,9 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
-    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
+          uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
+    const float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
   } arm_biquad_cascade_df2T_instance_f32;
 
   /**
@@ -3601,9 +3760,9 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 4*numStages. */
-    float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
+          uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          float32_t *pState;         /**< points to the array of state coefficients.  The array is of length 4*numStages. */
+    const float32_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
   } arm_biquad_cascade_stereo_df2T_instance_f32;
 
   /**
@@ -3611,9 +3770,9 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
-    float64_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
-    float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
+          uint8_t numStages;         /**< number of 2nd order stages in the filter.  Overall order is 2*numStages. */
+          float64_t *pState;         /**< points to the array of state coefficients.  The array is of length 2*numStages. */
+          float64_t *pCoeffs;        /**< points to the array of coefficients.  The array is of length 5*numStages. */
   } arm_biquad_cascade_df2T_instance_f64;
 
 
@@ -3626,9 +3785,9 @@ void arm_rfft_fast_f32(
    */
   void arm_biquad_cascade_df2T_f32(
   const arm_biquad_cascade_df2T_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3640,9 +3799,9 @@ void arm_rfft_fast_f32(
    */
   void arm_biquad_cascade_stereo_df2T_f32(
   const arm_biquad_cascade_stereo_df2T_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3654,11 +3813,17 @@ void arm_rfft_fast_f32(
    */
   void arm_biquad_cascade_df2T_f64(
   const arm_biquad_cascade_df2T_instance_f64 * S,
-  float64_t * pSrc,
-  float64_t * pDst,
-  uint32_t blockSize);
+        float64_t * pSrc,
+        float64_t * pDst,
+        uint32_t blockSize);
 
 
+#if defined(ARM_MATH_NEON) 
+void arm_biquad_cascade_df2T_compute_coefs_f32(
+  arm_biquad_cascade_df2T_instance_f32 * S,
+  uint8_t numStages,
+  float32_t * pCoeffs);
+#endif
   /**
    * @brief  Initialization function for the floating-point transposed direct form II Biquad cascade filter.
    * @param[in,out] S          points to an instance of the filter data structure.
@@ -3667,10 +3832,10 @@ void arm_rfft_fast_f32(
    * @param[in]     pState     points to the state buffer.
    */
   void arm_biquad_cascade_df2T_init_f32(
-  arm_biquad_cascade_df2T_instance_f32 * S,
-  uint8_t numStages,
-  float32_t * pCoeffs,
-  float32_t * pState);
+        arm_biquad_cascade_df2T_instance_f32 * S,
+        uint8_t numStages,
+  const float32_t * pCoeffs,
+        float32_t * pState);
 
 
   /**
@@ -3681,10 +3846,10 @@ void arm_rfft_fast_f32(
    * @param[in]     pState     points to the state buffer.
    */
   void arm_biquad_cascade_stereo_df2T_init_f32(
-  arm_biquad_cascade_stereo_df2T_instance_f32 * S,
-  uint8_t numStages,
-  float32_t * pCoeffs,
-  float32_t * pState);
+        arm_biquad_cascade_stereo_df2T_instance_f32 * S,
+        uint8_t numStages,
+  const float32_t * pCoeffs,
+        float32_t * pState);
 
 
   /**
@@ -3695,10 +3860,10 @@ void arm_rfft_fast_f32(
    * @param[in]     pState     points to the state buffer.
    */
   void arm_biquad_cascade_df2T_init_f64(
-  arm_biquad_cascade_df2T_instance_f64 * S,
-  uint8_t numStages,
-  float64_t * pCoeffs,
-  float64_t * pState);
+        arm_biquad_cascade_df2T_instance_f64 * S,
+        uint8_t numStages,
+        float64_t * pCoeffs,
+        float64_t * pState);
 
 
   /**
@@ -3706,9 +3871,9 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numStages;                  /**< number of filter stages. */
-    q15_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
-    q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
+          uint16_t numStages;                  /**< number of filter stages. */
+          q15_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
+    const q15_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
   } arm_fir_lattice_instance_q15;
 
   /**
@@ -3716,9 +3881,9 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numStages;                  /**< number of filter stages. */
-    q31_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
-    q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
+          uint16_t numStages;                  /**< number of filter stages. */
+          q31_t *pState;                       /**< points to the state variable array. The array is of length numStages. */
+    const q31_t *pCoeffs;                      /**< points to the coefficient array. The array is of length numStages. */
   } arm_fir_lattice_instance_q31;
 
   /**
@@ -3726,9 +3891,9 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numStages;                  /**< number of filter stages. */
-    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
-    float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
+          uint16_t numStages;                  /**< number of filter stages. */
+          float32_t *pState;                   /**< points to the state variable array. The array is of length numStages. */
+    const float32_t *pCoeffs;                  /**< points to the coefficient array. The array is of length numStages. */
   } arm_fir_lattice_instance_f32;
 
 
@@ -3740,10 +3905,10 @@ void arm_rfft_fast_f32(
    * @param[in] pState     points to the state buffer.  The array is of length numStages.
    */
   void arm_fir_lattice_init_q15(
-  arm_fir_lattice_instance_q15 * S,
-  uint16_t numStages,
-  q15_t * pCoeffs,
-  q15_t * pState);
+        arm_fir_lattice_instance_q15 * S,
+        uint16_t numStages,
+  const q15_t * pCoeffs,
+        q15_t * pState);
 
 
   /**
@@ -3755,9 +3920,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_lattice_q15(
   const arm_fir_lattice_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3768,10 +3933,10 @@ void arm_rfft_fast_f32(
    * @param[in] pState     points to the state buffer.   The array is of length numStages.
    */
   void arm_fir_lattice_init_q31(
-  arm_fir_lattice_instance_q31 * S,
-  uint16_t numStages,
-  q31_t * pCoeffs,
-  q31_t * pState);
+        arm_fir_lattice_instance_q31 * S,
+        uint16_t numStages,
+  const q31_t * pCoeffs,
+        q31_t * pState);
 
 
   /**
@@ -3783,9 +3948,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_lattice_q31(
   const arm_fir_lattice_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
 /**
@@ -3796,10 +3961,10 @@ void arm_rfft_fast_f32(
  * @param[in] pState     points to the state buffer.  The array is of length numStages.
  */
   void arm_fir_lattice_init_f32(
-  arm_fir_lattice_instance_f32 * S,
-  uint16_t numStages,
-  float32_t * pCoeffs,
-  float32_t * pState);
+        arm_fir_lattice_instance_f32 * S,
+        uint16_t numStages,
+  const float32_t * pCoeffs,
+        float32_t * pState);
 
 
   /**
@@ -3811,9 +3976,9 @@ void arm_rfft_fast_f32(
    */
   void arm_fir_lattice_f32(
   const arm_fir_lattice_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3821,10 +3986,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numStages;                  /**< number of stages in the filter. */
-    q15_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
-    q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
-    q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
+          uint16_t numStages;                  /**< number of stages in the filter. */
+          q15_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
+          q15_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
+          q15_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
   } arm_iir_lattice_instance_q15;
 
   /**
@@ -3832,10 +3997,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numStages;                  /**< number of stages in the filter. */
-    q31_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
-    q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
-    q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
+          uint16_t numStages;                  /**< number of stages in the filter. */
+          q31_t *pState;                       /**< points to the state variable array. The array is of length numStages+blockSize. */
+          q31_t *pkCoeffs;                     /**< points to the reflection coefficient array. The array is of length numStages. */
+          q31_t *pvCoeffs;                     /**< points to the ladder coefficient array. The array is of length numStages+1. */
   } arm_iir_lattice_instance_q31;
 
   /**
@@ -3843,10 +4008,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numStages;                  /**< number of stages in the filter. */
-    float32_t *pState;                   /**< points to the state variable array. The array is of length numStages+blockSize. */
-    float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array is of length numStages. */
-    float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is of length numStages+1. */
+          uint16_t numStages;                  /**< number of stages in the filter. */
+          float32_t *pState;                   /**< points to the state variable array. The array is of length numStages+blockSize. */
+          float32_t *pkCoeffs;                 /**< points to the reflection coefficient array. The array is of length numStages. */
+          float32_t *pvCoeffs;                 /**< points to the ladder coefficient array. The array is of length numStages+1. */
   } arm_iir_lattice_instance_f32;
 
 
@@ -3859,9 +4024,9 @@ void arm_rfft_fast_f32(
    */
   void arm_iir_lattice_f32(
   const arm_iir_lattice_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3874,12 +4039,12 @@ void arm_rfft_fast_f32(
    * @param[in] blockSize  number of samples to process.
    */
   void arm_iir_lattice_init_f32(
-  arm_iir_lattice_instance_f32 * S,
-  uint16_t numStages,
-  float32_t * pkCoeffs,
-  float32_t * pvCoeffs,
-  float32_t * pState,
-  uint32_t blockSize);
+        arm_iir_lattice_instance_f32 * S,
+        uint16_t numStages,
+        float32_t * pkCoeffs,
+        float32_t * pvCoeffs,
+        float32_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3891,9 +4056,9 @@ void arm_rfft_fast_f32(
    */
   void arm_iir_lattice_q31(
   const arm_iir_lattice_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t blockSize);
 
 
   /**
@@ -3906,12 +4071,12 @@ void arm_rfft_fast_f32(
    * @param[in] blockSize  number of samples to process.
    */
   void arm_iir_lattice_init_q31(
-  arm_iir_lattice_instance_q31 * S,
-  uint16_t numStages,
-  q31_t * pkCoeffs,
-  q31_t * pvCoeffs,
-  q31_t * pState,
-  uint32_t blockSize);
+        arm_iir_lattice_instance_q31 * S,
+        uint16_t numStages,
+        q31_t * pkCoeffs,
+        q31_t * pvCoeffs,
+        q31_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3923,9 +4088,9 @@ void arm_rfft_fast_f32(
    */
   void arm_iir_lattice_q15(
   const arm_iir_lattice_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t blockSize);
 
 
 /**
@@ -3938,12 +4103,12 @@ void arm_rfft_fast_f32(
  * @param[in] blockSize  number of samples to process per call.
  */
   void arm_iir_lattice_init_q15(
-  arm_iir_lattice_instance_q15 * S,
-  uint16_t numStages,
-  q15_t * pkCoeffs,
-  q15_t * pvCoeffs,
-  q15_t * pState,
-  uint32_t blockSize);
+        arm_iir_lattice_instance_q15 * S,
+        uint16_t numStages,
+        q15_t * pkCoeffs,
+        q15_t * pvCoeffs,
+        q15_t * pState,
+        uint32_t blockSize);
 
 
   /**
@@ -3951,10 +4116,10 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;    /**< number of coefficients in the filter. */
-    float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
-    float32_t mu;        /**< step size that controls filter coefficient updates. */
+          uint16_t numTaps;    /**< number of coefficients in the filter. */
+          float32_t *pState;   /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          float32_t *pCoeffs;  /**< points to the coefficient array. The array is of length numTaps. */
+          float32_t mu;        /**< step size that controls filter coefficient updates. */
   } arm_lms_instance_f32;
 
 
@@ -3969,11 +4134,11 @@ void arm_rfft_fast_f32(
    */
   void arm_lms_f32(
   const arm_lms_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pRef,
-  float32_t * pOut,
-  float32_t * pErr,
-  uint32_t blockSize);
+  const float32_t * pSrc,
+        float32_t * pRef,
+        float32_t * pOut,
+        float32_t * pErr,
+        uint32_t blockSize);
 
 
   /**
@@ -3986,12 +4151,12 @@ void arm_rfft_fast_f32(
    * @param[in] blockSize  number of samples to process.
    */
   void arm_lms_init_f32(
-  arm_lms_instance_f32 * S,
-  uint16_t numTaps,
-  float32_t * pCoeffs,
-  float32_t * pState,
-  float32_t mu,
-  uint32_t blockSize);
+        arm_lms_instance_f32 * S,
+        uint16_t numTaps,
+        float32_t * pCoeffs,
+        float32_t * pState,
+        float32_t mu,
+        uint32_t blockSize);
 
 
   /**
@@ -3999,11 +4164,11 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;    /**< number of coefficients in the filter. */
-    q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
-    q15_t mu;            /**< step size that controls filter coefficient updates. */
-    uint32_t postShift;  /**< bit shift applied to coefficients. */
+          uint16_t numTaps;    /**< number of coefficients in the filter. */
+          q15_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          q15_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
+          q15_t mu;            /**< step size that controls filter coefficient updates. */
+          uint32_t postShift;  /**< bit shift applied to coefficients. */
   } arm_lms_instance_q15;
 
 
@@ -4018,13 +4183,13 @@ void arm_rfft_fast_f32(
    * @param[in] postShift  bit shift applied to coefficients.
    */
   void arm_lms_init_q15(
-  arm_lms_instance_q15 * S,
-  uint16_t numTaps,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  q15_t mu,
-  uint32_t blockSize,
-  uint32_t postShift);
+        arm_lms_instance_q15 * S,
+        uint16_t numTaps,
+        q15_t * pCoeffs,
+        q15_t * pState,
+        q15_t mu,
+        uint32_t blockSize,
+        uint32_t postShift);
 
 
   /**
@@ -4038,11 +4203,11 @@ void arm_rfft_fast_f32(
    */
   void arm_lms_q15(
   const arm_lms_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pRef,
-  q15_t * pOut,
-  q15_t * pErr,
-  uint32_t blockSize);
+  const q15_t * pSrc,
+        q15_t * pRef,
+        q15_t * pOut,
+        q15_t * pErr,
+        uint32_t blockSize);
 
 
   /**
@@ -4050,11 +4215,11 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;    /**< number of coefficients in the filter. */
-    q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
-    q31_t mu;            /**< step size that controls filter coefficient updates. */
-    uint32_t postShift;  /**< bit shift applied to coefficients. */
+          uint16_t numTaps;    /**< number of coefficients in the filter. */
+          q31_t *pState;       /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          q31_t *pCoeffs;      /**< points to the coefficient array. The array is of length numTaps. */
+          q31_t mu;            /**< step size that controls filter coefficient updates. */
+          uint32_t postShift;  /**< bit shift applied to coefficients. */
   } arm_lms_instance_q31;
 
 
@@ -4069,11 +4234,11 @@ void arm_rfft_fast_f32(
    */
   void arm_lms_q31(
   const arm_lms_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pRef,
-  q31_t * pOut,
-  q31_t * pErr,
-  uint32_t blockSize);
+  const q31_t * pSrc,
+        q31_t * pRef,
+        q31_t * pOut,
+        q31_t * pErr,
+        uint32_t blockSize);
 
 
   /**
@@ -4087,13 +4252,13 @@ void arm_rfft_fast_f32(
    * @param[in] postShift  bit shift applied to coefficients.
    */
   void arm_lms_init_q31(
-  arm_lms_instance_q31 * S,
-  uint16_t numTaps,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  q31_t mu,
-  uint32_t blockSize,
-  uint32_t postShift);
+        arm_lms_instance_q31 * S,
+        uint16_t numTaps,
+        q31_t * pCoeffs,
+        q31_t * pState,
+        q31_t mu,
+        uint32_t blockSize,
+        uint32_t postShift);
 
 
   /**
@@ -4101,12 +4266,12 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;     /**< number of coefficients in the filter. */
-    float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
-    float32_t mu;         /**< step size that control filter coefficient updates. */
-    float32_t energy;     /**< saves previous frame energy. */
-    float32_t x0;         /**< saves previous input sample. */
+          uint16_t numTaps;     /**< number of coefficients in the filter. */
+          float32_t *pState;    /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          float32_t *pCoeffs;   /**< points to the coefficient array. The array is of length numTaps. */
+          float32_t mu;         /**< step size that control filter coefficient updates. */
+          float32_t energy;     /**< saves previous frame energy. */
+          float32_t x0;         /**< saves previous input sample. */
   } arm_lms_norm_instance_f32;
 
 
@@ -4120,12 +4285,12 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process.
    */
   void arm_lms_norm_f32(
-  arm_lms_norm_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pRef,
-  float32_t * pOut,
-  float32_t * pErr,
-  uint32_t blockSize);
+        arm_lms_norm_instance_f32 * S,
+  const float32_t * pSrc,
+        float32_t * pRef,
+        float32_t * pOut,
+        float32_t * pErr,
+        uint32_t blockSize);
 
 
   /**
@@ -4138,12 +4303,12 @@ void arm_rfft_fast_f32(
    * @param[in] blockSize  number of samples to process.
    */
   void arm_lms_norm_init_f32(
-  arm_lms_norm_instance_f32 * S,
-  uint16_t numTaps,
-  float32_t * pCoeffs,
-  float32_t * pState,
-  float32_t mu,
-  uint32_t blockSize);
+        arm_lms_norm_instance_f32 * S,
+        uint16_t numTaps,
+        float32_t * pCoeffs,
+        float32_t * pState,
+        float32_t mu,
+        uint32_t blockSize);
 
 
   /**
@@ -4151,14 +4316,14 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;     /**< number of coefficients in the filter. */
-    q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
-    q31_t mu;             /**< step size that controls filter coefficient updates. */
-    uint8_t postShift;    /**< bit shift applied to coefficients. */
-    q31_t *recipTable;    /**< points to the reciprocal initial value table. */
-    q31_t energy;         /**< saves previous frame energy. */
-    q31_t x0;             /**< saves previous input sample. */
+          uint16_t numTaps;     /**< number of coefficients in the filter. */
+          q31_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          q31_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
+          q31_t mu;             /**< step size that controls filter coefficient updates. */
+          uint8_t postShift;    /**< bit shift applied to coefficients. */
+    const q31_t *recipTable;    /**< points to the reciprocal initial value table. */
+          q31_t energy;         /**< saves previous frame energy. */
+          q31_t x0;             /**< saves previous input sample. */
   } arm_lms_norm_instance_q31;
 
 
@@ -4172,12 +4337,12 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process.
    */
   void arm_lms_norm_q31(
-  arm_lms_norm_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pRef,
-  q31_t * pOut,
-  q31_t * pErr,
-  uint32_t blockSize);
+        arm_lms_norm_instance_q31 * S,
+  const q31_t * pSrc,
+        q31_t * pRef,
+        q31_t * pOut,
+        q31_t * pErr,
+        uint32_t blockSize);
 
 
   /**
@@ -4191,13 +4356,13 @@ void arm_rfft_fast_f32(
    * @param[in] postShift  bit shift applied to coefficients.
    */
   void arm_lms_norm_init_q31(
-  arm_lms_norm_instance_q31 * S,
-  uint16_t numTaps,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  q31_t mu,
-  uint32_t blockSize,
-  uint8_t postShift);
+        arm_lms_norm_instance_q31 * S,
+        uint16_t numTaps,
+        q31_t * pCoeffs,
+        q31_t * pState,
+        q31_t mu,
+        uint32_t blockSize,
+        uint8_t postShift);
 
 
   /**
@@ -4205,14 +4370,14 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;     /**< Number of coefficients in the filter. */
-    q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
-    q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
-    q15_t mu;             /**< step size that controls filter coefficient updates. */
-    uint8_t postShift;    /**< bit shift applied to coefficients. */
-    q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
-    q15_t energy;         /**< saves previous frame energy. */
-    q15_t x0;             /**< saves previous input sample. */
+          uint16_t numTaps;     /**< Number of coefficients in the filter. */
+          q15_t *pState;        /**< points to the state variable array. The array is of length numTaps+blockSize-1. */
+          q15_t *pCoeffs;       /**< points to the coefficient array. The array is of length numTaps. */
+          q15_t mu;             /**< step size that controls filter coefficient updates. */
+          uint8_t postShift;    /**< bit shift applied to coefficients. */
+    const q15_t *recipTable;    /**< Points to the reciprocal initial value table. */
+          q15_t energy;         /**< saves previous frame energy. */
+          q15_t x0;             /**< saves previous input sample. */
   } arm_lms_norm_instance_q15;
 
 
@@ -4226,12 +4391,12 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize  number of samples to process.
    */
   void arm_lms_norm_q15(
-  arm_lms_norm_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pRef,
-  q15_t * pOut,
-  q15_t * pErr,
-  uint32_t blockSize);
+        arm_lms_norm_instance_q15 * S,
+  const q15_t * pSrc,
+        q15_t * pRef,
+        q15_t * pOut,
+        q15_t * pErr,
+        uint32_t blockSize);
 
 
   /**
@@ -4245,13 +4410,13 @@ void arm_rfft_fast_f32(
    * @param[in] postShift  bit shift applied to coefficients.
    */
   void arm_lms_norm_init_q15(
-  arm_lms_norm_instance_q15 * S,
-  uint16_t numTaps,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  q15_t mu,
-  uint32_t blockSize,
-  uint8_t postShift);
+        arm_lms_norm_instance_q15 * S,
+        uint16_t numTaps,
+        q15_t * pCoeffs,
+        q15_t * pState,
+        q15_t mu,
+        uint32_t blockSize,
+        uint8_t postShift);
 
 
   /**
@@ -4263,81 +4428,80 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
    */
   void arm_correlate_f32(
-  float32_t * pSrcA,
-  uint32_t srcALen,
-  float32_t * pSrcB,
-  uint32_t srcBLen,
-  float32_t * pDst);
+  const float32_t * pSrcA,
+        uint32_t srcALen,
+  const float32_t * pSrcB,
+        uint32_t srcBLen,
+        float32_t * pDst);
 
 
-   /**
-   * @brief Correlation of Q15 sequences
-   * @param[in]  pSrcA     points to the first input sequence.
-   * @param[in]  srcALen   length of the first input sequence.
-   * @param[in]  pSrcB     points to the second input sequence.
-   * @param[in]  srcBLen   length of the second input sequence.
-   * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
-   * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
-   */
-  void arm_correlate_opt_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  q15_t * pScratch);
-
+/**
+ @brief Correlation of Q15 sequences
+ @param[in]  pSrcA     points to the first input sequence
+ @param[in]  srcALen   length of the first input sequence
+ @param[in]  pSrcB     points to the second input sequence
+ @param[in]  srcBLen   length of the second input sequence
+ @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+ @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+*/
+void arm_correlate_opt_q15(
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        q15_t * pScratch);
 
-  /**
-   * @brief Correlation of Q15 sequences.
-   * @param[in]  pSrcA    points to the first input sequence.
-   * @param[in]  srcALen  length of the first input sequence.
-   * @param[in]  pSrcB    points to the second input sequence.
-   * @param[in]  srcBLen  length of the second input sequence.
-   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
-   */
 
+/**
+  @brief Correlation of Q15 sequences.
+  @param[in]  pSrcA    points to the first input sequence
+  @param[in]  srcALen  length of the first input sequence
+  @param[in]  pSrcB    points to the second input sequence
+  @param[in]  srcBLen  length of the second input sequence
+  @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+ */
   void arm_correlate_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst);
-
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst);
 
-  /**
-   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
-   * @param[in]  pSrcA    points to the first input sequence.
-   * @param[in]  srcALen  length of the first input sequence.
-   * @param[in]  pSrcB    points to the second input sequence.
-   * @param[in]  srcBLen  length of the second input sequence.
-   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
-   */
 
-  void arm_correlate_fast_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst);
+/**
+  @brief         Correlation of Q15 sequences (fast version).
+  @param[in]     pSrcA      points to the first input sequence
+  @param[in]     srcALen    length of the first input sequence
+  @param[in]     pSrcB      points to the second input sequence
+  @param[in]     srcBLen    length of the second input sequence
+  @param[out]    pDst       points to the location where the output result is written.  Length 2 * max(srcALen, srcBLen) - 1.
+  @return        none
+ */
+void arm_correlate_fast_q15(
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst);
 
 
-  /**
-   * @brief Correlation of Q15 sequences (fast version) for Cortex-M3 and Cortex-M4.
-   * @param[in]  pSrcA     points to the first input sequence.
-   * @param[in]  srcALen   length of the first input sequence.
-   * @param[in]  pSrcB     points to the second input sequence.
-   * @param[in]  srcBLen   length of the second input sequence.
-   * @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
-   * @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
-   */
-  void arm_correlate_fast_opt_q15(
-  q15_t * pSrcA,
-  uint32_t srcALen,
-  q15_t * pSrcB,
-  uint32_t srcBLen,
-  q15_t * pDst,
-  q15_t * pScratch);
+/**
+  @brief Correlation of Q15 sequences (fast version).
+  @param[in]  pSrcA     points to the first input sequence.
+  @param[in]  srcALen   length of the first input sequence.
+  @param[in]  pSrcB     points to the second input sequence.
+  @param[in]  srcBLen   length of the second input sequence.
+  @param[out] pDst      points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+  @param[in]  pScratch  points to scratch buffer of size max(srcALen, srcBLen) + 2*min(srcALen, srcBLen) - 2.
+ */
+void arm_correlate_fast_opt_q15(
+  const q15_t * pSrcA,
+        uint32_t srcALen,
+  const q15_t * pSrcB,
+        uint32_t srcBLen,
+        q15_t * pDst,
+        q15_t * pScratch);
 
 
   /**
@@ -4349,27 +4513,27 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
    */
   void arm_correlate_q31(
-  q31_t * pSrcA,
-  uint32_t srcALen,
-  q31_t * pSrcB,
-  uint32_t srcBLen,
-  q31_t * pDst);
+  const q31_t * pSrcA,
+        uint32_t srcALen,
+  const q31_t * pSrcB,
+        uint32_t srcBLen,
+        q31_t * pDst);
 
 
-  /**
-   * @brief Correlation of Q31 sequences (fast version) for Cortex-M3 and Cortex-M4
-   * @param[in]  pSrcA    points to the first input sequence.
-   * @param[in]  srcALen  length of the first input sequence.
-   * @param[in]  pSrcB    points to the second input sequence.
-   * @param[in]  srcBLen  length of the second input sequence.
-   * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
-   */
-  void arm_correlate_fast_q31(
-  q31_t * pSrcA,
-  uint32_t srcALen,
-  q31_t * pSrcB,
-  uint32_t srcBLen,
-  q31_t * pDst);
+/**
+  @brief Correlation of Q31 sequences (fast version).
+  @param[in]  pSrcA    points to the first input sequence
+  @param[in]  srcALen  length of the first input sequence
+  @param[in]  pSrcB    points to the second input sequence
+  @param[in]  srcBLen  length of the second input sequence
+  @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
+ */
+void arm_correlate_fast_q31(
+  const q31_t * pSrcA,
+        uint32_t srcALen,
+  const q31_t * pSrcB,
+        uint32_t srcBLen,
+        q31_t * pDst);
 
 
  /**
@@ -4383,13 +4547,13 @@ void arm_rfft_fast_f32(
    * @param[in]  pScratch2  points to scratch buffer (of type q15_t) of size min(srcALen, srcBLen).
    */
   void arm_correlate_opt_q7(
-  q7_t * pSrcA,
-  uint32_t srcALen,
-  q7_t * pSrcB,
-  uint32_t srcBLen,
-  q7_t * pDst,
-  q15_t * pScratch1,
-  q15_t * pScratch2);
+  const q7_t * pSrcA,
+        uint32_t srcALen,
+  const q7_t * pSrcB,
+        uint32_t srcBLen,
+        q7_t * pDst,
+        q15_t * pScratch1,
+        q15_t * pScratch2);
 
 
   /**
@@ -4401,11 +4565,11 @@ void arm_rfft_fast_f32(
    * @param[out] pDst     points to the block of output data  Length 2 * max(srcALen, srcBLen) - 1.
    */
   void arm_correlate_q7(
-  q7_t * pSrcA,
-  uint32_t srcALen,
-  q7_t * pSrcB,
-  uint32_t srcBLen,
-  q7_t * pDst);
+  const q7_t * pSrcA,
+        uint32_t srcALen,
+  const q7_t * pSrcB,
+        uint32_t srcBLen,
+        q7_t * pDst);
 
 
   /**
@@ -4413,12 +4577,12 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;             /**< number of coefficients in the filter. */
-    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
-    float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
-    float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
-    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
-    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+          uint16_t numTaps;             /**< number of coefficients in the filter. */
+          uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+          float32_t *pState;            /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    const float32_t *pCoeffs;           /**< points to the coefficient array. The array is of length numTaps.*/
+          uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+          int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
   } arm_fir_sparse_instance_f32;
 
   /**
@@ -4426,12 +4590,12 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;             /**< number of coefficients in the filter. */
-    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
-    q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
-    q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
-    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
-    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+          uint16_t numTaps;             /**< number of coefficients in the filter. */
+          uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+          q31_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    const q31_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
+          uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+          int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
   } arm_fir_sparse_instance_q31;
 
   /**
@@ -4439,12 +4603,12 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;             /**< number of coefficients in the filter. */
-    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
-    q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
-    q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
-    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
-    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+          uint16_t numTaps;             /**< number of coefficients in the filter. */
+          uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+          q15_t *pState;                /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    const q15_t *pCoeffs;               /**< points to the coefficient array. The array is of length numTaps.*/
+          uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+          int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
   } arm_fir_sparse_instance_q15;
 
   /**
@@ -4452,12 +4616,12 @@ void arm_rfft_fast_f32(
    */
   typedef struct
   {
-    uint16_t numTaps;             /**< number of coefficients in the filter. */
-    uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
-    q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
-    q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
-    uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
-    int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
+          uint16_t numTaps;             /**< number of coefficients in the filter. */
+          uint16_t stateIndex;          /**< state buffer index.  Points to the oldest sample in the state buffer. */
+          q7_t *pState;                 /**< points to the state buffer array. The array is of length maxDelay+blockSize-1. */
+    const q7_t *pCoeffs;                /**< points to the coefficient array. The array is of length numTaps.*/
+          uint16_t maxDelay;            /**< maximum offset specified by the pTapDelay array. */
+          int32_t *pTapDelay;           /**< points to the array of delay values.  The array is of length numTaps. */
   } arm_fir_sparse_instance_q7;
 
 
@@ -4470,11 +4634,11 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize   number of input samples to process per call.
    */
   void arm_fir_sparse_f32(
-  arm_fir_sparse_instance_f32 * S,
-  float32_t * pSrc,
-  float32_t * pDst,
-  float32_t * pScratchIn,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_f32 * S,
+  const float32_t * pSrc,
+        float32_t * pDst,
+        float32_t * pScratchIn,
+        uint32_t blockSize);
 
 
   /**
@@ -4488,13 +4652,13 @@ void arm_rfft_fast_f32(
    * @param[in]     blockSize  number of samples that will be processed per block.
    */
   void arm_fir_sparse_init_f32(
-  arm_fir_sparse_instance_f32 * S,
-  uint16_t numTaps,
-  float32_t * pCoeffs,
-  float32_t * pState,
-  int32_t * pTapDelay,
-  uint16_t maxDelay,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_f32 * S,
+        uint16_t numTaps,
+  const float32_t * pCoeffs,
+        float32_t * pState,
+        int32_t * pTapDelay,
+        uint16_t maxDelay,
+        uint32_t blockSize);
 
 
   /**
@@ -4506,11 +4670,11 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize   number of input samples to process per call.
    */
   void arm_fir_sparse_q31(
-  arm_fir_sparse_instance_q31 * S,
-  q31_t * pSrc,
-  q31_t * pDst,
-  q31_t * pScratchIn,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_q31 * S,
+  const q31_t * pSrc,
+        q31_t * pDst,
+        q31_t * pScratchIn,
+        uint32_t blockSize);
 
 
   /**
@@ -4524,13 +4688,13 @@ void arm_rfft_fast_f32(
    * @param[in]     blockSize  number of samples that will be processed per block.
    */
   void arm_fir_sparse_init_q31(
-  arm_fir_sparse_instance_q31 * S,
-  uint16_t numTaps,
-  q31_t * pCoeffs,
-  q31_t * pState,
-  int32_t * pTapDelay,
-  uint16_t maxDelay,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_q31 * S,
+        uint16_t numTaps,
+  const q31_t * pCoeffs,
+        q31_t * pState,
+        int32_t * pTapDelay,
+        uint16_t maxDelay,
+        uint32_t blockSize);
 
 
   /**
@@ -4543,12 +4707,12 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize    number of input samples to process per call.
    */
   void arm_fir_sparse_q15(
-  arm_fir_sparse_instance_q15 * S,
-  q15_t * pSrc,
-  q15_t * pDst,
-  q15_t * pScratchIn,
-  q31_t * pScratchOut,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_q15 * S,
+  const q15_t * pSrc,
+        q15_t * pDst,
+        q15_t * pScratchIn,
+        q31_t * pScratchOut,
+        uint32_t blockSize);
 
 
   /**
@@ -4562,13 +4726,13 @@ void arm_rfft_fast_f32(
    * @param[in]     blockSize  number of samples that will be processed per block.
    */
   void arm_fir_sparse_init_q15(
-  arm_fir_sparse_instance_q15 * S,
-  uint16_t numTaps,
-  q15_t * pCoeffs,
-  q15_t * pState,
-  int32_t * pTapDelay,
-  uint16_t maxDelay,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_q15 * S,
+        uint16_t numTaps,
+  const q15_t * pCoeffs,
+        q15_t * pState,
+        int32_t * pTapDelay,
+        uint16_t maxDelay,
+        uint32_t blockSize);
 
 
   /**
@@ -4581,12 +4745,12 @@ void arm_rfft_fast_f32(
    * @param[in]  blockSize    number of input samples to process per call.
    */
   void arm_fir_sparse_q7(
-  arm_fir_sparse_instance_q7 * S,
-  q7_t * pSrc,
-  q7_t * pDst,
-  q7_t * pScratchIn,
-  q31_t * pScratchOut,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_q7 * S,
+  const q7_t * pSrc,
+        q7_t * pDst,
+        q7_t * pScratchIn,
+        q31_t * pScratchOut,
+        uint32_t blockSize);
 
 
   /**
@@ -4600,13 +4764,13 @@ void arm_rfft_fast_f32(
    * @param[in]     blockSize  number of samples that will be processed per block.
    */
   void arm_fir_sparse_init_q7(
-  arm_fir_sparse_instance_q7 * S,
-  uint16_t numTaps,
-  q7_t * pCoeffs,
-  q7_t * pState,
-  int32_t * pTapDelay,
-  uint16_t maxDelay,
-  uint32_t blockSize);
+        arm_fir_sparse_instance_q7 * S,
+        uint16_t numTaps,
+  const q7_t * pCoeffs,
+        q7_t * pState,
+        int32_t * pTapDelay,
+        uint16_t maxDelay,
+        uint32_t blockSize);
 
 
   /**
@@ -4616,9 +4780,9 @@ void arm_rfft_fast_f32(
    * @param[out] pCosVal  points to the processed cos output.
    */
   void arm_sin_cos_f32(
-  float32_t theta,
-  float32_t * pSinVal,
-  float32_t * pCosVal);
+        float32_t theta,
+        float32_t * pSinVal,
+        float32_t * pCosVal);
 
 
   /**
@@ -4628,9 +4792,9 @@ void arm_rfft_fast_f32(
    * @param[out] pCosVal  points to the processed cosine output.
    */
   void arm_sin_cos_q31(
-  q31_t theta,
-  q31_t * pSinVal,
-  q31_t * pCosVal);
+        q31_t theta,
+        q31_t * pSinVal,
+        q31_t * pCosVal);
 
 
   /**
@@ -4640,9 +4804,9 @@ void arm_rfft_fast_f32(
    * @param[in]  numSamples  number of complex samples in each vector
    */
   void arm_cmplx_conj_f32(
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t numSamples);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t numSamples);
 
   /**
    * @brief  Q31 complex conjugate.
@@ -4651,9 +4815,9 @@ void arm_rfft_fast_f32(
    * @param[in]  numSamples  number of complex samples in each vector
    */
   void arm_cmplx_conj_q31(
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t numSamples);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t numSamples);
 
 
   /**
@@ -4663,9 +4827,9 @@ void arm_rfft_fast_f32(
    * @param[in]  numSamples  number of complex samples in each vector
    */
   void arm_cmplx_conj_q15(
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t numSamples);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t numSamples);
 
 
   /**
@@ -4675,9 +4839,9 @@ void arm_rfft_fast_f32(
    * @param[in]  numSamples  number of complex samples in the input vector
    */
   void arm_cmplx_mag_squared_f32(
-  float32_t * pSrc,
-  float32_t * pDst,
-  uint32_t numSamples);
+  const float32_t * pSrc,
+        float32_t * pDst,
+        uint32_t numSamples);
 
 
   /**
@@ -4687,9 +4851,9 @@ void arm_rfft_fast_f32(
    * @param[in]  numSamples  number of complex samples in the input vector
    */
   void arm_cmplx_mag_squared_q31(
-  q31_t * pSrc,
-  q31_t * pDst,
-  uint32_t numSamples);
+  const q31_t * pSrc,
+        q31_t * pDst,
+        uint32_t numSamples);
 
 
   /**
@@ -4699,9 +4863,9 @@ void arm_rfft_fast_f32(
    * @param[in]  numSamples  number of complex samples in the input vector
    */
   void arm_cmplx_mag_squared_q15(
-  q15_t * pSrc,
-  q15_t * pDst,
-  uint32_t numSamples);
+  const q15_t * pSrc,
+        q15_t * pDst,
+        uint32_t numSamples);
 
 
  /**
@@ -4726,7 +4890,8 @@ void arm_rfft_fast_f32(
    *    y[n] = y[n-1] + A0 * x[n] + A1 * x[n-1] + A2 * x[n-2]
    *    A0 = Kp + Ki + Kd
    *    A1 = (-Kp ) - (2 * Kd )
-   *    A2 = Kd  </pre>
+   *    A2 = Kd
+   * </pre>
    *
    * \par
    * where 