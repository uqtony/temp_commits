fc16c5d jenkins 2020-05-26

Download imx-android-10.0.0_2.0.0.tar.gz from nxp.com

Change-Id: Ifed831cf437a1b8de11279853378b7da98665ceb

diff --git a/Makefile_G1G2 b/Makefile_G1G2
index 8280cce..b63c608 100755
--- a/Makefile_G1G2
+++ b/Makefile_G1G2
@@ -101,6 +101,7 @@ RELEASE_BIN=bin
 LIBG1COMMONNAME=libcommon_g1
 
 VERSION = imx8mq
+export M32=-m64
 
 all: $(LIBNAME).so $(LIBNAME).a $(LIBG1NAME).so $(LIBG1NAME).a $(LIBCODECNAME) test
 
@@ -135,15 +136,15 @@ $(LIBG1NAME).so: $(LIBG1NAME).so.$(SONAMEVERSION)
 	ln -fs $< $@
 
 $(LIBG1NAME).a:
-	make -C $(SOURCE_ROOT)/linux/h264high versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/mpeg4 versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/mpeg2 versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/vc1 versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/vp6 versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/vp8 versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/jpeg versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/rv versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
-	make -C $(SOURCE_ROOT)/linux/avs versatile M32=-m64 CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/h264high versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/mpeg4 versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/mpeg2 versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/vc1 versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/vp6 versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/vp8 versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/jpeg versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/rv versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
+	make -C $(SOURCE_ROOT)/linux/avs versatile CLEAR_HDRINFO_IN_SEEK=n USE_EXTERNAL_BUFFER=y USE_OUTPUT_RELEASE=y USE_DEC_IRQ=y USE_NON_BLOCKING=y USE_ONE_THREAD_WAITCC=y USE_PICTURE_DISCARD=y CC="$(CC)" AR="$(AR) -rc"
 	$(AR) -rc $@ $(LIBG1_LIBS)
 
 
diff --git a/Makefile_H1 b/Makefile_H1
index 9ab62e1..961303e 100755
--- a/Makefile_H1
+++ b/Makefile_H1
@@ -81,4 +81,5 @@ clean:
 	make -C $(SOURCE_ROOT)/linux_reference/test/h264 clean
 #	make -C $(SOURCE_ROOT)/linux_reference/test/jpeg clean
 	make -C $(SOURCE_ROOT)/linux_reference/test/vp8 clean
+	make -f Makefile_codec_enc LIBNAME="$(LIBENCNAME)" clean
 
diff --git a/decoder_sw/lib/lib8170hw.a b/decoder_sw/lib/lib8170hw.a
index 745d639..b1a64b1 100755
Binary files a/decoder_sw/lib/lib8170hw.a and b/decoder_sw/lib/lib8170hw.a differ
diff --git a/decoder_sw/software/common/common.mk b/decoder_sw/software/common/common.mk
index a99100c..c8ff0e9 100755
--- a/decoder_sw/software/common/common.mk
+++ b/decoder_sw/software/common/common.mk
@@ -110,7 +110,7 @@ ifeq ($(USE_HW_PIC_DIMENSIONS), y)
 endif
 
 # Define for using prebuilt library
-USE_MODEL_LIB ?= y
+USE_MODEL_LIB ?= n
 
 DEFINES += -DFIFO_DATATYPE=void*
 # Common error flags for all targets
@@ -120,7 +120,7 @@ CFLAGS += -Wno-variadic-macros
 
 # Common libraries
 LDFLAGS += -L$(OBJDIR) -pthread
-LDFLAGS += -L./lib -lg2hw
+
 # MACRO for cleaning object -files
 RM  = rm -f
 
diff --git a/decoder_sw/software/linux/avs/Makefile b/decoder_sw/software/linux/avs/Makefile
index dd0b945..11cf675 100755
--- a/decoder_sw/software/linux/avs/Makefile
+++ b/decoder_sw/software/linux/avs/Makefile
@@ -86,7 +86,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) $(DEBFLAGS) $(INCLUDE) $(SETTING_FLAGS)
+CFLAGS += $(ARCH) $(DEBFLAGS) $(INCLUDE) $(SETTING_FLAGS) $(M32)
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
 	CFLAGS += -DASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/linux/dwl/Makefile b/decoder_sw/software/linux/dwl/Makefile
index 3f0e180..5f50db6 100755
--- a/decoder_sw/software/linux/dwl/Makefile
+++ b/decoder_sw/software/linux/dwl/Makefile
@@ -213,11 +213,11 @@ $(OBJDIR):
 
 pclinux: CFLAGS += $(M32)
 pclinux: $(DECLIB)
-#	make -C ../../../system/models/g1hw
+	make -C ../../../system/models/g1hw
 	
 arm_pclinux: CROSS = aarch64-linux-gnu-
 arm_pclinux: $(DECLIB)
-#	make -C ../../../system/models/g1hw arm_pclinux
+	make -C ../../../system/models/g1hw arm_pclinux
 
 pclinux_eval: CFLAGS += $(M32)
 pclinux_eval: DEBFLAGS = -O3 -DNDEBUG
@@ -262,7 +262,7 @@ clean:
 	$(RM) $(DECLIB)
 	$(RM) .depend
 	$(RM) -r $(OBJDIR)
-#	@-make -C ../../../system/models/g1hw/ clean 2>/dev/null
+	@-make -C ../../../system/models/g1hw/ clean 2>/dev/null
 
 depend .depend: $(SRCS)
 	$(CC) $(CFLAGS) $(ENVSET) -M  $^ > .depend
diff --git a/decoder_sw/software/linux/dwl/dwl_hw_core_array.c b/decoder_sw/software/linux/dwl/dwl_hw_core_array.c
index 229f89a..20a39c7 100755
--- a/decoder_sw/software/linux/dwl/dwl_hw_core_array.c
+++ b/decoder_sw/software/linux/dwl/dwl_hw_core_array.c
@@ -67,12 +67,22 @@ HwCoreArray InitializeCoreArray() {
   u32 i;
   struct HwCoreArrayInstance* array =
     malloc(sizeof(struct HwCoreArrayInstance));
+  if (array == NULL)
+    return NULL;
   array->num_of_cores = GetCoreCount();
   sem_init(&array->core_lock, 0, array->num_of_cores);
 
   sem_init(&array->core_rdy, 0, 0);
 
   array->cores = calloc(array->num_of_cores, sizeof(struct HwCoreContainer));
+  if (array->cores == NULL) 
+  {
+    sem_destroy(&array->core_lock);
+    sem_destroy(&array->core_rdy);
+    free(array);
+    return NULL;
+  }
+
   assert(array->cores);
   for (i = 0; i < array->num_of_cores; i++) {
     array->cores[i].core = HwCoreInit();
@@ -113,10 +123,10 @@ Core BorrowHwCore(HwCoreArray inst) {
   return array->cores[i].core;
 }
 
-void ReturnHwCore(HwCoreArray inst, Core Core) {
+void ReturnHwCore(HwCoreArray inst, Core core) {
   struct HwCoreArrayInstance* array = (struct HwCoreArrayInstance*)inst;
 
-  HwCoreUnlock(Core);
+  HwCoreUnlock(core);
 
   sem_post(&array->core_lock);
 }
diff --git a/decoder_sw/software/linux/dwl/dwl_linux.c b/decoder_sw/software/linux/dwl/dwl_linux.c
index 4b4e304..6de0c8a 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux.c
@@ -166,7 +166,7 @@ static void DWLFakeTimeout(u32 *status);
 /* shadow HW registers */
 u32 dwl_shadow_regs[MAX_ASIC_CORES][264];
 
-static inline u32 CheckRegOffset(struct HX170DWL *dec_dwl, u32 offset) {
+static inline u32 CheckRegOffset(struct HANTRODWL *dec_dwl, u32 offset) {
   if (dec_dwl->client_type == DWL_CLIENT_TYPE_PP)
     return offset < dec_dwl->reg_size && offset >= HANTRODECPP_REG_START;
   else
@@ -196,6 +196,34 @@ static void PrintIrqType(u32 core_id, u32 status) {
 }
 #endif
 
+#ifdef CFG_SECURE_DATA_PATH
+u32 *DWLReadRegisters(int mem_dev, unsigned int core_id, unsigned int reg_size)
+{
+  const char *io = NULL;
+  struct core_desc Core;
+ 
+  DWL_DEBUG("%s %d
", __func__, core_id);
+ 
+  io = DWLmalloc(reg_size);
+  if (!io)
+    goto error;
+ 
+  Core.id = core_id;
+  Core.regs = io;
+  Core.size = reg_size;
+
+  if (ioctl(mem_dev, HANTRODEC_IOCS_DEC_PULL_REG, &Core)) {
+    DWL_DEBUG("%s","ioctl HANTRODEC_IOCS_*_PULL_REG failed
");
+    goto error;
+  }
+ 
+  return (u32 *)io;
+
+error:
+  DWLfree(io);
+  return NULL;
+}
+#endif
 /*------------------------------------------------------------------------------
     Function name   : DWLMapRegisters
     Description     :
@@ -687,19 +715,31 @@ void DWLReadAsicConfig(DWLHwConfig *hw_cfg,u32 client_type) {
     goto end;
   }
   
+#ifdef CFG_SECURE_DATA_PATH
+  io = DWLReadRegisters(fd_dec,core_id, reg_size);
+  if (io == NULL) {
+    DWL_DEBUG("%s","failed to read registers
");
+    goto end;
+  }
+#else
   io = DWLMapRegisters(fd_dec, base, reg_size, 0);
   if (io == MAP_FAILED) {
     DWL_DEBUG("%s","failed to mmap registers
");
     goto end;
   }
-  
+#endif
+
   /* Decoder configuration */
   memset(hw_cfg, 0, sizeof(*hw_cfg));
 
   ReadCoreConfig(io, hw_cfg);
   asic_cfg_info[idx].cfg = *hw_cfg; /*store the value*/
 
+#ifdef CFG_SECURE_DATA_PATH
+  DWLfree(io);
+#else
   DWLUnmapRegisters(io, reg_size);
+#endif
 
 end:
   //if (fd != -1) close(fd);
@@ -753,15 +793,27 @@ void DWLReadMCAsicConfig(DWLHwConfig hw_cfg[MAX_ASIC_CORES]) {
   memset(hw_cfg, 0, MAX_ASIC_CORES * sizeof(*hw_cfg));
 
   for (i = 0; i < n_cores; i++) {
+#ifdef CFG_SECURE_DATA_PATH
+    io = DWLReadRegisters(fd_dec,i, reg_size);
+    if (io == NULL) {
+      DWL_DEBUG("%s","failed to read registers
");
+      goto end;
+    }
+#else
     io = DWLMapRegisters(fd_dec, mc_reg_base[i], reg_size, 0);
     if (io == MAP_FAILED) {
       DWL_DEBUG("%s","failed to mmap registers
");
       goto end;
     }
+#endif
 
     ReadCoreConfig(io, hw_cfg + i);
 
+#ifdef CFG_SECURE_DATA_PATH
+    DWLfree(io);
+#else
     DWLUnmapRegisters(io, reg_size);
+#endif
   }
 
 end:
@@ -814,17 +866,28 @@ void DWLReadAsicFuseStatus(struct DWLHwFuseStatus *hw_fuse_sts) {
     goto end;
   }
 
+#ifdef CFG_SECURE_DATA_PATH
+  io = DWLReadRegisters(fd_dec,0, reg_size);
+  if (io == NULL) {
+    DWL_DEBUG("%s","failed to read registers
");
+    goto end;
+  }
+#else
   io = DWLMapRegisters(fd_dec, base, reg_size, 0);
-
   if (io == MAP_FAILED) {
     DWL_DEBUG("%s","failed to mmap
");
     goto end;
   }
+#endif
 
   /* Decoder fuse configuration */
   ReadCoreFuse(io, hw_fuse_sts);
 
+#ifdef CFG_SECURE_DATA_PATH
+  DWLfree(io);
+#else
   DWLUnmapRegisters(io, reg_size);
+#endif
 
 end:
   //if (fd != -1) close(fd);
@@ -879,7 +942,7 @@ void DWLFreeRefFrm(const void *instance, struct DWLLinearMem *info) {
 #ifdef USE_ION
 #if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 34)
 i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   u32 pgsize = getpagesize();
 #ifdef USE_ION
@@ -930,7 +993,6 @@ i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
 #else
 #ifdef ANDROID
   allocation_data.heap_id_mask = ((1 << ION_CMA_HEAP_ID) | (1 << ION_CARVEOUT_HEAP_ID));
-  allocation_data.flags = ION_FLAG_CACHED;
 #else
   allocation_data.heap_id_mask = 1;
 #endif
@@ -1006,7 +1068,7 @@ i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
 #endif
 
 #ifdef MEMORY_USAGE_TRACE
-printf("DWLMallocLinear 0x%08x virtual_address: 0x%08x (type %d)
", info->bus_address,
+  printf("DWLMallocLinear 0x%08x virtual_address: 0x%08x (type %d)
", info->bus_address,
          (unsigned)info->virtual_address, info->mem_type);
 #endif
   
@@ -1026,7 +1088,7 @@ bail:
 
 #else //LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 34)
 i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   u32 pgsize = getpagesize();
 
@@ -1122,7 +1184,6 @@ i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
   allocation_data.heap_id_mask = heap_mask;
   allocation_data.len = info->size;
 #ifdef ANDROID
-  allocation_data.flags = ION_FLAG_CACHED;
   ret = ioctl (dec_dwl->fd_memalloc, ION_IOC_NEW_ALLOC, &allocation_data);
 #else
   ret = ioctl (dec_dwl->fd_memalloc, ION_IOC_ALLOC, &allocation_data);
@@ -1202,7 +1263,7 @@ bail:
     Argument        : void *info - linear buffer memory information
 ------------------------------------------------------------------------------*/
 void DWLFreeLinear(const void *instance, struct DWLLinearMem *info) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   assert(dec_dwl != NULL);
   assert(info != NULL);
@@ -1256,7 +1317,7 @@ void DWLFreeLinear(const void *instance, struct DWLLinearMem *info) {
 ------------------------------------------------------------------------------*/
 
 void DWLWriteReg(const void *instance, i32 core_id, u32 offset, u32 value) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
 #ifndef DWL_DISABLE_REG_PRINTS
   DWL_DEBUG("Core[%d] swreg[%d] at offset 0x%02X = %08X
", core_id, offset / 4,
@@ -1287,7 +1348,7 @@ void DWLWriteReg(const void *instance, i32 core_id, u32 offset, u32 value) {
     Argument        : u32 offset - byte offset of the register to be read
 ------------------------------------------------------------------------------*/
 u32 DWLReadReg(const void *instance, i32 core_id, u32 offset) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
   u32 val;
 
   assert(dec_dwl != NULL);
@@ -1320,8 +1381,8 @@ u32 DWLReadReg(const void *instance, i32 core_id, u32 offset) {
     Argument        : u32 value - value to be written out
 ------------------------------------------------------------------------------*/
 void DWLEnableHw(const void *instance, i32 core_id, u32 offset, u32 value) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
-  struct core_desc Core;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
+  struct core_desc core;
   int ioctl_req;
 
   assert(dec_dwl);
@@ -1332,13 +1393,13 @@ void DWLEnableHw(const void *instance, i32 core_id, u32 offset, u32 value) {
 
   DWL_DEBUG("%s %d enabled by previous DWLWriteReg
", "DEC", core_id);
 
-  Core.id = core_id;
-  Core.regs = dwl_shadow_regs[core_id];
-  Core.size = dec_dwl->reg_size;
+  core.id = core_id;
+  core.regs = dwl_shadow_regs[core_id];
+  core.size = dec_dwl->reg_size;
 
   ActivityTraceStartDec(&dec_dwl->activity);
 
-  if (ioctl(dec_dwl->fd, ioctl_req, &Core)) {
+  if (ioctl(dec_dwl->fd, ioctl_req, &core)) {
     DWL_DEBUG("%s","ioctl HANTRODEC_IOCS_*_PUSH_REG failed
");
     assert(0);
   }
@@ -1353,8 +1414,8 @@ void DWLEnableHw(const void *instance, i32 core_id, u32 offset, u32 value) {
     Argument        : u32 value - value to be written out
 ------------------------------------------------------------------------------*/
 void DWLDisableHw(const void *instance, i32 core_id, u32 offset, u32 value) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
-  struct core_desc Core;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
+  struct core_desc core;
   int ioctl_req;
 
   assert(dec_dwl);
@@ -1365,11 +1426,11 @@ void DWLDisableHw(const void *instance, i32 core_id, u32 offset, u32 value) {
 
   DWL_DEBUG("%s %d disabled by previous DWLWriteReg
", "DEC", core_id);
 
-  Core.id = core_id;
-  Core.regs = dwl_shadow_regs[core_id];
-  Core.size = dec_dwl->reg_size;
+  core.id = core_id;
+  core.regs = dwl_shadow_regs[core_id];
+  core.size = dec_dwl->reg_size;
 
-  if (ioctl(dec_dwl->fd, ioctl_req, &Core)) {
+  if (ioctl(dec_dwl->fd, ioctl_req, &core)) {
     DWL_DEBUG("%s","ioctl HANTRODEC_IOCS_*_PUSH_REG failed
");
     assert(0);
   }
@@ -1388,8 +1449,8 @@ void DWLDisableHw(const void *instance, i32 core_id, u32 offset, u32 value) {
     Argument        : const void * instance - DWL instance
 ------------------------------------------------------------------------------*/
 i32 DWLWaitHwReady(const void *instance, i32 core_id, u32 timeout) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
-  struct core_desc Core;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
+  struct core_desc core;
   int ioctl_req;
   i32 ret = DWL_HW_WAIT_OK;
 
@@ -1401,16 +1462,16 @@ i32 DWLWaitHwReady(const void *instance, i32 core_id, u32 timeout) {
 
   DWL_DEBUG("%s %d
", "DEC", core_id);
 
-  Core.id = core_id;
-  Core.regs = dwl_shadow_regs[core_id];
-  Core.size = dec_dwl->reg_size;
+  core.id = core_id;
+  core.regs = dwl_shadow_regs[core_id];
+  core.size = dec_dwl->reg_size;
 
 #ifdef DWL_USE_DEC_IRQ
 #if 1
   /*wait for interrupt from specified core*/
   ioctl_req = (int)HANTRODEC_IOCX_DEC_WAIT;
   DWL_DEBUG("%s","DWLWaitHwReady wait irq
");
-  if (ioctl(dec_dwl->fd, ioctl_req, &Core)) {
+  if (ioctl(dec_dwl->fd, ioctl_req, &core)) {
     DWL_DEBUG("%s","ioctl HANTRODEC_IOCG_*_WAIT failed
");
     ret = DWL_HW_WAIT_ERROR;
   }
@@ -1427,7 +1488,7 @@ i32 DWLWaitHwReady(const void *instance, i32 core_id, u32 timeout) {
     u32 irq_stats;
     const unsigned int usec = 1000; /* 1 ms polling interval */
     DWL_DEBUG("%s","do polling to get IRQ status
");
-    if (ioctl(dec_dwl->fd, ioctl_req, &Core)) {
+    if (ioctl(dec_dwl->fd, ioctl_req, &core)) {
       DWL_DEBUG("%s","ioctl HANTRODEC_IOCS_*_PULL_REG failed
");
       ret = DWL_HW_WAIT_ERROR;
       break;
diff --git a/decoder_sw/software/linux/dwl/dwl_linux.h b/decoder_sw/software/linux/dwl/dwl_linux.h
index c6b7574..f270eeb 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux.h
+++ b/decoder_sw/software/linux/dwl/dwl_linux.h
@@ -114,7 +114,7 @@ struct MCListenerThreadParams {
 };
 
 /* wrapper information */
-struct HX170DWL {
+struct HANTRODWL {
   u32 client_type;
   int fd;          /* decoder device file */
   int fd_mem;      /* /dev/mem for mapping */
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_hw.c b/decoder_sw/software/linux/dwl/dwl_linux_hw.c
index 5600d57..5c6c278 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_hw.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_hw.c
@@ -68,7 +68,7 @@ const char *dec_dev = DEC_MODULE_PATH;
 /* the memalloc device driver nod */
 const char *mem_dev = MEMALLOC_MODULE_PATH;
 
-/* counters for Core usage statistics */
+/* counters for core usage statistics */
 u32 core_usage_counts[MAX_ASIC_CORES] = {0};
 
 /* a mutex protecting the wrapper init */
@@ -85,16 +85,16 @@ extern u32 dwl_shadow_regs[MAX_ASIC_CORES][264];
     Argument        : void * param - not in use, application passes NULL
 ------------------------------------------------------------------------------*/
 const void *DWLInit(struct DWLInitParam *param) {
-  struct HX170DWL *dec_dwl;
+  struct HANTRODWL *dec_dwl;
   
   int core_id;
   
   DWL_DEBUG("%s","INITIALIZE
");
 
-  dec_dwl = (struct HX170DWL *)calloc(1, sizeof(struct HX170DWL));
+  dec_dwl = (struct HANTRODWL *)calloc(1, sizeof(struct HANTRODWL));
 
   if (dec_dwl == NULL) {
-    DWL_DEBUG("%s","failed to alloc struct HX170DWL struct
");
+    DWL_DEBUG("%s","failed to alloc struct HANTRODWL struct
");
     return NULL;
   }
 
@@ -212,7 +212,7 @@ err:
     Argument        : const void * instance - instance to be released
 ------------------------------------------------------------------------------*/
 i32 DWLRelease(const void *instance) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
   unsigned int i = 0;
 
   DWL_DEBUG("%s","RELEASE
");
@@ -230,7 +230,7 @@ i32 DWLRelease(const void *instance) {
   /* linear memory allocator */
   if (dec_dwl->fd_memalloc != -1) close(dec_dwl->fd_memalloc);
 
-  /* print Core usage stats */
+  /* print core usage stats */
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
     u32 total_usage = 0;
     u32 cores = dec_dwl->num_cores;
@@ -267,11 +267,11 @@ i32 DWLRelease(const void *instance) {
     Description     :
     Return type     : i32
     Argument        : const void *instance
-    Argument        : i32 *core_id - ID of the reserved HW Core
+    Argument        : i32 *core_id - ID of the reserved HW core
 ------------------------------------------------------------------------------*/
 i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
   
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   assert(dec_dwl != NULL);
   assert(dec_dwl->client_type != DWL_CLIENT_TYPE_PP);
@@ -288,7 +288,7 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
 
   core_usage_counts[*core_id]++;
 
-  DWL_DEBUG("Reserved DEC Core %d
", *core_id);
+  DWL_DEBUG("Reserved DEC core %d
", *core_id);
 
   return DWL_OK;
 }
@@ -298,10 +298,10 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
     Description     :
     Return type     : i32
     Argument        : const void *instance
-    Argument        : i32 *core_id - ID of the reserved HW Core
+    Argument        : i32 *core_id - ID of the reserved HW core
 ------------------------------------------------------------------------------*/
 i32 DWLReserveHw(const void *instance, i32 *core_id) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   assert(dec_dwl != NULL);
 
@@ -320,7 +320,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
 
   core_usage_counts[*core_id]++;
 
-  DWL_DEBUG("Reserved %s Core %d
", "DEC", *core_id);
+  DWL_DEBUG("Reserved %s core %d
", "DEC", *core_id);
 
   return DWL_OK;
 }
@@ -332,7 +332,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
     Argument        : const void *instance
 ------------------------------------------------------------------------------*/
 void DWLReleaseHw(const void *instance, i32 core_id) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   assert((u32)core_id < dec_dwl->num_cores);
   assert(dec_dwl != NULL);
@@ -342,14 +342,14 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
     return;
   }
 
-  DWL_DEBUG(" %s Core %d
", "DEC", core_id);
+  DWL_DEBUG(" %s core %d
", "DEC", core_id);
 
   ioctl(dec_dwl->fd, HANTRODEC_IOCT_DEC_RELEASE, core_id);
 }
 
 void DWLSetIRQCallback(const void *instance, i32 core_id,
                        DWLIRQCallbackFn *callback_fn, void *arg) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
 
   dec_dwl->sync_params->callback[core_id] = callback_fn;
   dec_dwl->sync_params->callback_arg[core_id] = arg;
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_mc.c b/decoder_sw/software/linux/dwl/dwl_linux_mc.c
index cb38fb0..8cf950f 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_mc.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_mc.c
@@ -68,7 +68,7 @@ const char *dec_dev = DEC_MODULE_PATH;
 /* the memalloc device driver nod */
 const char *mem_dev = MEMALLOC_MODULE_PATH;
 
-/* counters for Core usage statistics */
+/* counters for core usage statistics */
 u32 core_usage_counts[MAX_ASIC_CORES] = {0};
 
 /* a mutex protecting the wrapper init */
@@ -85,7 +85,7 @@ void * thread_mc_listener(void *args) {
 
   while (!params->b_stopped) {
     u32 id;
-    struct core_desc Core;
+    struct core_desc core;
 
 #ifdef DWL_USE_DEC_IRQ
     if (ioctl(params->fd, HANTRODEC_IOCG_CORE_WAIT, &id)) {
@@ -97,15 +97,15 @@ void * thread_mc_listener(void *args) {
 
     DWL_DEBUG("DEC IRQ by Core %d
", id);
 
-    Core.id = id;
-    Core.regs = dwl_shadow_regs[id];
+    core.id = id;
+    core.regs = dwl_shadow_regs[id];
 #ifdef USE_64BIT_ENV
-    Core.size = (60+27)*4;
+    core.size = (60+27)*4;
 #else
-    Core.size = 60*4;
+    core.size = 60*4;
 #endif
 
-    if (ioctl(params->fd, HANTRODEC_IOCS_DEC_PULL_REG, &Core)) {
+    if (ioctl(params->fd, HANTRODEC_IOCS_DEC_PULL_REG, &core)) {
       DWL_DEBUG("ioctl HANTRODEC_IOCS_DEC_PULL_REG failed
");
       assert(0);
     }
@@ -113,15 +113,15 @@ void * thread_mc_listener(void *args) {
     if(params->callback[id] != NULL) {
       params->callback[id](params->callback_arg[id], id);
     } else {
-      DWL_DEBUG("SINGLE CORE IRQ, Core = %d
", id);
+      DWL_DEBUG("SINGLE CORE IRQ, core = %d
", id);
       sem_post(params->sc_dec_rdy_sem + id);
     }
 #else
 
 #ifdef USE_64BIT_ENV
-    Core.size = (60+27)*4;
+    core.size = (60+27)*4;
 #else
-    Core.size = 60*4;
+    core.size = 60*4;
 #endif
 
     for (id = 0; id < params->n_dec_cores; id++) {
@@ -140,10 +140,10 @@ void * thread_mc_listener(void *args) {
         continue;
       }
 
-      Core.id = id;
-      Core.regs = dwl_shadow_regs[id];
+      core.id = id;
+      core.regs = dwl_shadow_regs[id];
 
-      if (ioctl(params->fd, HANTRODEC_IOCS_DEC_PULL_REG, &Core)) {
+      if (ioctl(params->fd, HANTRODEC_IOCS_DEC_PULL_REG, &core)) {
         DWL_DEBUG("ioctl HANTRODEC_IOCS_DEC_PULL_REG failed
");
         continue;
       }
@@ -174,13 +174,13 @@ void * thread_mc_listener(void *args) {
     Argument        : void * param - not in use, application passes NULL
 ------------------------------------------------------------------------------*/
 const void *DWLInit(struct DWLInitParam * param) {
-  struct HX170DWL *dec_dwl;
+  struct HANTRODWL *dec_dwl;
   unsigned long multicore_base[MAX_ASIC_CORES];
   unsigned int i;
 
   DWL_DEBUG("INITIALIZE
");
 
-  dec_dwl = (struct HX170DWL *) calloc(1, sizeof(struct HX170DWL));
+  dec_dwl = (struct HANTRODWL *) calloc(1, sizeof(struct HANTRODWL));
 
   if(dec_dwl == NULL) {
     DWL_DEBUG("failed to alloc struct HX170DWL struct
");
@@ -271,7 +271,7 @@ const void *DWLInit(struct DWLInitParam * param) {
 
     listener_thread_params.fd = dec_dwl->fd;
     listener_thread_params.n_dec_cores = dec_dwl->num_cores;
-    listener_thread_params.n_ppcores  = 1; /* no multi-Core support */
+    listener_thread_params.n_ppcores  = 1; /* no multi-core support */
 
     for (i = 0; i < listener_thread_params.n_dec_cores; i++) {
       sem_init(listener_thread_params.sc_dec_rdy_sem + i, 0,0);
@@ -312,7 +312,7 @@ err:
     Argument        : const void * instance - instance to be released
 ------------------------------------------------------------------------------*/
 i32 DWLRelease(const void *instance) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
   unsigned int i = 0;
 
   DWL_DEBUG("RELEASE
");
@@ -346,7 +346,7 @@ i32 DWLRelease(const void *instance) {
     close(dec_dwl->fd_memalloc);
 
 
-  /* print Core usage stats */
+  /* print core usage stats */
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
     u32 total_usage = 0;
     u32 cores = dec_dwl->num_cores;
@@ -355,7 +355,7 @@ i32 DWLRelease(const void *instance) {
     /* avoid zero division */
     total_usage = total_usage ? total_usage : 1;
 
-    printf("
Multi-Core usage statistics:
");
+    printf("
Multi-core usage statistics:
");
     for(i = 0; i < cores; i++)
       printf("	Core[%2d] used %6d times (%2d%%)
",
              i, core_usage_counts[i],
@@ -384,11 +384,11 @@ i32 DWLRelease(const void *instance) {
     Description     :
     Return type     : i32
     Argument        : const void *instance
-    Argument        : i32 *core_id - ID of the reserved HW Core
+    Argument        : i32 *core_id - ID of the reserved HW core
 ------------------------------------------------------------------------------*/
 i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
   i32 ret;
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
 
   assert(dec_dwl != NULL);
   assert(dec_dwl->client_type != DWL_CLIENT_TYPE_PP);
@@ -406,7 +406,7 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
   /* reserve PP */
   ret = ioctl(dec_dwl->fd, HANTRODEC_IOCQ_PP_RESERVE);
 
-  /* for pipeline we expect same Core for both dec and PP */
+  /* for pipeline we expect same core for both dec and PP */
   if (ret != *core_id) {
     /* release the decoder */
     ioctl(dec_dwl->fd, HANTRODEC_IOCT_DEC_RELEASE, core_id);
@@ -417,7 +417,7 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
 
   dec_dwl->b_ppreserved = 1;
 
-  DWL_DEBUG("Reserved DEC+PP Core %d
", *core_id);
+  DWL_DEBUG("Reserved DEC+PP core %d
", *core_id);
 
   return DWL_OK;
 }
@@ -427,10 +427,10 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
     Description     :
     Return type     : i32
     Argument        : const void *instance
-    Argument        : i32 *core_id - ID of the reserved HW Core
+    Argument        : i32 *core_id - ID of the reserved HW core
 ------------------------------------------------------------------------------*/
 i32 DWLReserveHw(const void *instance, i32 *core_id) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
   int is_pp;
 
   assert(dec_dwl != NULL);
@@ -442,7 +442,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
   if (is_pp) {
     *core_id = ioctl(dec_dwl->fd, HANTRODEC_IOCQ_PP_RESERVE);
 
-    /* PP is single Core so we expect a zero return value */
+    /* PP is single core so we expect a zero return value */
     if (*core_id != 0) {
       return DWL_ERROR;
     }
@@ -460,7 +460,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
 
   core_usage_counts[*core_id]++;
 
-  DWL_DEBUG("Reserved %s Core %d
", is_pp ? "PP" : "DEC", *core_id);
+  DWL_DEBUG("Reserved %s core %d
", is_pp ? "PP" : "DEC", *core_id);
 
   return DWL_OK;
 }
@@ -472,7 +472,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
     Argument        : const void *instance
 ------------------------------------------------------------------------------*/
 void DWLReleaseHw(const void *instance, i32 core_id) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
   int is_pp;
 
   assert((u32)core_id < dec_dwl->num_cores);
@@ -485,7 +485,7 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
     return;
   }
 
-  DWL_DEBUG(" %s Core %d
", is_pp ? "PP" : "DEC", core_id);
+  DWL_DEBUG(" %s core %d
", is_pp ? "PP" : "DEC", core_id);
 
   if (is_pp) {
     assert(core_id == 0);
@@ -494,7 +494,7 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
   } else {
     if (dec_dwl->b_ppreserved) {
       /* decoder has reserved PP also => release it */
-      DWL_DEBUG("DEC released PP Core %d
", core_id);
+      DWL_DEBUG("DEC released PP core %d
", core_id);
 
       dec_dwl->b_ppreserved = 0;
 
@@ -509,7 +509,7 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
 
 void DWLSetIRQCallback(const void *instance, i32 core_id,
                        DWLIRQCallbackFn *callback_fn, void* arg) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
 
   dec_dwl->sync_params->callback[core_id] = callback_fn;
   dec_dwl->sync_params->callback_arg[core_id] = arg;
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_sc.c b/decoder_sw/software/linux/dwl/dwl_linux_sc.c
index 75e0cb2..563402c 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_sc.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_sc.c
@@ -64,7 +64,7 @@ const char *mem_dev = MEMALLOC_MODULE_PATH;
 /* a mutex protecting the wrapper init */
 static pthread_mutex_t x170_init_mutex = PTHREAD_MUTEX_INITIALIZER;
 
-/* counters for Core usage statistics */
+/* counters for core usage statistics */
 u32 core_usage_counts[MAX_ASIC_CORES] = {0};
 
 /*------------------------------------------------------------------------------
@@ -76,16 +76,16 @@ u32 core_usage_counts[MAX_ASIC_CORES] = {0};
     Argument        : void * param - not in use, application passes NULL
 ------------------------------------------------------------------------------*/
 const void *DWLInit(struct DWLInitParam * param) {
-  struct HX170DWL *dec_dwl;
+  struct HANTRODWL *dec_dwl;
   
   int core_id;
   
   DWL_DEBUG("%s","INITIALIZE
");
 
-  dec_dwl = (struct HX170DWL *)calloc(1, sizeof(struct HX170DWL));
+  dec_dwl = (struct HANTRODWL *)calloc(1, sizeof(struct HANTRODWL));
 
   if (dec_dwl == NULL) {
-	DWL_DEBUG("%s","failed to alloc struct HX170DWL struct
");
+	DWL_DEBUG("%s","failed to alloc struct HANTRODWL struct
");
 	return NULL;
   }
 
@@ -201,7 +201,7 @@ err:
     Argument        : const void * instance - instance to be released
 ------------------------------------------------------------------------------*/
 i32 DWLRelease(const void *instance) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *)instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
   unsigned int i = 0;
 
   DWL_DEBUG("%s","RELEASE
");
@@ -219,7 +219,7 @@ i32 DWLRelease(const void *instance) {
   /* linear memory allocator */
   if (dec_dwl->fd_memalloc != -1) close(dec_dwl->fd_memalloc);
 
-  /* print Core usage stats */
+  /* print core usage stats */
   if (dec_dwl->client_type != DWL_CLIENT_TYPE_PP) {
 	u32 total_usage = 0;
 	u32 cores = dec_dwl->num_cores;
@@ -256,11 +256,11 @@ i32 DWLRelease(const void *instance) {
     Description     :
     Return type     : i32
     Argument        : const void *instance
-    Argument        : i32 *core_id - ID of the reserved HW Core
+    Argument        : i32 *core_id - ID of the reserved HW core
 ------------------------------------------------------------------------------*/
 i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
   i32 ret;
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
 
   assert(dec_dwl != NULL);
   assert(dec_dwl->client_type != DWL_CLIENT_TYPE_PP);
@@ -287,7 +287,7 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
 
   dec_dwl->b_ppreserved = 1;
 
-  DWL_DEBUG("Reserved DEC+PP Core %d
", *core_id);
+  DWL_DEBUG("Reserved DEC+PP core %d
", *core_id);
 
   return DWL_OK;
 }
@@ -297,10 +297,10 @@ i32 DWLReserveHwPipe(const void *instance, i32 *core_id) {
     Description     :
     Return type     : i32
     Argument        : const void *instance
-    Argument        : i32 *core_id - ID of the reserved HW Core
+    Argument        : i32 *core_id - ID of the reserved HW core
 ------------------------------------------------------------------------------*/
 i32 DWLReserveHw(const void *instance, i32 *core_id) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
   int is_pp;
 
   assert(dec_dwl != NULL);
@@ -312,7 +312,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
   if (is_pp) {
     *core_id = ioctl(dec_dwl->fd, HANTRODEC_IOCQ_PP_RESERVE);
 
-    /* PP is single Core so we expect a zero return value */
+    /* PP is single core so we expect a zero return value */
     if (*core_id != 0) {
       return DWL_ERROR;
     }
@@ -323,12 +323,12 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
 
   /* negative value signals an error */
   if (*core_id < 0) {
-    DWL_DEBUG("ioctl HANTRODEC_IOCS_%s_reserve failed
",
+    DWL_DEBUG("ioctl HANTRODEC_IOCS_%s_RESERVE failed
",
               is_pp ? "PP" : "DEC");
     return DWL_ERROR;
   }
 
-  DWL_DEBUG("Reserved %s Core %d
", is_pp ? "PP" : "DEC", *core_id);
+  DWL_DEBUG("Reserved %s core %d
", is_pp ? "PP" : "DEC", *core_id);
 
   return DWL_OK;
 }
@@ -340,7 +340,7 @@ i32 DWLReserveHw(const void *instance, i32 *core_id) {
     Argument        : const void *instance
 ------------------------------------------------------------------------------*/
 void DWLReleaseHw(const void *instance, i32 core_id) {
-  struct HX170DWL *dec_dwl = (struct HX170DWL *) instance;
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *) instance;
   int is_pp;
 
   assert((u32)core_id < dec_dwl->num_cores);
@@ -351,7 +351,7 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
   if ((u32) core_id >= dec_dwl->num_cores)
     return;
 
-  DWL_DEBUG(" %s Core %d
", is_pp ? "PP" : "DEC", core_id);
+  DWL_DEBUG(" %s core %d
", is_pp ? "PP" : "DEC", core_id);
 
   if (is_pp) {
     assert(core_id == 0);
@@ -360,7 +360,7 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
   } else {
     if (dec_dwl->b_ppreserved) {
       /* decoder has reserved PP also => release it */
-      DWL_DEBUG("DEC released PP Core %d
", core_id);
+      DWL_DEBUG("DEC released PP core %d
", core_id);
 
       dec_dwl->b_ppreserved = 0;
 
@@ -375,7 +375,7 @@ void DWLReleaseHw(const void *instance, i32 core_id) {
 
 void DWLSetIRQCallback(const void *instance, i32 core_id,
                        DWLIRQCallbackFn *callback_fn, void* arg) {
-  /* not in use with single Core only control code */
+  /* not in use with single core only control code */
   UNUSED(instance);
   UNUSED(core_id);
   UNUSED(callback_fn);
diff --git a/decoder_sw/software/linux/dwl/dwl_pc.c b/decoder_sw/software/linux/dwl/dwl_pc.c
index c4af7a5..e60c720 100755
--- a/decoder_sw/software/linux/dwl/dwl_pc.c
+++ b/decoder_sw/software/linux/dwl/dwl_pc.c
@@ -340,6 +340,8 @@ const void *DWLInit(struct DWLInitParam *param) {
   unsigned int i;
 
   dwl_inst = (struct DWLInstance *)calloc(1, sizeof(struct DWLInstance));
+  if (dwl_inst == NULL)
+    return NULL;
   dwl_inst->reference_total = 0;
   dwl_inst->linear_total = 0;
 
@@ -382,6 +384,7 @@ const void *DWLInit(struct DWLInitParam *param) {
     break;
   default:
     printf("ERROR: DWL client type has to be always specified!
");
+    free(dwl_inst);
     return NULL;
   }
 
@@ -402,8 +405,10 @@ const void *DWLInit(struct DWLInitParam *param) {
 
     g_hw_core_array = InitializeCoreArray();
     if (g_hw_core_array == NULL) {
+      pthread_attr_destroy(&attr);
       free(dwl_inst);
       dwl_inst = NULL;
+      return NULL;
     }
 
     listener_thread_params.n_dec_cores = GetCoreCount();
@@ -705,6 +710,8 @@ void DWLWriteReg(const void *instance, i32 core_id, u32 offset, u32 value) {
   struct DWLInstance *dwl_inst = (struct DWLInstance *)instance;
   Core c = GetCoreById(dwl_inst->hw_core_array, core_id);
   u32 *core_reg_base = HwCoreGetBaseAddress(c);
+  if (core_reg_base == NULL)
+    return ;
 #ifndef DWL_DISABLE_REG_PRINTS
   DWL_DEBUG("core[%d] swreg[%d] at offset 0x%02X = %08X
", core_id, offset / 4,
             offset, value);
diff --git a/decoder_sw/software/linux/h264high/Makefile b/decoder_sw/software/linux/h264high/Makefile
index bc10c9f..9d102e9 100755
--- a/decoder_sw/software/linux/h264high/Makefile
+++ b/decoder_sw/software/linux/h264high/Makefile
@@ -50,10 +50,10 @@ CLEAR_HDRINFO_IN_SEEK = n
 DEBUG = y
 # Add your debugging flag (or not) to CFLAGS
 ifeq ($(DEBUG),y)
-  CFLAGS   = -g -O0
+  CFLAGS   = $(M32) -g -O0
   DEBFLAGS = -DDEBUG -D_ASSERT_USED -D_RANGE_CHECK -D_ERROR_PRINT
 else
-  CFLAGS   = -O3
+  CFLAGS   = $(M32) -O3
   DEBFLAGS = -DNDEBUG
 endif
 
diff --git a/decoder_sw/software/linux/jpeg/Makefile b/decoder_sw/software/linux/jpeg/Makefile
index 2df7f66..49d8398 100755
--- a/decoder_sw/software/linux/jpeg/Makefile
+++ b/decoder_sw/software/linux/jpeg/Makefile
@@ -91,7 +91,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE)
+CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(M32)
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
 	CFLAGS+=-DASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/linux/mpeg2/Makefile b/decoder_sw/software/linux/mpeg2/Makefile
index 37d2b92..73d3d6f 100755
--- a/decoder_sw/software/linux/mpeg2/Makefile
+++ b/decoder_sw/software/linux/mpeg2/Makefile
@@ -88,7 +88,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(SETTING_FLAGS)
+CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(SETTING_FLAGS) $(M32)
 
 # Update data elements from repeat sequence header and repeat sequence extension header
 # This is not allowed by the mpeg2 specification
diff --git a/decoder_sw/software/linux/mpeg4/Makefile b/decoder_sw/software/linux/mpeg4/Makefile
index 2f99bbc..6899d8c 100755
--- a/decoder_sw/software/linux/mpeg4/Makefile
+++ b/decoder_sw/software/linux/mpeg4/Makefile
@@ -97,7 +97,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(SETTING_FLAGS)
+CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(SETTING_FLAGS) $(M32)
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
 	CFLAGS += -DASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c b/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c
index 3054666..6b872f5 100755
--- a/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c
+++ b/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c
@@ -108,6 +108,18 @@ void WriteAsicCtrl(DecContainer * dec_container) {
   fdc_hex = fopen("dc_separate_coeffs.hex", "at");
   if(fctrl == NULL || fctrla == NULL ||
       fmv == NULL || fdc == NULL || hex_motion_vectors == NULL || fdc_hex == NULL) {
+    if(fctrl)
+      fclose(fctrl);
+    if(fctrla)
+      fclose(fctrla);
+    if(fmv)
+      fclose(fmv);
+    if(fdc)
+      fclose(fdc);
+    if(fdc_hex)
+      fclose(fdc_hex);
+    if(hex_motion_vectors)
+      fclose(hex_motion_vectors);
     return;
   }
 
@@ -314,6 +326,10 @@ void WriteAsicRlc(DecContainer * dec_container, u32 * phalves, u32 * pnum_addr)
   frlca = fopen("rlc.trc", "at");
 
   if(frlc == NULL || frlca == NULL) {
+    if(frlc)
+      fclose(frlc);
+    if(frlca)
+      fclose(frlca);
     return;
   }
 
diff --git a/decoder_sw/software/linux/rv/Makefile b/decoder_sw/software/linux/rv/Makefile
index 9b0d498..e85b98b 100755
--- a/decoder_sw/software/linux/rv/Makefile
+++ b/decoder_sw/software/linux/rv/Makefile
@@ -88,7 +88,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) -D_GNU_SOURCE $(INCLUDE) $(SETTING_FLAGS)
+CFLAGS += $(ARCH) -D_GNU_SOURCE $(INCLUDE) $(SETTING_FLAGS) $(M32)
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
 	CFLAGS += -DASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/linux/vc1/Makefile b/decoder_sw/software/linux/vc1/Makefile
index 4bcfd82..d38ac89 100755
--- a/decoder_sw/software/linux/vc1/Makefile
+++ b/decoder_sw/software/linux/vc1/Makefile
@@ -52,7 +52,7 @@ DEBUG = y
 
 # Add your debugging flag (or not) to CFLAGS
 ifeq ($(DEBUG),y)
-  DEBFLAGS = -g -DDEBUG -D_ASSERT_USED -D_RANGE_CHECK -D_ERROR_PRINT
+  DEBFLAGS = -g -DDEBUG -D_ASSERT_USED -D_RANGE_CHECK
 else
   DEBFLAGS = -O3 -DNDEBUG
 endif
@@ -93,7 +93,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE)
+CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(M32)
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
 	CFLAGS+=-DASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/linux/vp6/Makefile b/decoder_sw/software/linux/vp6/Makefile
index 66454cc..b6e6914 100755
--- a/decoder_sw/software/linux/vp6/Makefile
+++ b/decoder_sw/software/linux/vp6/Makefile
@@ -107,7 +107,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc \
 
 
 # extra compiler switches
-CFLAGS += -Wall -std=c99 -pedantic -fPIC
+CFLAGS += -Wall -std=c99 -pedantic $(M32) -fPIC
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
 	CFLAGS += -DASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/linux/vp8/Makefile b/decoder_sw/software/linux/vp8/Makefile
index da89c07..4d0b3fc 100755
--- a/decoder_sw/software/linux/vp8/Makefile
+++ b/decoder_sw/software/linux/vp8/Makefile
@@ -97,7 +97,7 @@ INCLUDE = -I. -I$(COMMON_SOURCE_DIR)/inc -I$(COMMON_SOURCE_DIR)/dwl \
 
 # compiler switches
 CFLAGS += -Wall -Wextra -std=c99 -pedantic -fPIC
-CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE)
+CFLAGS += $(ARCH) -D_GNU_SOURCE $(DEBFLAGS) $(INCLUDE) $(M32)
 CFLAGS += -DFIFO_DATATYPE=addr_t
 
 ifeq ($(ASIC_TRACE_SUPPORT), y)
diff --git a/decoder_sw/software/source/avs/avsdecapi.c b/decoder_sw/software/source/avs/avsdecapi.c
index e4dc6be..8bc62e0 100755
--- a/decoder_sw/software/source/avs/avsdecapi.c
+++ b/decoder_sw/software/source/avs/avsdecapi.c
@@ -1045,6 +1045,8 @@ void AvsDecRelease(AvsDecInst dec_inst) {
 #endif
 
   AvsFreeBuffers(dec_cont);
+  if (dec_cont->pp_buffer_queue)
+    InputQueueRelease(dec_cont->pp_buffer_queue);
 
   DWLfree(dec_cont);
 
diff --git a/decoder_sw/software/source/common/decapi.c b/decoder_sw/software/source/common/decapi.c
index 78af5bf..8e0c003 100755
--- a/decoder_sw/software/source/common/decapi.c
+++ b/decoder_sw/software/source/common/decapi.c
@@ -958,7 +958,7 @@ static void ParseSuperframeIndex(const u8* data, size_t data_sz,
 
 static enum DecRet Vp9Decode(void* inst, struct DWLLinearMem input, struct DecOutput* output,
                              u8* stream, u32 strm_len, struct DWL dwl, u32 pic_id) {
-  enum DecRet rv;
+  enum DecRet rv = DEC_OK;
   struct Vp9DecInput vp9_input;
   struct Vp9DecOutput vp9_output;
   dwl.memset(&vp9_input, 0, sizeof(vp9_input));
diff --git a/decoder_sw/software/source/common/raster_buffer_mgr.c b/decoder_sw/software/source/common/raster_buffer_mgr.c
index 5293517..ac0f1be 100755
--- a/decoder_sw/software/source/common/raster_buffer_mgr.c
+++ b/decoder_sw/software/source/common/raster_buffer_mgr.c
@@ -122,6 +122,8 @@ void RbmRelease(RasterBufferMgr instance) {
 /* Allocate internal buffers here. */
 RasterBufferMgr RbmInit(struct RasterBufferParams params) {
   RasterBufferMgrInst* inst = DWLmalloc(sizeof(RasterBufferMgrInst));
+  if (!inst)
+    return NULL;
   inst->num_buffers = params.num_buffers;
   inst->dwl = params.dwl;
   inst->ext_buffer_config = params.ext_buffer_config;
@@ -130,8 +132,10 @@ RasterBufferMgr RbmInit(struct RasterBufferParams params) {
   inst->pp_queue = NULL;
   if (size) {
     inst->pp_queue = InputQueueInit(inst->num_buffers);
-    if (!inst->pp_queue)
-      RbmRelease(inst);
+    if (!inst->pp_queue) {
+      DWLfree(inst);
+      return NULL;
+    }
   }
   return inst;
 }
diff --git a/decoder_sw/software/source/common/regdrv.c b/decoder_sw/software/source/common/regdrv.c
index 34e7220..8073442 100755
--- a/decoder_sw/software/source/common/regdrv.c
+++ b/decoder_sw/software/source/common/regdrv.c
@@ -118,8 +118,11 @@ void FlushDecRegisters(const void* dwl, i32 core_id, u32* regs) {
 #endif
 
   GetDecRegNumbers(&reg_count, reg_offsets, /* Writable regs only */1);
-  for (u32 i = 0; i < reg_count; i++)
+  for (u32 i = 0; i < reg_count; i++) {
+    if (i >= MAX_REG_COUNT)
+      return;
     DWLWriteReg(dwl, core_id, reg_offsets[i] * 4, regs[reg_offsets[i]]);
+  }
 }
 
 void RefreshDecRegisters(const void* dwl, i32 core_id, u32* regs) {
@@ -127,6 +130,9 @@ void RefreshDecRegisters(const void* dwl, i32 core_id, u32* regs) {
   u32 reg_offsets[MAX_REG_COUNT] = {0};
 
   GetDecRegNumbers(&reg_count, reg_offsets, /* All regs */0);
-  for (u32 i = 0; i < reg_count; i++)
+  for (u32 i = 0; i < reg_count; i++) {
+    if (i >= MAX_REG_COUNT)
+      return;
     regs[reg_offsets[i]] = DWLReadReg(dwl, core_id, reg_offsets[i] * 4);
+  }
 }
diff --git a/decoder_sw/software/source/common/regdrv_g1.h b/decoder_sw/software/source/common/regdrv_g1.h
index 49046b3..5beea56 100755
--- a/decoder_sw/software/source/common/regdrv_g1.h
+++ b/decoder_sw/software/source/common/regdrv_g1.h
@@ -48,6 +48,24 @@
     Module defines
 ------------------------------------------------------------------------------*/
 
+#define G1_RENAME_MACRO(macro) G1_##macro
+#define G1_RENAME_FUNC(func) G1##func
+
+#define SET_ADDR_REG G1_RENAME_MACRO(SET_ADDR_REG)
+#define SET_ADDR_REG2 G1_RENAME_MACRO(SET_ADDR_REG2)
+#define SET_PP_ADDR_REG G1_RENAME_MACRO(SET_PP_ADDR_REG)
+#define SET_PP_ADDR_REG2 G1_RENAME_MACRO(SET_PP_ADDR_REG2)
+#define GET_ADDR_REG G1_RENAME_MACRO(GET_ADDR_REG)
+#define GET_ADDR_REG2 G1_RENAME_MACRO(GET_ADDR_REG2)
+#define GET_PP_ADDR_REG G1_RENAME_MACRO(GET_PP_ADDR_REG)
+#define GET_PP_ADDR_REG2 G1_RENAME_MACRO(GET_PP_ADDR_REG2)
+#define SET_ADDR64_REG G1_RENAME_MACRO(SET_ADDR64_REG)
+#define GET_ADDR64_REG G1_RENAME_MACRO(GET_ADDR64_REG)
+#define SetDecRegister G1_RENAME_FUNC(SetDecRegister)
+#define GetDecRegister G1_RENAME_FUNC(GetDecRegister)
+#define SetPpRegister G1_RENAME_FUNC(SetPpRegister)
+#define GetPpRegister G1_RENAME_FUNC(GetPpRegister)
+
 #define DEC_8170_IRQ_RDY            0x02
 #define DEC_8170_IRQ_BUS            0x04
 #define DEC_8170_IRQ_BUFFER         0x08
@@ -72,91 +90,91 @@
 
 #ifdef USE_64BIT_ENV
 
-#define SET_ADDR_REG(reg_base, REGBASE, addr) do {\
+#define G1_SET_ADDR_REG(reg_base, REGBASE, addr) do {\
     SetDecRegister((reg_base), REGBASE, (u32)(addr));  \
     SetDecRegister((reg_base), REGBASE##_MSB, (u32)((addr) >> 32)); \
   } while (0)
 
-#define SET_ADDR_REG2(reg_base, lsb, msb, addr) do {\
+#define G1_SET_ADDR_REG2(reg_base, lsb, msb, addr) do {\
     SetDecRegister((reg_base), (lsb), (u32)(addr));  \
     SetDecRegister((reg_base), (msb), (u32)((addr) >> 32)); \
   } while (0)
 
-#define SET_PP_ADDR_REG(reg_base, REGBASE, addr) do {\
+#define G1_SET_PP_ADDR_REG(reg_base, REGBASE, addr) do {\
     SetPpRegister((reg_base), REGBASE, (u32)(addr));  \
     SetPpRegister((reg_base), REGBASE##_MSB, (u32)((addr) >> 32)); \
   } while (0)
 
-#define SET_PP_ADDR_REG2(reg_base, lsb, msb, addr) do {\
+#define G1_SET_PP_ADDR_REG2(reg_base, lsb, msb, addr) do {\
     SetPpRegister((reg_base), (lsb), (u32)(addr));  \
     SetPpRegister((reg_base), (msb), (u32)((addr) >> 32)); \
   } while (0)
 
-#define GET_ADDR_REG(reg_base, REGBASE)  \
+#define G1_GET_ADDR_REG(reg_base, REGBASE)  \
   (((addr_t)GetDecRegister((reg_base), REGBASE)) |  \
   (((addr_t)GetDecRegister((reg_base), REGBASE##_MSB)) << 32))
 
-#define GET_ADDR_REG2(reg_base, lsb, msb)  \
+#define G1_GET_ADDR_REG2(reg_base, lsb, msb)  \
   (((addr_t)GetDecRegister((reg_base), (lsb))) |  \
   (((addr_t)GetDecRegister((reg_base), (msb))) << 32))
 
-#define GET_PP_ADDR_REG(reg_base, REGBASE)  \
+#define G1_GET_PP_ADDR_REG(reg_base, REGBASE)  \
   (((addr_t)GetPpRegister((reg_base), REGBASE)) |  \
   (((addr_t)GetPpRegister((reg_base), REGBASE##_MSB)) << 32))
 
-#define GET_PP_ADDR_REG2(reg_base, lsb, msb)  \
+#define G1_GET_PP_ADDR_REG2(reg_base, lsb, msb)  \
   (((addr_t)GetPpRegister((reg_base), (lsb))) |  \
   (((addr_t)GetPpRegister((reg_base), (msb))) << 32))
 
 #else
 
-#define SET_ADDR_REG(reg_base, REGBASE, addr) do {\
+#define G1_SET_ADDR_REG(reg_base, REGBASE, addr) do {\
     SetDecRegister((reg_base), REGBASE, (u32)(addr));  \
   } while (0)
 
-#define SET_ADDR_REG2(reg_base, lsb, msb, addr) do {\
+#define G1_SET_ADDR_REG2(reg_base, lsb, msb, addr) do {\
     SetDecRegister((reg_base), (lsb), (u32)(addr));  \
     SetDecRegister((reg_base), (msb), 0); \
   } while (0)
 
-#define SET_PP_ADDR_REG(reg_base, REGBASE, addr) do {\
+#define G1_SET_PP_ADDR_REG(reg_base, REGBASE, addr) do {\
     SetPpRegister((reg_base), REGBASE, (u32)(addr));  \
   } while (0)
 
-#define SET_PP_ADDR_REG2(reg_base, lsb, msb, addr) do {\
+#define G1_SET_PP_ADDR_REG2(reg_base, lsb, msb, addr) do {\
     SetPpRegister((reg_base), (lsb), (u32)(addr));  \
     SetPpRegister((reg_base), (msb), 0); \
   } while (0)
 
-#define GET_ADDR_REG(reg_base, REGID)  \
+#define G1_GET_ADDR_REG(reg_base, REGID)  \
   ((addr_t)GetDecRegister((reg_base), REGID))
 
-#define GET_ADDR_REG2(reg_base, lsb, msb)  \
+#define G1_GET_ADDR_REG2(reg_base, lsb, msb)  \
   (((addr_t)GetDecRegister((reg_base), (lsb))) |  \
   (((addr_t)GetDecRegister((reg_base), (msb))) & 0))
 
-#define GET_PP_ADDR_REG(reg_base, REGID)  \
+#define G1_GET_PP_ADDR_REG(reg_base, REGID)  \
   ((addr_t)GetDecRegister((reg_base), REGID))
 
-#define GET_PP_ADDR_REG2(reg_base, lsb, msb)  \
+#define G1_GET_PP_ADDR_REG2(reg_base, lsb, msb)  \
   ((addr_t)GetPpRegister((reg_base), (lsb)))
 
 #endif
 
 #ifdef USE_64BIT_ENV
-#define SET_ADDR64_REG(reg_base, REGBASE, addr) do {\
+#define G1_SET_ADDR64_REG(reg_base, REGBASE, addr) do {\
     SetDecRegister((reg_base), REGBASE##_LSB, (u32)(addr));  \
     SetDecRegister((reg_base), REGBASE##_MSB, (u32)((addr) >> 32)); \
   } while (0)
-#define GET_ADDR64_REG(reg_base, REGBASE)  \
+#define G1_GET_ADDR64_REG(reg_base, REGBASE)  \
   (((addr_t)GetDecRegister((reg_base), REGBASE##_LSB)) |  \
   (((addr_t)GetDecRegister((reg_base), REGBASE##_MSB)) << 32))
 #else
-#define SET_ADDR64_REG(reg_base, REGBASE, addr) do {\
+#define G1_SET_ADDR64_REG(reg_base, REGBASE, addr) do {\
     SetDecRegister((reg_base), REGBASE##_LSB, (u32)(addr));  \
     SetDecRegister((reg_base), REGBASE##_MSB, 0); \
   } while (0)
-#define GET_ADDR64_REG(reg_base, REGBASE)  \
+#define G1_GET_ADDR64_REG(reg_base, REGBASE)  \
   (((addr_t)GetDecRegister((reg_base), REGBASE##_LSB)) |  \
   (((addr_t)GetDecRegister((reg_base), REGBASE##_MSB)) << 32))
 #endif
diff --git a/decoder_sw/software/source/common/stream_corrupt.c b/decoder_sw/software/source/common/stream_corrupt.c
index 47c4abd..b896f51 100755
--- a/decoder_sw/software/source/common/stream_corrupt.c
+++ b/decoder_sw/software/source/common/stream_corrupt.c
@@ -112,10 +112,10 @@ a
 ------------------------------------------------------------------------------*/
 
 u32 RandomizeBitSwapInStream(u8* stream, u32 stream_len, char* odds) {
-  u32 dividend;
-  u32 divisor;
-  u32 ret_val;
-  u32 chunks;
+  u32 dividend = 0;
+  u32 divisor = 0;
+  u32 ret_val = 0;
+  u32 chunks = 0;
   u32 i = 0;
   u32 j = 0;
   u32 k = 0;
@@ -252,7 +252,7 @@ u32 RandomizeU32(u32* value) {
 
 u32 ParseOdds(char* odds, u32* dividend, u32* divisor) {
   u32 i;
-  char odds_copy[23];
+  char odds_copy[24];
   char* ptr;
   u32 str_len = strlen(odds);
 
@@ -269,8 +269,12 @@ u32 ParseOdds(char* odds, u32* dividend, u32* divisor) {
         odds_copy[i + 2] == ' ') {
       odds_copy[i] = ' ';
       *dividend = atoi(ptr);
+      if (*dividend > 0xFFFFFFFF)
+        return 1;
       ptr += 3 + i;
       *divisor = atoi(ptr);
+      if (*divisor > 0xFFFFFFFF)
+        return 1;
       ptr -= 3 - i;
       if (*divisor == 0) return 1;
       return 0;
diff --git a/decoder_sw/software/source/common/sw_stream.c b/decoder_sw/software/source/common/sw_stream.c
index c3a6214..bcf5e1c 100755
--- a/decoder_sw/software/source/common/sw_stream.c
+++ b/decoder_sw/software/source/common/sw_stream.c
@@ -102,7 +102,8 @@ u32 SwShowBits(const struct StrmData *stream, u32 num_bits) {
                      tmp_strm_buf, stream->strm_buff_size,
                      num_bits + stream->bit_pos_in_word + 32);
 
-  if(tmp != NULL) strm = tmp;
+  if(tmp != NULL)
+    strm = tmp;
 
   if (!stream->remove_emul3_byte) {
 
diff --git a/decoder_sw/software/source/common/sw_util.c b/decoder_sw/software/source/common/sw_util.c
index a61b7bc..8d5ec13 100755
--- a/decoder_sw/software/source/common/sw_util.c
+++ b/decoder_sw/software/source/common/sw_util.c
@@ -93,6 +93,8 @@ u8* SwTurnAround(const u8 * strm, const u8* buf, u8* tmp_buf, u32 buf_size, u32
 
     /*turn around point*/
     for(i = 0; i < bytes + left_byte; i++) {
+      if (i + 2 >= 32)
+        return NULL;
       tmp_buf[i + 2] = DWLPrivateAreaReadByte(buf + i);
     }
 
diff --git a/decoder_sw/software/source/common/workaround.c b/decoder_sw/software/source/common/workaround.c
index 74c2f51..9ab94b0 100755
--- a/decoder_sw/software/source/common/workaround.c
+++ b/decoder_sw/software/source/common/workaround.c
@@ -198,6 +198,9 @@ void PrepareStuffingWorkaround( u8 *p_dec_out, u32 vop_width, u32 vop_height ) {
   u32 i;
   u8 * p_base;
 
+  if (p_dec_out == NULL)
+    return;
+
   p_base = p_dec_out + GetMbOffset(vop_width*vop_height - (MB_OFFSET + vop_width * vop_height / 6), vop_width);
 
   for( i = 0 ; i < MAGIC_WORD_LENGTH ; ++i )
@@ -231,6 +234,9 @@ u32  ProcessStuffingWorkaround( u8 * p_dec_out, u8 * p_ref_pic, u32 vop_width,
   u32 num_mbs;
   u32 match = HANTRO_TRUE;
 
+  if (p_dec_out == NULL)
+    return  HANTRO_FALSE;
+
   num_mbs = vop_width*vop_height;
 
   p_base = p_dec_out + GetMbOffset(num_mbs - (MB_OFFSET + vop_width * vop_height / 6), vop_width);
diff --git a/decoder_sw/software/source/h264high/h264decapi.c b/decoder_sw/software/source/h264high/h264decapi.c
index 431b904..b9a83a3 100755
--- a/decoder_sw/software/source/h264high/h264decapi.c
+++ b/decoder_sw/software/source/h264high/h264decapi.c
@@ -267,6 +267,11 @@ H264DecRet H264DecInit(H264DecInst * dec_inst,
   if(reference_frame_format == DEC_REF_FRM_TILED_DEFAULT) {
     /* Assert support in HW before enabling.. */
     if(!hw_cfg.tiled_mode_support) {
+      pthread_mutex_destroy(&dec_cont->protect_mutex); 
+      DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+      (void) DWLRelease(dwl);
+#endif
       return H264DEC_FORMAT_NOT_SUPPORTED;
     }
     dec_cont->tiled_mode_support = hw_cfg.tiled_mode_support;
@@ -286,6 +291,11 @@ H264DecRet H264DecInit(H264DecInst * dec_inst,
               dscale_cfg->down_scale_y != 2 &&
               dscale_cfg->down_scale_y != 4 &&
               dscale_cfg->down_scale_y != 8 )) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex); 
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void) DWLRelease(dwl);
+#endif
     return (H264DEC_PARAM_ERROR);
   } else {
     u32 scale_table[9] = {0, 0, 1, 0, 2, 0, 0, 0, 3};
@@ -304,6 +314,11 @@ H264DecRet H264DecInit(H264DecInst * dec_inst,
 
   dec_cont->pp_buffer_queue = InputQueueInit(0);
   if (dec_cont->pp_buffer_queue == NULL) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex); 
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void) DWLRelease(dwl);
+#endif
     return (H264DEC_MEMFAIL);
   }
   dec_cont->storage.pp_buffer_queue = dec_cont->pp_buffer_queue;
@@ -522,7 +537,7 @@ u32 IsDpbRealloc(decContainer_t *dec_cont) {
   seqParamSet_t *p_sps = storage->active_sps;
   u32 is_high_supported = (dec_cont->h264_profile_support == H264_HIGH_PROFILE) ? 1 : 0;
   u32 n_cores = dec_cont->n_cores;
-  u32 max_dpb_size, new_pic_size_in_mbs, new_pic_size, new_tot_buffers, dpb_size, max_ref_frames;
+  u32 max_dpb_size, new_pic_size_in_mbs = 0, new_pic_size, new_tot_buffers, dpb_size, max_ref_frames;
   u32 no_reorder;
   struct dpbInitParams dpb_params;
 
@@ -739,6 +754,8 @@ void H264DecRelease(H264DecInst dec_inst) {
       dec_cont->storage.dpbs[1]);
 
   ReleaseAsicBuffers(dwl, dec_cont->asic_buff);
+  if (dec_cont->pp_buffer_queue)
+    InputQueueRelease(dec_cont->pp_buffer_queue);
 
   ReleaseList(&dec_cont->fb_list);
   dec_cont->checksum = NULL;
@@ -1478,6 +1495,7 @@ RESOURCE_NOT_READY:
         }
 
         dec_cont->asic_buff->enable_dmv_and_poc = 0;
+        ASSERT(storage->active_sps != NULL);
         storage->dpb->interlaced = (storage->active_sps->frame_mbs_only_flag == 0) ? 1 : 0;
 
         /* FMO always decoded in rlc mode */
@@ -1537,6 +1555,7 @@ RESOURCE_NOT_READY:
       }
 
       /* Initialize DPB mode */
+      ASSERT(dec_cont->storage.active_sps != NULL);
       if( !dec_cont->storage.active_sps->frame_mbs_only_flag &&
           dec_cont->allow_dpb_field_ordering )
         dec_cont->dpb_mode = DEC_DPB_INTERLACED_FIELD;
@@ -1576,6 +1595,7 @@ RESOURCE_NOT_READY:
       if (!dec_cont->rlc_mode && dec_cont->workarounds.h264.frame_num &&
           !dec_cont->secure_mode) {
         u32 tmp;
+        ASSERT(storage->active_sps != NULL);
         dec_cont->force_nal_mode =
           h264bsdFixFrameNum((u8*)tmp_stream - num_read_bytes,
                              strm_len + num_read_bytes,
diff --git a/decoder_sw/software/source/h264high/h264decmcapi.c b/decoder_sw/software/source/h264high/h264decmcapi.c
index d3ad439..4309871 100755
--- a/decoder_sw/software/source/h264high/h264decmcapi.c
+++ b/decoder_sw/software/source/h264high/h264decmcapi.c
@@ -93,6 +93,7 @@ H264DecRet H264DecMCInit(H264DecInst *dec_inst, H264DecMCConfig *p_mcinit_cfg) {
 
   if(dwl == NULL) {
     DEC_API_TRC("H264DecInit# ERROR: DWL Init failed
");
+    DWLRelease(dwl);
     return (H264DEC_DWL_ERROR);
   }
 #endif
@@ -101,6 +102,7 @@ H264DecRet H264DecMCInit(H264DecInst *dec_inst, H264DecMCConfig *p_mcinit_cfg) {
 
   if(dec_inst == NULL || p_mcinit_cfg == NULL) {
     DEC_API_TRC("H264DecMCInit# ERROR: dec_inst or p_mcinit_cfg is NULL
");
+    DWLRelease(dwl);
     return (H264DEC_PARAM_ERROR);
   }
 
diff --git a/decoder_sw/software/source/h264high/h264hwd_asic.c b/decoder_sw/software/source/h264high/h264hwd_asic.c
index 1e85bef..46901b8 100755
--- a/decoder_sw/software/source/h264high/h264hwd_asic.c
+++ b/decoder_sw/software/source/h264high/h264hwd_asic.c
@@ -1079,20 +1079,20 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
     case P_L0_16x16:
       tmp = ((u32) (mv[0].hor & ASIC_HOR_MV_MASK)) << ASIC_HOR_MV_OFFSET;
       tmp |= ((u32) (mv[0].ver & ASIC_VER_MV_MASK)) << ASIC_VER_MV_OFFSET;
-      tmp |= p_mb->ref_id[0];
+      tmp |= (u32) p_mb->ref_id[0];
       *p_mv_ctrl++ = tmp;
 
       break;
     case P_L0_L0_16x8:
       tmp = ((u32) (mv[0].hor & ASIC_HOR_MV_MASK)) << ASIC_HOR_MV_OFFSET;
       tmp |= ((u32) (mv[0].ver & ASIC_VER_MV_MASK)) << ASIC_VER_MV_OFFSET;
-      tmp |= p_mb->ref_id[0];
+      tmp |= (u32) p_mb->ref_id[0];
 
       *p_mv_ctrl++ = tmp;
 
       tmp = ((u32) (mv[8].hor & ASIC_HOR_MV_MASK)) << ASIC_HOR_MV_OFFSET;
       tmp |= ((u32) (mv[8].ver & ASIC_VER_MV_MASK)) << ASIC_VER_MV_OFFSET;
-      tmp |= p_mb->ref_id[1];
+      tmp |= (u32) p_mb->ref_id[1];
 
       *p_mv_ctrl++ = tmp;
 
@@ -1100,13 +1100,13 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
     case P_L0_L0_8x16:
       tmp = ((u32) (mv[0].hor & ASIC_HOR_MV_MASK)) << ASIC_HOR_MV_OFFSET;
       tmp |= ((u32) (mv[0].ver & ASIC_VER_MV_MASK)) << ASIC_VER_MV_OFFSET;
-      tmp |= p_mb->ref_id[0];
+      tmp |= (u32) p_mb->ref_id[0];
 
       *p_mv_ctrl++ = tmp;
 
       tmp = ((u32) (mv[4].hor & ASIC_HOR_MV_MASK)) << ASIC_HOR_MV_OFFSET;
       tmp |= ((u32) (mv[4].ver & ASIC_VER_MV_MASK)) << ASIC_VER_MV_OFFSET;
-      tmp |= p_mb->ref_id[1];
+      tmp |= (u32) p_mb->ref_id[1];
 
       *p_mv_ctrl++ = tmp;
 
@@ -1125,7 +1125,7 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
           tmp |=
             ((u32) ((*mv).ver & ASIC_VER_MV_MASK)) <<
             ASIC_VER_MV_OFFSET;
-          tmp |= p_mb->ref_id[i];
+          tmp |= (u32) p_mb->ref_id[i];
           *p_mv_ctrl++ = tmp;
           mv += 4;
           break;
@@ -1137,7 +1137,7 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
           tmp |=
             ((u32) ((*mv).ver & ASIC_VER_MV_MASK)) <<
             ASIC_VER_MV_OFFSET;
-          tmp |= p_mb->ref_id[i];
+          tmp |= (u32) p_mb->ref_id[i];
           *p_mv_ctrl++ = tmp;
           mv += 2;
 
@@ -1147,7 +1147,7 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
           tmp |=
             ((u32) ((*mv).ver & ASIC_VER_MV_MASK)) <<
             ASIC_VER_MV_OFFSET;
-          tmp |= p_mb->ref_id[i];
+          tmp |= (u32) p_mb->ref_id[i];
           *p_mv_ctrl++ = tmp;
           mv += 2;
           break;
@@ -1159,7 +1159,7 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
           tmp |=
             ((u32) ((*mv).ver & ASIC_VER_MV_MASK)) <<
             ASIC_VER_MV_OFFSET;
-          tmp |= p_mb->ref_id[i];
+          tmp |= (u32) p_mb->ref_id[i];
           *p_mv_ctrl++ = tmp;
           mv++;
           tmp =
@@ -1168,7 +1168,7 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
           tmp |=
             ((u32) ((*mv).ver & ASIC_VER_MV_MASK)) <<
             ASIC_VER_MV_OFFSET;
-          tmp |= p_mb->ref_id[i];
+          tmp |= (u32) p_mb->ref_id[i];
           *p_mv_ctrl++ = tmp;
           mv += 3;
 
@@ -1184,7 +1184,7 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
             tmp |=
               ((u32) ((*mv).ver & ASIC_VER_MV_MASK)) <<
               ASIC_VER_MV_OFFSET;
-            tmp |= p_mb->ref_id[i];
+            tmp |= (u32) p_mb->ref_id[i];
             *p_mv_ctrl++ = tmp;
             mv++;
           }
@@ -1234,7 +1234,7 @@ void PrepareIntra4x4ModeData(storage_t * storage, DecAsicBuffers_t * p_asic_buff
       u8 mode = p_mb->intra4x4_pred_mode_asic[block];
 
       tmp <<= 4;
-      tmp |= mode;
+      tmp |= (u32) mode;
 
       if(block == 7) {
         *p_intra_pred++ = tmp;
@@ -1506,7 +1506,7 @@ void H264SetupVlcRegs(decContainer_t * dec_cont) {
 
     if(dec_cont->asic_buff->ref_pic_list[i])
       dec_cont->asic_buff->ref_pic_list[i] |=
-        (diff_poc < itmp ? 0x1 : 0) | (p_dpb->buffer[i].is_field_pic ? 0x2 : 0);
+        (addr_t)(diff_poc < itmp ? 0x1 : 0) | (p_dpb->buffer[i].is_field_pic ? 0x2 : 0);
   }
 
   SetDecRegister(dec_cont->h264_regs, HWIF_REFER_VALID_E, valid_flags);
@@ -1769,7 +1769,7 @@ void h264StreamPosUpdate(decContainer_t * dec_cont) {
   dec_cont->hw_bit_pos = tmp;
 
   tmp = dec_cont->hw_stream_start_bus;   /* unaligned base */
-  tmp &= (~DEC_X170_ALIGN_MASK);  /* align the base */
+  tmp &= (addr_t)(~DEC_X170_ALIGN_MASK);  /* align the base */
 
   DEBUG_PRINT(("	Stream base   %08x
", tmp));
   SET_ADDR_REG(dec_cont->h264_regs, HWIF_RLC_VLC_BASE, tmp);
@@ -1914,10 +1914,10 @@ void H264ErrorRecover(decContainer_t *dec_cont)
   dpbStorage_t *dpb = dec_cont->storage.dpb;
   dpbPicture_t *buffer = dpb->buffer;
   u32 i;
+  i32 idx = 0;
 
   if (!dec_cont->rlc_mode) {
     u32 k = dpb->dpb_size + 1;
-    i32 idx = 0x7FFFFFFF;
 
     /* find the buffer index of current image */
     while((k--) > 0) {
diff --git a/decoder_sw/software/source/h264high/h264hwd_cavlc.c b/decoder_sw/software/source/h264high/h264hwd_cavlc.c
index 59e11f1..f0f3ba2 100755
--- a/decoder_sw/software/source/h264high/h264hwd_cavlc.c
+++ b/decoder_sw/software/source/h264high/h264hwd_cavlc.c
@@ -426,7 +426,7 @@ u32 DecodeCoeffToken(u32 bits, u32 nc) {
 
   /* Variables */
 
-  u32 value;
+  u32 value = 0;
 
   /* Code */
 
@@ -455,15 +455,27 @@ u32 DecodeCoeffToken(u32 bits, u32 nc) {
     else
       value = coeff_token2_2[bits >> 2];
   } else if(nc < 8) {
+    if (bits >= 0x10000)
+      return value;
     value = coeff_token4_0[bits >> 10];
-    if(!value)
+    if(!value) {
+      if (bits >= 0x2000)
+        return value;
       value = coeff_token4_1[bits >> 6];
+    }
   } else if(nc <= 16) {
+    if (bits >= 0x10000)
+      return value;
     value = coeff_token8[bits >> 10];
   } else {
+    if (bits >= 0x10000)
+      return value;
     value = coeff_token_minus1_0[bits >> 13];
-    if(!value)
+    if(!value) {
+      if (bits >= 0x2000)
+        return value;
       value = coeff_token_minus1_1[bits >> 8];
+    }
   }
 
   return (value);
@@ -564,60 +576,91 @@ u32 DecodeTotalZeros(u32 bits, u32 total_coeff, u32 is_chroma_dc) {
     ASSERT(total_coeff < 16);
     switch (total_coeff) {
     case 1:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_1_0[bits >> 4];
-      if(!value)
+      if(!value) {
+        if (bits >= 32)
+          return value;
         value = total_zeros_1_1[bits];
+      }
       break;
 
     case 2:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_2[bits >> 3];
       break;
 
     case 3:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_3[bits >> 3];
       break;
 
     case 4:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_4[bits >> 4];
       break;
 
     case 5:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_5[bits >> 4];
       break;
 
     case 6:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_6[bits >> 3];
       break;
 
     case 7:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_7[bits >> 3];
       break;
 
     case 8:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_8[bits >> 3];
       break;
 
     case 9:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_9[bits >> 3];
       break;
 
     case 10:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_10[bits >> 4];
       break;
 
     case 11:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_11[bits >> 5];
       break;
 
     case 12:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_12[bits >> 5];
       break;
 
     case 13:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_13[bits >> 6];
       break;
 
     case 14:
+      if (bits >= 0x200)
+        return value;
       value = total_zeros_14[bits >> 7];
       break;
 
@@ -674,26 +717,38 @@ u32 DecodeRunBefore(u32 bits, u32 zeros_left) {
 
   switch (zeros_left) {
   case 1:
+    if (bits >= 0x800)
+      return value;
     value = run_before_1[bits >> 10];
     break;
 
   case 2:
+    if (bits >= 0x800)
+      return value;
     value = run_before_2[bits >> 9];
     break;
 
   case 3:
+    if (bits >= 0x800)
+      return value;
     value = run_before_3[bits >> 9];
     break;
 
   case 4:
+    if (bits >= 0x800)
+      return value;
     value = run_before_4[bits >> 8];
     break;
 
   case 5:
+    if (bits >= 0x800)
+      return value;
     value = run_before_5[bits >> 8];
     break;
 
   case 6:
+    if (bits >= 0x800)
+      return value;
     value = run_before_6[bits >> 8];
     break;
 
diff --git a/decoder_sw/software/source/h264high/h264hwd_decoder.c b/decoder_sw/software/source/h264high/h264hwd_decoder.c
index 318a9ab..b5694dc 100755
--- a/decoder_sw/software/source/h264high/h264hwd_decoder.c
+++ b/decoder_sw/software/source/h264high/h264hwd_decoder.c
@@ -165,6 +165,7 @@ u32 h264bsdDecode(decContainer_t * dec_cont, const u8 * byte_strm, u32 len,
 
   DEBUG_PRINT(("Valid slice in access unit %d
",
                storage->valid_slice_in_access_unit));
+  strm.emul_byte_count = 0;
 
   if(dec_cont->rlc_mode) {
     storage->strm[0].remove_emul3_byte = 1;
@@ -377,6 +378,11 @@ u32 h264bsdDecode(decContainer_t * dec_cont, const u8 * byte_strm, u32 len,
         ret = H264BSD_ERROR;
       } else {
         tmp = h264bsdStorePicParamSet(storage, &pic_param_set);
+         /* allocated new memory inside h264bsdStorePicParamSet */
+        FREE(pic_param_set.run_length);
+        FREE(pic_param_set.top_left);
+        FREE(pic_param_set.bottom_right);
+        FREE(pic_param_set.slice_group_id);
         if(tmp != HANTRO_OK) {
           ERROR_PRINT("PIC_PARAM_SET allocation");
           ret = H264BSD_ERROR;
diff --git a/decoder_sw/software/source/h264high/h264hwd_dpb.c b/decoder_sw/software/source/h264high/h264hwd_dpb.c
index da7cae0..059f2c8 100755
--- a/decoder_sw/software/source/h264high/h264hwd_dpb.c
+++ b/decoder_sw/software/source/h264high/h264hwd_dpb.c
@@ -51,6 +51,7 @@
 --------------------------------------------------------------------------------
     3. Module defines
 ------------------------------------------------------------------------------*/
+#define MAX_DPB_SIZE 16
 
 /* Function style implementation for IS_REFERENCE() macro to fix compiler
  * warnings */
@@ -550,9 +551,11 @@ u32 h264bsdReorderRefPicList(dpbStorage_t * dpb,
     dpb->list[ref_idx++] = (u32)index;
     /* remove later references to the same picture */
     for(j = k = ref_idx; j <= num_ref_idx_active; j++)
-      if(dpb->list[j] != (u32)index)
+      if(dpb->list[j] != (u32)index) {
+        if(k >= MAX_DPB_SIZE + 1)
+          break;
         dpb->list[k++] = dpb->list[j];
-
+      }
     i++;
   }
 
@@ -3029,21 +3032,19 @@ void h264EmptyDpb(dpbStorage_t *dpb) {
 #endif
   }
 
-  if(dpb->fb_list) {
 #ifndef USE_OMXIL_BUFFER
-    /* Remove pictures in dpb->out_buf */
-    u32 tmp_idx, id;
-    for (i = 0; i < dpb->num_out; i++) {
-      tmp_idx = dpb->out_index_r++;
-      if (dpb->out_index_r == dpb->dpb_size + 1)
-        dpb->out_index_r = 0;
-      id = dpb->out_buf[tmp_idx].mem_idx;
-      ClearOutput(dpb->fb_list, id);
-    }
-#endif
-    RemoveTempOutputAll(dpb->fb_list);
-    RemoveOutputAll(dpb->fb_list);
+  /* Remove pictures in dpb->out_buf */
+  u32 tmp_idx, id;
+  for (i = 0; i < dpb->num_out; i++) {
+    tmp_idx = dpb->out_index_r++;
+    if (dpb->out_index_r == dpb->dpb_size + 1)
+      dpb->out_index_r = 0;
+    id = dpb->out_buf[tmp_idx].mem_idx;
+    ClearOutput(dpb->fb_list, id);
   }
+#endif
+  RemoveTempOutputAll(dpb->fb_list);
+  RemoveOutputAll(dpb->fb_list);
 
 #ifdef USE_OMXIL_BUFFER
   for (i = 0; i < dpb->tot_buffers; i++) {
diff --git a/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c b/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c
index 4afd548..277e464 100755
--- a/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c
+++ b/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c
@@ -503,7 +503,10 @@ void MarkOutputPicCorrupt(FrameBufferList *fb_list, u32 id, u32 errors) {
   pthread_mutex_lock(&fb_list->out_count_mutex);
 
   rd_id = fb_list->rd_id;
-
+  if (rd_id < 0) {
+    pthread_mutex_unlock(&fb_list->out_count_mutex);
+    return;
+  }
   for(i = 0; i < fb_list->num_out; i++) {
     if(fb_list->out_fifo[rd_id].mem_idx == id) {
       DPB_TRACE("id = %d
", id);
@@ -656,6 +659,10 @@ void RemoveOutputAll(FrameBufferList *fb_list) {
 #else
   i32 id;
   i32 rd_id = fb_list->rd_id;
+  if (rd_id < 0) {
+    return;
+  }
+
   for (i = 0; i < fb_list->num_out; i++) {
     id = fb_list->out_fifo[rd_id].mem_idx;
     if (fb_list->fb_stat[id].b_used & FB_OUTPUT) {
diff --git a/decoder_sw/software/source/h264high/h264hwd_macroblock_layer.c b/decoder_sw/software/source/h264high/h264hwd_macroblock_layer.c
index fca4bbd..1e60cc5 100755
--- a/decoder_sw/software/source/h264high/h264hwd_macroblock_layer.c
+++ b/decoder_sw/software/source/h264high/h264hwd_macroblock_layer.c
@@ -868,9 +868,9 @@ void WritePCMToAsic(const u8 * lev, DecAsicBuffers_t * p_asic_buff) {
     u32 tmp;
 
     tmp = (*lev++) << 24;
-    tmp |= (*lev++) << 16;
-    tmp |= (*lev++) << 8;
-    tmp |= (*lev++);
+    tmp |= (u32) ((*lev++) << 16);
+    tmp |= (u32) ((*lev++) << 8);
+    tmp |= (u32) (*lev++);
 
     *p_res++ = tmp;
   }
@@ -1026,7 +1026,7 @@ void WriteSubBlock(const u16 * rlc, u32 * p_wrt_buff, u32 ** res,
     words = rlc_ctrl >> 11;
 
     if((word_count++) & 0x01) {
-      wrt_buff |= rlc_ctrl;
+      wrt_buff |= (u32) rlc_ctrl;
       *p_res++ = wrt_buff;
     } else {
       wrt_buff = rlc_ctrl << 16;
@@ -1041,7 +1041,7 @@ void WriteSubBlock(const u16 * rlc, u32 * p_wrt_buff, u32 ** res,
 
   for(; words > 0; words--) {
     if((word_count++) & 0x01) {
-      wrt_buff |= *p_tmp++;
+      wrt_buff |= (u32) (*p_tmp++);
       *p_res++ = wrt_buff;
     } else {
       wrt_buff = (*p_tmp++) << 16;
diff --git a/decoder_sw/software/source/h264high/h264hwd_storage.c b/decoder_sw/software/source/h264high/h264hwd_storage.c
index 574f12b..ec5520a 100755
--- a/decoder_sw/software/source/h264high/h264hwd_storage.c
+++ b/decoder_sw/software/source/h264high/h264hwd_storage.c
@@ -297,6 +297,43 @@ u32 h264bsdStorePicParamSet(storage_t * storage, picParamSet_t * p_pic_param_set
 
   *storage->pps[id] = *p_pic_param_set;
 
+  /* to fix klocwork warning we have to allocate new memory for pStorage->pps[id] */
+  if (p_pic_param_set->run_length) {
+    ALLOCATE(storage->pps[id]->run_length,
+        p_pic_param_set->num_slice_groups, u32);
+    if (storage->pps[id]->run_length == NULL)
+      return(MEMORY_ALLOCATION_ERROR);
+    (void)DWLmemcpy(storage->pps[id]->run_length,
+        p_pic_param_set->run_length, p_pic_param_set->num_slice_groups * sizeof(32));
+  }
+
+  if (p_pic_param_set->top_left) {
+    ALLOCATE(storage->pps[id]->top_left,
+        p_pic_param_set->num_slice_groups - 1, u32);
+    if (storage->pps[id]->top_left == NULL)
+      return(MEMORY_ALLOCATION_ERROR);
+    (void)DWLmemcpy(storage->pps[id]->top_left,
+        p_pic_param_set->top_left, (p_pic_param_set->num_slice_groups - 1) * sizeof(32));
+  }
+
+  if (p_pic_param_set->bottom_right) {
+    ALLOCATE(storage->pps[id]->bottom_right,
+        p_pic_param_set->num_slice_groups - 1, u32);
+    if (storage->pps[id]->bottom_right == NULL)
+      return(MEMORY_ALLOCATION_ERROR);
+    (void)DWLmemcpy(storage->pps[id]->bottom_right,
+      p_pic_param_set->bottom_right, (p_pic_param_set->num_slice_groups - 1) * sizeof(32));
+  }
+
+  if (p_pic_param_set->slice_group_id) {
+    ALLOCATE(storage->pps[id]->slice_group_id,
+        p_pic_param_set->pic_size_in_map_units, u32);
+    if (storage->pps[id]->slice_group_id == NULL)
+      return(MEMORY_ALLOCATION_ERROR);
+    (void)DWLmemcpy(storage->pps[id]->slice_group_id,
+        p_pic_param_set->slice_group_id, p_pic_param_set->pic_size_in_map_units * sizeof(32));
+  }
+
   return (HANTRO_OK);
 
 }
diff --git a/decoder_sw/software/source/h264high/legacy/h264hwd_sei.c b/decoder_sw/software/source/h264high/legacy/h264hwd_sei.c
index 8c512b4..e10629d 100755
--- a/decoder_sw/software/source/h264high/legacy/h264hwd_sei.c
+++ b/decoder_sw/software/source/h264high/legacy/h264hwd_sei.c
@@ -306,8 +306,8 @@ u32 h264bsdDecodePicTimingInfo(seqParamSet_t **sps, strmData_t *p_strm_data,
 
   u32 tmp, i;
   u32 CpbDpbDelaysPresentFlag;
-  u32 cpb_removal_len;
-  u32 dpb_output_len;
+  u32 cpb_removal_len = 0;
+  u32 dpb_output_len = 0;
   u32 pic_struct_present_flag;
   u32 NumClockTs = 0;
   u32 time_offset_length;
diff --git a/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c b/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
index 82e2415..08b6e72 100755
--- a/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
+++ b/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
@@ -193,7 +193,7 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
   /* Variables */
 
   u32 tmp, i, value;
-  u32 invalid_dpb_size;
+  u32 invalid_dpb_size = 0;
 
   /* Code */
 
diff --git a/decoder_sw/software/source/hevc/hevc_asic.c b/decoder_sw/software/source/hevc/hevc_asic.c
index 2dfa4b4..8a60da5 100755
--- a/decoder_sw/software/source/hevc/hevc_asic.c
+++ b/decoder_sw/software/source/hevc/hevc_asic.c
@@ -192,7 +192,8 @@ void GenerateFakeRFCTable(u8 *cmp_tble_addr,
   u8 cbs_sizes_10bit[14] = {0xa1, 0x42, 0x85, 10, 20, 40, 80, 0xa1, 0x42, 0x85, 10, 20, 40, 80};
 #endif
   u32 i, j, offset;
-  u8 *pcbs, *ptbl = NULL;
+  u8 *pcbs;
+  u8 *ptbl = cbs_sizes_8bit;
   if (bit_depth == 8) {
     cbs_size_y = cbs_size_c = 64;
     ptbl = cbs_sizes_8bit;
@@ -1171,7 +1172,7 @@ void HevcStreamPosUpdate(struct HevcDecContainer *dec_cont) {
   if(is_rb) {
     /* stream buffer base address */
     tmp_addr = dec_cont->hw_buffer_start_bus; /* aligned base */
-    ASSERT((tmp_addr & 0xF) == 0);
+    ASSERT((tmp_addr & (addr_t)0xF) == 0);
 
     SET_ADDR_REG(dec_cont->hevc_regs, HWIF_STREAM_BASE, tmp_addr);
 
@@ -1196,8 +1197,8 @@ void HevcStreamPosUpdate(struct HevcDecContainer *dec_cont) {
   } else {
     /* stream data base address */
     tmp_addr = dec_cont->hw_stream_start_bus; /* unaligned base */
-    tmp_addr &= (~DEC_HW_ALIGN_MASK);         /* align the base */
-    ASSERT((tmp_addr & 0xF) == 0);
+    tmp_addr &= (addr_t) (~DEC_HW_ALIGN_MASK);         /* align the base */
+    ASSERT((tmp_addr & (addr_t)0xF) == 0);
 
     SET_ADDR_REG(dec_cont->hevc_regs, HWIF_STREAM_BASE, tmp_addr);
 
diff --git a/decoder_sw/software/source/hevc/hevc_decoder.c b/decoder_sw/software/source/hevc/hevc_decoder.c
index 8f71bbf..0f4b346 100755
--- a/decoder_sw/software/source/hevc/hevc_decoder.c
+++ b/decoder_sw/software/source/hevc/hevc_decoder.c
@@ -97,7 +97,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
   struct SeqParamSet seq_param_set;
   struct PicParamSet pic_param_set;
   struct VideoParamSet video_param_set = {0};
-  struct StrmData strm;
+  struct StrmData strm = {0};
   const u8 *strm_buf = dec_cont->hw_buffer;
   u32 buf_len = dec_cont->hw_buffer_length;
 #ifdef GET_FREE_BUFFER_NON_BLOCK
@@ -191,14 +191,12 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
 
   /* FIXME: Sometimes SPS/PPS NAL following the filler data NAL,
      The stream is consumed incorrectly if discard the whole buffer here */
-#if 1
 #ifndef HEVC_INPUT_MULTI_FRM
   /* Discard filler data */
   if(nal_unit.nal_unit_type == 38) {
     *read_bytes = strm_len;
     return HEVC_RDY;
   }
-#endif
 #endif
 
   if (!storage->checked_aub) {
@@ -407,7 +405,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
       /* check if picture shall be skipped (non-decodable picture after
        * random access etc) */
       if (SkipPicture(storage, &nal_unit)) {
-        ret = HEVC_RDY;
+        ret = HEVC_NONREF_PIC_SKIPPED;
         goto NEXT_NAL;
         /*FIXME: below code may cause side-effect */
         //storage->prev_bytes_consumed = *read_bytes = strm_len;
diff --git a/decoder_sw/software/source/hevc/hevc_dpb.c b/decoder_sw/software/source/hevc/hevc_dpb.c
index 6a0f21e..566f9d9 100755
--- a/decoder_sw/software/source/hevc/hevc_dpb.c
+++ b/decoder_sw/software/source/hevc/hevc_dpb.c
@@ -207,6 +207,9 @@ void *HevcAllocateDpbImage(struct DpbStorage *dpb, i32 pic_order_cnt,
     if (new_id != dpb->current_out->mem_idx) {
       SetFreePicBuffer(dpb->fb_list, dpb->current_out->mem_idx);
       dpb->current_out->mem_idx = new_id;
+      ASSERT(new_id < MAX_FRAME_BUFFER_NUMBER);
+      if (new_id >= MAX_FRAME_BUFFER_NUMBER)
+        return NULL;
       dpb->current_out->data = GetDataById(dpb->fb_list, new_id);
     }
   }
@@ -502,7 +505,7 @@ u32 HevcInitDpb(const void *dec_inst, struct DpbStorage *dpb,
       if (DWLMallocRefFrm(dec_cont->dwl, dpb_params->buff_size, dpb->pic_buffers + i) != 0)
         return (MEMORY_ALLOCATION_ERROR);
 
-      if (i < dpb->dpb_size + 1) {
+      if (i < dpb->dpb_size + 1 && (i < (MAX_DPB_SIZE + 1))) {
         u32 id = AllocateIdUsed(dpb->fb_list, dpb->pic_buffers + i);
         if (id == FB_NOT_VALID_ID) return MEMORY_ALLOCATION_ERROR;
 
diff --git a/decoder_sw/software/source/hevc/hevc_fb_mngr.c b/decoder_sw/software/source/hevc/hevc_fb_mngr.c
index 550c422..34d7650 100755
--- a/decoder_sw/software/source/hevc/hevc_fb_mngr.c
+++ b/decoder_sw/software/source/hevc/hevc_fb_mngr.c
@@ -162,6 +162,8 @@ u32 AllocateIdFree(struct FrameBufferList *fb_list, const void *data) {
 void ReleaseId(struct FrameBufferList *fb_list, u32 id) {
   assert(id < MAX_FRAME_BUFFER_NUMBER);
 
+  if (id >= MAX_FRAME_BUFFER_NUMBER) return;
+
   /* it is "bad" to release referenced or unallocated buffers */
   assert(fb_list->fb_stat[id].n_ref_count == 0);
 #ifndef USE_EXTERNAL_BUFFER
@@ -170,8 +172,6 @@ void ReleaseId(struct FrameBufferList *fb_list, u32 id) {
   if(fb_list->fb_stat[id].b_used == FB_UNALLOCATED) return;
 #endif
 
-  if (id >= MAX_FRAME_BUFFER_NUMBER) return;
-
   if (fb_list->fb_stat[id].b_used == FB_FREE) {
     assert(fb_list->free_buffers > 0);
     fb_list->free_buffers--;
@@ -478,7 +478,10 @@ void MarkOutputPicCorrupt(struct FrameBufferList *fb_list, u32 id, u32 errors) {
   pthread_mutex_lock(&fb_list->out_count_mutex);
 
   rd_id = fb_list->out_rd_id;
-
+  if (rd_id < 0) {
+    pthread_mutex_unlock(&fb_list->out_count_mutex);
+    return;
+  }
   for (i = 0; i < fb_list->num_out; i++) {
     if (fb_list->out_fifo[rd_id].mem_idx == id) {
       DPB_TRACE("id = %d
", id);
@@ -646,7 +649,7 @@ void RemoveTempOutputAll(struct FrameBufferList *fb_list, struct DpbStorage *dpb
 #ifdef USE_EXTERNAL_BUFFER
 void RemoveOutputAll(struct FrameBufferList *fb_list, struct DpbStorage *dpb) {
   i32 i, j;
-  i32 rd_id, id;
+  u32 rd_id, id;
 
   if (!dpb || !dpb->storage)
     return;
diff --git a/decoder_sw/software/source/hevc/hevc_video_param_set.c b/decoder_sw/software/source/hevc/hevc_video_param_set.c
index 906c523..770f444 100755
--- a/decoder_sw/software/source/hevc/hevc_video_param_set.c
+++ b/decoder_sw/software/source/hevc/hevc_video_param_set.c
@@ -75,7 +75,7 @@ u32 HevcDecodeVideoParamSet(struct StrmData *stream,
   tmp = SwGetBits(stream, 3);
   if (tmp == END_OF_STREAM)
     return(HANTRO_NOK);
-  if (tmp < 0 || tmp > 6) {
+  if (tmp > 6) {
     ERROR_PRINT("video_parameter_set_id");
     return (HANTRO_NOK);
   }
@@ -126,7 +126,7 @@ u32 HevcDecodeVideoParamSet(struct StrmData *stream,
 
   tmp = HevcDecodeExpGolombUnsigned(stream, &value);
   if (tmp != HANTRO_OK) return (tmp);
-  if (value < 0 || value > 1023) {
+  if (value > 1023) {
     ERROR_PRINT("video_parameter_set_id");
     return (HANTRO_NOK);
   }
diff --git a/decoder_sw/software/source/hevc/hevc_vui.c b/decoder_sw/software/source/hevc/hevc_vui.c
index fcb5d62..579fdf0 100755
--- a/decoder_sw/software/source/hevc/hevc_vui.c
+++ b/decoder_sw/software/source/hevc/hevc_vui.c
@@ -142,7 +142,7 @@ u32 HevcDecodeHrdParameters(struct StrmData *stream, u32 max_sub_layers,
     if (!hdr_parameters->low_delay_hrd_flag[i]) {
       tmp = HevcDecodeExpGolombUnsigned(stream, &value);
       if (tmp == END_OF_STREAM) return (END_OF_STREAM);
-      if (value < 0 || value > 32)
+      if (value > 32)
         return (HANTRO_NOK);
       else
         hdr_parameters->cpb_cnt[i] = value;
diff --git a/decoder_sw/software/source/hevc/hevcdecapi.c b/decoder_sw/software/source/hevc/hevcdecapi.c
index 571209d..eb1d3a7 100755
--- a/decoder_sw/software/source/hevc/hevcdecapi.c
+++ b/decoder_sw/software/source/hevc/hevcdecapi.c
@@ -345,7 +345,7 @@ enum DecRet HevcDecGetInfo(HevcDecInst dec_inst, struct HevcDecInfo *dec_info) {
   dec_info->matrix_coefficients = HevcMatrixCoefficients(storage);
   dec_info->colour_primaries = HevcColourPrimaries(storage);
   dec_info->transfer_characteristics = HevcTransferCharacteristics(storage);
-
+  dec_info->interlaced_sequence = 0;
 
   dec_info->mono_chrome = HevcIsMonoChrome(storage);
   if (dec_cont->output_format == DEC_OUT_FRM_RASTER_SCAN)
@@ -487,7 +487,7 @@ enum DecRet HevcDecDecode(HevcDecInst dec_inst,
                           struct HevcDecOutput *output) {
   struct HevcDecContainer *dec_cont = (struct HevcDecContainer *)dec_inst;
   u32 strm_len;
-  u32 input_data_len = input->data_len; // used to generate error stream
+  u32 input_data_len; // used to generate error stream
   const u8 *tmp_stream;
   enum DecRet return_value = DEC_STRM_PROCESSED;
 
@@ -496,6 +496,8 @@ enum DecRet HevcDecDecode(HevcDecInst dec_inst,
     return (DEC_PARAM_ERROR);
   }
 
+  input_data_len = input->data_len;
+
   /* Check for valid decoder instance */
   if (dec_cont->checksum != dec_cont) {
     return (DEC_NOT_INITIALIZED);
@@ -1137,6 +1139,8 @@ RESOURCE_NOT_READY:
       storage->prev_idr_pic_ready = IS_IDR_NAL_UNIT(storage->prev_nal_unit);
 #endif /* FFWD_WORKAROUND */
       {
+        if (storage->active_sps == NULL)
+          return DEC_PARAM_ERROR;
         u32 sublayer = storage->active_sps->max_sub_layers - 1;
         u32 max_latency =
           dec_cont->storage.active_sps->max_num_reorder_pics[sublayer] +
@@ -2589,8 +2593,7 @@ enum DecRet HevcDecSetInfo(HevcDecInst dec_inst,
   dec_cont->output_format = dec_cfg->output_format;
   if (dec_cfg->output_format == DEC_OUT_FRM_RASTER_SCAN) {
     dec_cont->storage.raster_enabled = 1;
-  }
-  else {
+  } else {
     dec_cont->storage.raster_enabled = 0;
   }
   dec_cont->down_scale_enabled = 0;
diff --git a/decoder_sw/software/source/jpeg/jpegdechdrs.c b/decoder_sw/software/source/jpeg/jpegdechdrs.c
index 964b314..09605be 100755
--- a/decoder_sw/software/source/jpeg/jpegdechdrs.c
+++ b/decoder_sw/software/source/jpeg/jpegdechdrs.c
@@ -487,7 +487,8 @@ JpegDecRet JpegDecDecodeHuffmanTables(JpegDecContainer * p_dec_data) {
     }
 
     p_dec_data->vlc.table->vals = (u32 *) DWLmalloc(sizeof(u32) * tmp);
-
+    if (p_dec_data->vlc.table->vals == NULL)
+      return JPEGDEC_MEMFAIL;
     /* set the table length */
     p_dec_data->vlc.table->table_length = tmp;
     /* read in the HUFFVALs */
@@ -527,7 +528,7 @@ JpegDecRet JpegDecDecodeHuffmanTables(JpegDecContainer * p_dec_data) {
 
 ------------------------------------------------------------------------------*/
 void JpegDecDefaultHuffmanTables(JpegDecContainer * p_dec_data) {
-  u32 i, k, len, tmp;
+  u32 i, k, len = 0, tmp;
   i32 j;
   u32 table = 0;
   u8 * stream_bits = 0;
@@ -577,6 +578,8 @@ void JpegDecDefaultHuffmanTables(JpegDecContainer * p_dec_data) {
 
     p_dec_data->vlc.table->vals = (u32 *) DWLmalloc(sizeof(u32) * tmp);
 
+    if (p_dec_data->vlc.table->vals == NULL)
+      return;
     /* set the table length */
     p_dec_data->vlc.table->table_length = tmp;
     /* read in the HUFFVALs */
diff --git a/decoder_sw/software/source/mpeg2/mpeg2decapi.c b/decoder_sw/software/source/mpeg2/mpeg2decapi.c
index 0c292d5..3eeeca0 100755
--- a/decoder_sw/software/source/mpeg2/mpeg2decapi.c
+++ b/decoder_sw/software/source/mpeg2/mpeg2decapi.c
@@ -1268,6 +1268,8 @@ void Mpeg2DecRelease(Mpeg2DecInst dec_inst) {
 #endif
 
   mpeg2FreeBuffers(dec_cont);
+  if (dec_cont->pp_buffer_queue)
+    InputQueueRelease(dec_cont->pp_buffer_queue);
 
   DWLfree(dec_cont);
 #ifndef USE_EXTERNAL_BUFFER
diff --git a/decoder_sw/software/source/mpeg2/mpeg2decapi_internal.c b/decoder_sw/software/source/mpeg2/mpeg2decapi_internal.c
index c0464ae..d62ed74 100755
--- a/decoder_sw/software/source/mpeg2/mpeg2decapi_internal.c
+++ b/decoder_sw/software/source/mpeg2/mpeg2decapi_internal.c
@@ -330,6 +330,7 @@ Mpeg2DecRet mpeg2DecAllocExtraBPic(DecContainer * dec_cont) {
   if (dec_cont->pp_enabled) {
     /* Add PP output buffers. */
     struct DWLLinearMem pp_buffer;
+    pp_buffer.mem_type = DWL_MEM_TYPE_DPB;
     u32 pp_width, pp_height, pp_stride, pp_buff_size;
 
     pp_width = (dec_cont->FrameDesc.frame_width * 16) >> dec_cont->dscale_shift_x;
@@ -353,6 +354,8 @@ Mpeg2DecRet mpeg2DecAllocExtraBPic(DecContainer * dec_cont) {
     if (dec_cont->pp_enabled) {
       /* Add PP output buffers. */
       struct DWLLinearMem pp_buffer;
+      pp_buffer.mem_type = DWL_MEM_TYPE_DPB;
+
       u32 pp_width, pp_height, pp_stride, pp_buff_size;
 
       pp_width = (dec_cont->FrameDesc.frame_width * 16) >> dec_cont->dscale_shift_x;
diff --git a/decoder_sw/software/source/mpeg4/mp4decapi.c b/decoder_sw/software/source/mpeg4/mp4decapi.c
index cca99b7..7cb3f68 100755
--- a/decoder_sw/software/source/mpeg4/mp4decapi.c
+++ b/decoder_sw/software/source/mpeg4/mp4decapi.c
@@ -61,6 +61,8 @@
 #include "mpeg4asicdbgtrace.h"
 #endif
 
+#include "stdlib.h"
+
 #ifdef MP4DEC_TRACE
 #define MP4_API_TRC(str)    MP4DecTrace((str))
 #else
@@ -1350,6 +1352,11 @@ MP4DecRet MP4DecInit(MP4DecInst * dec_inst,
 
   if(!config.addr64_support && sizeof(void *) == 8) {
     MP4_API_TRC("MPEG4DecInit# ERROR: HW not support 64bit address!
");
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void) DWLRelease(dwl);
+#endif
     return (MP4DEC_PARAM_ERROR);
   }
 
@@ -1362,6 +1369,11 @@ MP4DecRet MP4DecInit(MP4DecInst * dec_inst,
   if(reference_frame_format == DEC_REF_FRM_TILED_DEFAULT) {
     /* Assert support in HW before enabling.. */
     if(!config.tiled_mode_support) {
+      pthread_mutex_destroy(&dec_cont->protect_mutex);
+      DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+      (void) DWLRelease(dwl);
+#endif
       return MP4DEC_FORMAT_NOT_SUPPORTED;
     }
     dec_cont->tiled_mode_support = config.tiled_mode_support;
@@ -1381,6 +1393,11 @@ MP4DecRet MP4DecInit(MP4DecInst * dec_inst,
               dscale_cfg->down_scale_y != 2 &&
               dscale_cfg->down_scale_y != 4 &&
               dscale_cfg->down_scale_y != 8 )) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void) DWLRelease(dwl);
+#endif
     return (MP4DEC_PARAM_ERROR);
   } else {
     u32 scale_table[9] = {0, 0, 1, 0, 2, 0, 0, 0, 3};
@@ -1394,6 +1411,11 @@ MP4DecRet MP4DecInit(MP4DecInst * dec_inst,
 
   dec_cont->pp_buffer_queue = InputQueueInit(0);
   if (dec_cont->pp_buffer_queue == NULL) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void) DWLRelease(dwl);
+#endif
     return (MP4DEC_MEMFAIL);
   }
   dec_cont->StrmStorage.release_buffer = 0;
@@ -1417,8 +1439,16 @@ MP4DecRet MP4DecInit(MP4DecInst * dec_inst,
 
 #ifdef USE_OUTPUT_RELEASE
   /* take top/botom fields into consideration */
-  if (FifoInit(MP4_MAX_BUFFERS*2, &dec_cont->fifo_display) != FIFO_OK)
+  if (FifoInit(MP4_MAX_BUFFERS*2, &dec_cont->fifo_display) != FIFO_OK) {
+    if (dec_cont->pp_buffer_queue)
+      free(dec_cont->pp_buffer_queue);
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void) DWLRelease(dwl);
+#endif
     return MP4DEC_MEMFAIL;
+  }
 #endif
 #ifdef USE_EXTERNAL_BUFFER
   dec_cont->no_reallocation = 1;
@@ -1629,6 +1659,8 @@ void MP4DecRelease(MP4DecInst dec_inst) {
     if(dec_cont->StrmStorage.data[i].virtual_address != NULL)
       DWLFreeRefFrm(dec_cont->dwl, &dec_cont->StrmStorage.data[i]);
 #endif
+  if (dec_cont->pp_buffer_queue)
+    InputQueueRelease(dec_cont->pp_buffer_queue);
 
   DWLfree(dec_cont);
 #ifndef USE_EXTERNAL_BUFFER
@@ -2129,6 +2161,10 @@ u32 RunDecoderAsic(DecContainer * dec_container, addr_t strm_bus_address) {
   addr_t tmp = 0;
   u32 asic_status = 0;
 
+  if (dec_container->StrmStorage.work_out >= 
+      sizeof(dec_container->StrmStorage.p_pic_buf) / sizeof(dec_container->StrmStorage.p_pic_buf[0]))
+    return 0;
+
   ASSERT(MP4DecResolveVirtual(dec_container,
                               dec_container->StrmStorage.work_out) != 0);
   ASSERT(dec_container->rlc_mode || strm_bus_address != 0);
@@ -3592,6 +3628,12 @@ static void PPControl(DecContainer * dec_cont, u32 pipeline_off) {
   u32 index_for_pp = BUFFER_UNDEFINED;
   u32 next_buffer_index;
 
+  if (dec_cont->StrmStorage.work_out >= 
+      sizeof(dec_cont->StrmStorage.p_pic_buf) / sizeof(dec_cont->StrmStorage.p_pic_buf[0])) {
+    MP4DEC_API_DEBUG(("Access picture buffer error.# 
"));
+    return;
+  }
+
   DecPpInterface * pc = &dec_cont->pp_control;
   DecHdrs        * p_hdrs = &dec_cont->Hdrs;
 
@@ -4204,6 +4246,10 @@ static void MP4DecRunFullmode(DecContainer * dec_cont) {
   }
 
   index_for_pp = dec_cont->StrmStorage.work_out;
+  if (index_for_pp >= MP4_MAX_BUFFERS + 1) {
+    MP4DEC_API_DEBUG(("index_for_pp %d error
", index_for_pp));
+    return;
+  }
   pc->tiled_input_mode = dec_cont->tiled_reference_enable;
   pc->progressive_sequence =
     !dec_cont->Hdrs.interlaced;
diff --git a/decoder_sw/software/source/mpeg4/mp4decapi_internal.c b/decoder_sw/software/source/mpeg4/mp4decapi_internal.c
index 25444d6..73dcd97 100755
--- a/decoder_sw/software/source/mpeg4/mp4decapi_internal.c
+++ b/decoder_sw/software/source/mpeg4/mp4decapi_internal.c
@@ -551,6 +551,7 @@ MP4DecRet MP4DecAllocExtraBPic(DecContainer * dec_cont) {
   if (dec_cont->pp_enabled) {
     /* Add PP output buffers. */
     struct DWLLinearMem pp_buffer;
+    pp_buffer.mem_type = DWL_MEM_TYPE_DPB;
     u32 pp_width, pp_height, pp_stride, pp_buff_size;
 
     pp_width = (dec_cont->VopDesc.vop_width * 16) >> dec_cont->dscale_shift_x;
@@ -574,6 +575,7 @@ MP4DecRet MP4DecAllocExtraBPic(DecContainer * dec_cont) {
     if (dec_cont->pp_enabled) {
       /* Add PP output buffers. */
       struct DWLLinearMem pp_buffer;
+      pp_buffer.mem_type = DWL_MEM_TYPE_DPB;
       u32 pp_width, pp_height, pp_stride, pp_buff_size;
 
       pp_width = (dec_cont->VopDesc.vop_width * 16) >> dec_cont->dscale_shift_x;
@@ -918,7 +920,8 @@ u32 MP4DecBFrameSupport(DecContainer * dec_cont) {
 
 ------------------------------------------------------------------------------*/
 u32 * MP4DecResolveVirtual(DecContainer * dec_cont, u32 index ) {
-  if( (i32)index < 0 )
+  if( (i32)index < 0  ||
+      index >= sizeof(dec_cont->StrmStorage.p_pic_buf) / sizeof(dec_cont->StrmStorage.p_pic_buf[0]))
     return NULL;
   return dec_cont->StrmStorage.data[dec_cont->StrmStorage.
                                     p_pic_buf[index].data_index].virtual_address;
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c b/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c
index 2970b69..1d84cf8 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c
@@ -905,8 +905,11 @@ u32 StrmDec_DecodeVlcBlock(DecContainer * dec_container, u32 mb_num,
                   MP4DEC_DEBUG(("NOK5
"));
                   return (HANTRO_NOK);
                 }
-              } else
+              } else {
+                if (run >= 27)
+                  return (HANTRO_NOK);
                 lmax = lmax_inter_table[run];
+              }
             } else if(escape_type == 1 && intra) {
               if(last == 1) {
                 if(run == 0)
@@ -921,13 +924,22 @@ u32 StrmDec_DecodeVlcBlock(DecContainer * dec_container, u32 mb_num,
                   MP4DEC_DEBUG(("NOK6
"));
                   return (HANTRO_NOK);
                 }
-              } else
+              } else {
+                if (run >= 15)
+                  return (HANTRO_NOK);
                 lmax = lmax_intra_table[run];
+              }
             } else if(escape_type == 2 && intra) {
-              if(last == 1)
+              if(last == 1) {
+                if (level < 1 || level >= 10)
+                  return (HANTRO_NOK);
                 rmax = rmax_intra_table_last[level - 1];
-              else    /* Last == 0 */
+              }
+              else {   /* Last == 0 */
+                if (level < 1 || level >= 29)
+                  return (HANTRO_NOK);
                 rmax = rmax_intra_table[level - 1];
+              }
             } else {
               /* inter mb and escape type 2 */
               if(last == 1) {
@@ -941,8 +953,11 @@ u32 StrmDec_DecodeVlcBlock(DecContainer * dec_container, u32 mb_num,
                   MP4DEC_DEBUG(("NOK7
"));
                   return (HANTRO_NOK);
                 }
-              } else  /* Last == 0 */
+              } else { /* Last == 0 */
+                if (level < 1 || level >= 14)
+                  return (HANTRO_NOK);
                 rmax = rmax_inter_table[level - 1];
+              }
             }
 
             if(escape_type == 1) {
diff --git a/decoder_sw/software/source/rv/rvdecapi.c b/decoder_sw/software/source/rv/rvdecapi.c
index 5f39c0c..116c49b 100755
--- a/decoder_sw/software/source/rv/rvdecapi.c
+++ b/decoder_sw/software/source/rv/rvdecapi.c
@@ -276,6 +276,8 @@ RvDecRet RvDecInit(RvDecInst * dec_inst,
 
   pthread_mutex_init(&dec_cont->protect_mutex, NULL);
 
+  rv_api_init_data_structures(dec_cont);
+
   dec_cont->ApiStorage.DecStat = INITIALIZED;
 
   *dec_inst = (DecContainer *) dec_cont;
@@ -600,6 +602,7 @@ RvDecRet RvDecDecode(RvDecInst dec_inst,
     for( i = 0 ; i < num_pics_resampled ; ++i ) {
       u32 j = resample_pics[i];
       picture_t * p_ref_pic;
+      u32 rpr_buf_idx = 0;
 
       p_ref_pic = &dec_cont->StrmStorage.p_pic_buf[j];
 
@@ -607,6 +610,16 @@ RvDecRet RvDecDecode(RvDecInst dec_inst,
           p_ref_pic->coded_height == new_height )
         continue;
 
+      /* Get rpr buffer from bq */
+      rpr_buf_idx = BqueueNext2(&dec_cont->StrmStorage.bq,
+                                dec_cont->StrmStorage.work0,
+                                dec_cont->StrmStorage.work1,
+                                BQUEUE_UNUSED,
+                                dec_cont->StrmStorage.rpr_next_pic_type == RV_B_PIC );
+      if (rpr_buf_idx == (u32)0xFFFFFFFFU)
+        return RVDEC_ABORTED;
+      dec_cont->StrmStorage.p_rpr_buf = dec_cont->StrmStorage.p_pic_buf[rpr_buf_idx];
+
       rvRpr( p_ref_pic,
              &dec_cont->StrmStorage.p_rpr_buf,
              &dec_cont->StrmStorage.rpr_work_buffer,
@@ -620,9 +633,8 @@ RvDecRet RvDecDecode(RvDecInst dec_inst,
       p_ref_pic->coded_height = new_height;
       p_ref_pic->frame_height = ( 15 + new_height ) & ~15;
 
-      tmp_data = dec_cont->StrmStorage.p_rpr_buf.data;
-      dec_cont->StrmStorage.p_rpr_buf.data = p_ref_pic->data;
-      p_ref_pic->data = tmp_data;
+      /* set rpr buffer as forward reference */
+      dec_cont->StrmStorage.work0 = rpr_buf_idx;
     }
 
     dec_cont->Hdrs.horizontal_size = new_width;
@@ -1135,6 +1147,8 @@ void RvDecRelease(RvDecInst dec_inst) {
 
   if (dec_cont->StrmStorage.slices.virtual_address != NULL)
     DWLFreeLinear(dec_cont->dwl, &dec_cont->StrmStorage.slices);
+  if (dec_cont->pp_buffer_queue)
+    InputQueueRelease(dec_cont->pp_buffer_queue);
 
   DWLfree(dec_cont);
 #ifndef USE_EXTERNAL_BUFFER
@@ -2852,18 +2866,16 @@ void RvSetExternalBufferInfo(DecContainer * dec_cont) {
   u32 ref_buff_size = pic_size;
   ext_buffer_size = ref_buff_size;
 
-  u32 buffers = 3;
+  u32 buffers = 4;
 
   if( dec_cont->pp_instance ) { /* Combined mode used */
-    buffers = 3;
+    buffers = 4;
   } else { /* Dec only or separate PP */
     buffers = dec_cont->StrmStorage.max_num_buffers;
-    if( buffers < 3 )
-      buffers = 3;
+    if( buffers < 4 )
+      buffers = 4;
   }
 
-  dec_cont->tot_buffers_added = dec_cont->tot_buffers;
-
   if(pic_size > (dec_cont->use_adaptive_buffers ?
                  dec_cont->n_ext_buf_size :  dec_cont->next_buf_size))
     dec_cont->no_reallocation = 0;
@@ -2882,11 +2894,10 @@ void RvSetExternalBufferInfo(DecContainer * dec_cont) {
     ext_buffer_size = pp_buff_size;
   }
 
-  dec_cont->tot_buffers_added = dec_cont->tot_buffers;
   if (dec_cont->pp_enabled)
     dec_cont->tot_buffers = dec_cont->buf_num =  buffers;
   else
-    dec_cont->tot_buffers = dec_cont->buf_num =  buffers + 1;
+    dec_cont->tot_buffers = dec_cont->buf_num =  buffers;
   dec_cont->next_buf_size = ext_buffer_size;
 }
 
@@ -2977,11 +2988,13 @@ RvDecRet RvDecAddBuffer(RvDecInst dec_inst, struct DWLLinearMem *info) {
         dec_cont->StrmStorage.p_pic_buf[i].data = *info;
 
         dec_cont->buffer_index++;
+        dec_cont->tot_buffers_added++;
         if(dec_cont->buffer_index < dec_cont->tot_buffers)
           dec_ret = RVDEC_WAITING_FOR_BUFFER;
       } else {
-        dec_cont->StrmStorage.p_rpr_buf.data = *info;
+        dec_cont->StrmStorage.p_pic_buf[i].data = *info;
         dec_cont->buffer_index++;
+        dec_cont->tot_buffers_added++;
         dec_ret = RVDEC_OK;
       }
     } else {
@@ -2991,9 +3004,10 @@ RvDecRet RvDecAddBuffer(RvDecInst dec_inst, struct DWLLinearMem *info) {
         return RVDEC_EXT_BUFFER_REJECTED;
       }
 
-      dec_cont->StrmStorage.p_pic_buf[i - 1].data = *info;
+      dec_cont->StrmStorage.p_pic_buf[i].data = *info;
 
       dec_cont->buffer_index++;
+      dec_cont->tot_buffers_added++;
       dec_cont->tot_buffers++;
       dec_cont->StrmStorage.bq.queue_size++;
       dec_cont->StrmStorage.num_buffers++;
@@ -3032,19 +3046,20 @@ void RvEmptyBufferQueue(DecContainer *dec_cont) {
 }
 
 void RvStateReset(DecContainer *dec_cont) {
-  u32 buffers = 3;
+  u32 buffers = 4;
 
   if( !dec_cont->pp_instance ) { /* Combined mode used */
     buffers = dec_cont->StrmStorage.max_num_buffers;
-    if( buffers < 3 )
-      buffers = 3;
+    if( buffers < 4 )
+      buffers = 4;
   }
 
   /* Clear internal parameters in DecContainer */
 #ifdef USE_EXTERNAL_BUFFER
 #ifdef USE_OMXIL_BUFFER
-  dec_cont->tot_buffers = buffers + 1;
+  dec_cont->tot_buffers = buffers;
   dec_cont->buffer_index = 0;
+  dec_cont->tot_buffers_added = 0;
 #endif
   dec_cont->no_reallocation = 1;
 #endif
@@ -3100,7 +3115,6 @@ void RvStateReset(DecContainer *dec_cont) {
   (void) DWLmemset(dec_cont->StrmStorage.out_buf, 0, 16 * sizeof(u32));
 #ifdef USE_OMXIL_BUFFER
   (void) DWLmemset(dec_cont->StrmStorage.p_pic_buf, 0, 16 * sizeof(picture_t));
-  (void) DWLmemset(&dec_cont->StrmStorage.p_rpr_buf, 0, sizeof(picture_t));
   (void) DWLmemset(dec_cont->StrmStorage.picture_info, 0, 32 * sizeof(RvDecPicture));
 #endif
 #ifdef CLEAR_HDRINFO_IN_SEEK
diff --git a/decoder_sw/software/source/rv/rvdecapi_internal.c b/decoder_sw/software/source/rv/rvdecapi_internal.c
index be2bda9..14dcdca 100755
--- a/decoder_sw/software/source/rv/rvdecapi_internal.c
+++ b/decoder_sw/software/source/rv/rvdecapi_internal.c
@@ -87,8 +87,8 @@ RvDecRet rvAllocateBuffers(DecContainer * dec_cont) {
     /*size_tmp = 384 * dec_cont->FrameDesc.total_mb_in_frame;*/
     size_tmp = 384 * dec_cont->StrmStorage.max_mbs_per_frame;
 
-    /* Calculate minimum amount of buffers */
-    buffers = 3;
+    /* Calculate minimum amount of buffers(including one rpr buffer) */
+    buffers = 4;
 
     if( dec_cont->pp_instance ) { /* Combined mode used */
       dec_cont->StrmStorage.num_pp_buffers = dec_cont->StrmStorage.max_num_buffers;
diff --git a/decoder_sw/software/source/vc1/vc1decapi.c b/decoder_sw/software/source/vc1/vc1decapi.c
index 74d806e..a595a4a 100755
--- a/decoder_sw/software/source/vc1/vc1decapi.c
+++ b/decoder_sw/software/source/vc1/vc1decapi.c
@@ -203,6 +203,11 @@ VC1DecRet VC1DecInit( VC1DecInst* dec_inst,
   if(reference_frame_format == DEC_REF_FRM_TILED_DEFAULT) {
     /* Assert support in HW before enabling.. */
     if(!config.tiled_mode_support) {
+      pthread_mutex_destroy(&dec_cont->protect_mutex);
+      DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+      (void)DWLRelease(dwl);
+#endif
       return VC1DEC_FORMAT_NOT_SUPPORTED;
     }
     dec_cont->tiled_mode_support = config.tiled_mode_support;
@@ -228,6 +233,7 @@ VC1DecRet VC1DecInit( VC1DecInst* dec_inst,
                   num_frame_buffers);
   if ( rv != VC1HWD_OK) {
     DEC_API_TRC("VC1DecInit# ERROR: Invalid initialization metadata");
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
     DWLfree(dec_cont);
 #ifndef USE_EXTERNAL_BUFFER
     (void)DWLRelease(dwl);
@@ -268,6 +274,11 @@ VC1DecRet VC1DecInit( VC1DecInst* dec_inst,
 
   if(!config.addr64_support && sizeof(void *) == 8) {
     DEC_API_TRC("VC1DecInit# ERROR: HW not support 64bit address!
");
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void)DWLRelease(dwl);
+#endif
     return (VC1DEC_PARAM_ERROR);
   }
 
@@ -284,6 +295,11 @@ VC1DecRet VC1DecInit( VC1DecInst* dec_inst,
               dscale_cfg->down_scale_y != 2 &&
               dscale_cfg->down_scale_y != 4 &&
               dscale_cfg->down_scale_y != 8 )) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void)DWLRelease(dwl);
+#endif
     return (VC1DEC_PARAM_ERROR);
   } else {
     u32 scale_table[9] = {0, 0, 1, 0, 2, 0, 0, 0, 3};
@@ -297,6 +313,11 @@ VC1DecRet VC1DecInit( VC1DecInst* dec_inst,
 
   dec_cont->pp_buffer_queue = InputQueueInit(0);
   if (dec_cont->pp_buffer_queue == NULL) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
+#ifndef USE_EXTERNAL_BUFFER
+    (void)DWLRelease(dwl);
+#endif
     return (VC1DEC_MEMFAIL);
   }
   dec_cont->storage.release_buffer = 0;
@@ -1371,6 +1392,8 @@ void VC1DecRelease(VC1DecInst dec_inst) {
   dec_cont->storage.hrd_rate = NULL;
   dec_cont->storage.hrd_buffer = NULL;
   dec_cont->storage.hrd_fullness = NULL;
+  if (dec_cont->pp_buffer_queue)
+    InputQueueRelease(dec_cont->pp_buffer_queue);
   DWLfree(dec_cont);
 #ifndef USE_EXTERNAL_BUFFER
   (void)DWLRelease(dwl);
diff --git a/decoder_sw/software/source/vp6/vp6booldec.c b/decoder_sw/software/source/vp6/vp6booldec.c
index d00ac21..c403c90 100755
--- a/decoder_sw/software/source/vp6/vp6booldec.c
+++ b/decoder_sw/software/source/vp6/vp6booldec.c
@@ -89,7 +89,7 @@ u32 VP6HWDecodeBool(BOOL_CODER * br, i32 probability) {
           break;
         }
         count = 8;
-        value |= br->buffer[br->pos];
+        value |= (u32) br->buffer[br->pos];
         br->pos++;
       }
     } while(range < 0x80);
@@ -149,7 +149,7 @@ u32 VP6HWDecodeBool128(BOOL_CODER * br) {
       return 0; /* any value, not valid */
     }
     count = 8;
-    value |= br->buffer[br->pos];
+    value |= (u32) br->buffer[br->pos];
     br->pos++;
   }
 
diff --git a/decoder_sw/software/source/vp6/vp6hwd_asic.c b/decoder_sw/software/source/vp6/vp6hwd_asic.c
index 780605e..d3a4535 100755
--- a/decoder_sw/software/source/vp6/vp6hwd_asic.c
+++ b/decoder_sw/software/source/vp6/vp6hwd_asic.c
@@ -461,7 +461,7 @@ void VP6HwdAsicStrmPosUpdate(VP6DecContainer_t * dec_cont) {
   DEBUG_PRINT(("	Start bit pos %8d
", hw_bit_pos));
 
   tmp = dec_cont->asic_buff->partition1_base;   /* unaligned base */
-  tmp &= (~DEC_8190_ALIGN_MASK);  /* align the base */
+  tmp &= (addr_t)(~DEC_8190_ALIGN_MASK);  /* align the base */
 
   SET_ADDR_REG(dec_cont->vp6_regs, HWIF_VP6HWPART1_BASE, (addr_t)(~0));
   SET_ADDR_REG(dec_cont->vp6_regs, HWIF_VP6HWPART2_BASE, (addr_t)(~0));
diff --git a/decoder_sw/software/source/vp8/vp8decapi.c b/decoder_sw/software/source/vp8/vp8decapi.c
index 9db9f6e..fd847f7 100755
--- a/decoder_sw/software/source/vp8/vp8decapi.c
+++ b/decoder_sw/software/source/vp8/vp8decapi.c
@@ -2296,7 +2296,7 @@ static i32 FindIndex(VP8DecContainer_t* dec_cont, const u32* address) {
 
 #ifdef USE_OUTPUT_RELEASE
 static VP8DecRet VP8PushOutput(VP8DecContainer_t* dec_cont) {
-  u32 ret=VP8DEC_OK;
+  u32 ret = VP8DEC_OK;
   VP8DecPicture output;
 
   /* Sample dec_cont->out_count for Peek */
diff --git a/decoder_sw/software/source/vp8/vp8hwd_asic.c b/decoder_sw/software/source/vp8/vp8hwd_asic.c
index 3d9328d..72dfd25 100755
--- a/decoder_sw/software/source/vp8/vp8hwd_asic.c
+++ b/decoder_sw/software/source/vp8/vp8hwd_asic.c
@@ -1088,7 +1088,7 @@ void VP8HwdAsicStrmPosUpdate(VP8DecContainer_t * dec_cont, addr_t strm_bus_addre
 
   tmp_addr = strm_bus_address + tmp/8;
   hw_bit_pos = (tmp_addr & DEC_8190_ALIGN_MASK) * 8;
-  tmp_addr &= (~DEC_8190_ALIGN_MASK);  /* align the base */
+  tmp_addr &= (addr_t) (~DEC_8190_ALIGN_MASK);  /* align the base */
 
   hw_bit_pos += tmp & 0x7;
 
diff --git a/decoder_sw/software/source/vp8/vp8hwd_bool.c b/decoder_sw/software/source/vp8/vp8hwd_bool.c
index b25a710..ee3793f 100755
--- a/decoder_sw/software/source/vp8/vp8hwd_bool.c
+++ b/decoder_sw/software/source/vp8/vp8hwd_bool.c
@@ -101,7 +101,7 @@ u32 vp8hwdDecodeBool(vpBoolCoder_t * br, i32 probability) {
           break;
         }
         count = 8;
-        value |= br->buffer[br->pos];
+        value |= (u32) br->buffer[br->pos];
         br->pos++;
       }
     } while(range < 0x80);
@@ -177,7 +177,7 @@ u32 vp8hwdDecodeBool128(vpBoolCoder_t * br) {
         return 0; /* any value, not valid */
       }
       count = 8;
-      value |= br->buffer[br->pos];
+      value |= (u32) br->buffer[br->pos];
       br->pos++;
     }
   }
diff --git a/decoder_sw/software/source/vp9/vp9decapi.c b/decoder_sw/software/source/vp9/vp9decapi.c
index ade20d3..5eaba59 100755
--- a/decoder_sw/software/source/vp9/vp9decapi.c
+++ b/decoder_sw/software/source/vp9/vp9decapi.c
@@ -151,6 +151,8 @@ enum DecRet Vp9DecInit(Vp9DecInst *dec_inst, const void *dwl, struct Vp9DecConfi
   dec_cont =
     (struct Vp9DecContainer *)DWLmalloc(sizeof(struct Vp9DecContainer));
 
+  if (dec_cont == NULL)
+    return DEC_MEMFAIL;
   (void)DWLmemset(dec_cont, 0, sizeof(struct Vp9DecContainer));
   dec_cont->dwl = dwl;
 
@@ -169,6 +171,8 @@ enum DecRet Vp9DecInit(Vp9DecInst *dec_inst, const void *dwl, struct Vp9DecConfi
              (dec_cfg->dscale_cfg.down_scale_y != 2 &&
               dec_cfg->dscale_cfg.down_scale_y != 4 &&
               dec_cfg->dscale_cfg.down_scale_y != 8 )) {
+    pthread_mutex_destroy(&dec_cont->protect_mutex);
+    DWLfree(dec_cont);
     return (DEC_PARAM_ERROR);
   } else {
     u32 scale_table[9] = {0, 0, 1, 0, 2, 0, 0, 0, 3};
@@ -218,9 +222,12 @@ enum DecRet Vp9DecInit(Vp9DecInst *dec_inst, const void *dwl, struct Vp9DecConfi
   if (FifoInit(VP9DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_display) != FIFO_OK)
     return DEC_MEMFAIL;
 
-  if (pthread_mutex_init(&dec_cont->sync_out, NULL) ||
-      pthread_cond_init(&dec_cont->sync_out_cv, NULL))
+  if (pthread_mutex_init(&dec_cont->sync_out, NULL))
+    return DEC_SYSTEM_ERROR;
+  if(pthread_cond_init(&dec_cont->sync_out_cv, NULL)) {
+    pthread_mutex_destroy(&dec_cont->sync_out);
     return DEC_SYSTEM_ERROR;
+  }
 
   DWLmemcpy(&dec_cont->hw_cfg, &hw_cfg, sizeof(DWLHwConfig));
 
@@ -1047,7 +1054,7 @@ enum DecRet Vp9DecAddBuffer(Vp9DecInst dec_inst,
           && IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, RASTERSCAN_OUT_BUFFER)) {
         dec_cont->buf_type = RASTERSCAN_OUT_BUFFER;
         dec_cont->next_buf_size = asic_buff->pp_size;
-        dec_cont->buf_to_free = asic_buff->realloc_out_buffer ? &asic_buff->pp_pictures[dec_cont->buffer_index] : NULL;
+        dec_cont->buf_to_free = asic_buff->realloc_out_buffer ? &asic_buff->pp_pictures[dec_cont->buffer_index - 1] : NULL;
         dec_cont->buf_num = 1;
 #ifdef ASIC_TRACE_SUPPORT
         dec_cont->is_frame_buffer = 0;
@@ -1059,7 +1066,7 @@ enum DecRet Vp9DecAddBuffer(Vp9DecInst dec_inst,
                && IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, DOWNSCALE_OUT_BUFFER)) {
         dec_cont->buf_type = DOWNSCALE_OUT_BUFFER;
         dec_cont->next_buf_size = asic_buff->pp_size;
-        dec_cont->buf_to_free = asic_buff->realloc_out_buffer ? &asic_buff->pp_pictures[dec_cont->buffer_index] : NULL;
+        dec_cont->buf_to_free = asic_buff->realloc_out_buffer ? &asic_buff->pp_pictures[dec_cont->buffer_index - 1] : NULL;
         dec_cont->buf_num = 1;
 #ifdef ASIC_TRACE_SUPPORT
         dec_cont->is_frame_buffer = 0;
diff --git a/decoder_sw/software/source/vp9/vp9hwd_asic.c b/decoder_sw/software/source/vp9/vp9hwd_asic.c
index 4ec74d8..2567d12 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_asic.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_asic.c
@@ -761,7 +761,7 @@ i32 Vp9AllocateFrame(struct Vp9DecContainer *dec_cont, u32 index) {
 i32 Vp9ReallocateFrame(struct Vp9DecContainer *dec_cont, u32 index) {
   i32 ret = HANTRO_OK;
   struct DecAsicBuffers *asic_buff = dec_cont->asic_buff;
-  u32 out_index;
+  u32 out_index = index;
 
   if (IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, REFERENCE_BUFFER))
     out_index = index;
@@ -1126,6 +1126,8 @@ i32 Vp9GetRefFrm(struct Vp9DecContainer *dec_cont, u32 id) {
         //asic_buff->out_buffer_i = Vp9BufferQueueGetBuffer(dec_cont->bq, limit);
       }
 
+      if (asic_buff->out_buffer_i < 0)
+        return HANTRO_OK;
 #ifdef USE_VP9_EC
       asic_buff->picture_info[asic_buff->out_buffer_i].nbr_of_err_mbs = 0;
 #endif
@@ -1971,8 +1973,8 @@ void Vp9AsicStrmPosUpdate(struct Vp9DecContainer *dec_cont,
       turn_around = 1;
     }
 
-    hw_bit_pos = (tmp_addr & DEC_HW_ALIGN_MASK) * 8;
-    tmp_addr &= (~DEC_HW_ALIGN_MASK); /* align the base */
+    hw_bit_pos = (tmp_addr & ((addr_t) DEC_HW_ALIGN_MASK)) * 8;
+    tmp_addr &= (addr_t) (~DEC_HW_ALIGN_MASK); /* align the base */
 
     SetDecRegister(dec_cont->vp9_regs, HWIF_STRM_START_BIT, hw_bit_pos);
 
@@ -1995,8 +1997,8 @@ void Vp9AsicStrmPosUpdate(struct Vp9DecContainer *dec_cont,
   } else {
     tmp_addr = strm_bus_address + tmp;
 
-    hw_bit_pos = (tmp_addr & DEC_HW_ALIGN_MASK) * 8;
-    tmp_addr &= (~DEC_HW_ALIGN_MASK); /* align the base */
+    hw_bit_pos = (tmp_addr & ((addr_t) DEC_HW_ALIGN_MASK)) * 8;
+    tmp_addr &= (addr_t) (~DEC_HW_ALIGN_MASK); /* align the base */
 
     SetDecRegister(dec_cont->vp9_regs, HWIF_STRM_START_BIT, hw_bit_pos);
 
@@ -2223,10 +2225,12 @@ void Vp9FixChromaRFCTable(struct Vp9DecContainer *dec_cont) {
   u32 frame_width = NEXT_MULTIPLE(dec_cont->width, 8);
   u32 frame_height = NEXT_MULTIPLE(dec_cont->height, 8);
   struct DecAsicBuffers *asic_buff = dec_cont->asic_buff;
-  u32 i, j, cbs_size=0;
-  u8 *pch_rfc_tbl, *ptbl=NULL;
+  u32 i, j;
+  u32 cbs_size = 64;
+  u8 *pch_rfc_tbl;
   u8 cbs_sizes_8bit[14] = {129, 2, 4, 8, 16, 32, 64, 129, 2, 4, 8, 16, 32, 64};
   u8 cbs_sizes_10bit[14] = {0xa1, 0x42, 0x85, 10, 20, 40, 80, 0xa1, 0x42, 0x85, 10, 20, 40, 80};
+  u8 *ptbl = cbs_sizes_8bit;
   u32 pic_width_in_cbsc  = NEXT_MULTIPLE(frame_width, 256)/16;
   u32 pic_height_in_cbsc = NEXT_MULTIPLE(frame_height/2, 4)/4;
   u32 offset;
diff --git a/decoder_sw/software/source/vp9/vp9hwd_bool.c b/decoder_sw/software/source/vp9/vp9hwd_bool.c
index 137cb21..13f3f12 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_bool.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_bool.c
@@ -94,7 +94,7 @@ u32 Vp9DecodeBool(struct VpBoolCoder* br, i32 probability) {
           break;
         } else {
           count = 8;
-          value |= DWLPrivateAreaReadByte(br->buffer);
+          value |= (u32) DWLPrivateAreaReadByte(br->buffer);
           br->buffer++;
           br->read_len++;
           if(br->buffer >= (br->buffer_start + br->buffer_len))
@@ -171,7 +171,7 @@ u32 Vp9DecodeBool128(struct VpBoolCoder* br) {
       } else {
         count = 8;
 
-        value |= DWLPrivateAreaReadByte(br->buffer);
+        value |= (u32) DWLPrivateAreaReadByte(br->buffer);
         br->buffer++;
         br->read_len++;
         if(br->buffer >= (br->buffer_start + br->buffer_len))
diff --git a/decoder_sw/software/source/vp9/vp9hwd_output.c b/decoder_sw/software/source/vp9/vp9hwd_output.c
index ad05a2d..5e3e5d5 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_output.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_output.c
@@ -94,8 +94,8 @@ i32 FindIndex(struct Vp9DecContainer *dec_cont, const u32 *address) {
 #else
 i32 FindIndex(struct Vp9DecContainer *dec_cont, const u32 *address, u32 buffer_type) {
   i32 i;
-  struct DWLLinearMem *pictures;
-  i32 num_buffers;
+  struct DWLLinearMem *pictures = dec_cont->asic_buff->pictures;
+  i32 num_buffers = dec_cont->num_buffers;
 
   if (buffer_type == REFERENCE_BUFFER) {
     pictures = dec_cont->asic_buff->pictures;
diff --git a/decoder_sw/software/source/vp9/vp9hwd_probs.c b/decoder_sw/software/source/vp9/vp9hwd_probs.c
index 9f69d8a..036d9dd 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_probs.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_probs.c
@@ -108,6 +108,9 @@ void Vp9ResetProbs(struct Vp9Decoder *dec) {
       DWLmemcpy(&dec->entropy_last[i], &dec->entropy,
                 sizeof(struct Vp9EntropyProbs));
   } else if (dec->reset_frame_context == 2) {
+    ASSERT(dec->frame_context_idx < NUM_FRAME_CONTEXTS);
+    if (dec->frame_context_idx >= NUM_FRAME_CONTEXTS)
+      return;
     DWLmemcpy(&dec->entropy_last[dec->frame_context_idx], &dec->entropy,
               sizeof(struct Vp9EntropyProbs));
   }
@@ -361,6 +364,9 @@ void Vp9ResetProbs(struct Vp9Decoder *dec) {
 void Vp9GetProbs(struct Vp9Decoder *dec) {
   /* Frame context tells which frame is used as reference, make
    * a copy of the context to use as base for this frame probs. */
+  ASSERT(dec->frame_context_idx < NUM_FRAME_CONTEXTS);
+  if (dec->frame_context_idx >= NUM_FRAME_CONTEXTS)
+    return;
   dec->entropy = dec->entropy_last[dec->frame_context_idx];
 }
 
@@ -667,10 +673,14 @@ static void UpdateModeProbs(int n_modes, const vp9_tree_index *tree,
     count = branch_ct[t][0] + branch_ct[t][1];
     count = count > MODE_COUNT_SAT ? MODE_COUNT_SAT : count;
     factor = (MODE_MAX_UPDATE_FACTOR * count / MODE_COUNT_SAT);
-    if (t < 8 || dst_probs_b == NULL)
+    if (dst_probs_b == NULL)
       dst_probs[t] = WeightedProb(pre_probs[t], probs[t], factor);
-    else
-      dst_probs_b[t - 8] = WeightedProb(pre_probs_b[t - 8], probs[t], factor);
+    else {
+      if (t < 8)
+        dst_probs[t] = WeightedProb(pre_probs[t], probs[t], factor);
+      else
+        dst_probs_b[t - 8] = WeightedProb(pre_probs_b[t - 8], probs[t], factor);
+    }
   }
 }
 
diff --git a/decoder_sw/software/test/avs/Makefile b/decoder_sw/software/test/avs/Makefile
index 9c0bc21..27e692a 100755
--- a/decoder_sw/software/test/avs/Makefile
+++ b/decoder_sw/software/test/avs/Makefile
@@ -59,7 +59,7 @@ INCLUDE = -I../../source/inc -I../../source/avs/ -I../../source/config \
           -I../../source/common  -I../common/swhw -I../common/utils
 
 DECLIBDIR = -L../../linux/avs -L../../linux/dwl -L../common/swhw \
-            -L../../../lib -L../common/utils
+            -L../../../system/models/g1hw -L../common/utils
 DECLIB =  libdecx170a.a
 DWLLIB = libdwlx170.a
 TBLIB = libtbcommon.a
@@ -222,7 +222,7 @@ pclinux_eval: test
 
 export SYSTEM_VERIFICATION_TEST
 
-test:  $(OBJS)
+test: $(OBJS)
 	$(CC) $(LDFLAGS) $(CFLAGS) $(OBJS) $(LIBS) -o $(TESTDEC)
 
 lib:
diff --git a/decoder_sw/software/test/avs/avsdectest.c b/decoder_sw/software/test/avs/avsdectest.c
index 2def3fb..db5875b 100755
--- a/decoder_sw/software/test/avs/avsdectest.c
+++ b/decoder_sw/software/test/avs/avsdectest.c
@@ -212,6 +212,7 @@ static void *AddBufferThread(void *arg) {
     pthread_mutex_lock(&ext_buffer_contro);
     if(add_extra_flag && num_buffers < 16) {
       struct DWLLinearMem mem;
+      mem.mem_type = DWL_MEM_TYPE_DPB;
       i32 dwl_ret;
       if (pp_enabled)
         dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -284,6 +285,7 @@ static void* buf_release_thread(void* arg) {
         pthread_mutex_lock(&ext_buffer_contro);
         if(add_extra_flag && num_buffers < 16) {
           struct DWLLinearMem mem;
+          mem.mem_type = DWL_MEM_TYPE_DPB;
           i32 dwl_ret;
           if (pp_enabled)
             dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -500,6 +502,11 @@ int main(int argc, char **argv) {
     /* Check expiry date */
     time(&sys_time);
     tm = localtime(&sys_time);
+    if (tm == NULL) {
+      fprintf(stderr,"Get localtime failed!
");
+      return -1;
+    }
+
     strftime(tm_buf, sizeof(tm_buf), "%y%m%d", tm);
     tmp1 = 1000000+atoi(tm_buf);
     if (tmp1 > (EXPIRY_DATE) && (EXPIRY_DATE) > 1 ) {
@@ -2023,8 +2030,11 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
       /* start of bottom field */
       if(!top)
         p += width;
-      else
+      else {
+        if(raster_scan)
+          free(raster_scan);
         return; /* TODO! use "return" ==> match to reference model */
+      }
 
       if(planar_output) {
         /* luma */
@@ -2211,11 +2221,11 @@ void WriteOutputLittleEndian(u8 * data, u32 pic_size) {
   for(i = 0; i < chunks; ++i) {
     word = data[0];
     word <<= 8;
-    word |= data[1];
+    word |= (u32) data[1];
     word <<= 8;
-    word |= data[2];
+    word |= (u32) data[2];
     word <<= 8;
-    word |= data[3];
+    word |= (u32) data[3];
     fwrite(&word, 4, 1, fout);
     data += 4;
   }
@@ -2229,15 +2239,15 @@ void WriteOutputLittleEndian(u8 * data, u32 pic_size) {
   } else if(pic_size % 4 == 2) {
     word = data[0];
     word <<= 8;
-    word |= data[1];
+    word |= (u32) data[1];
     word <<= 16;
     fwrite(&word, 2, 1, fout);
   } else if(pic_size % 4 == 3) {
     word = data[0];
     word <<= 8;
-    word |= data[1];
+    word |= (u32) data[1];
     word <<= 8;
-    word |= data[2];
+    word |= (u32) data[2];
     word <<= 8;
     fwrite(&word, 3, 1, fout);
   }
diff --git a/decoder_sw/software/test/common/Makefile b/decoder_sw/software/test/common/Makefile
index 4a9c458..79e1c67 100755
--- a/decoder_sw/software/test/common/Makefile
+++ b/decoder_sw/software/test/common/Makefile
@@ -152,7 +152,7 @@ endif
 
 g2dec: env depend $(LIBS) $(G2_OBJS) $(DEC_OBJS) $(OMX_LIB_G2_DWL) $(OMX_LIB_G2_COMMON)  $(OMX_LIB_G2_HEVC) $(OMX_LIB_G2_VP9) $(OMX_LIB_G2_HW) $(OMX_LIB_G2_TBCOMMON)
 	@echo -e "[LINK]	$(OBJDIR)/$@"
-	$(CC) $(filter %.o, $^) $(LDFLAGS) -o $(OBJDIR)/$@
+	$(CC) $(LDFLAGS) $(filter %.o, $^) $(LIBS) -o $(OBJDIR)/$@
 ifeq ($(strip $(SYMLINKS)),y)
 	@ln -fs $@ $(OBJDIR)/hevcdec_tb
 	@ln -fs $@ $(OBJDIR)/vp9dec
diff --git a/decoder_sw/software/test/common/bytestream_parser.c b/decoder_sw/software/test/common/bytestream_parser.c
index 35c3d65..8e70644 100755
--- a/decoder_sw/software/test/common/bytestream_parser.c
+++ b/decoder_sw/software/test/common/bytestream_parser.c
@@ -86,6 +86,8 @@ static off_t FindNextStartCode(struct BSParser* inst, u32* zero_count) {
 
 BSParserInst ByteStreamParserOpen(const char* fname, u32 mode) {
   struct BSParser* inst = malloc(sizeof(struct BSParser));
+  if (inst == NULL)
+    return NULL;
   inst->mode = mode;
   inst->file = fopen(fname, "rb");
   if (inst->file == NULL) {
diff --git a/decoder_sw/software/test/common/dectestbench.c b/decoder_sw/software/test/common/dectestbench.c
index 1451a48..0765e93 100755
--- a/decoder_sw/software/test/common/dectestbench.c
+++ b/decoder_sw/software/test/common/dectestbench.c
@@ -264,14 +264,17 @@ int main(int argc, char* argv[]) {
     dwl_params.client_type = DWL_CLIENT_TYPE_VP9_DEC;
     if (client.test_params.read_mode == STREAMREADMODE_FULLSTREAM) {
       fprintf(stderr, "Full-stream (-F) is not supported in VP9.
");
+      sem_destroy(&client.dec_done);
       return -1;
     }
     if (client.test_params.disable_display_order) {
       fprintf(stderr, "Disable display reorder (-R) is not supported in VP9.
");
+      sem_destroy(&client.dec_done);
       return -1;
     }
     break;
   default:
+    sem_destroy(&client.dec_done);
     return -1;
   }
 
@@ -289,11 +292,15 @@ int main(int argc, char* argv[]) {
   case DEC_OUT_FRM_PLANAR_420:
     if (!build.hw_config[0].pp_support) {
       fprintf(stderr, "Cannot do raster output; No PP support.
");
+      sem_destroy(&client.dec_done);
+      DWLRelease(client.dwl);
       return -1;
     }
     config.output_format = DEC_OUT_FRM_RASTER_SCAN;
     break;
   default:
+    sem_destroy(&client.dec_done);
+    DWLRelease(client.dwl);
     return -1;
   }
   printf("Configuring hardware to output: %s
",
@@ -313,6 +320,7 @@ int main(int argc, char* argv[]) {
 
   /* Initialize the decoder. */
   if (DecInit(codec, &client.decoder, config, client_if) != DEC_OK) {
+    sem_destroy(&client.dec_done);
     return -1;
   }
 
@@ -326,6 +334,8 @@ int main(int argc, char* argv[]) {
 
   CloseTestHooks(&client);
 
+  sem_destroy(&client.dec_done);
+
   return 0;
 }
 
@@ -614,6 +624,8 @@ static void PictureReadyCb(ClientInst inst, struct DecPicture picture) {
                picture.picture_info.is_corrupted ? "CORRUPT" : ""));
   if (client->test_params.extra_output_thread) {
     struct DecPicture* copy = malloc(sizeof(struct DecPicture));
+    if (copy == NULL)
+      return;
     *copy = picture;
     FifoPush(client->pic_fifo, copy, FIFO_EXCEPTION_DISABLE);
   } else {
@@ -861,6 +873,7 @@ static void ReleaseDemuxer(struct Client* client) {
 
 static const void* CreateSink(struct Client* client) {
   YuvSink yuvsink;
+  yuvsink.open = NULL;
   switch (client->test_params.sink_type) {
   case SINK_FILE_SEQUENCE:
     yuvsink.open = FilesinkOpen;
@@ -897,6 +910,8 @@ static const void* CreateSink(struct Client* client) {
   default:
     assert(0);
   }
+  if (yuvsink.open == NULL)
+    return NULL;
   yuvsink.inst = yuvsink.open(client->test_params.out_file_name);
   client->yuvsink = yuvsink;
   return client->yuvsink.inst;
diff --git a/decoder_sw/software/test/common/error_simulator.c b/decoder_sw/software/test/common/error_simulator.c
index 942032a..2822069 100755
--- a/decoder_sw/software/test/common/error_simulator.c
+++ b/decoder_sw/software/test/common/error_simulator.c
@@ -54,6 +54,8 @@ ErrorSimulator ErrorSimulatorInject(Demuxer* demuxer,
   /* Our error simulator injects it's own function in place of the bitstream
      read function. */
   struct ErrorSim* sim = calloc(1, sizeof(struct ErrorSim));
+  if (sim == NULL)
+    return NULL;
   sim->concrete_demuxer = *demuxer;
   demuxer->GetVideoFormat = ErrorSimulatorIdentifyFormat;
   demuxer->HeadersDecoded = ErrorSimulatorHeadersDecoded;
diff --git a/decoder_sw/software/test/common/swhw/tb_cfg.c b/decoder_sw/software/test/common/swhw/tb_cfg.c
index 4afbe02..953fb13 100755
--- a/decoder_sw/software/test/common/swhw/tb_cfg.c
+++ b/decoder_sw/software/test/common/swhw/tb_cfg.c
@@ -85,8 +85,8 @@ static enum ParseResult ParseBlock(FILE *fid, char *block, u32 *line,
   enum ParseMode prev_mode = CFG_MODE_IDLE;
   enum ParseResult sub_block_res;
   enum TBCfgCallbackResult cb_result;
-  char blk[1024];
-  char val[1024];
+  char blk[1024] = {0};
+  char val[1024] = {0};
   char escape;
   i32 blk_len = 0;
   i32 val_len = 0;
diff --git a/decoder_sw/software/test/common/swhw/tb_params.c b/decoder_sw/software/test/common/swhw/tb_params.c
index 6b8967c..70365b5 100755
--- a/decoder_sw/software/test/common/swhw/tb_params.c
+++ b/decoder_sw/software/test/common/swhw/tb_params.c
@@ -898,8 +898,7 @@ u32 TBCheckCfg(const struct TBCfg* tb_cfg) {
     return 1;
   }
 
-  if (tb_cfg->dec_params.latency_compensation > 63 ||
-      tb_cfg->dec_params.latency_compensation < 0) {
+  if (tb_cfg->dec_params.latency_compensation > 63) {
     printf("Error in DecParams.LatencyCompensation: %d
",
            tb_cfg->dec_params.latency_compensation);
     return 1;
diff --git a/decoder_sw/software/test/common/swhw/tb_params_g1.c b/decoder_sw/software/test/common/swhw/tb_params_g1.c
index 09682bf..829f09c 100755
--- a/decoder_sw/software/test/common/swhw/tb_params_g1.c
+++ b/decoder_sw/software/test/common/swhw/tb_params_g1.c
@@ -640,8 +640,7 @@ u32 TBCheckCfg(const struct TBCfg* tb_cfg) {
     return 1;
   }
 
-  if (tb_cfg->dec_params.latency_compensation > 63 ||
-      tb_cfg->dec_params.latency_compensation < 0) {
+  if (tb_cfg->dec_params.latency_compensation > 63) {
     printf("Error in DecParams.LatencyCompensation: %d
", tb_cfg->dec_params.latency_compensation);
     return 1;
   }
diff --git a/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c b/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c
index 91069ef..7fff9e0 100755
--- a/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c
+++ b/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c
@@ -112,10 +112,10 @@ a
 ------------------------------------------------------------------------------*/
 
 u32 TBRandomizeBitSwapInStream(u8* stream, u32 stream_len, char* odds) {
-  u32 dividend;
-  u32 divisor;
+  u32 dividend = 0;
+  u32 divisor = 0;
   u32 ret_val;
-  u32 chunks;
+  u32 chunks = 0;
   u32 i = 0;
   u32 j = 0;
   u32 k = 0;
@@ -137,6 +137,10 @@ u32 TBRandomizeBitSwapInStream(u8* stream, u32 stream_len, char* odds) {
 
   /* select (randomize) and swap the bits in the stream */
   /* for each chunk */
+  if (chunks > stream_len) {
+    free(randomized_bits);
+    return 1;
+  }
   for (i = 0; i < chunks; ++i) {
     /* randomize and swap the bits */
     while (j < dividend) {
@@ -252,7 +256,7 @@ u32 TBRandomizeU32(u32* value) {
 
 u32 ParseOdds(char* odds, u32* dividend, u32* divisor) {
   u32 i;
-  char odds_copy[23];
+  char odds_copy[24];
   char* ptr;
   u32 str_len = strlen(odds);
 
@@ -269,8 +273,12 @@ u32 ParseOdds(char* odds, u32* dividend, u32* divisor) {
         odds_copy[i + 2] == ' ') {
       odds_copy[i] = ' ';
       *dividend = atoi(ptr);
+      if (*dividend > 0xFFFFFFFF)
+        return 1;
       ptr += 3 + i;
       *divisor = atoi(ptr);
+      if (*dividend > 0xFFFFFFFF)
+        return 1;
       ptr -= 3 - i;
       if (*divisor == 0) return 1;
       return 0;
diff --git a/decoder_sw/software/test/common/swhw/tb_sw_performance.h b/decoder_sw/software/test/common/swhw/tb_sw_performance.h
index 0cae741..ed36ee7 100755
--- a/decoder_sw/software/test/common/swhw/tb_sw_performance.h
+++ b/decoder_sw/software/test/common/swhw/tb_sw_performance.h
@@ -37,6 +37,7 @@
 #ifndef TB_SW_PERFORMANCE_H
 #define TB_SW_PERFORMANCE_H
 
+#include "stdio.h"
 #include "basetype.h"
 #include "time.h"
 
diff --git a/decoder_sw/software/test/common/swhw/tb_tiled.c b/decoder_sw/software/test/common/swhw/tb_tiled.c
index 860a0fe..b6fb792 100755
--- a/decoder_sw/software/test/common/swhw/tb_tiled.c
+++ b/decoder_sw/software/test/common/swhw/tb_tiled.c
@@ -63,6 +63,7 @@ void TbWriteTiledOutput(FILE *file, u8 *data, u32 mb_width, u32 mb_height,
   tiled_yuv = (u8 *)malloc((width * height * 3) / 2);
 
   if (file == NULL) {
+    free(tiled_yuv);
     return;
   }
 
diff --git a/decoder_sw/software/test/common/swhw/trace.c b/decoder_sw/software/test/common/swhw/trace.c
index e855b5f..3e5cc28 100755
--- a/decoder_sw/software/test/common/swhw/trace.c
+++ b/decoder_sw/software/test/common/swhw/trace.c
@@ -58,7 +58,7 @@ u32 OpenAsicTraceFiles(void) {
 
   char trace_string[80];
   FILE *trace_cfg;
-  u32 i;
+  u32 i, j;
   u32 top = 0, all = 0;
 
   /* traces already opened */
@@ -69,7 +69,7 @@ u32 OpenAsicTraceFiles(void) {
     return (0);
   }
 
-  while (fscanf(trace_cfg, "%s
", trace_string) != EOF) {
+  while (fscanf(trace_cfg, "%79s
", trace_string) != EOF) {
     if (!strcmp(trace_string, "toplevel")) top = 1;
 
     if (!strcmp(trace_string, "all")) all = 1;
@@ -131,10 +131,20 @@ u32 OpenAsicTraceFiles(void) {
     if (all || (top && trace_files[i].top_level)) {
       trace_files[i].fid =
         fopen(trace_files[i].name, trace_files[i].bin ? "wb" : "w");
-      if (trace_files[i].fid == NULL) return 1;
+      if (trace_files[i].fid == NULL) {
+        for (j = 0; j < i; j++) {
+          if (strlen(trace_files[j].name) == 0) break;
+          if (trace_files[j].fid) {
+            fclose(trace_files[j].fid);
+            trace_files[j].fid = NULL;
+          }
+        }
+        fclose(trace_cfg);
+        return 0;
+      }
     }
   }
-
+  fclose(trace_cfg);
   return (1);
 }
 
diff --git a/decoder_sw/software/test/common/swhw/trace_g1.c b/decoder_sw/software/test/common/swhw/trace_g1.c
index b71761e..473eaa2 100755
--- a/decoder_sw/software/test/common/swhw/trace_g1.c
+++ b/decoder_sw/software/test/common/swhw/trace_g1.c
@@ -126,10 +126,12 @@ extern FILE *trace_out2nd_ch;
 extern FILE *trace_pp_ablend1;
 extern FILE *trace_pp_ablend2;
 extern FILE *trace_pp_in;
+#if 0
 extern FILE *trace_pp_in_tiled4x4;
 extern FILE *trace_ctrl_pp_in_tiled4x4;
 extern FILE *trace_dscale_pp_out;
 extern FILE *trace_ctrl_dscale_pp_out;
+#endif
 extern FILE *trace_pp_in_tiled;
 extern FILE *trace_pp_in_bot;
 extern FILE *trace_pp_out;
@@ -198,10 +200,10 @@ u32 openTraceFiles(void) {
 
   trace_cfg = fopen("trace.cfg", "r");
   if(!trace_cfg) {
-    return (1);
+    return (0);
   }
 
-  while(fscanf(trace_cfg, "%s
", trace_string) != EOF) {
+  while(fscanf(trace_cfg, "%79s
", trace_string) != EOF) {
     if(!strcmp(trace_string, "toplevel") && !trace_sequence_ctrl) {
       for (i = 0 ; i < 9 ; ++i) {
         sprintf(tmp_string, "stream_%d.trc", i+1 );
@@ -209,59 +211,59 @@ u32 openTraceFiles(void) {
         sprintf(tmp_string, "stream_control_%d.trc", i+1 );
         trace_bc_stream_ctrl[i] = fopen(tmp_string, "w");
       }
-      trace_prob_tables = fopen("boolcoder_prob.trc", "w");
-      trace_sequence_ctrl = fopen("sequence_ctrl.trc", "w");
-      trace_picture_ctrl_dec = fopen("picture_ctrl_dec.trc", "w");
-      trace_picture_ctrl_dec_tiled = fopen("picture_ctrl_dec_tiled.trc", "w");
-      trace_jpeg_tables = fopen("jpeg_tables.trc", "w");
-      trace_stream = fopen("stream.trc", "w");
-      trace_stream_ctrl = fopen("stream_control.trc", "w");
-      trace_out = fopen("decoder_out.trc", "w");
-      trace_out_tiled = fopen("decoder_out_tiled.trc", "w");
-      trace_separ_dc = fopen("dc_separate_coeffs.trc", "w");
-      trace_separ_dc_hex = fopen("dc_separate_coeffs.hex", "w");
-      trace_bit_plane_ctrl = fopen("vc1_bitplane_ctrl.trc", "w");
-      trace_dir_mode_mvs = fopen("direct_mode_mvs.trc", "w");
-      trace_dir_mode_mvs_hex = fopen("direct_mode_mvs.hex", "w");
-      trace_qtables = fopen("qtables.trc", "w");
-      trace_sw_reg_access = fopen("swreg_accesses.trc", "w");
-      trace_sw_reg_access_tiled = fopen("swreg_accesses_tiled.trc", "w");
-      trace_busload = fopen("busload.trc", "w");
-
-      trace_cabac_table[0] = fopen("cabac_table_intra.trc", "w");
-      trace_cabac_table[1] = fopen("cabac_table_inter0.trc", "w");
-      trace_cabac_table[2] = fopen("cabac_table_inter1.trc", "w");
-      trace_cabac_table[3] = fopen("cabac_table_inter2.trc", "w");
-      trace_segmentation = fopen("segmentation.trc", "w");
+      if (!trace_prob_tables) trace_prob_tables = fopen("boolcoder_prob.trc", "w");
+      if (!trace_sequence_ctrl) trace_sequence_ctrl = fopen("sequence_ctrl.trc", "w");
+      if (!trace_picture_ctrl_dec) trace_picture_ctrl_dec = fopen("picture_ctrl_dec.trc", "w");
+      if (!trace_picture_ctrl_dec_tiled) trace_picture_ctrl_dec_tiled = fopen("picture_ctrl_dec_tiled.trc", "w");
+      if (!trace_jpeg_tables) trace_jpeg_tables = fopen("jpeg_tables.trc", "w");
+      if (!trace_stream) trace_stream = fopen("stream.trc", "w");
+      if (!trace_stream_ctrl) trace_stream_ctrl = fopen("stream_control.trc", "w");
+      if (!trace_out) trace_out = fopen("decoder_out.trc", "w");
+      if (!trace_out_tiled) trace_out_tiled = fopen("decoder_out_tiled.trc", "w");
+      if (!trace_separ_dc) trace_separ_dc = fopen("dc_separate_coeffs.trc", "w");
+      if (!trace_separ_dc_hex) trace_separ_dc_hex = fopen("dc_separate_coeffs.hex", "w");
+      if (!trace_bit_plane_ctrl) trace_bit_plane_ctrl = fopen("vc1_bitplane_ctrl.trc", "w");
+      if (!trace_dir_mode_mvs) trace_dir_mode_mvs = fopen("direct_mode_mvs.trc", "w");
+      if (!trace_dir_mode_mvs_hex) trace_dir_mode_mvs_hex = fopen("direct_mode_mvs.hex", "w");
+      if (!trace_qtables) trace_qtables = fopen("qtables.trc", "w");
+      if (!trace_sw_reg_access) trace_sw_reg_access = fopen("swreg_accesses.trc", "w");
+      if (!trace_sw_reg_access_tiled) trace_sw_reg_access_tiled = fopen("swreg_accesses_tiled.trc", "w");
+      if (!trace_busload) trace_busload = fopen("busload.trc", "w");
+
+      if (!trace_cabac_table[0]) trace_cabac_table[0] = fopen("cabac_table_intra.trc", "w");
+      if (!trace_cabac_table[1]) trace_cabac_table[1] = fopen("cabac_table_inter0.trc", "w");
+      if (!trace_cabac_table[2]) trace_cabac_table[2] = fopen("cabac_table_inter1.trc", "w");
+      if (!trace_cabac_table[3]) trace_cabac_table[3] = fopen("cabac_table_inter2.trc", "w");
+      if (!trace_segmentation) trace_segmentation = fopen("segmentation.trc", "w");
 
       /*required if sw is performing entropy decoding */
-      trace_mb_ctrl = fopen("mbcontrol.trc", "w");
-      trace_mb_ctrl_hex = fopen("mbcontrol.hex", "w");
-      trace_motion_vectors = fopen("motion_vectors.trc", "w");
-      trace_motion_vectors_hex = fopen("motion_vectors.hex", "w");
-      trace_intra4x4_modes = fopen("intra4x4_modes.trc", "w");
-      trace_intra4x4_modes_hex = fopen("intra4x4_modes.hex", "w");
-      trace_rlc = fopen("rlc.trc", "w");
-      trace_rlc_unpacked = fopen("rlc_unpacked.trc", "w");
-      trace_vp78_mv_weight = fopen("vp78_context_weight.trc", "w" );
+      if (!trace_mb_ctrl) trace_mb_ctrl = fopen("mbcontrol.trc", "w");
+      if (!trace_mb_ctrl_hex) trace_mb_ctrl_hex = fopen("mbcontrol.hex", "w");
+      if (!trace_motion_vectors) trace_motion_vectors = fopen("motion_vectors.trc", "w");
+      if (!trace_motion_vectors_hex) trace_motion_vectors_hex = fopen("motion_vectors.hex", "w");
+      if (!trace_intra4x4_modes) trace_intra4x4_modes = fopen("intra4x4_modes.trc", "w");
+      if (!trace_intra4x4_modes_hex) trace_intra4x4_modes_hex = fopen("intra4x4_modes.hex", "w");
+      if (!trace_rlc) trace_rlc = fopen("rlc.trc", "w");
+      if (!trace_rlc_unpacked) trace_rlc_unpacked = fopen("rlc_unpacked.trc", "w");
+      if (!trace_vp78_mv_weight) trace_vp78_mv_weight = fopen("vp78_context_weight.trc", "w" );
 
-      trace_ref_bufferd_pic_ctrl = fopen("refbufferd_picctrl.trc", "w");
-      trace_ref_bufferd_ctrl = fopen("refbufferd_ctrl.trc", "w");
+      if (!trace_ref_bufferd_pic_ctrl) trace_ref_bufferd_pic_ctrl = fopen("refbufferd_picctrl.trc", "w");
+      if (!trace_ref_bufferd_ctrl) trace_ref_bufferd_ctrl = fopen("refbufferd_ctrl.trc", "w");
 
-      trace_pjpeg_coeffs = fopen("prog_jpeg_coefficients.trc", "w");
-      trace_pjpeg_coeffs_hex = fopen("prog_jpeg_coefficients.hex", "w");
+      if (!trace_pjpeg_coeffs) trace_pjpeg_coeffs = fopen("prog_jpeg_coefficients.trc", "w");
+      if (!trace_pjpeg_coeffs_hex) trace_pjpeg_coeffs_hex = fopen("prog_jpeg_coefficients.hex", "w");
 
-      trace_pic_ord_cnts = fopen("picord_counts.trc", "w");
-      trace_scaling_lists = fopen("scaling_lists.trc", "w");
+      if (!trace_pic_ord_cnts) trace_pic_ord_cnts = fopen("picord_counts.trc", "w");
+      if (!trace_scaling_lists) trace_scaling_lists = fopen("scaling_lists.trc", "w");
 
-      trace_slice_sizes = fopen("slice_sizes.trc", "w");;
+      if (!trace_slice_sizes) trace_slice_sizes = fopen("slice_sizes.trc", "w");;
 
-      trace_rv_mvd_bits = fopen("mvd_flags.trc", "w");;
-      trace_huffman = fopen("huffman.trc", "w");
-      trace_prob1 = fopen("boolcoder_1.trc", "w");
-      trace_prob2 = fopen("boolcoder_2.trc", "w");
+      if (!trace_rv_mvd_bits) trace_rv_mvd_bits = fopen("mvd_flags.trc", "w");;
+      if (!trace_huffman) trace_huffman = fopen("huffman.trc", "w");
+      if (!trace_prob1) trace_prob1 = fopen("boolcoder_1.trc", "w");
+      if (!trace_prob2) trace_prob2 = fopen("boolcoder_2.trc", "w");
 
-      trace_out2nd_ch = fopen("decoder_out_ch_8pix.trc", "w");
+      if (!trace_out2nd_ch) trace_out2nd_ch = fopen("decoder_out_ch_8pix.trc", "w");
 
       if((trace_sequence_ctrl == NULL) || (trace_picture_ctrl_dec == NULL) ||
           (trace_jpeg_tables == NULL) || (trace_stream == NULL) ||
@@ -279,6 +281,8 @@ u32 openTraceFiles(void) {
           (trace_out2nd_ch == NULL))
 
       {
+        closeTraceFiles();
+        if (trace_cfg) fclose(trace_cfg);
         return (0);
       }
     }
@@ -288,63 +292,63 @@ u32 openTraceFiles(void) {
         sprintf(tmp_string, "boolcoder_%d_ctx.trc", i+1 );
         trace_boolcoder[i] = fopen(tmp_string, "w");
       }
-      trace_acdcd_out = fopen("acdcd_out.trc", "w");
-      trace_acdcd_out_data = fopen("acdcd_outdata.trc", "w");
-      trace_bs = fopen("bs.trc", "w");
-      trace_dct_out_data = fopen("dct_outdata.trc", "w");
-      trace_decoded_mvs = fopen("decoded_mvs.trc", "w");
-      trace_final_mvs = fopen("final_mvs.trc", "w");
-      trace_inter_ref_y = fopen("inter_reference_y.trc", "w");
-      trace_inter_ref_y1 = fopen("inter_reference1_y.trc", "w");
-      trace_inter_ref_cb = fopen("inter_reference_cb.trc", "w");
-      trace_inter_ref_cb1 = fopen("inter_reference1_cb.trc", "w");
-      trace_inter_ref_cr = fopen("inter_reference_cr.trc", "w");
-      trace_inter_ref_cr1 = fopen("inter_reference1_cr.trc", "w");
-      trace_overfill = fopen("inter_overfill.trc", "w");
-      trace_overfill1 = fopen("inter_overfill1.trc", "w");
-      trace_inter_out_data = fopen("inter_outdata.trc", "w");
-      trace_intra_pred = fopen("intra_predicted.trc", "w");
-      trace_recon = fopen("reconstructed.trc", "w");
-      trace_scd_out_data = fopen("scd_outdata.trc", "w");
-      trace_transd_first_round = fopen("transd_1rnd.trc", "w");
-      trace_h264_pic_id_map = fopen("h264_picid_map.trc", "w");
-      trace_residual = fopen("residual.trc", "w");
-      trace_iq = fopen("inverse_quant.trc", "w");
-      trace_overlap_smooth = fopen("overlap_smoothed.trc", "w");
-      trace_vc1_filtering_ctrl = fopen("vc1_filtering_ctrl.trc", "w");
-      trace_stream_txt = fopen("stream.txt", "w");
-      trace_neighbour_mv = fopen("neighbour_mvs.trc", "w");
-      trace_ic_sets = fopen("intensity_sets.trc", "w");
-      trace_above_mb_mem = fopen("above_mb_ctrl_sram.trc", "w");
-      trace_ref_pic_list = fopen("ref_pic_list.trc", "w");
-      trace_implicit_weights = fopen("implicit_weights.trc", "w");
-      trace_intra_filtered_pels = fopen("intra_filtered_pxls.trc", "w");
-      trace_motion_vectors_fixed = fopen("motion_vectors_fixed.trc", "w");
-      trace_decoded_mvs_fixed = fopen("decoded_mvs_fixed.trc", "w");
-      trace_dir_mv_fetch = fopen("h264_dirmv_fetch.trc", "w");
-      trace_scaling_out = fopen("h264_scaling_out.trc", "w");
-      trace_custom_idct = fopen("custom_idct.trc", "w");
-      trace_inter_out_y = fopen("inter_interpolated_y.trc", "w");
-      trace_inter_out_y1 = fopen("inter_interpolated1_y.trc", "w");
-      trace_inter_out_cb = fopen("inter_interpolated_cb.trc", "w");
-      trace_inter_out_cb1 = fopen("inter_interpolated1_cb.trc", "w");
-      trace_inter_out_cr = fopen("inter_interpolated_cr.trc", "w");
-      trace_inter_out_cr1 = fopen("inter_interpolated1_cr.trc", "w");
-      trace_filter_internal = fopen("rv_filter.trc", "w");
-      trace_variance = fopen("inter_variance.trc", "w");
-      trace_huffman_ctx = fopen("huffman_ctx.trc", "w");
-      trace_zig_zag = fopen("zigzag.trc", "w");
-      trace_nearest = fopen("nearest.trc", "w" );
-      trace_inter_filtered_y = fopen("inter_vp6_filtered_ref_y.trc","w");
-      trace_inter_filtered_cb = fopen("inter_vp6_filtered_ref_cb.trc","w");
-      trace_inter_filtered_cr = fopen("inter_vp6_filtered_ref_cr.trc","w");
-
-      trace_cabac_bin = fopen("cabac_bin.trc", "w");
-      trace_ref_bufferd_pic_y = fopen("refbufferd_buffil_y.trc", "w");
-      trace_adv_pre_fetch = fopen("advanced_prefetch.trc", "w" );
-      trace_ref_bufferd_pic_cb_cr = fopen("refbufferd_buffil_c.trc", "w");
-
-      trace_vp78_above_cbf = fopen("vp78_above_cbf.trc", "w");
+      if (!trace_acdcd_out) trace_acdcd_out = fopen("acdcd_out.trc", "w");
+      if (!trace_acdcd_out_data) trace_acdcd_out_data = fopen("acdcd_outdata.trc", "w");
+      if (!trace_bs) trace_bs = fopen("bs.trc", "w");
+      if (!trace_dct_out_data) trace_dct_out_data = fopen("dct_outdata.trc", "w");
+      if (!trace_decoded_mvs) trace_decoded_mvs = fopen("decoded_mvs.trc", "w");
+      if (!trace_final_mvs) trace_final_mvs = fopen("final_mvs.trc", "w");
+      if (!trace_inter_ref_y) trace_inter_ref_y = fopen("inter_reference_y.trc", "w");
+      if (!trace_inter_ref_y1) trace_inter_ref_y1 = fopen("inter_reference1_y.trc", "w");
+      if (!trace_inter_ref_cb) trace_inter_ref_cb = fopen("inter_reference_cb.trc", "w");
+      if (!trace_inter_ref_cb1) trace_inter_ref_cb1 = fopen("inter_reference1_cb.trc", "w");
+      if (!trace_inter_ref_cr) trace_inter_ref_cr = fopen("inter_reference_cr.trc", "w");
+      if (!trace_inter_ref_cr1) trace_inter_ref_cr1 = fopen("inter_reference1_cr.trc", "w");
+      if (!trace_overfill) trace_overfill = fopen("inter_overfill.trc", "w");
+      if (!trace_overfill1) trace_overfill1 = fopen("inter_overfill1.trc", "w");
+      if (!trace_inter_out_data) trace_inter_out_data = fopen("inter_outdata.trc", "w");
+      if (!trace_intra_pred) trace_intra_pred = fopen("intra_predicted.trc", "w");
+      if (!trace_recon) trace_recon = fopen("reconstructed.trc", "w");
+      if (!trace_scd_out_data) trace_scd_out_data = fopen("scd_outdata.trc", "w");
+      if (!trace_transd_first_round) trace_transd_first_round = fopen("transd_1rnd.trc", "w");
+      if (!trace_h264_pic_id_map) trace_h264_pic_id_map = fopen("h264_picid_map.trc", "w");
+      if (!trace_residual) trace_residual = fopen("residual.trc", "w");
+      if (!trace_iq) trace_iq = fopen("inverse_quant.trc", "w");
+      if (!trace_overlap_smooth) trace_overlap_smooth = fopen("overlap_smoothed.trc", "w");
+      if (!trace_vc1_filtering_ctrl) trace_vc1_filtering_ctrl = fopen("vc1_filtering_ctrl.trc", "w");
+      if (!trace_stream_txt) trace_stream_txt = fopen("stream.txt", "w");
+      if (!trace_neighbour_mv) trace_neighbour_mv = fopen("neighbour_mvs.trc", "w");
+      if (!trace_ic_sets) trace_ic_sets = fopen("intensity_sets.trc", "w");
+      if (!trace_above_mb_mem) trace_above_mb_mem = fopen("above_mb_ctrl_sram.trc", "w");
+      if (!trace_ref_pic_list) trace_ref_pic_list = fopen("ref_pic_list.trc", "w");
+      if (!trace_implicit_weights) trace_implicit_weights = fopen("implicit_weights.trc", "w");
+      if (!trace_intra_filtered_pels) trace_intra_filtered_pels = fopen("intra_filtered_pxls.trc", "w");
+      if (!trace_motion_vectors_fixed) trace_motion_vectors_fixed = fopen("motion_vectors_fixed.trc", "w");
+      if (!trace_decoded_mvs_fixed) trace_decoded_mvs_fixed = fopen("decoded_mvs_fixed.trc", "w");
+      if (!trace_dir_mv_fetch) trace_dir_mv_fetch = fopen("h264_dirmv_fetch.trc", "w");
+      if (!trace_scaling_out) trace_scaling_out = fopen("h264_scaling_out.trc", "w");
+      if (!trace_custom_idct) trace_custom_idct = fopen("custom_idct.trc", "w");
+      if (!trace_inter_out_y) trace_inter_out_y = fopen("inter_interpolated_y.trc", "w");
+      if (!trace_inter_out_y1) trace_inter_out_y1 = fopen("inter_interpolated1_y.trc", "w");
+      if (!trace_inter_out_cb) trace_inter_out_cb = fopen("inter_interpolated_cb.trc", "w");
+      if (!trace_inter_out_cb1) trace_inter_out_cb1 = fopen("inter_interpolated1_cb.trc", "w");
+      if (!trace_inter_out_cr) trace_inter_out_cr = fopen("inter_interpolated_cr.trc", "w");
+      if (!trace_inter_out_cr1) trace_inter_out_cr1 = fopen("inter_interpolated1_cr.trc", "w");
+      if (!trace_filter_internal) trace_filter_internal = fopen("rv_filter.trc", "w");
+      if (!trace_variance) trace_variance = fopen("inter_variance.trc", "w");
+      if (!trace_huffman_ctx) trace_huffman_ctx = fopen("huffman_ctx.trc", "w");
+      if (!trace_zig_zag) trace_zig_zag = fopen("zigzag.trc", "w");
+      if (!trace_nearest) trace_nearest = fopen("nearest.trc", "w" );
+      if (!trace_inter_filtered_y) trace_inter_filtered_y = fopen("inter_vp6_filtered_ref_y.trc","w");
+      if (!trace_inter_filtered_cb) trace_inter_filtered_cb = fopen("inter_vp6_filtered_ref_cb.trc","w");
+      if (!trace_inter_filtered_cr) trace_inter_filtered_cr = fopen("inter_vp6_filtered_ref_cr.trc","w");
+
+      if (!trace_cabac_bin) trace_cabac_bin = fopen("cabac_bin.trc", "w");
+      if (!trace_ref_bufferd_pic_y) trace_ref_bufferd_pic_y = fopen("refbufferd_buffil_y.trc", "w");
+      if (!trace_adv_pre_fetch) trace_adv_pre_fetch = fopen("advanced_prefetch.trc", "w" );
+      if (!trace_ref_bufferd_pic_cb_cr) trace_ref_bufferd_pic_cb_cr = fopen("refbufferd_buffil_c.trc", "w");
+
+      if (!trace_vp78_above_cbf) trace_vp78_above_cbf = fopen("vp78_above_cbf.trc", "w");
 
       if((trace_acdcd_out == NULL) || (trace_acdcd_out_data == NULL) ||
           (trace_bs == NULL) || (trace_dct_out_data == NULL) ||
@@ -371,19 +375,24 @@ u32 openTraceFiles(void) {
           (trace_inter_out_cr == NULL) || (trace_inter_out_cr1 == NULL) ||
           (trace_ref_bufferd_pic_y == NULL) || (trace_ref_bufferd_pic_cb_cr == NULL) ||
           (trace_filter_internal == NULL)) {
-        return (1);
+        closeTraceFiles();
+        if (trace_cfg) fclose(trace_cfg);
+        return (0);
       }
     }
     if(!strcmp(trace_string, "fpga") && !trace_picture_ctrl_dec) {
-      trace_picture_ctrl_dec = fopen("picture_ctrl_dec.trc", "w");
-      trace_picture_ctrl_pp = fopen("picture_ctrl_pp.trc", "w");
-      trace_picture_ctrl_dec_tiled = fopen("picture_ctrl_dec_tiled.trc", "w");
-      trace_picture_ctrl_pp_tiled = fopen("picture_ctrl_pp_tiled.trc", "w");
-      trace_busload = fopen("busload.trc", "w");
+      if (!trace_picture_ctrl_dec) trace_picture_ctrl_dec = fopen("picture_ctrl_dec.trc", "w");
+      if (!trace_picture_ctrl_pp) trace_picture_ctrl_pp = fopen("picture_ctrl_pp.trc", "w");
+      if (!trace_picture_ctrl_dec_tiled) trace_picture_ctrl_dec_tiled = fopen("picture_ctrl_dec_tiled.trc", "w");
+      if (!trace_picture_ctrl_pp_tiled) trace_picture_ctrl_pp_tiled = fopen("picture_ctrl_pp_tiled.trc", "w");
+      if (!trace_busload) trace_busload = fopen("busload.trc", "w");
 
 
-      if(trace_picture_ctrl_dec == NULL)
-        return (1);
+      if(trace_picture_ctrl_dec == NULL) {
+        closeTraceFiles();
+        if (trace_cfg) fclose(trace_cfg);
+        return (0);
+      }
     }
     if(!strcmp(trace_string, "decoding_tools")) {
       /* MPEG2 decoding tools trace */
@@ -428,52 +437,60 @@ u32 openTraceFiles(void) {
       memset(&trace_rv_dec_tools, 0,
              sizeof(struct TraceRvDecTools));
 
-      trace_decoding_tools = fopen("decoding_tools.trc", "w");
+      if (!trace_decoding_tools) trace_decoding_tools = fopen("decoding_tools.trc", "w");
 
-      if(trace_decoding_tools == NULL)
-        return (1);
+      if(trace_decoding_tools == NULL) {
+        closeTraceFiles();
+        if (trace_cfg) fclose(trace_cfg);
+        return (0);
+      }
     }
     if(!strcmp(trace_string, "pp_toplevel")) {
-      trace_sequence_ctrl_pp = fopen("sequence_ctrl_pp.trc", "w");
-      trace_picture_ctrl_pp = fopen("picture_ctrl_pp.trc", "w");
-      trace_picture_ctrl_pp_tiled = fopen("picture_ctrl_pp_tiled.trc", "w");
-      trace_pp_in = fopen("pp_in.trc", "w");
-      trace_pp_in_tiled = fopen("pp_in_tiled.trc", "w");
-      trace_pp_in_bot = fopen("pp_in_bot.trc", "w");
-      trace_pp_out = fopen("pp_out.trc", "w");
-      trace_pp_background = fopen("pp_background.trc", "w");
-      trace_pp_ablend1 = fopen("pp_ablend1.trc", "w");
-      trace_pp_ablend2 = fopen("pp_ablend2.trc", "w");
+      if (!trace_sequence_ctrl_pp) trace_sequence_ctrl_pp = fopen("sequence_ctrl_pp.trc", "w");
+      if (!trace_picture_ctrl_pp) trace_picture_ctrl_pp = fopen("picture_ctrl_pp.trc", "w");
+      if (!trace_picture_ctrl_pp_tiled) trace_picture_ctrl_pp_tiled = fopen("picture_ctrl_pp_tiled.trc", "w");
+      if (!trace_pp_in) trace_pp_in = fopen("pp_in.trc", "w");
+      if (!trace_pp_in_tiled) trace_pp_in_tiled = fopen("pp_in_tiled.trc", "w");
+      if (!trace_pp_in_bot) trace_pp_in_bot = fopen("pp_in_bot.trc", "w");
+      if (!trace_pp_out) trace_pp_out = fopen("pp_out.trc", "w");
+      if (!trace_pp_background) trace_pp_background = fopen("pp_background.trc", "w");
+      if (!trace_pp_ablend1) trace_pp_ablend1 = fopen("pp_ablend1.trc", "w");
+      if (!trace_pp_ablend2) trace_pp_ablend2 = fopen("pp_ablend2.trc", "w");
+#if 0
       trace_pp_in_tiled4x4 = fopen("ppin_tiled4x4.bin", "wb");
       trace_ctrl_pp_in_tiled4x4 = fopen("ppin_ctrl_tiled4x4.bin", "wb");
       trace_dscale_pp_out = fopen("ppout_downscale.bin", "wb");
       trace_ctrl_dscale_pp_out = fopen("ppout_ctrl_downscale.bin", "wb");
+#endif
       if(trace_sequence_ctrl_pp == NULL ||
           trace_picture_ctrl_pp == NULL ||
           trace_pp_in == NULL ||
           trace_pp_in_bot == NULL ||
           trace_pp_out == NULL ||
           trace_pp_background == NULL ||
-          trace_pp_ablend1 == NULL || trace_pp_ablend2 == NULL ||
+          trace_pp_ablend1 == NULL || trace_pp_ablend2 == NULL /*||
           trace_pp_in_tiled4x4 == NULL || trace_ctrl_pp_in_tiled4x4 == NULL ||
-          trace_dscale_pp_out == NULL || trace_ctrl_dscale_pp_out == NULL)
-        return (1);
+          trace_dscale_pp_out == NULL || trace_ctrl_dscale_pp_out == NULL*/) {
+        closeTraceFiles();
+        if (trace_cfg) fclose(trace_cfg);
+        return (0);
+      }
     }
     if(!strcmp(trace_string, "pp_all")) {
-      trace_pp_deint_in = fopen("pp_deint_in.trc", "w");
-      trace_pp_deint_out_y = fopen("pp_deint_out_y.trc", "w");
-      trace_pp_deint_out_cb = fopen("pp_deint_out_cb.trc", "w");
-      trace_pp_deint_out_cr = fopen("pp_deint_out_cr.trc", "w");
-      trace_pp_crop = fopen("pp_crop.trc", "w");;
-      trace_pp_rotation = fopen("pp_rotation.trc", "w");;
-      trace_pp_scaling_kernel = fopen("pp_scaling_kernel.trc", "w");;
-      trace_pp_scaling_r = fopen("pp_scaling_r.trc", "w");;
-      trace_pp_scaling_g = fopen("pp_scaling_g.trc", "w");;
-      trace_pp_scaling_b = fopen("pp_scaling_b.trc", "w");;
-      trace_pp_color_conv_r = fopen("pp_colorconv_r.trc", "w");;
-      trace_pp_color_conv_g = fopen("pp_colorconv_g.trc", "w");;
-      trace_pp_color_conv_b = fopen("pp_colorconv_b.trc", "w");;
-      trace_pp_weights = fopen("pp_weights.trc", "w");;
+      if (!trace_pp_deint_in) trace_pp_deint_in = fopen("pp_deint_in.trc", "w");
+      if (!trace_pp_deint_out_y) trace_pp_deint_out_y = fopen("pp_deint_out_y.trc", "w");
+      if (!trace_pp_deint_out_cb) trace_pp_deint_out_cb = fopen("pp_deint_out_cb.trc", "w");
+      if (!trace_pp_deint_out_cr) trace_pp_deint_out_cr = fopen("pp_deint_out_cr.trc", "w");
+      if (!trace_pp_crop) trace_pp_crop = fopen("pp_crop.trc", "w");;
+      if (!trace_pp_rotation) trace_pp_rotation = fopen("pp_rotation.trc", "w");;
+      if (!trace_pp_scaling_kernel) trace_pp_scaling_kernel = fopen("pp_scaling_kernel.trc", "w");;
+      if (!trace_pp_scaling_r) trace_pp_scaling_r = fopen("pp_scaling_r.trc", "w");;
+      if (!trace_pp_scaling_g) trace_pp_scaling_g = fopen("pp_scaling_g.trc", "w");;
+      if (!trace_pp_scaling_b) trace_pp_scaling_b = fopen("pp_scaling_b.trc", "w");;
+      if (!trace_pp_color_conv_r) trace_pp_color_conv_r = fopen("pp_colorconv_r.trc", "w");;
+      if (!trace_pp_color_conv_g) trace_pp_color_conv_g = fopen("pp_colorconv_g.trc", "w");;
+      if (!trace_pp_color_conv_b) trace_pp_color_conv_b = fopen("pp_colorconv_b.trc", "w");;
+      if (!trace_pp_weights) trace_pp_weights = fopen("pp_weights.trc", "w");;
       if(trace_pp_deint_in == NULL ||
           trace_pp_deint_out_y == NULL ||
           trace_pp_deint_out_cb == NULL ||
@@ -486,10 +503,14 @@ u32 openTraceFiles(void) {
           trace_pp_scaling_b == NULL ||
           trace_pp_color_conv_r == NULL ||
           trace_pp_color_conv_g == NULL ||
-          trace_pp_color_conv_b == NULL || trace_pp_weights == NULL)
-        return (1);
+          trace_pp_color_conv_b == NULL || trace_pp_weights == NULL) {
+        closeTraceFiles();
+        if (trace_cfg) fclose(trace_cfg);
+        return (0);
+      }
     }
   }
+  if (trace_cfg) fclose(trace_cfg);
   return (1);
 }
 
diff --git a/decoder_sw/software/test/common/utils/async_task.c b/decoder_sw/software/test/common/utils/async_task.c
index 119ebb6..f5f17ea 100755
--- a/decoder_sw/software/test/common/utils/async_task.c
+++ b/decoder_sw/software/test/common/utils/async_task.c
@@ -43,6 +43,8 @@
 async_task run_task(task_func func, void* param) {
   int ret;
   pthread_t* thread_handle = malloc(sizeof(pthread_t));
+  if (thread_handle == NULL)
+    return NULL;
   ret = pthread_create(thread_handle, NULL, func, param);
   assert(ret == 0);
 
diff --git a/decoder_sw/software/test/common/yuvfilters.c b/decoder_sw/software/test/common/yuvfilters.c
index 6a3a14c..5b154be 100755
--- a/decoder_sw/software/test/common/yuvfilters.c
+++ b/decoder_sw/software/test/common/yuvfilters.c
@@ -141,7 +141,14 @@ void YuvfilterTiled2Planar(struct DecPicture* pic) {
   u32 num_pixels = pic->sequence_info.pic_width * pic->sequence_info.pic_height;
   u16* cbcr_src = (u16*)pic->chroma.virtual_address;
   u16* luma_dst = malloc(num_pixels * sizeof(u16));
+  if (luma_dst == NULL)
+    return;
   u16* cbcr_dst = malloc(num_pixels / 2 * sizeof(u16));
+  if (cbcr_dst == NULL) {
+    free(luma_dst);
+    return;
+  }
+
   /* luma */
   Tiled4x4picToRaster(luma_dst, luma_src, pic->sequence_info.pic_width,
                       pic->sequence_info.pic_height);
@@ -186,6 +193,8 @@ void YuvfilterTiledcrop(struct DecPicture* pic) {
    * 1. tile-to-semiplanar conversion. */
   u16* luma_src = (u16*)pic->luma.virtual_address;
   u16* luma_tmp = malloc(num_pixels * sizeof(u16));
+  if (luma_tmp == NULL)
+    return;
   u16* cbcr_src;
   u16* cbcr_tmp = 0;
   for (int y = 0; y < pic->sequence_info.pic_height / tile_h; y++) {
@@ -199,6 +208,10 @@ void YuvfilterTiledcrop(struct DecPicture* pic) {
   if (!pic->sequence_info.is_mono_chrome) {
     cbcr_src = (u16*)pic->chroma.virtual_address;
     cbcr_tmp = malloc(num_pixels / 2 * sizeof(u16));
+    if (cbcr_tmp == NULL) {
+      free(luma_tmp);
+      return;
+    }
     for (int y = 0; y < pic->sequence_info.pic_height / (tile_h * 2); y++) {
       for (int x = 0; x < pic->sequence_info.pic_width / tile_w; x++) {
         Tile4x4ToRaster(
@@ -286,7 +299,9 @@ void YuvfilterSemiplanar2Planar(struct DecPicture* pic) {
   if (h & 1) h += 1;
   u32 num_pixels = w * h;
   u16* cbcr_tmp = malloc(num_pixels / 2 * sizeof(u16));
-
+  if (cbcr_tmp == NULL)
+    return;
+  memset(cbcr_tmp, 0, num_pixels / 2 * sizeof(u16));
   /* nothing to do for luma */
 
   /* chroma */
diff --git a/decoder_sw/software/test/h264high/Makefile b/decoder_sw/software/test/h264high/Makefile
index 7857153..ec76f94 100755
--- a/decoder_sw/software/test/h264high/Makefile
+++ b/decoder_sw/software/test/h264high/Makefile
@@ -58,7 +58,7 @@ DECLIBDIR = -L../../linux/h264high \
             -L../../linux/dwl \
             -L../common \
             -L../common/swhw \
-            -L../../../lib \
+            -L../../../system/models/g1hw \
             -L../common/utils
 
 # libav stuff
diff --git a/decoder_sw/software/test/h264high/dectestbench.c b/decoder_sw/software/test/h264high/dectestbench.c
index 967c437..ff98ced 100755
--- a/decoder_sw/software/test/h264high/dectestbench.c
+++ b/decoder_sw/software/test/h264high/dectestbench.c
@@ -160,8 +160,8 @@ u32 convert_to_frame_dpb = 0;
 /* variables for indexing */
 u32 save_index = 0;
 u32 use_index = 0;
-off64_t cur_index = 0;
-off64_t next_index = 0;
+addr_t cur_index = 0;
+addr_t next_index = 0;
 /* indicate when we save index */
 u8 save_flag = 0;
 
@@ -444,7 +444,7 @@ static void* h264_output_thread(void* arg) {
       break;
     }
   }
-  return NULL;
+  return  NULL;
 }
 #endif
 
@@ -457,7 +457,7 @@ void SetMissingField2Const( u8 *output_picture,
   i32 i;
   /* TODO: Does not support tiled input */
   /* TODO: Fix reference data before enabling this */
-  return;
+  //return;
 
   if (dpb_mode != DEC_DPB_FRAME) {
     /* luma */
@@ -468,7 +468,7 @@ void SetMissingField2Const( u8 *output_picture,
       field_base += pic_width * pic_height / 2;
     }
 
-    memset(field_base, 128, pic_width * pic_height / 2);
+    memset(field_base, 0, pic_width * pic_height / 2);
 
     if (monochrome)
       return;
@@ -481,7 +481,7 @@ void SetMissingField2Const( u8 *output_picture,
       field_base += pic_width * pic_height / 4;
     }
 
-    memset(field_base, 128, pic_width * pic_height / 4);
+    memset(field_base, 0, pic_width * pic_height / 4);
 
     return;
   }
@@ -495,7 +495,7 @@ void SetMissingField2Const( u8 *output_picture,
   }
 
   for (i = 0; i < pic_height / 2; i++) {
-    memset(field_base, 128, pic_width);
+    memset(field_base, 0, pic_width);
     field_base += 2 * pic_width;
   }
 
@@ -511,7 +511,7 @@ void SetMissingField2Const( u8 *output_picture,
   }
 
   for (i = 0; i < (pic_height / 2 + 1) / 2; i++) {
-    memset(field_base, 128, pic_width);
+    memset(field_base, 0, pic_width);
     field_base += 2 * pic_width;
   }
 }
@@ -621,6 +621,10 @@ int main(int argc, char **argv) {
     /* Check expiry date */
     time(&sys_time);
     tm = localtime(&sys_time);
+    if (tm == NULL) {
+      fprintf(stderr,"Get localtime failed!
");
+      return -1;
+    }
     strftime(tm_buf, sizeof(tm_buf), "%y%m%d", tm);
     tmp1 = 1000000+atoi(tm_buf);
     if (tmp1 > (EXPIRY_DATE) && (EXPIRY_DATE) > 1 ) {
@@ -1230,7 +1234,7 @@ int main(int argc, char **argv) {
 
       /* read index */
       /* off64_t defined differ between LP32 and LP64*/
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
       ra = fscanf(findex, "%lu", &next_index);
 #else
       ra = fscanf(findex, "%llu", &next_index);
@@ -1266,7 +1270,7 @@ int main(int argc, char **argv) {
   else {
     if(use_index) {
       if(!nal_unit_stream)
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
         ra = fscanf(findex, "%lu", &cur_index);
 #else
         ra = fscanf(findex, "%llu", &cur_index);
@@ -1442,7 +1446,7 @@ int main(int argc, char **argv) {
       /* Set a flag to indicate that headers are ready */
       hdrs_rdy = 1;
       printf("sizeof(dpb) = %ld
", sizeof(dpbStorage_t));
-      printf("offset of dpbs = %ld
", (u8 *)((decContainer_t *) dec_inst)->storage.dpbs-(u8 *)&(((decContainer_t *) dec_inst)->storage));
+      printf("offset of dpbs = %ld
", (long)((u8 *)((decContainer_t *) dec_inst)->storage.dpbs-(u8 *)&(((decContainer_t *) dec_inst)->storage)));
       TBSetRefbuMemModel( &tb_cfg,
                           ((decContainer_t *) dec_inst)->h264_regs,
                           &((decContainer_t *) dec_inst)->ref_buffer_ctrl );
@@ -2148,6 +2152,10 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 pic_size,
   if(*fout == NULL) {
     if (view && mvc_separate_views) {
       strcpy(alt_file_name, filename);
+      if (strlen(alt_file_name) >= 256 - 12) {
+        DEBUG_PRINT(("TOO LONG FILE NAME!
"));
+        return;
+      }
       sprintf(alt_file_name+strlen(alt_file_name)-4, "_%d.yuv", view);
       fn = alt_file_name;
     } else
@@ -2240,6 +2248,8 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 pic_size,
   }
 
   if(*fout == NULL || data == NULL) {
+    if(raster_scan)
+      free(raster_scan);
     return;
   }
 
@@ -2662,7 +2672,7 @@ u32 NextPacketFromFile(u8 ** p_strm) {
     u32 f_pos = 0;
 
     if(nal_unit_stream)
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
       ret = fscanf(findex, "%lu", &cur_index);
 #else
       ret = fscanf(findex, "%llu", &cur_index);
@@ -2677,7 +2687,7 @@ u32 NextPacketFromFile(u8 ** p_strm) {
     if(nal_unit_stream) {
       ret = fscanf(findex, "%u", &amount);
     } else {
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
       ret = fscanf(findex, "%lu", &next_index);
 #else
       ret = fscanf(findex, "%llu", &next_index);
@@ -2685,7 +2695,10 @@ u32 NextPacketFromFile(u8 ** p_strm) {
       amount = next_index - cur_index;
       cur_index = next_index;
     }
-
+    if (amount > DEC_X170_MAX_STREAM) {
+      DEBUG_PRINT(("FILE ERROR
"));
+      return 0;
+    }
     ret = fread(*p_strm, 1, amount, finput);
     index = amount;
   }
@@ -2951,7 +2964,7 @@ u32 fillBuffer(const u8 *stream) {
   }
 
   /* read next index */
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
   ret = fscanf(findex, "%lu", &next_index);
 #else
   ret = fscanf(findex, "%llu", &next_index);
@@ -2960,6 +2973,10 @@ u32 fillBuffer(const u8 *stream) {
   cur_index = next_index;
 
   /* read data */
+  if (amount > DEC_X170_MAX_STREAM) {
+    DEBUG_PRINT(("FILE ERROR
"));
+    return 0;
+  }
   data_len = fread((u8 *)stream, 1, amount, finput);
 
   return data_len;
diff --git a/decoder_sw/software/test/jpeg/Makefile b/decoder_sw/software/test/jpeg/Makefile
index 1f2f571..a3002a1 100755
--- a/decoder_sw/software/test/jpeg/Makefile
+++ b/decoder_sw/software/test/jpeg/Makefile
@@ -49,7 +49,7 @@ INCLUDE = -I../../source/inc -I../../source/jpeg -I../../source/dwl \
 	  -I../../source/config -I../../source/common -I../common/swhw
 
 DECLIBDIR = -L../../linux/jpeg -L../../linux/dwl -L../common/swhw \
-	    -L../../../lib -L../common/utils
+	    -L../../../system/models/g1hw -L../common/utils
 DECLIB = libx170j.a
 DWLLIB = libdwlx170.a
 TBLIB = libtbcommon.a
@@ -192,7 +192,7 @@ pclinux_eval: test
 
 export SYSTEM_VERIFICATION_TEST
 
-test:  $(OBJS) 
+test: $(OBJS) 
 	$(CC) $(LDFLAGS) $(CFLAGS) $(OBJS) $(LIBS) -o $(TESTDEC) 
 
 lib:
diff --git a/decoder_sw/software/test/jpeg/dectestbench.c b/decoder_sw/software/test/jpeg/dectestbench.c
index a0e614e..87b689e 100755
--- a/decoder_sw/software/test/jpeg/dectestbench.c
+++ b/decoder_sw/software/test/jpeg/dectestbench.c
@@ -267,6 +267,10 @@ int main(int argc, char *argv[]) {
     /* Check expiry date */
     time(&sys_time);
     tm = localtime(&sys_time);
+    if (tm == NULL) {
+      fprintf(stderr,"Get localtime failed!
");
+      return -1;
+    }
     strftime(tm_buf, sizeof(tm_buf), "%y%m%d", tm);
     tmp1 = 1000000 + atoi(tm_buf);
     if(tmp1 > (EXPIRY_DATE) && (EXPIRY_DATE) > 1) {
@@ -357,7 +361,7 @@ int main(int argc, char *argv[]) {
     if(strncmp(argv[i], "-X", 2) == 0) {
       write_output = 0;
     } else if(strncmp(argv[i], "-S", 2) == 0) {
-      f_stream_trace = fopen((argv[i] + 2), "r");
+      if (!f_stream_trace) f_stream_trace = fopen((argv[i] + 2), "r");
     } else if(strncmp(argv[i], "-P", 2) == 0) {
       planar_output = 1;
     } else if(strncmp(argv[i], "-M", 2) == 0) {
@@ -503,6 +507,11 @@ start_full_decode:
   decsw_performance();
   jpeg_ret = JpegDecInit(&jpeg);
   END_SW_PERFORMANCE;
+  if (jpeg == NULL) {
+    if (f_in)
+      fclose(f_in);
+    return -1;
+  }
   decsw_performance();
   if(jpeg_ret != JPEGDEC_OK) {
     /* Handle here the error situation */
@@ -562,6 +571,8 @@ reallocate_input_buffer:
 
 #ifndef PP_PIPELINE_ENABLED
   /* Reading input file */
+  if (f_in)
+    fclose (f_in);
   f_in = fopen(argv[argc - 1], "rb");
   if(f_in == NULL) {
     fprintf(stdout, "Unable to open input file
");
@@ -569,6 +580,8 @@ reallocate_input_buffer:
   }
 #else
   /* Reading input file */
+  if (f_in)
+    fclose (f_in);
   f_in = fopen(argv[argc - 2], "rb");
   if(f_in == NULL) {
     fprintf(stdout, "Unable to open input file
");
@@ -612,6 +625,7 @@ reallocate_input_buffer:
     ret = fread(byte_strm_start, sizeof(u8), len, f_in);
 
     fclose(f_in);
+    f_in = NULL;
 
     jpeg_ret = FindImageEnd(byte_strm_start, len, &image_info_length);
 
@@ -630,6 +644,8 @@ reallocate_input_buffer:
 
 #ifndef PP_PIPELINE_ENABLED
   /* Reading input file */
+  if (f_in)
+    fclose (f_in);
   f_in = fopen(argv[argc - 1], "rb");
   if(f_in == NULL) {
     fprintf(stdout, "Unable to open input file
");
@@ -637,6 +653,8 @@ reallocate_input_buffer:
   }
 #else
   /* Reading input file */
+  if (f_in)
+    fclose (f_in);
   f_in = fopen(argv[argc - 2], "rb");
   if(f_in == NULL) {
     fprintf(stdout, "Unable to open input file
");
@@ -714,6 +732,7 @@ reallocate_input_buffer:
   ret = fread(byte_strm_start, sizeof(u8), len, f_in);
 
   fclose(f_in);
+  f_in = NULL;
 
   /* initialize JpegDecDecode input structure */
   jpeg_in.stream_buffer.virtual_address = (u32 *) byte_strm_start;
@@ -1097,6 +1116,7 @@ decode:
       stream_in_file -= len;
       stream_seek_len += len;
 
+#if 0
       if(stream_in_file < 0) {
         fprintf(stdout, "		==> Unable to load input buffer
");
         fprintf(stdout,
@@ -1104,6 +1124,7 @@ decode:
         jpeg_ret = JPEGDEC_STRM_ERROR;
         goto strm_error;
       }
+#endif
 
       if(stream_in_file < len) {
         len = stream_in_file;
@@ -1136,6 +1157,7 @@ decode:
       /* read input stream from file to buffer and close input file */
       ret = fread(byte_strm_start, sizeof(u8), len, f_in);
       fclose(f_in);
+      f_in = NULL;
 
       /* update */
       jpeg_in.stream_buffer.virtual_address = (u32 *) byte_strm_start;
@@ -1258,7 +1280,10 @@ error:
         calcSize(&image_info, mode);
 
         printf("size_luma %d and size_chroma %d
", size_luma, size_chroma);
-
+        if(jpeg_out.output_picture_y.virtual_address == NULL) {
+          printf("No output buffer!
");
+          goto end;
+        }
         WriteProgressiveOutput(size_luma, size_chroma, mode,
                                (u8*)jpeg_out.output_picture_y.virtual_address,
                                (u8*)jpeg_out.output_picture_cb_cr.
@@ -1268,6 +1293,10 @@ error:
 
     }
 
+    if(jpeg_out.output_picture_y.virtual_address == NULL) {
+      printf("No output buffer!
");
+      goto end;
+    }
     if(crop)
       WriteCroppedOutput(&image_info,
                          (u8*)jpeg_out.output_picture_y.virtual_address,
@@ -1366,6 +1395,7 @@ error:
         /* read input stream from file to buffer and close input file */
         ret = fread(byte_strm_start, sizeof(u8), len, f_in);
         fclose(f_in);
+        f_in = NULL;
       } while(jpeg_ret != 0);
     } else {
       /* Find next image */
@@ -1420,6 +1450,7 @@ error:
     /* read input stream from file to buffer and close input file */
     ret = fread(byte_strm_start, sizeof(u8), len, f_in);
     fclose(f_in);
+    f_in = NULL;
 
     /* update */
     jpeg_in.stream_buffer.virtual_address = (u32 *) byte_strm_start;
@@ -1442,8 +1473,10 @@ end:
   pp_close();
 #endif
 
-  if(stream_mem.virtual_address != NULL)
+  if(stream_mem.virtual_address != NULL) {
     DWLFreeLinear(((JpegDecContainer *) jpeg)->dwl, &stream_mem);
+    stream_mem.virtual_address = NULL;
+  }
 
   if(user_alloc_luma.virtual_address != NULL)
     DWLFreeRefFrm(((JpegDecContainer *) jpeg)->dwl, &user_alloc_luma);
@@ -1469,10 +1502,8 @@ end:
     goto start_full_decode;
   }
 
-  if(input_read_type) {
-    if(f_in) {
-      fclose(f_in);
-    }
+  if(f_in) {
+    fclose(f_in);
   }
 
   if(fout) {
@@ -1879,6 +1910,12 @@ void WriteFullOutput(u32 pic_mode) {
 
     p_yuv_out_chroma = JpegDecMalloc(sizeof(u8) * (chroma_len));
 
+    if (!p_yuv_out_chroma) {
+      fprintf(stdout, "UNABLE TO MALLOC OUTPUT BUFFER
");
+      if (f_input_chroma) 
+        fclose(f_input_chroma);
+      return;
+    }
     /* read output stream from file to buffer and close input file */
     ret = fread(p_yuv_out_chroma, sizeof(u8), chroma_len, f_input_chroma);
 
@@ -1892,6 +1929,8 @@ void WriteFullOutput(u32 pic_mode) {
 
     if(foutput == NULL) {
       fprintf(stdout, "UNABLE TO OPEN OUTPUT FILE
");
+      if (p_yuv_out_chroma)
+        JpegDecFree(p_yuv_out_chroma);
       return;
     }
 
diff --git a/decoder_sw/software/test/mpeg2/Makefile b/decoder_sw/software/test/mpeg2/Makefile
index c196c32..2fbefd4 100755
--- a/decoder_sw/software/test/mpeg2/Makefile
+++ b/decoder_sw/software/test/mpeg2/Makefile
@@ -60,7 +60,7 @@ INCLUDE = -I../../source/inc -I../../source/mpeg2/ -I../../source/config \
           -I../common/utils
 
 DECLIBDIR = -L../../linux/dwl -L../../linux/mpeg2 -L../common/swhw \
-            -L../../../lib -L../common/utils
+            -L../../../system/models/g1hw -L../common/utils
 DECLIB =  libdecx170m2.a
 DWLLIB = libdwlx170.a
 TBLIB = libtbcommon.a
@@ -241,7 +241,7 @@ pclinux_eval: test
 
 export SYSTEM_VERIFICATION_TEST
 
-test:  $(OBJS)
+test: $(OBJS)
 	$(CC) $(LDFLAGS) $(CFLAGS) $(OBJS) $(LIBS) -o $(TESTDEC)
 
 lib:
diff --git a/decoder_sw/software/test/mpeg2/mpeg2dectest.c b/decoder_sw/software/test/mpeg2/mpeg2dectest.c
index 69cf214..5c37db6 100755
--- a/decoder_sw/software/test/mpeg2/mpeg2dectest.c
+++ b/decoder_sw/software/test/mpeg2/mpeg2dectest.c
@@ -167,7 +167,7 @@ FILE *findex = NULL;
 u32 save_index = 0;
 u32 use_index = 0;
 off64_t cur_index = 0;
-off64_t next_index = 0;
+addr_t next_index = 0;
 u32 ds_ratio_x, ds_ratio_y;
 
 #if defined(ASIC_TRACE_SUPPORT) || defined(SYSTEM_VERIFICATION)
@@ -212,11 +212,12 @@ static void *AddBufferThread(void *arg) {
     pthread_mutex_lock(&ext_buffer_contro);
     if(add_extra_flag && num_buffers < MAX_BUFFERS) {
       struct DWLLinearMem mem;
+      mem.mem_type = DWL_MEM_TYPE_DPB;
       i32 dwl_ret;
       if (pp_enabled)
-        DWLMallocLinear(dwl_inst, buffer_size, &mem);
+        dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
       else
-        DWLMallocRefFrm(dwl_inst, buffer_size, &mem);
+        dwl_ret = DWLMallocRefFrm(dwl_inst, buffer_size, &mem);
       if(dwl_ret == DWL_OK) {
         Mpeg2DecRet rv = Mpeg2DecAddBuffer(decoder, &mem);
         if(rv != MPEG2DEC_OK && rv != MPEG2DEC_WAITING_FOR_BUFFER) {
@@ -284,6 +285,7 @@ static void* buf_release_thread(void* arg) {
         pthread_mutex_lock(&ext_buffer_contro);
         if(add_extra_flag && num_buffers < MAX_BUFFERS) {
           struct DWLLinearMem mem;
+          mem.mem_type = DWL_MEM_TYPE_DPB;
           i32 dwl_ret;
           if (pp_enabled)
             dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -502,6 +504,10 @@ int main(int argc, char **argv) {
     /* Check expiry date */
     time(&sys_time);
     tm = localtime(&sys_time);
+    if (tm == NULL) {
+      fprintf(stderr,"Get localtime failed!
");
+      return -1;
+    }
     strftime(tm_buf, sizeof(tm_buf), "%y%m%d", tm);
     tmp1 = 1000000+atoi(tm_buf);
     if (tmp1 > (EXPIRY_DATE) && (EXPIRY_DATE) > 1 ) {
@@ -588,7 +594,7 @@ int main(int argc, char **argv) {
     } else if(strncmp(argv[i], "-X", 2) == 0) {
       write_output = 0;
     } else if(strncmp(argv[i], "-S", 2) == 0) {
-      f_stream_trace = fopen((argv[i] + 2), "r");
+      if (!f_stream_trace) f_stream_trace = fopen((argv[i] + 2), "r");
     } else if(strncmp(argv[i], "-P", 2) == 0) {
       planar_output = 1;
     } else if(strcmp(argv[i], "-Q") == 0) {
@@ -751,6 +757,8 @@ int main(int argc, char **argv) {
     findex = fopen("stream.cfg", "w");
     if(findex == NULL) {
       printf("UNABLE TO OPEN INDEX FILE
");
+      if (f_in)
+        fclose(f_in);
       return -1;
     }
   } else {
@@ -1661,7 +1669,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
     u32 amount = 0;
 
     /* get next index */
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
     ret = fscanf(findex, "%lu", &next_index);
 #else
     ret = fscanf(findex, "%llu", &next_index);
@@ -1669,6 +1677,10 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
     amount = next_index - cur_index;
 
     /* read data */
+    if (amount > DEC_X170_MAX_STREAM) {
+      printf("FILE ERROR
");
+      return 0;
+    }
     idx = fread(frame_buffer, 1, amount, fp);
 
     VopStart = 1;
@@ -2135,8 +2147,11 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
 #endif
       /*printf("first_field %d
");*/
 
-      if(interlaced && !interlaced_field && first_field)
+      if(interlaced && !interlaced_field && first_field) {
+        if(raster_scan)
+          free(raster_scan);
         return;
+      }
 
       /*
        * printf("PIC %d, %s", DecPicture.pic_id,
@@ -2276,11 +2291,11 @@ void WriteOutputLittleEndian(u8 * data, u32 pic_size) {
   for(i = 0; i < chunks; ++i) {
     word = data[0];
     word <<= 8;
-    word |= data[1];
+    word |= (u32) data[1];
     word <<= 8;
-    word |= data[2];
+    word |= (u32) data[2];
     word <<= 8;
-    word |= data[3];
+    word |= (u32) data[3];
     fwrite(&word, 4, 1, fout);
     data += 4;
   }
@@ -2294,15 +2309,15 @@ void WriteOutputLittleEndian(u8 * data, u32 pic_size) {
   } else if(pic_size % 4 == 2) {
     word = data[0];
     word <<= 8;
-    word |= data[1];
+    word |= (u32) data[1];
     word <<= 16;
     fwrite(&word, 2, 1, fout);
   } else if(pic_size % 4 == 3) {
     word = data[0];
     word <<= 8;
-    word |= data[1];
+    word |= (u32) data[1];
     word <<= 8;
-    word |= data[2];
+    word |= (u32) data[2];
     word <<= 8;
     fwrite(&word, 3, 1, fout);
   }
diff --git a/decoder_sw/software/test/mpeg4/Makefile b/decoder_sw/software/test/mpeg4/Makefile
index 14a25a2..93ed5c7 100755
--- a/decoder_sw/software/test/mpeg4/Makefile
+++ b/decoder_sw/software/test/mpeg4/Makefile
@@ -63,7 +63,7 @@ INCLUDE = -I../../source/inc -I../../source/mpeg4/ -I../../source/config \
           -I../../source/common  -I../common/swhw -I../common/utils
 
 DECLIBDIR = -L../../linux/mpeg4 -L../common/swhw \
-            -L../../../lib -L../../linux/dwl -L../common/utils
+            -L../../../system/models/g1hw -L../../linux/dwl -L../common/utils
 
 DECLIB =  libdecx170m.a
 DWLLIB = libdwlx170.a
diff --git a/decoder_sw/software/test/mpeg4/mpeg4dectest.c b/decoder_sw/software/test/mpeg4/mpeg4dectest.c
index 0b1e4c1..7e39810 100755
--- a/decoder_sw/software/test/mpeg4/mpeg4dectest.c
+++ b/decoder_sw/software/test/mpeg4/mpeg4dectest.c
@@ -168,7 +168,7 @@ FILE *findex = NULL;
 u32 save_index = 0;
 u32 use_index = 0;
 off64_t cur_index = 0;
-off64_t next_index = 0;
+addr_t next_index = 0;
 u32 ds_ratio_x, ds_ratio_y;
 
 #if defined(ASIC_TRACE_SUPPORT) || defined(SYSTEM_VERIFICATION)
@@ -209,6 +209,7 @@ static void *AddBufferThread(void *arg) {
     pthread_mutex_lock(&ext_buffer_contro);
     if(add_extra_flag && num_buffers < MAX_BUFFERS) {
       struct DWLLinearMem mem;
+      mem.mem_type = DWL_MEM_TYPE_DPB;
       i32 dwl_ret;
       if (pp_enabled)
         dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -289,6 +290,7 @@ static void* buf_release_thread(void* arg) {
         pthread_mutex_lock(&ext_buffer_contro);
         if(add_extra_flag && num_buffers < MAX_BUFFERS) {
           struct DWLLinearMem mem;
+          mem.mem_type = DWL_MEM_TYPE_DPB;
           i32 dwl_ret;
           if (pp_enabled)
             dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -602,7 +604,7 @@ int main(int argc, char **argv) {
       u32 frame_width, frame_height;
       custom_dimensions = 1;
       no_start_codes = 1;
-      tmp = sscanf(argv[i]+2, "%dx%d", &custom_width, &custom_height );
+      tmp = sscanf(argv[i]+2, "%ux%u", &custom_width, &custom_height );
       if( tmp != 2 ) {
         printf("MALFORMED WIDTHxHEIGHT: %s
", argv[i]+2);
         return 1;
@@ -1748,7 +1750,7 @@ static u32 readDecodeUnitNoSc(FILE * fp, u8 * frame_buffer, void *dec_inst) {
   int ret;
 
   if(use_index) {
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
     ret = fscanf(findex, "%lu", &next_index);
 #else
     ret = fscanf(findex, "%llu", &next_index);
@@ -1855,13 +1857,17 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
     u32 amount = 0;
 
     /* read index */
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
     ret = fscanf(findex, "%lu", &next_index);
 #else
     ret = fscanf(findex, "%llu", &next_index);
 #endif
     amount = next_index - cur_index;
 
+    if (amount > DEC_X170_MAX_STREAM) {
+      printf("FILE ERROR
");
+      return 0;
+    }
     idx = fread(frame_buffer, 1, amount, fp);
 
     /* start code */
@@ -2228,24 +2234,40 @@ void GetUserData(MP4DecInst dec_inst,
   case MP4DEC_USER_DATA_VOS:
     size = dec_info.user_data_voslen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
+    if (data == NULL) {
+      printf(("ERROR, calloc failed!
"));
+      return;
+    }
     user_data_config.p_user_data_vos = data;
     user_data_config.user_data_vosmax_len = size;
     break;
   case MP4DEC_USER_DATA_VISO:
     size = dec_info.user_data_visolen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
+    if (data == NULL) {
+      printf(("ERROR, calloc failed!
"));
+      return;
+    }
     user_data_config.p_user_data_viso = data;
     user_data_config.user_data_visomax_len = size;
     break;
   case MP4DEC_USER_DATA_VOL:
     size = dec_info.user_data_vollen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
+    if (data == NULL) {
+      printf(("ERROR, calloc failed!
"));
+      return;
+    }
     user_data_config.p_user_data_vol = data;
     user_data_config.user_data_volmax_len = size;
     break;
   case MP4DEC_USER_DATA_GOV:
     size = dec_info.user_data_govlen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
+    if (data == NULL) {
+      printf(("ERROR, calloc failed!
"));
+      return;
+    }
     user_data_config.p_user_data_gov = data;
     user_data_config.user_data_govmax_len = size;
 
diff --git a/decoder_sw/software/test/vc1/Makefile b/decoder_sw/software/test/vc1/Makefile
index 9c1d1a4..4af01c5 100755
--- a/decoder_sw/software/test/vc1/Makefile
+++ b/decoder_sw/software/test/vc1/Makefile
@@ -59,7 +59,7 @@ INCLUDE = -I../../source/inc -I../../source/vc1 -I../../source/config \
           -I../common/utils
 
 DECLIBDIR = -L../../linux/vc1 -L../../linux/dwl -L../common/swhw \
-	    -L../../../lib -L../common/utils
+	    -L../../../system/models/g1hw -L../common/utils
 DECLIB = libdecx170v.a
 DWLLIB = libdwlx170.a
 TBLIB = libtbcommon.a
diff --git a/decoder_sw/software/test/vc1/dectestbench.c b/decoder_sw/software/test/vc1/dectestbench.c
index fc16d53..8b362d4 100755
--- a/decoder_sw/software/test/vc1/dectestbench.c
+++ b/decoder_sw/software/test/vc1/dectestbench.c
@@ -130,7 +130,7 @@ u32 use_index = 0;
 FILE *f_index = NULL;
 
 off64_t cur_index = 0;
-off64_t next_index = 0;
+addr_t next_index = 0;
 off64_t last_stream_pos = 0;
 u32 ds_ratio_x, ds_ratio_y;
 
@@ -203,6 +203,7 @@ static void *AddBufferThread(void *arg) {
     pthread_mutex_lock(&ext_buffer_contro);
     if(add_extra_flag && num_buffers < MAX_BUFFERS) {
       struct DWLLinearMem mem;
+      mem.mem_type = DWL_MEM_TYPE_DPB;
       i32 dwl_ret;
       if (pp_enabled)
         dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -282,6 +283,7 @@ static void* buf_release_thread(void* arg) {
         pthread_mutex_lock(&ext_buffer_contro);
         if(add_extra_flag && num_buffers < MAX_BUFFERS) {
           struct DWLLinearMem mem;
+          mem.mem_type = DWL_MEM_TYPE_DPB;
           i32 dwl_ret;
           if (pp_enabled)
             dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -2416,8 +2418,11 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 frame_numb
       u8* pic_copy = NULL;
 #endif
 
-      if (interlaced && !interlaced_field && first_field)
+      if (interlaced && !interlaced_field && first_field) {
+        if(raster_scan)
+          free(raster_scan);
         return;
+      }
 
 #ifndef ASIC_TRACE_SUPPORT
       if(output_picture_endian == DEC_X170_BIG_ENDIAN) {
@@ -2872,7 +2877,7 @@ u32 fillBuffer(u8 *stream) {
   if(cur_index != pos) {
     fseeko64(finput, cur_index, SEEK_SET);
   }
-#ifdef USE_64BIT_ENV
+#ifndef _WIN64
   ret = fscanf(f_index, "%lu", &next_index);
 #else
   ret = fscanf(f_index, "%llu", &next_index);
@@ -2881,6 +2886,10 @@ u32 fillBuffer(u8 *stream) {
   cur_index = next_index;
 
   /* read data */
+  if (amount > DEC_X170_MAX_STREAM) {
+    printf("FILE ERROR
");
+    return 0;
+  }
   data_len = fread(stream, 1, amount, finput);
 
   return data_len;
diff --git a/decoder_sw/software/test/vp6/Makefile b/decoder_sw/software/test/vp6/Makefile
index 1bf64f1..abe9425 100755
--- a/decoder_sw/software/test/vp6/Makefile
+++ b/decoder_sw/software/test/vp6/Makefile
@@ -77,7 +77,7 @@ LIB_REF=on2vpplugin6
 LIB_MODEL=vp6hwmodel
 
 DECLIBDIR = -L../../linux/vp6 -L../../linux/dwl -L../common/swhw \
-	    -L../../../lib -L../common/utils
+	    -L../../../system/models/g1hw -L../common/utils
 DECLIB = libdec8190vp6.a
 
 # Enable SW performance  measurement
diff --git a/decoder_sw/software/test/vp6/on2vp6dec.c b/decoder_sw/software/test/vp6/on2vp6dec.c
index d9b40c8..b0eec9f 100755
--- a/decoder_sw/software/test/vp6/on2vp6dec.c
+++ b/decoder_sw/software/test/vp6/on2vp6dec.c
@@ -156,6 +156,7 @@ static void *AddBufferThread(void *arg) {
     pthread_mutex_lock(&ext_buffer_contro);
     if(add_extra_flag && (external_buf_num < MAX_BUFFERS)) {
       struct DWLLinearMem mem;
+      mem.mem_type = DWL_MEM_TYPE_DPB;
       i32 dwl_ret;
       if (pp_enabled)
         dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -258,6 +259,7 @@ static void* buf_release_thread(void* arg) {
         pthread_mutex_lock(&ext_buffer_contro);
         if(add_extra_flag && (external_buf_num < MAX_BUFFERS)) {
           struct DWLLinearMem mem;
+          mem.mem_type = DWL_MEM_TYPE_DPB;
           i32 dwl_ret;
           if (pp_enabled)
             dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -669,6 +671,7 @@ int decode_file(const options_s * opts) {
 
   if(out_file == NULL) {
     perror(opts->output);
+    fclose(input_file);
     return -1;
   }
 #endif
@@ -855,6 +858,7 @@ int decode_file(const options_s * opts) {
       if (ret == VP6DEC_WAITING_FOR_BUFFER) {
         DEBUG_PRINT(("Waiting for frame buffers
"));
         struct DWLLinearMem mem;
+        mem.mem_type = DWL_MEM_TYPE_DPB;
 
         rv = VP6DecGetBufferInfo(dec_inst, &hbuf);
         printf("VP6DecGetBufferInfo ret %d
", rv);
@@ -1008,7 +1012,7 @@ end:
   pp_close();
 #endif
 
-  if(stream_mem.virtual_address)
+  if(stream_mem.virtual_address && dec_inst != NULL)
     DWLFreeLinear(((VP6DecContainer_t *) dec_inst)->dwl, &stream_mem);
 #ifdef USE_EXTERNAL_BUFFER
   ReleaseExtBuffers();
@@ -1066,6 +1070,10 @@ int main(int argc, char *argv[]) {
     /* Check expiry date */
     time(&sys_time);
     tm = localtime(&sys_time);
+    if (tm == NULL) {
+      fprintf(stderr,"Get localtime failed!
");
+      return -1;
+    }
     strftime(tm_buf, sizeof(tm_buf), "%y%m%d", tm);
     tmp1 = 1000000+atoi(tm_buf);
     if (tmp1 > (EXPIRY_DATE) && (EXPIRY_DATE) > 1 ) {
diff --git a/decoder_sw/software/test/vp8/Makefile b/decoder_sw/software/test/vp8/Makefile
index 2fc1fc1..b672700 100755
--- a/decoder_sw/software/test/vp8/Makefile
+++ b/decoder_sw/software/test/vp8/Makefile
@@ -61,7 +61,7 @@ INCLUDE = -I../../source/inc -I../../source/vp8 -I../../source/config \
           -I../common/utils
 
 DECLIBDIR = -L../../linux/vp8 -L../../linux/dwl -L../common/swhw \
-			-L../../../lib -L../common/utils
+			-L../../../system/models/g1hw -L../common/utils
 DECLIB = libdecx170vp8.a
 DWLLIB = libdwlx170.a
 TBLIB = libtbcommon.a
@@ -226,8 +226,9 @@ pclinux_eval: test
 export FIFO_DATATYPE
 
 .PHONY: test
-test: $(DIRCHECK) $(OBJS) $(OBJS_SINGLE) $(OBJS_MULTI)
-	$(CC) $(LDFLAGS) $(CFLAGS) $(INCLUDE) $(OBJS_MULTI) $(OBJS) $(LIBS) -o $(TESTDEC)-mc
+#test: $(DIRCHECK) $(OBJS) $(OBJS_SINGLE) $(OBJS_MULTI)
+#	$(CC) $(CFLAGS) $(INCLUDE) $(OBJS_MULTI) $(OBJS) $(LIBS) -o $(TESTDEC)-mc
+test: $(DIRCHECK) $(OBJS) $(OBJS_SINGLE)
 	$(CC) $(LDFLAGS) $(CFLAGS) $(INCLUDE) $(OBJS_SINGLE) $(OBJS) $(LIBS) -o $(TESTDEC)
 
 .PHONY: dircheck
diff --git a/decoder_sw/software/test/vp8/dectestbench.c b/decoder_sw/software/test/vp8/dectestbench.c
index 2ba22c9..8ae5929 100755
--- a/decoder_sw/software/test/vp8/dectestbench.c
+++ b/decoder_sw/software/test/vp8/dectestbench.c
@@ -212,6 +212,7 @@ static void *AddBufferThread(void *arg) {
     pthread_mutex_lock(&ext_buffer_contro);
     if(add_extra_flag && (num_buffers < MAX_BUFFERS)) {
       struct DWLLinearMem mem;
+      mem.mem_type = DWL_MEM_TYPE_DPB;
       i32 dwl_ret;
       if (pp_enabled)
         dwl_ret = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -282,6 +283,7 @@ static void* buf_release_thread(void* arg) {
         pthread_mutex_lock(&ext_buffer_contro);
         if(add_extra_flag && num_buffers < MAX_BUFFERS) {
           struct DWLLinearMem mem;
+          mem.mem_type = DWL_MEM_TYPE_DPB;
           i32 dwl_ret;
           if (pp_enabled)
             dwl_ret  = DWLMallocLinear(dwl_inst, buffer_size, &mem);
@@ -491,6 +493,11 @@ int main(int argc, char**argv) {
     /* Check expiry date */
     time(&sys_time);
     tm = localtime(&sys_time);
+    if (tm == NULL) {
+      fprintf(stderr,"Get localtime failed!
");
+      return -1;
+    }
+
     strftime(tm_buf, sizeof(tm_buf), "%y%m%d", tm);
     tmp1 = 1000000+atoi(tm_buf);
     if (tmp1 > (EXPIRY_DATE) && (EXPIRY_DATE) > 1 ) {
@@ -1527,10 +1534,10 @@ end:
     if (dec_picture.num_slice_rows)
 #endif
     {
-      char cmd[256];
-      sprintf(cmd, "md5sum %s | tr 'a-z' 'A-Z' | sed 's/ .*//' > .md5sum.txt", out_file_name);
+      char cmd[310];
+      sprintf(cmd, "md5sum %255s | tr 'a-z' 'A-Z' | sed 's/ .*//' > .md5sum.txt", out_file_name);
       ret = system(cmd);
-      sprintf(cmd, "mv .md5sum.txt %s", out_file_name);
+      sprintf(cmd, "mv .md5sum.txt %255s", out_file_name);
       ret = system(cmd);
     }
   }
@@ -1786,8 +1793,10 @@ void writeSlice(FILE * fp, VP8DecPicture *dec_pic) {
   u32 i, j;
   u8 *ptr = (u8*)dec_pic->p_output_frame;
 
+  tmp_ch = (u8*)malloc(chroma_size);
   if (tmp_ch == NULL) {
-    tmp_ch = (u8*)malloc(chroma_size);
+    DEBUG_PRINT(("malloc error!
"));
+    return;
   }
 
   slice_rows = dec_pic->num_slice_rows;
diff --git a/decoder_sw/software/test/vp8/mcdectestbench.c b/decoder_sw/software/test/vp8/mcdectestbench.c
index 7466c96..3476382 100755
--- a/decoder_sw/software/test/vp8/mcdectestbench.c
+++ b/decoder_sw/software/test/vp8/mcdectestbench.c
@@ -224,7 +224,7 @@ int main(int argc, char* argv[]) {
 }
 
 static int vp8_multicore_decode(decoder_utils* decoder_utils) {
-  shared_data shared_data;
+  shared_data shared_data = {0};
   set_state(&shared_data, STATE_INITIALIZING);
   shared_data.write_pic_ = decoder_utils->write_pic;
   /* Start the actual decoding loop. */
@@ -233,6 +233,7 @@ static int vp8_multicore_decode(decoder_utils* decoder_utils) {
     case STATE_INITIALIZING:
       if(input_on_initializing(&shared_data)) {
         /* If init fails do not continue. */
+        if (shared_data.dwl) free(shared_data.dwl);
         return 0;
       }
       break;
@@ -402,6 +403,10 @@ static int input_on_initializing(shared_data* shared_data) {
     FifoObject stream_buffer;
     struct DWLLinearMem stream_mem;
     stream_buffer = malloc(sizeof(decoder_cb_data));
+    if (!stream_buffer) {
+      fprintf(stderr,"UNABLE TO MALLOC STREAM BUFFER
");
+      return -1;
+    }
     stream_buffer->input_fifo_ = shared_data->input_fifo_;
     if (DWLMallocLinear(
           ((VP8DecContainer_t *)shared_data->dec_inst_)->dwl,
@@ -409,6 +414,7 @@ static int input_on_initializing(shared_data* shared_data) {
           &stream_buffer->stream_mem_) != DWL_OK) {
       fprintf(stderr,"UNABLE TO ALLOCATE STREAM BUFFER MEM
");
       set_state(shared_data, STATE_TEARING_DOWN);
+      if (stream_buffer) free(stream_buffer);
       return -1;
     }
     FifoPush(shared_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
@@ -739,4 +745,5 @@ static int hwconfig_override(VP8DecInst dec_inst,  struct TBCfg* tbcfg) {
                  data_discard);
   SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_SERV_MERGE_DIS,
                  service_merge_disable);
+  return 0;
 }
diff --git a/decoder_sw/software/test/vp8/vp8bufferalloc.c b/decoder_sw/software/test/vp8/vp8bufferalloc.c
index 42ff334..239bd65 100755
--- a/decoder_sw/software/test/vp8/vp8bufferalloc.c
+++ b/decoder_sw/software/test/vp8/vp8bufferalloc.c
@@ -55,8 +55,10 @@ useralloc_inst useralloc_open(test_params* params) {
   if (inst==NULL)
     return NULL;
 
-  if(params==NULL)
+  if (params == NULL) {
+    free(inst);
     return NULL;
+  }
 
   inst->params = params;
 
diff --git a/decoder_sw/software/test/vp8/vp8writeoutput.c b/decoder_sw/software/test/vp8/vp8writeoutput.c
index 7a9933b..2f4efe1 100755
--- a/decoder_sw/software/test/vp8/vp8writeoutput.c
+++ b/decoder_sw/software/test/vp8/vp8writeoutput.c
@@ -60,8 +60,11 @@ output_inst output_open(char* filename, test_params *params) {
   if (inst==NULL)
     return NULL;
 
-  if(params==NULL)
+  if(params==NULL) {
+    if (inst)
+      free(inst);
     return NULL;
+  }
 
   inst->params = params;
 
@@ -129,6 +132,8 @@ i32 output_write_pic(output_inst inst, unsigned char *buffer,
     if (output->frame_pic_ == NULL) {
       output->frame_pic_ =
         (u8*)malloc( frame_height * frame_width *3/2 * sizeof(u8));
+      if (output->frame_pic_ == NULL)
+        return 0;
     }
     FramePicture((u8*)buffer,
                  (u8*)buffer_ch,
diff --git a/openmax_il/source/decoder/codec_h264.c b/openmax_il/source/decoder/codec_h264.c
index 6eae72b..30baf63 100755
--- a/openmax_il/source/decoder/codec_h264.c
+++ b/openmax_il/source/decoder/codec_h264.c
@@ -858,8 +858,8 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_h264(const void *DWLInstance,
 
     /* Version */
     DBGT_PDEBUG("X170 PP API v%d.%d - SW build: %d.%d - HW build: %x",
-            ppVer.major, ppVer.minor, ppBuild.swBuild >> 16,
-            ppBuild.swBuild & 0xFFFF, ppBuild.hwBuild);
+            ppVer.major, ppVer.minor, ppBuild.sw_build >> 16,
+            ppBuild.sw_build & 0xFFFF, ppBuild.hw_build);
 #endif
 
 #ifdef IS_G1_DECODER
diff --git a/openmax_il/source/decoder/codec_jpeg.c b/openmax_il/source/decoder/codec_jpeg.c
index 8078280..d8a79ca 100755
--- a/openmax_il/source/decoder/codec_jpeg.c
+++ b/openmax_il/source/decoder/codec_jpeg.c
@@ -768,7 +768,6 @@ static CODEC_STATE decoder_getframe_jpeg(CODEC_PROTOTYPE * arg, FRAME * frame,
 static CODEC_STATE decoder_abort_jpeg(CODEC_PROTOTYPE * arg)
 {
     UNUSED_PARAMETER(arg);
-
     CODEC_JPEG *this = (CODEC_JPEG *) arg;
     this->state = JPEG_PARSE_HEADERS;
     return CODEC_ERROR_UNSPECIFIED;
diff --git a/openmax_il/source/decoder/codec_rv.c b/openmax_il/source/decoder/codec_rv.c
index 8cf52fa..80864fe 100755
--- a/openmax_il/source/decoder/codec_rv.c
+++ b/openmax_il/source/decoder/codec_rv.c
@@ -701,6 +701,9 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_rv(const void *DWLInstance,
 
     memset(this, 0, sizeof(CODEC_RV));
 
+    u32 i;
+    u32 imagesizes[18];
+
     this->base.destroy = decoder_destroy_rv;
     this->base.decode = decoder_decode_rv;
     this->base.getinfo = decoder_getinfo_rv;
@@ -720,6 +723,9 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_rv(const void *DWLInstance,
     this->instance = 0;
     this->picId = 0;
 
+    for (i = 0; i < 18; i++)
+      imagesizes[i] = (u32)frame_sizes[i];
+
     /* Print API version number */
     decApi = RvDecGetAPIVersion();
     decBuild = RvDecGetBuild();
@@ -760,7 +766,7 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_rv(const void *DWLInstance,
                             DWLInstance,
 #endif
                             ERROR_HANDLING,
-                            frame_code_length, bIsRV8 == OMX_TRUE ?  frame_sizes : NULL ,
+                            frame_code_length, bIsRV8 == OMX_TRUE ?  imagesizes : NULL ,
                             bIsRV8 ? 0 : 1,
                             maxWidth, maxHeight, FRAME_BUFFERS, dpbFlags,
                             g1Conf->bEnableAdaptiveBuffers,
@@ -769,7 +775,7 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_rv(const void *DWLInstance,
 #else
     RvDecRet ret = RvDecInit(&this->instance,
                             USE_VIDEO_FREEZE_CONCEALMENT,
-                            frame_code_length, bIsRV8 == OMX_TRUE ?  frame_sizes : NULL ,
+                            frame_code_length, bIsRV8 == OMX_TRUE ?  imagesizes : NULL ,
                             bIsRV8 ? 0 : 1,
                             maxWidth, maxHeight, FRAME_BUFFERS);
 #endif
diff --git a/openmax_il/source/decoder/decoder.c b/openmax_il/source/decoder/decoder.c
index 083f426..20cce50 100755
--- a/openmax_il/source/decoder/decoder.c
+++ b/openmax_il/source/decoder/decoder.c
@@ -4796,9 +4796,14 @@ static OMX_ERRORTYPE transition_to_idle_from_loaded(OMX_DECODER * dec)
 #ifdef ENABLE_CODEC_RV
     case OMX_VIDEO_CodingRV:
         strcpy((char *) dec->role, "video_decoder.rv");
+        u32 imagesizes[18];
+        imagesizes[0] =
+        imagesizes[2] = dec->width;
+        imagesizes[1] =
+        imagesizes[3] = dec->height;
         dec->codec =
             HantroHwDecOmx_decoder_create_rv(dec->alloc.pdwl,
-                                             dec->bIsRV8, dec->imageSize,
+                                             dec->bIsRV8, dec->imageSize, imagesizes,
                                              dec->width, dec->height,
                                              &dec->g1Conf);
         DBGT_PDEBUG("ASYNC: created RV codec");
