272680ab5d84 George.Huang 2020-05-30

Fix conflicts of android-10.0.0_2.0.0

Change-Id: I36061313eee6dfd720fe1fd4fcf5366202476d2c

diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index 9c5420c2d9ad..52862abf7418 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -124,164 +124,19 @@ dtb-$(CONFIG_ARCH_MXC) += imx8qxp-mek.dtb imx8qxp-mek-dsp.dtb imx8qxp-mek-ov5640
 dtb-$(CONFIG_ARCH_MXC) += imx8qxp-mek-dom0.dtb imx8qxp-mek-root.dtb \
 			  imx8qxp-mek-inmate.dtb
 
-<<<<<<< HEAD
+dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk-idtech-spi.dtb \
+			 idt_imx8mq_evt-0_evk_dual-0.dtb \
+			 idt_imx8mq_evt-0_evk_evk-0.dtb \
+			 idt_imx8mq_evt-0_evk_idtechspi-0.dtb \
+			 idt_imx8mq_evt-0_evk_mipi-0.dtb \
+			 idt_imx8mq_evt-0_evk_mipipanel-0.dtb \
+			 idt_imx8mq_evt-0_evk_ram1gb-0.dtb \
+			 idt_a300_evt-0_devboard_evt-0.dtb \
+			 idt_a300_evt-0_devboard_hdmi-0.dtb \
+			 idt_a300_evt-0_devboard_evt-1.dtb \
+			 idt_imx8mn_evt-0_evk_rpmsg-0.dtb \
+			 idt_imx8mn_evt-0_evk_evk-0.dtb
+
 dtb-$(CONFIG_ARCH_S32) += s32v234-evb.dtb \
 			  s32v234-sbc.dtb
-=======
-dtb-$(CONFIG_ARCH_FSL_IMX8QM) += fsl-imx8qm-lpddr4-arm2.dtb \
-				 fsl-imx8qm-lpddr4-arm2-dom0.dtb \
-				 fsl-imx8qm-lpddr4-arm2-domu.dtb \
-				 fsl-imx8qm-ddr4-arm2.dtb \
-				 fsl-imx8qm-ddr4-arm2-hdmi.dtb \
-				 fsl-imx8qm-lpddr4-arm2_ca53.dtb \
-				 fsl-imx8qm-lpddr4-arm2_ca72.dtb \
-				 fsl-imx8qm-mek.dtb \
-				 fsl-imx8qm-mek-rpmsg.dtb \
-				 fsl-imx8qm-mek-car.dtb \
-				 fsl-imx8qm-mek-car-md.dtb \
-				 fsl-imx8qm-mek-car2.dtb \
-				 fsl-imx8qm-mek-car2-md.dtb \
-				 fsl-imx8qm-mek-dsp.dtb \
-				 fsl-imx8qm-mek-ov5640.dtb \
-				 fsl-imx8qm-mek_ca53.dtb \
-				 fsl-imx8qm-mek_ca72.dtb \
-				 fsl-imx8qm-mek-hdmi.dtb \
-				 fsl-imx8qm-mek-hdmi-in.dtb \
-				 fsl-imx8qm-mek-dsi-rm67191.dtb \
-				 fsl-imx8qm-mek-enet2-tja1100.dtb \
-				 fsl-imx8qm-mek-jdi-wuxga-lvds1-panel.dtb \
-				 fsl-imx8qm-mek-dom0.dtb \
-				 fsl-imx8qm-mek-dom0-dpu2.dtb \
-				 fsl-imx8qm-mek-domu.dtb \
-				 fsl-imx8qm-mek-domu-car.dtb \
-				 fsl-imx8qm-mek-domu-dpu1.dtb \
-				 fsl-imx8qm-mek-domu-dpu1-hdmi.dtb \
-				 fsl-imx8qm-mek-root.dtb \
-				 fsl-imx8qm-mek-inmate.dtb \
-				 fsl-imx8qm-lpddr4-arm2-dp.dtb \
-				 fsl-imx8qm-lpddr4-arm2-hdmi.dtb \
-				 fsl-imx8qm-lpddr4-arm2-hdmi-in.dtb \
-				 fsl-imx8qm-lpddr4-arm2-8cam.dtb \
-				 fsl-imx8qm-lpddr4-arm2-it6263-dual-channel.dtb \
-				 fsl-imx8qm-lpddr4-arm2-jdi-wuxga-lvds1-panel.dtb \
-				 fsl-imx8qm-lpddr4-arm2-lpspi.dtb \
-				 fsl-imx8qm-lpddr4-arm2-lpspi-slave.dtb \
-				 fsl-imx8qm-lpddr4-arm2-spdif.dtb \
-				 fsl-imx8qm-lpddr4-arm2-mqs.dtb \
-				 fsl-imx8qm-lpddr4-arm2-usb3.dtb \
-				 fsl-imx8qm-lpddr4-arm2-dsi-rm67191.dtb \
-				 fsl-imx8qm-lpddr4-arm2-enet2-tja1100.dtb \
-				 fsl-imx8qm-lpddr4-arm2-hsic.dtb \
-				 fsl-imx8dm-lpddr4-arm2.dtb \
-				 fsl-imx8qp-lpddr4-arm2.dtb \
-				 fsl-imx8qm-lpddr4-arm2-dp-dig-pll.dtb \
-				 fsl-imx8qm-mek-car-no-product.dtb \
-				 fsl-imx8qm-mek-car2-no-product.dtb \
-				 fsl-imx8qm-mek-ov5640-no-product.dtb
-dtb-$(CONFIG_ARCH_FSL_IMX8QXP) += fsl-imx8qxp-lpddr4-arm2.dtb \
-				  fsl-imx8qxp-mek.dtb \
-				  fsl-imx8qxp-mek-car.dtb \
-				  fsl-imx8qxp-mek-car2.dtb \
-				  fsl-imx8qxp-mek-rpmsg.dtb \
-				  fsl-imx8qxp-mek-dsp.dtb \
-				  fsl-imx8qxp-mek-dom0.dtb \
-				  fsl-imx8qxp-mek-ov5640.dtb \
-				  fsl-imx8qxp-mek-enet2.dtb \
-				  fsl-imx8qxp-mek-enet2-tja1100.dtb \
-				  fsl-imx8qxp-mek-dsi-rm67191.dtb \
-				  fsl-imx8qxp-mek-a0.dtb \
-				  fsl-imx8qxp-mek-lcdif.dtb \
-				  fsl-imx8qxp-mek-it6263-lvds0-dual-channel.dtb \
-				  fsl-imx8qxp-mek-it6263-lvds1-dual-channel.dtb \
-				  fsl-imx8qxp-mek-jdi-wuxga-lvds0-panel.dtb \
-				  fsl-imx8qxp-mek-jdi-wuxga-lvds1-panel.dtb \
-				  fsl-imx8qxp-mek-root.dtb \
-				  fsl-imx8qxp-mek-inmate.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-enet2.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-enet2-tja1100.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-gpmi-nand.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-lpspi.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-lpspi-slave.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-spdif.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-mlb.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-mqs.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-wm8962.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-dsp.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-dsi-rm67191.dtb \
-				  fsl-imx8qxp-lpddr4-arm2-a0.dtb \
-				  fsl-imx8qxp-17x17-val.dtb \
-				  fsl-imx8qxp-ddr3l-val.dtb \
-				  fsl-imx8dx-17x17-val.dtb \
-				  fsl-imx8dx-lpddr4-arm2.dtb \
-				  fsl-imx8dxp-lpddr4-arm2.dtb \
-				  fsl-imx8dxl-phantom-mek.dtb \
-				  fsl-imx8dxl-phantom-mek-rpmsg.dtb \
-				  fsl-imx8qxp-mek-car-no-product.dtb \
-				  fsl-imx8qxp-mek-car2-no-product.dtb \
-				  fsl-imx8qxp-mek-ov5640-no-product.dtb
-dtb-$(CONFIG_ARCH_FSL_IMX8MQ) += fsl-imx8mq-ddr3l-arm2.dtb \
-				 fsl-imx8mq-ddr4-arm2.dtb \
-				 fsl-imx8mq-ddr4-arm2-gpmi-nand.dtb \
-				 fsl-imx8mq-evk.dtb \
-				 fsl-imx8mq-evk-idtech-spi.dtb \
-				 fsl-imx8mq-evk-b3.dtb \
-				 fsl-imx8mq-evk-m4.dtb \
-				 fsl-imx8mq-evk-pcie1-m2.dtb \
-				 fsl-imx8mq-evk-lcdif-adv7535.dtb \
-				 fsl-imx8mq-evk-lcdif-adv7535-b3.dtb \
-				 fsl-imx8mq-evk-lcdif-rm67191.dtb \
-				 fsl-imx8mq-evk-mipi-csi2.dtb \
-				 fsl-imx8mq-evk-pdm.dtb \
-				 fsl-imx8mq-evk-dcss-adv7535.dtb \
-				 fsl-imx8mq-evk-dcss-adv7535-b3.dtb \
-				 fsl-imx8mq-evk-dcss-rm67191.dtb \
-				 fsl-imx8mq-evk-dcss-rm67191-b3.dtb \
-				 fsl-imx8mq-evk-dual-display.dtb \
-				 fsl-imx8mq-evk-dual-display-b3.dtb \
-				 fsl-imx8mq-evk-ak4497.dtb \
-				 fsl-imx8mq-evk-audio-tdm.dtb \
-				 fsl-imx8mq-evk-drm.dtb \
-				 fsl-imx8mq-evk-root.dtb \
-				 fsl-imx8mq-evk-inmate.dtb \
-				 fsl-imx8mq-evk-dp.dtb \
-				 fsl-imx8mq-evk-edp.dtb \
-				 fsl-imx8mq-phanbell.dtb \
-				 fsl-imx8mq-phanbell-no-product.dtb \
-				 fsl-imx8mq-evk-no-product.dtb \
-				 idt_imx8mq_evt-0_evk_dual-0.dtb \
-				 idt_imx8mq_evt-0_evk_evk-0.dtb \
-				 idt_imx8mq_evt-0_evk_idtechspi-0.dtb \
-				 idt_imx8mq_evt-0_evk_mipi-0.dtb \
-				 idt_imx8mq_evt-0_evk_mipipanel-0.dtb \
-				 idt_imx8mq_evt-0_evk_ram1gb-0.dtb \
-				 idt_a300_evt-0_devboard_evt-0.dtb \
-				 idt_a300_evt-0_devboard_hdmi-0.dtb \
-				 idt_a300_evt-0_devboard_evt-1.dtb
-dtb-$(CONFIG_ARCH_FSL_IMX8MM) += fsl-imx8mm-evk.dtb \
-				 fsl-imx8mm-evk-drm.dtb \
-				 fsl-imx8mm-evk-ak4497.dtb \
-				 fsl-imx8mm-evk-m4.dtb \
-				 fsl-imx8mm-evk-ak5558.dtb \
-				 fsl-imx8mm-evk-audio-tdm.dtb \
-				 fsl-imx8mm-ddr3l-val.dtb \
-				 fsl-imx8mm-ddr4-evk.dtb \
-				 fsl-imx8mm-ddr4-val.dtb \
-				 fsl-imx8mm-evk-rm67191.dtb \
-				 fsl-imx8mm-evk-root.dtb \
-				 fsl-imx8mm-evk-inmate.dtb \
-				 fsl-imx8mm-evk-revb.dtb \
-				 fsl-imx8mm-evk-revb-rm67191.dtb \
-				 fsl-imx8mm-ddr4-evk-rm67191.dtb \
-				 fsl-imx8mm-ddr4-qca9377-evk.dtb \
-				 fsl-imx8mm-evk-no-product.dtb \
-				 fsl-imx8mm-ddr4-evk-no-product.dtb
-dtb-$(CONFIG_ARCH_FSL_IMX8MN) += fsl-imx8mn-ddr4-evk.dtb \
-				 fsl-imx8mn-ddr4-evk-rpmsg.dtb \
-				 fsl-imx8mn-ddr4-evk-rm67191.dtb \
-				 fsl-imx8mn-ddr4-evk-ak5558.dtb \
-				 fsl-imx8mn-ddr4-evk-root.dtb \
-				 fsl-imx8mn-ddr4-evk-inmate.dtb \
-				 fsl-imx8mn-ddr4-evk-no-product.dtb \
-				 idt_imx8mn_evt-0_evk_rpmsg-0.dtb \
-				 idt_imx8mn_evt-0_evk_evk-0.dtb
->>>>>>> android_10_idt_dev_200527-2
+
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_evk-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_evk-0.dts
index 49ae6f269b9e..df2b1b487772 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_evk-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_evk-0.dts
@@ -7,7 +7,7 @@
 
 /dts-v1/;
 
-#include "fsl-imx8mn-ddr4-evk.dts"
+#include "imx8mn-ddr4-evk.dts"
 
 / {
 	idt,prod-id = "idt_imx8mn_evt-0_evk_evk-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_rpmsg-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_rpmsg-0.dts
index 596283096f50..c965077898e9 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_rpmsg-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mn_evt-0_evk_rpmsg-0.dts
@@ -7,7 +7,7 @@
 
 /dts-v1/;
 
-#include "fsl-imx8mn-ddr4-evk-rpmsg.dts"
+#include "imx8mn-ddr4-evk-rpmsg.dts"
 
 / {
 	idt,prod-id = "idt_imx8mn_evt-0_evk_rpmsg-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_dual-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_dual-0.dts
index 14bb089803e8..58ff70877039 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_dual-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_dual-0.dts
@@ -7,7 +7,7 @@
  
 /dts-v1/;
 
-#include "fsl-imx8mq-evk-dual-display.dts"
+#include "imx8mq-evk-dual-display.dts"
 
 / {
 	idt,prod-id = "idt_imx8mq_evt-0_evk_dual-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_evk-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_evk-0.dts
index ca7e5c269537..76fd626ef30e 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_evk-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_evk-0.dts
@@ -7,7 +7,7 @@
  
 /dts-v1/;
 
-#include "fsl-imx8mq-evk.dts"
+#include "imx8mq-evk.dts"
 
 / {
 	idt,prod-id = "idt_imx8mq_evt-0_evk_evk-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_idtechspi-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_idtechspi-0.dts
index 79384154962a..2589b67a0a7a 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_idtechspi-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_idtechspi-0.dts
@@ -7,7 +7,7 @@
  
 /dts-v1/;
 
-#include "fsl-imx8mq-evk-idtech-spi.dts"
+#include "imx8mq-evk-idtech-spi.dts"
 
 / {
 	idt,prod-id = "idt_imx8mq_evt-0_evk_idtechspi-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipi-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipi-0.dts
index 730ae9224af2..31da86d71217 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipi-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipi-0.dts
@@ -7,7 +7,7 @@
  
 /dts-v1/;
 
-#include "fsl-imx8mq-evk-lcdif-adv7535.dts"
+#include "imx8mq-evk-lcdif-adv7535.dts"
 
 / {
 	idt,prod-id = "idt_imx8mq_evt-0_evk_mipi-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipipanel-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipipanel-0.dts
index ac864d54583e..53724e1852e7 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipipanel-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_mipipanel-0.dts
@@ -7,7 +7,7 @@
  
 /dts-v1/;
 
-#include "fsl-imx8mq-evk-dcss-rm67191.dts"
+#include "imx8mq-evk-dcss-rm67191.dts"
 
 / {
 	idt,prod-id = "idt_imx8mq_evt-0_evk_mipipanel-0";
diff --git a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_ram1gb-0.dts b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_ram1gb-0.dts
index c1724e1fe7fa..938360c38dac 100644
--- a/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_ram1gb-0.dts
+++ b/arch/arm64/boot/dts/freescale/idt_imx8mq_evt-0_evk_ram1gb-0.dts
@@ -7,7 +7,7 @@
 
 /dts-v1/;
 
-#include "fsl-imx8mq-evk-idtech-spi.dts"
+#include "imx8mq-evk-idtech-spi.dts"
 
 / {
 	idt,prod-id = "idt_imx8mq_evt-0_evk_ram1gb-0";
diff --git a/arch/arm64/boot/dts/freescale/fsl-imx8mq-evk-idtech-spi.dts b/arch/arm64/boot/dts/freescale/imx8mq-evk-idtech-spi.dts
similarity index 100%
rename from arch/arm64/boot/dts/freescale/fsl-imx8mq-evk-idtech-spi.dts
rename to arch/arm64/boot/dts/freescale/imx8mq-evk-idtech-spi.dts
diff --git a/drivers/cpufreq/imx8mq-cpufreq.c b/drivers/cpufreq/imx8mq-cpufreq.c
deleted file mode 100644
index 51e3c9c36240..000000000000
--- a/drivers/cpufreq/imx8mq-cpufreq.c
+++ /dev/null
@@ -1,364 +0,0 @@
-/*
- * Copyright (C) 2017-2018 NXP
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 as
- * published by the Free Software Foundation.
- */
-
-#include <linux/clk.h>
-#include <linux/cpu.h>
-#include <linux/cpufreq.h>
-#include <linux/cpu_cooling.h>
-#include <linux/err.h>
-#include <linux/module.h>
-#include <linux/slab.h>
-#include <linux/of.h>
-#include <linux/pm_opp.h>
-#include <linux/platform_device.h>
-#include <linux/regulator/consumer.h>
-#include <linux/suspend.h>
-#include <linux/device_cooling.h>
-
-#define DC_VOLTAGE_MIN		900000
-#define DC_VOLTAGE_MAX		1000000
-
-static struct device *cpu_dev;
-static bool free_opp;
-static struct cpufreq_frequency_table *freq_table;
-static struct mutex set_cpufreq_lock;
-static unsigned int transition_latency;
-static struct clk *a53_clk;
-static struct clk *arm_a53_src_clk;
-static struct clk *arm_pll_clk;
-static struct clk *arm_pll_out_clk;
-static struct clk *sys1_pll_800m_clk;
-struct thermal_cooling_device *cdev;
-static struct regulator *dc_reg;
-static struct regulator *arm_reg;
-
-static int imx8mq_set_target(struct cpufreq_policy *policy, unsigned int index)
-{
-	struct dev_pm_opp *opp;
-	unsigned long freq_hz, volt;
-	unsigned int old_freq, new_freq;
-	int ret;
-
-	mutex_lock(&set_cpufreq_lock);
-
-	new_freq = freq_table[index].frequency;
-	freq_hz = new_freq * 1000;
-	old_freq = policy->cur;
-
-	rcu_read_lock();
-	opp = dev_pm_opp_find_freq_ceil(cpu_dev, &freq_hz);
-	if (IS_ERR(opp)) {
-		rcu_read_unlock();
-		dev_err(cpu_dev, "failed to find OPP for %ld
", freq_hz);
-		mutex_unlock(&set_cpufreq_lock);
-		return PTR_ERR(opp);
-	}
-	volt = dev_pm_opp_get_voltage(opp);
-	rcu_read_unlock();
-
-	dev_dbg(cpu_dev, "%u MHz --> %u MHz
",
-		old_freq / 1000, new_freq / 1000);
-
-	if (new_freq > old_freq) {
-		if (!IS_ERR(dc_reg)) {
-			ret = regulator_set_voltage_tol(dc_reg, DC_VOLTAGE_MAX, 0);
-			if (ret) {
-				dev_err(cpu_dev, "failed to scale dc_reg up: %d
", ret);
-				mutex_unlock(&set_cpufreq_lock);
-				return ret;
-			}
-		}
-	}
-
-	if (new_freq > old_freq) {
-		if (!IS_ERR(arm_reg)) {
-			ret = regulator_set_voltage_tol(arm_reg, volt, 0);
-			if (ret) {
-				dev_err(cpu_dev, "failed to scale arm_reg up: %d
", ret);
-				mutex_unlock(&set_cpufreq_lock);
-				return ret;
-			}
-		}
-	}
-
-	clk_set_parent(arm_a53_src_clk, sys1_pll_800m_clk);
-	clk_set_rate(arm_pll_clk, new_freq * 1000);
-	clk_set_parent(arm_a53_src_clk, arm_pll_out_clk);
-
-	if (new_freq < old_freq) {
-		if (!IS_ERR(dc_reg)) {
-			ret = regulator_set_voltage_tol(dc_reg, DC_VOLTAGE_MIN, 0);
-			if (ret) {
-				dev_err(cpu_dev, "failed to scale dc_reg down: %d
", ret);
-				mutex_unlock(&set_cpufreq_lock);
-				return ret;
-			}
-		}
-	}
-
-	if (new_freq < old_freq) {
-		if (!IS_ERR(arm_reg)) {
-			ret = regulator_set_voltage_tol(arm_reg, volt, 0);
-			if (ret) {
-				dev_err(cpu_dev, "failed to scale arm_reg down: %d
", ret);
-				mutex_unlock(&set_cpufreq_lock);
-				return ret;
-			}
-		}
-	}
-
-	/* Ensure the arm clock divider is what we expect */
-	ret = clk_set_rate(a53_clk, new_freq * 1000);
-	if (ret)
-		dev_err(cpu_dev, "failed to set clock rate: %d
", ret);
-
-	mutex_unlock(&set_cpufreq_lock);
-	return ret;
-}
-
-static void imx8mq_cpufreq_ready(struct cpufreq_policy *policy)
-{
-	struct device_node *np = of_get_cpu_node(policy->cpu, NULL);
-
-	if (of_find_property(np, "#cooling-cells", NULL)) {
-		cdev = of_cpufreq_cooling_register(policy);
-
-		if (IS_ERR(cdev) && PTR_ERR(cdev) != -ENOSYS) {
-			pr_err("cpu%d is not running as cooling device: %ld
",
-					policy->cpu, PTR_ERR(cdev));
-
-			cdev = NULL;
-		}
-	}
-
-	of_node_put(np);
-}
-
-#define cpu_cooling_core_mask ((1 << 2) | (1 << 3))   /* offline cpu2 and cpu3 if needed*/
-static int thermal_hot_pm_notify(struct notifier_block *nb, unsigned long event,
-       void *dummy)
-{
-	static unsigned long prev_event = 0xffffffff;
-	struct device *cpu_dev = NULL;
-	static int cpus_offlined = 0;
-	int i = 0, ret = 0;
-
-	if (event == prev_event)
-		return NOTIFY_OK;
-
-	prev_event = event;
-
-	switch (event) {
-	case 0: /* default state, no trip point reached*/
-	case 1: /* trip1 temperature are lower than trip2, we can
-		   online the cpu2 and cpu3 to get better performance */
-		for (i = 0; i < num_possible_cpus(); i++) {
-			if (!(cpu_cooling_core_mask & BIT(i)))
-				continue;
-			if (!(cpus_offlined & BIT(i)))
-				continue;
-			cpus_offlined &= ~BIT(i);
-			pr_info("Allow Online CPU%d, devfreq state: %d
",
-					i, event);
-
-			lock_device_hotplug();
-			if (cpu_online(i)) {
-				unlock_device_hotplug();
-				continue;
-			}
-			cpu_dev = get_cpu_device(i);
-			ret = device_online(cpu_dev);
-			if (ret)
-				pr_err("Error %d online core %d
",
-						ret, i);
-			unlock_device_hotplug();
-		}
-		break;
-	case 2: /* rise above trip2 temperature, offline cpu2 and cpu3 to
-		   to limit the max online cpu cores */
-		for (i = num_possible_cpus() - 1; i >= 0; i--) {
-			if (!(cpu_cooling_core_mask & BIT(i)))
-				continue;
-			if (cpus_offlined & BIT(i) && !cpu_online(i))
-				continue;
-			pr_info("Set Offline: CPU%d, devfreq state: %d
",
-					i, event);
-			lock_device_hotplug();
-			if (cpu_online(i)) {
-				cpu_dev = get_cpu_device(i);
-				ret = device_offline(cpu_dev);
-				if (ret < 0)
-					pr_err("Error %d offline core %d
",
-					       ret, i);
-			}
-			unlock_device_hotplug();
-			cpus_offlined |= BIT(i);
-		}
-		break;
-	default:
-		break;
-	}
-	return NOTIFY_OK;
-}
-
-static struct notifier_block thermal_hot_pm_notifier =
-{
-	.notifier_call = thermal_hot_pm_notify,
-};
-
-static int imx8mq_cpufreq_init(struct cpufreq_policy *policy)
-{
-	int ret;
-
-	policy->clk = a53_clk;
-	policy->cur = clk_get_rate(a53_clk) / 1000;
-
-	ret = cpufreq_generic_init(policy, freq_table, transition_latency);
-	if (ret) {
-		dev_err(cpu_dev, "imx8mq cpufreq init failed!
");
-		return ret;
-	}
-
-	policy->suspend_freq = policy->max;
-
-	return 0;
-}
-
-static struct cpufreq_driver imx8mq_cpufreq_driver = {
-	.flags = CPUFREQ_NEED_INITIAL_FREQ_CHECK,
-	.verify = cpufreq_generic_frequency_table_verify,
-	.target_index = imx8mq_set_target,
-	.get = cpufreq_generic_get,
-	.init = imx8mq_cpufreq_init,
-	.name = "imx8mq-cpufreq",
-	.ready = imx8mq_cpufreq_ready,
-	.attr = cpufreq_generic_attr,
-#ifdef CONFIG_PM
-	.suspend = cpufreq_generic_suspend,
-#endif
-};
-
-static int imx8mq_cpufreq_probe(struct platform_device *pdev)
-{
-	struct device_node *np;
-	int ret, num;
-
-	cpu_dev = get_cpu_device(0);
-	if (!cpu_dev) {
-		pr_err("failed to get cpu0 device
");
-		return -ENODEV;
-	}
-
-	np = of_node_get(cpu_dev->of_node);
-	if (!np) {
-		dev_err(cpu_dev, "failed to find cpu0 node
");
-		return -ENOENT;
-	}
-
-	a53_clk = clk_get(cpu_dev, "a53");
-	arm_a53_src_clk = clk_get(cpu_dev, "arm_a53_src");
-	arm_pll_clk = clk_get(cpu_dev, "arm_pll");
-	arm_pll_out_clk = clk_get(cpu_dev, "arm_pll_out");
-	sys1_pll_800m_clk = clk_get(cpu_dev, "sys1_pll_800m");
-	if (IS_ERR(a53_clk) || IS_ERR(arm_a53_src_clk)
-		|| IS_ERR(arm_pll_out_clk) || IS_ERR(arm_pll_clk)
-		|| IS_ERR(sys1_pll_800m_clk)) {
-		dev_err(cpu_dev, "failed to get clocks
");
-		ret = -ENOENT;
-		goto put_clk;
-	}
-
-	dc_reg = regulator_get_optional(cpu_dev, "dc");
-	arm_reg = regulator_get_optional(cpu_dev, "arm");
-
-	/*
-	 * We expect an OPP table supplied by platform.
-	 * Just, incase the platform did not supply the OPP
-	 * table, it will try to get it.
-	 */
-	num = dev_pm_opp_get_opp_count(cpu_dev);
-	if (num < 0) {
-		ret = dev_pm_opp_of_add_table(cpu_dev);
-		if (ret < 0) {
-			dev_err(cpu_dev, "failed to init OPP table: %d
", ret);
-			goto put_clk;
-		}
-	}
-
-	ret = dev_pm_opp_init_cpufreq_table(cpu_dev, &freq_table);
-	if (ret) {
-		dev_err(cpu_dev, "failed to init cpufreq table: %d
", ret);
-		goto out_free_opp;
-	}
-
-	if (of_property_read_u32(np, "clock-latency", &transition_latency))
-		transition_latency = CPUFREQ_ETERNAL;
-
-	mutex_init(&set_cpufreq_lock);
-
-	ret = cpufreq_register_driver(&imx8mq_cpufreq_driver);
-	if (ret) {
-		dev_err(cpu_dev, "failed register driver: %d
", ret);
-		goto free_freq_table;
-	}
-
-	of_node_put(np);
-	dev_info(cpu_dev, "registered imx8mq-cpufreq
");
-
-	register_devfreq_cooling_notifier(&thermal_hot_pm_notifier);
-
-	return 0;
-
-free_freq_table:
-	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);
-out_free_opp:
-	dev_pm_opp_of_remove_table(cpu_dev);
-put_clk:
-	if (!IS_ERR(a53_clk))
-		clk_put(a53_clk);
-	if (!IS_ERR(arm_a53_src_clk))
-		clk_put(arm_a53_src_clk);
-	if (!IS_ERR(arm_pll_clk))
-		clk_put(arm_pll_clk);
-	if (!IS_ERR(arm_pll_out_clk))
-		clk_put(arm_pll_out_clk);
-	if (!IS_ERR(sys1_pll_800m_clk))
-		clk_put(sys1_pll_800m_clk);
-	of_node_put(np);
-	return ret;
-}
-
-static int imx8mq_cpufreq_remove(struct platform_device *pdev)
-{
-	unregister_devfreq_cooling_notifier(&thermal_hot_pm_notifier);
-	cpufreq_cooling_unregister(cdev);
-	cpufreq_unregister_driver(&imx8mq_cpufreq_driver);
-	dev_pm_opp_free_cpufreq_table(cpu_dev, &freq_table);
-	if (free_opp)
-		dev_pm_opp_of_remove_table(cpu_dev);
-	clk_put(a53_clk);
-	clk_put(arm_a53_src_clk);
-	clk_put(arm_pll_clk);
-	clk_put(arm_pll_out_clk);
-	clk_put(sys1_pll_800m_clk);
-
-	return 0;
-}
-
-static struct platform_driver imx8mq_cpufreq_platdrv = {
-	.driver = {
-		.name	= "imx8mq-cpufreq",
-	},
-	.probe		= imx8mq_cpufreq_probe,
-	.remove		= imx8mq_cpufreq_remove,
-};
-module_platform_driver(imx8mq_cpufreq_platdrv);
-
-MODULE_AUTHOR("Anson Huang <Anson.Huang@nxp.com>");
-MODULE_DESCRIPTION("Freescale i.MX8MQ cpufreq driver");
-MODULE_LICENSE("GPL");
diff --git a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c b/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
deleted file mode 100644
index bc041aef93b7..000000000000
--- a/drivers/gpu/drm/imx/hdp/API_AFE_t28hpc_hdmitx.c
+++ /dev/null
@@ -1,817 +0,0 @@
-/******************************************************************************
- *
- * Copyright (C) 2016-2017 Cadence Design Systems, Inc.
- * All rights reserved worldwide.
- *
- * Redistribution and use in source and binary forms, with or without modification,
- * are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- * this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- * this list of conditions and the following disclaimer in the documentation and/or
- * other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors
- * may be used to endorse or promote products derived from this software without
- * specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO,
- * THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE
- * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
- * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
- * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
- * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
- * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
- * INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
- * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
- * DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
- * TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE
- * OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
- *
- * Copyright 2017-2018 NXP
- *
- ******************************************************************************
- *
- * API_AFE_t28hpc_hdmitx.c
- *
- ******************************************************************************
- */
-
-#include <drm/drmP.h>
-#include "imx-hdp.h"
-#include "API_AFE_t28hpc_hdmitx.h"
-#include "t28hpc_hdmitx_table.h"
-
-/*
- * iMX has very limited list of supported pixel clocks
- * however, most displays has some tolerance on pixel clock.
- * This function will adjust pixel clock to closest supported
- * with predefined tolerance.
- */
-static void pixel_clock_fixup(struct drm_display_mode *mode) {
-	int i;
-	int ind = -1;
-	int tol = 5; /* pixel clock tolerance in % */
-	int rate_err = tol*2;
-
-	for (i = 0; i < T28HPC_HDMITX_CLOCK_CONTROL_TABLE_ROWS_PIXEL_OUT; i++) {
-		int rate = t28hpc_hdmitx_clock_control_table_pixel_out[i][T8_PIXEL_CLK_FREQ_KHZ];
-		int rate_err_new = abs(rate - mode->clock) * 100 / mode->clock;
-
-		if ((rate_err_new <= tol) && (rate_err_new < rate_err)) {
-			rate_err = rate_err_new;
-			ind = i;
-
-			if (!rate_err)
-				break;
-		}
-	}
-
-	if (ind >= 0 && rate_err) {
-		DRM_WARN("Pixel clock adjusted from %d to %d
", mode->clock, t28hpc_hdmitx_clock_control_table_pixel_out[ind][T8_PIXEL_CLK_FREQ_KHZ]);
-		mode->clock = t28hpc_hdmitx_clock_control_table_pixel_out[ind][T8_PIXEL_CLK_FREQ_KHZ];
-	}
-}
-
-/* check pixel clock rate in
- * Table 8. HDMI TX pixel clock */
-int pixel_clock_range_t28hpc(struct drm_display_mode *mode)
-{
-	int i, row, rate;
-
-	pixel_clock_fixup(mode);
-
-	row = T28HPC_HDMITX_CLOCK_CONTROL_TABLE_ROWS_PIXEL_OUT;
-	for (i = 0; i < row; i++) {
-		   rate = t28hpc_hdmitx_clock_control_table_pixel_out[i][T8_PIXEL_CLK_FREQ_KHZ];
-		   if (rate == mode->clock)
-			   return 1;
-	}
-	return 0;
-}
-
-int phy_cfg_hdp_t28hpc(state_struct *state,
-				int num_lanes,
-				struct drm_display_mode *mode,
-				int bpp,
-				VIC_PXL_ENCODING_FORMAT format,
-				bool pixel_clk_from_phy)
-{
-	const int phy_reset_workaround = 1;
-	u32 vco_freq_khz;
-	unsigned char k;
-	int row;
-	u32 feedback_factor;
-	u32 reg_val;
-	u32 pll_feedback_divider_total;
-	int pixel_freq_khz = mode->clock;
-	u32 character_clock_ratio_num = 1;
-	u32 character_clock_ratio_den = 1;
-	u32 character_freq_khz;
-	const u32 refclk_freq_khz = 27000;
-	clk_ratio_t clk_ratio = CLK_RATIO_1_1;
-
-	reg_field_t cmnda_pll0_hs_sym_div_sel;
-	reg_field_t cmnda_pll0_ip_div;
-	reg_field_t cmnda_pll0_fb_div_low;
-	reg_field_t cmnda_pll0_fb_div_high;
-	reg_field_t cmn_ref_clk_dig_div;
-	reg_field_t divider_scaler;
-	reg_field_t cmnda_hs_clk_0_sel;
-	reg_field_t cmnda_hs_clk_1_sel;
-	reg_field_t tx_subrate;
-	reg_field_t voltage_to_current_coarse;
-	reg_field_t voltage_to_current;
-	reg_field_t ndac_ctrl;
-	reg_field_t pmos_ctrl;
-	reg_field_t ptat_ndac_ctrl;
-	reg_field_t charge_pump_gain;
-	reg_field_t vco_ring_select;
-
-	reg_field_t cmnda_pll0_pxdiv_high;
-	reg_field_t cmnda_pll0_pxdiv_low;
-	reg_field_t coarse_code;
-	reg_field_t v2i_code;
-	reg_field_t vco_cal_code;
-
-	/* Set field position */
-	cmnda_pll0_hs_sym_div_sel.msb = 9;
-	cmnda_pll0_hs_sym_div_sel.lsb = 8;
-	cmnda_pll0_ip_div.msb = 7;
-	cmnda_pll0_ip_div.lsb = 0;
-	cmnda_pll0_fb_div_low.msb = 9;
-	cmnda_pll0_fb_div_low.lsb = 0;
-	cmnda_pll0_fb_div_high.msb = 9;
-	cmnda_pll0_fb_div_high.lsb = 0;
-	cmn_ref_clk_dig_div.msb = 13;
-	cmn_ref_clk_dig_div.lsb = 12;
-	divider_scaler.msb = 14;
-	divider_scaler.lsb = 12;
-	cmnda_hs_clk_0_sel.msb = 1;
-	cmnda_hs_clk_0_sel.lsb = 0;
-	cmnda_hs_clk_1_sel.msb = 1;
-	cmnda_hs_clk_1_sel.lsb = 0;
-	tx_subrate.msb = 2;
-	tx_subrate.lsb = 0;
-	voltage_to_current_coarse.msb = 2;
-	voltage_to_current_coarse.lsb = 0;
-	voltage_to_current.msb = 5;
-	voltage_to_current.lsb = 4;
-	ndac_ctrl.msb = 11;
-	ndac_ctrl.lsb = 8;
-	pmos_ctrl.msb = 7;
-	pmos_ctrl.lsb = 0;
-	ptat_ndac_ctrl.msb = 5;
-	ptat_ndac_ctrl.lsb = 0;
-	charge_pump_gain.msb = 8;
-	charge_pump_gain.lsb = 0;
-	vco_ring_select.msb = 12;
-	vco_ring_select.lsb = 12;
-	cmnda_pll0_pxdiv_high.msb = 9;
-	cmnda_pll0_pxdiv_high.lsb = 0;
-	cmnda_pll0_pxdiv_low.msb = 9;
-	cmnda_pll0_pxdiv_low.lsb = 0;
-	coarse_code.msb = 7;
-	coarse_code.lsb = 0;
-	v2i_code.msb = 3;
-	v2i_code.lsb = 0;
-	vco_cal_code.msb = 8;
-	vco_cal_code.lsb = 0;
-
-	pixel_clock_fixup(mode);
-	pixel_freq_khz = mode->clock;
-
-	switch (format) {
-	case YCBCR_4_2_2:
-		clk_ratio = CLK_RATIO_1_1;
-		character_clock_ratio_num = 1;
-		character_clock_ratio_den = 1;
-		break;
-	case YCBCR_4_2_0:
-		switch (bpp) {
-		case 8:
-			clk_ratio = CLK_RATIO_1_2;
-			character_clock_ratio_num = 1;
-			character_clock_ratio_den = 2;
-			break;
-		case 10:
-			clk_ratio = CLK_RATIO_5_8;
-			character_clock_ratio_num = 5;
-			character_clock_ratio_den = 8;
-			break;
-		case 12:
-			clk_ratio = CLK_RATIO_3_4;
-			character_clock_ratio_num = 3;
-			character_clock_ratio_den = 4;
-			break;
-		case 16:
-			clk_ratio = CLK_RATIO_1_1;
-			character_clock_ratio_num = 1;
-			character_clock_ratio_den = 1;
-			break;
-		default:
-			DRM_WARN("Invalid ColorDepth
");
-		}
-		break;
-
-	default:
-		switch (bpp) {	/* Assume RGB */
-		case 10:
-			clk_ratio = CLK_RATIO_5_4;
-			character_clock_ratio_num = 5;
-			character_clock_ratio_den = 4;
-			break;
-		case 12:
-			clk_ratio = CLK_RATIO_3_2;
-			character_clock_ratio_num = 3;
-			character_clock_ratio_den = 2;
-			break;
-		case 16:
-			clk_ratio = CLK_RATIO_2_1;
-			character_clock_ratio_num = 2;
-			character_clock_ratio_den = 1;
-			break;
-		default:
-			clk_ratio = CLK_RATIO_1_1;
-			character_clock_ratio_num = 1;
-			character_clock_ratio_den = 1;
-		}
-	}
-
-	/* Determine a relevant feedback factor as used in the
-	 * t28hpc_hdmitx_clock_control_table table */
-	switch (clk_ratio) {
-	case CLK_RATIO_1_1:
-		feedback_factor = 1000;
-		break;
-	case CLK_RATIO_5_4:
-		feedback_factor = 1250;
-		break;
-	case CLK_RATIO_3_2:
-		feedback_factor = 1500;
-		break;
-	case CLK_RATIO_2_1:
-		feedback_factor = 2000;
-		break;
-	case CLK_RATIO_1_2:
-		feedback_factor = 500;
-		break;
-	case CLK_RATIO_5_8:
-		feedback_factor = 625;
-		break;
-	case CLK_RATIO_3_4:
-		feedback_factor = 750;
-		break;
-	}
-
-	character_freq_khz =
-	    pixel_freq_khz * character_clock_ratio_num /
-	    character_clock_ratio_den;
-	DRM_INFO
-	    ("Pixel clock frequency: %d KHz, character clock frequency: %d, color depth is %0d-bit.
",
-	     pixel_freq_khz, character_freq_khz, bpp);
-
-	if (pixel_clk_from_phy == 0) {
-
-		/* Get right row from the t28hpc_hdmitx_clock_control_table_pixel_in table.
-		 * Check if 'pixel_freq_mhz' falls inside
-		 * the <PIXEL_CLK_FREQ_MHZ_MIN, PIXEL_CLK_FREQ_MHZ_MAX> range.
-		 * Consider only the rows with FEEDBACK_FACTOR column matching feedback_factor. */
-		row =
-		    get_table_row((const u32 *)&t28hpc_hdmitx_clock_control_table_pixel_in,
-				  T28HPC_HDMITX_CLOCK_CONTROL_TABLE_ROWS_PIXEL_IN,
-				  T28HPC_HDMITX_CLOCK_CONTROL_TABLE_COLS_PIXEL_IN,
-				  pixel_freq_khz, T6_PIXEL_CLK_FREQ_KHZ_MIN,
-				  T6_PIXEL_CLK_FREQ_KHZ_MAX, T6_FEEDBACK_FACTOR,
-				  feedback_factor);
-
-		/* Check if row was found */
-		if (row == -1) {
-			DRM_WARN("Pixel clock frequency (%d KHz) not supported for this color depth (%0d-bit)
",
-			     pixel_freq_khz, bpp);
-			return 0;
-		}
-		DRM_INFO
-		    ("Pixel clock frequency (%d KHz) is supported in this color depth (%0d-bit). Settings found in row %0d
",
-		     pixel_freq_khz, bpp, row);
-
-		/* Extract particular values from the
-		 * t28hpc_hdmitx_clock_control_table_pixel_in table */
-		set_field_value(&cmnda_pll0_ip_div,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMNDA_PLL0_IP_DIV]);
-		set_field_value(&cmn_ref_clk_dig_div,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMN_REF_CLK_DIG_DIV]);
-		set_field_value(&divider_scaler,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_REF_CLK_DIVIDER_SCALER]);
-		set_field_value(&cmnda_pll0_fb_div_low,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMNDA_PLL0_FB_DIV_LOW]);
-		set_field_value(&cmnda_pll0_fb_div_high,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMNDA_PLL0_FB_DIV_HIGH]);
-		set_field_value(&vco_ring_select,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_VCO_RING_SELECT]);
-		set_field_value(&cmnda_hs_clk_0_sel,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMNDA_HS_CLK_0_SEL]);
-		set_field_value(&cmnda_hs_clk_1_sel,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMNDA_HS_CLK_1_SEL]);
-		set_field_value(&tx_subrate,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_HSCLK_DIV_TX_SUB_RATE]);
-		set_field_value(&cmnda_pll0_hs_sym_div_sel,
-				t28hpc_hdmitx_clock_control_table_pixel_in[row]
-				[T6_CMNDA_PLL0_HS_SYM_DIV_SEL]);
-
-		/* Display parameters (informative message) */
-		DRM_DEBUG("set_field_value() cmnda_pll0_ip_div        : 0x%02X
",
-		       cmnda_pll0_ip_div.value);
-		DRM_DEBUG("set_field_value() cmn_ref_clk_dig_div      : 0x%X
",
-		       cmn_ref_clk_dig_div.value);
-		DRM_DEBUG("set_field_value() divider_scaler           : 0x%X
",
-		       divider_scaler.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_fb_div_low    : 0x%03X
",
-		       cmnda_pll0_fb_div_low.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_fb_div_high   : 0x%03X
",
-		       cmnda_pll0_fb_div_high.value);
-		DRM_DEBUG("set_field_value() vco_ring_select          : %0d
",
-		       vco_ring_select.value);
-		DRM_DEBUG("set_field_value() cmnda_hs_clk_0_sel       : %0d
",
-		       cmnda_hs_clk_0_sel.value);
-		DRM_DEBUG("set_field_value() cmnda_hs_clk_1_sel       : %0d
",
-		       cmnda_hs_clk_1_sel.value);
-		DRM_DEBUG("set_field_value() tx_subrate               : %0d
",
-		       tx_subrate.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_hs_sym_div_sel: 0x%X
",
-		       cmnda_pll0_hs_sym_div_sel.value);
-
-		pll_feedback_divider_total =
-		    cmnda_pll0_fb_div_low.value + cmnda_pll0_fb_div_high.value + 4;
-		vco_freq_khz =
-		    pixel_freq_khz * pll_feedback_divider_total /
-		    cmnda_pll0_ip_div.value;
-		DRM_INFO("VCO frequency is %d
", vco_freq_khz);
-
-		/* Get right row from the t28hpc_hdmitx_pll_tuning_table_pixel_in table.
-		 * Check if 'vco_freq_khz' falls inside the
-		 * <PLL_VCO_FREQ_KHZ_MIN, PLL_VCO_FREQ_KHZ_MAX> range.
-		 * Consider only the rows with PLL_FEEDBACK_DIV_TOTAL
-		 * column matching pll_feedback_divider_total. */
-		row =
-		    get_table_row((const u32 *)&t28hpc_hdmitx_pll_tuning_table_pixel_in,
-				  T28HPC_HDMITX_PLL_TUNING_TABLE_ROWS_PIXEL_IN,
-				  T28HPC_HDMITX_PLL_TUNING_TABLE_COLS_PIXEL_IN,
-				  vco_freq_khz, T7_PLL_VCO_FREQ_KHZ_MIN,
-				  T7_PLL_VCO_FREQ_KHZ_MAX,
-				  T7_PLL_FEEDBACK_DIV_TOTAL,
-				  pll_feedback_divider_total);
-
-		if (row == -1) {
-			DRM_WARN("VCO frequency (%d KHz) not supported
",
-			       vco_freq_khz);
-			return 0;
-		}
-		DRM_INFO ("VCO frequency (%d KHz) is supported. Settings found in row %0d
",
-			     vco_freq_khz, row);
-
-		/* Extract particular values from
-		 * the t28hpc_hdmitx_pll_tuning_table_pixel_in table */
-		set_field_value(&voltage_to_current_coarse,
-				t28hpc_hdmitx_pll_tuning_table_pixel_in[row]
-				[T7_VOLTAGE_TO_CURRENT_COARSE]);
-		set_field_value(&voltage_to_current,
-				t28hpc_hdmitx_pll_tuning_table_pixel_in[row]
-				[T7_VOLTAGE_TO_CURRENT]);
-		set_field_value(&ndac_ctrl,
-				t28hpc_hdmitx_pll_tuning_table_pixel_in[row]
-				[T7_NDAC_CTRL]);
-		set_field_value(&pmos_ctrl,
-				t28hpc_hdmitx_pll_tuning_table_pixel_in[row]
-				[T7_PMOS_CTRL]);
-		set_field_value(&ptat_ndac_ctrl,
-				t28hpc_hdmitx_pll_tuning_table_pixel_in[row]
-				[T7_PTAT_NDAC_CTRL]);
-		set_field_value(&charge_pump_gain,
-				t28hpc_hdmitx_pll_tuning_table_pixel_in[row]
-				[T7_CHARGE_PUMP_GAIN]);
-
-		/* Display parameters (informative message) */
-		DRM_DEBUG("set_field_value() voltage_to_current_coarse : 0x%X
",
-		       voltage_to_current_coarse.value);
-		DRM_DEBUG("set_field_value() voltage_to_current        : 0x%X
",
-		       voltage_to_current.value);
-		DRM_DEBUG("set_field_value() ndac_ctrl                 : 0x%X
",
-		       ndac_ctrl.value);
-		DRM_DEBUG("set_field_value() pmos_ctrl                 : 0x%02X
",
-		       pmos_ctrl.value);
-		DRM_DEBUG("set_field_value() ptat_ndac_ctrl            : 0x%02X
",
-		       ptat_ndac_ctrl.value);
-		DRM_DEBUG("set_field_value() charge_pump_gain          : 0x%03X
",
-		       charge_pump_gain.value);
-
-	} else {
-		/* pixel_clk_from_phy == 1 */
-
-		/* Get right row from the t28hpc_hdmitx_clock_control_table_pixel_out table.
-		 * Check if 'pixel_freq_khz' value matches the PIXEL_CLK_FREQ_MHZ column.
-		 * Consider only the rows with FEEDBACK_FACTOR column matching feedback_factor. */
-		row =
-		    get_table_row((const u32 *)&t28hpc_hdmitx_clock_control_table_pixel_out,
-				  T28HPC_HDMITX_CLOCK_CONTROL_TABLE_ROWS_PIXEL_OUT,
-				  T28HPC_HDMITX_CLOCK_CONTROL_TABLE_COLS_PIXEL_OUT,
-				  pixel_freq_khz, T8_PIXEL_CLK_FREQ_KHZ,
-				  T8_PIXEL_CLK_FREQ_KHZ, T8_FEEDBACK_FACTOR,
-				  feedback_factor);
-
-		/* Check if row was found */
-		if (row == -1) {
-			DRM_WARN("Pixel clock frequency (%d KHz) not supported for this color depth (%0d-bit)
",
-			     pixel_freq_khz, bpp);
-			return 0;
-		}
-		DRM_INFO
-			 ("Pixel clock frequency (%d KHz) is supported in this color depth (%0d-bit). Settings found in row %0d
",
-			     pixel_freq_khz, bpp, row);
-
-		/* Extract particular values from
-		 * the t28hpc_hdmitx_clock_control_table_pixel_out table */
-		set_field_value(&cmnda_pll0_ip_div,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_PLL0_IP_DIV]);
-		set_field_value(&cmn_ref_clk_dig_div,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMN_REF_CLK_DIG_DIV]);
-		set_field_value(&divider_scaler,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_REF_CLK_DIVIDER_SCALER]);
-		set_field_value(&cmnda_pll0_fb_div_low,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_PLL0_FB_DIV_LOW]);
-		set_field_value(&cmnda_pll0_fb_div_high,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_PLL0_FB_DIV_HIGH]);
-		set_field_value(&cmnda_pll0_pxdiv_low,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_PLL0_PXDIV_LOW]);
-		set_field_value(&cmnda_pll0_pxdiv_high,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_PLL0_PXDIV_HIGH]);
-		set_field_value(&vco_ring_select,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_VCO_RING_SELECT]);
-		set_field_value(&cmnda_hs_clk_0_sel,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_HS_CLK_0_SEL]);
-		set_field_value(&cmnda_hs_clk_1_sel,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_HS_CLK_1_SEL]);
-		set_field_value(&tx_subrate,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_HSCLK_DIV_TX_SUB_RATE]);
-		set_field_value(&cmnda_pll0_hs_sym_div_sel,
-				t28hpc_hdmitx_clock_control_table_pixel_out[row]
-				[T8_CMNDA_PLL0_HS_SYM_DIV_SEL]);
-
-		/* Display parameters (informative message) */
-		DRM_DEBUG("set_field_value() cmnda_pll0_ip_div        : 0x%02X
",
-		       cmnda_pll0_ip_div.value);
-		DRM_DEBUG("set_field_value() cmn_ref_clk_dig_div      : 0x%X
",
-		       cmn_ref_clk_dig_div.value);
-		DRM_DEBUG("set_field_value() divider_scaler           : 0x%X
",
-		       divider_scaler.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_fb_div_low    : 0x%03X
",
-		       cmnda_pll0_fb_div_low.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_fb_div_high   : 0x%03X
",
-		       cmnda_pll0_fb_div_high.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_pxdiv_low     : 0x%03X
",
-		       cmnda_pll0_pxdiv_low.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_pxdiv_high    : 0x%03X
",
-		       cmnda_pll0_pxdiv_high.value);
-		DRM_DEBUG("set_field_value() vco_ring_select          : %0d
",
-		       vco_ring_select.value);
-		DRM_DEBUG("set_field_value() cmnda_hs_clk_0_sel       : %0d
",
-		       cmnda_hs_clk_0_sel.value);
-		DRM_DEBUG("set_field_value() cmnda_hs_clk_1_sel       : %0d
",
-		       cmnda_hs_clk_1_sel.value);
-		DRM_DEBUG("set_field_value() tx_subrate               : %0d
",
-		       tx_subrate.value);
-		DRM_DEBUG("set_field_value() cmnda_pll0_hs_sym_div_sel: 0x%X
",
-		       cmnda_pll0_hs_sym_div_sel.value);
-
-		pll_feedback_divider_total =
-		    cmnda_pll0_fb_div_low.value + cmnda_pll0_fb_div_high.value + 4;
-		vco_freq_khz =
-		    refclk_freq_khz * pll_feedback_divider_total / cmnda_pll0_ip_div.value;
-
-		DRM_INFO("VCO frequency is %d
", vco_freq_khz);
-
-		/* Get right row from the t28hpc_hdmitx_pll_tuning_table table_pixel_out.
-		 * Check if 'vco_freq_khz' falls inside
-		 * the <PLL_VCO_FREQ_KH_MIN, PLL_VCO_FREQ_KHZ_MAX> range.
-		 * Consider only the rows with PLL_FEEDBACK_DIV_TOTAL
-		 * column matching pll_feedback_divider_total. */
-		row =
-		    get_table_row((const u32 *)&t28hpc_hdmitx_pll_tuning_table_pixel_out,
-				  T28HPC_HDMITX_PLL_TUNING_TABLE_ROWS_PIXEL_OUT,
-				  T28HPC_HDMITX_PLL_TUNING_TABLE_COLS_PIXEL_OUT,
-				  vco_freq_khz, T9_PLL_VCO_FREQ_KHZ_MIN,
-				  T9_PLL_VCO_FREQ_KHZ_MAX,
-				  T9_PLL_FEEDBACK_DIV_TOTAL,
-				  pll_feedback_divider_total);
-
-		if (row == -1) {
-			DRM_WARN("VCO frequency (%d KHz) not supported
",
-			       vco_freq_khz);
-			return 0;
-		}
-		DRM_INFO("VCO frequency (%d KHz) is supported. Settings found in row %0d
",
-			     vco_freq_khz, row);
-
-		/* Extract particular values from
-		 * the t28hpc_hdmitx_pll_tuning_table_pixel_out table. */
-		set_field_value(&voltage_to_current_coarse,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_VOLTAGE_TO_CURRENT_COARSE]);
-		set_field_value(&voltage_to_current,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_VOLTAGE_TO_CURRENT]);
-		set_field_value(&ndac_ctrl,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_NDAC_CTRL]);
-		set_field_value(&pmos_ctrl,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_PMOS_CTRL]);
-		set_field_value(&ptat_ndac_ctrl,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_PTAT_NDAC_CTRL]);
-		set_field_value(&charge_pump_gain,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_CHARGE_PUMP_GAIN]);
-		set_field_value(&coarse_code,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_COARSE_CODE]);
-		set_field_value(&v2i_code,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_V2I_CODE]);
-		set_field_value(&vco_cal_code,
-				t28hpc_hdmitx_pll_tuning_table_pixel_out[row]
-				[T9_VCO_CAL_CODE]);
-
-		/* Display parameters (informative message) */
-		DRM_DEBUG("set_field_value() voltage_to_current_coarse : 0x%X
",
-		       voltage_to_current_coarse.value);
-		DRM_DEBUG("set_field_value() voltage_to_current        : 0x%X
",
-		       voltage_to_current.value);
-		DRM_DEBUG("set_field_value() ndac_ctrl                 : 0x%X
",
-		       ndac_ctrl.value);
-		DRM_DEBUG("set_field_value() pmos_ctrl                 : 0x%02X
",
-		       pmos_ctrl.value);
-		DRM_DEBUG("set_field_value() ptat_ndac_ctrl            : 0x%02X
",
-		       ptat_ndac_ctrl.value);
-		DRM_DEBUG("set_field_value() charge_pump_gain          : 0x%03X
",
-		       charge_pump_gain.value);
-		DRM_DEBUG("set_field_value() coarse_code               : %0d
",
-		       coarse_code.value);
-		DRM_DEBUG("set_field_value() v2i_code                  : %0d
",
-		       v2i_code.value);
-		DRM_DEBUG("set_field_value() vco_cal_code              : %0d
",
-		       vco_cal_code.value);
-	}
-
-	if (phy_reset_workaround) {
-		/* register PHY_PMA_ISOLATION_CTRL */
-		/* enable PHY isolation mode only for CMN */
-		Afe_write(state, 0xC81F, 0xD000);
-		/* register PHY_PMA_ISO_PLL_CTRL1 */
-		reg_val = Afe_read(state, 0xC812);
-		reg_val &= 0xFF00;
-		reg_val |= 0x0012;
-		/* set cmn_pll0_clk_datart1_div/cmn_pll0_clk_datart0_div dividers */
-		Afe_write(state, 0xC812, reg_val);
-		/* register PHY_ISO_CMN_CTRL */
-		/* assert PHY reset from isolation register */
-		Afe_write(state, 0xC010, 0x0000);
-		/* register PHY_PMA_ISO_CMN_CTRL */
-		/* assert PMA CMN reset */
-		Afe_write(state, 0xC810, 0x0000);
-		/* register XCVR_DIAG_BIDI_CTRL */
-		for (k = 0; k < num_lanes; k++) {
-			Afe_write(state, 0x40E8 | (k << 9), 0x00FF);
-		}
-	}
-	/* Describing Task phy_cfg_hdp */
-
-	/* register PHY_PMA_CMN_CTRL1 */
-	reg_val = Afe_read(state, 0xC800);
-	reg_val &= 0xFFF7;
-	reg_val |= 0x0008;
-	Afe_write(state, 0xC800, reg_val);
-
-	/* register CMN_DIAG_PLL0_TEST_MODE */
-	Afe_write(state, 0x01C4, 0x0020);
-	/* register CMN_PSM_CLK_CTRL */
-	Afe_write(state, 0x0061, 0x0016);
-
-	/* Describing Task phy_cfg_hdmi_pll0_0pt5736 */
-
-	/* register CMN_PLL0_VCOCAL_INIT_TMR */
-	Afe_write(state, 0x0084, 0x0064);
-	/* register CMN_PLL0_VCOCAL_ITER_TMR */
-	Afe_write(state, 0x0085, 0x000A);
-	/*register PHY_HDP_CLK_CTL */
-	reg_val = Afe_read(state, 0xC009);
-	reg_val &= 0x00FF;
-	reg_val |= 0x1200;
-	Afe_write(state, 0xC009, reg_val);
-	/* register CMN_DIAG_PLL0_INCLK_CTRL */
-	reg_val = set_reg_value(cmnda_pll0_hs_sym_div_sel);
-	reg_val |= set_reg_value(cmnda_pll0_ip_div);
-	Afe_write(state, 0x01CA, reg_val);
-	/* register CMN_DIAG_PLL0_FBH_OVRD */
-	reg_val = set_reg_value(cmnda_pll0_fb_div_high);
-	reg_val |= (1 << 15);
-	Afe_write(state, 0x01C0, reg_val);
-	/* register CMN_DIAG_PLL0_FBL_OVRD */
-	reg_val = set_reg_value(cmnda_pll0_fb_div_low);
-	reg_val |= (1 << 15);
-	Afe_write(state, 0x01C1, reg_val);
-	/*register PHY_PMA_CMN_CTRL1 */
-	reg_val = Afe_read(state, 0xC800);
-	reg_val &= 0xCFFF;
-	reg_val |= set_reg_value(cmn_ref_clk_dig_div);
-	Afe_write(state, 0xC800, reg_val);
-	/* register CMN_CDIAG_REFCLK_CTRL */
-	reg_val = Afe_read(state, 0x0062);
-	reg_val &= 0x8FFF;
-	reg_val |= set_reg_value(divider_scaler);
-	reg_val |= 0x00C0;
-	Afe_write(state, 0x0062, reg_val);
-	/*register CMN_DIAG_HSCLK_SEL */
-	reg_val = Afe_read(state, 0x01E0);
-	reg_val &= 0xFF00;
-	reg_val |= (cmnda_hs_clk_0_sel.value >> 1) << 0;
-	reg_val |= (cmnda_hs_clk_1_sel.value >> 1) << 4;
-	Afe_write(state, 0x01E0, reg_val);
-	/*register XCVR_DIAG_HSCLK_SEL */
-	for (k = 0; k < num_lanes; k++) {
-		reg_val = Afe_read(state, 0x40E1 | (k << 9));
-		reg_val &= 0xCFFF;
-		reg_val |= (cmnda_hs_clk_0_sel.value >> 1) << 12;
-		Afe_write(state, 0x40E1 | (k << 9), reg_val);
-	}
-	/* register TX_DIAG_TX_CTRL */
-	for (k = 0; k < num_lanes; k++) {
-		reg_val = Afe_read(state, 0x41E0 | (k << 9));
-		reg_val &= 0xFF3F;
-		reg_val |= (tx_subrate.value >> 1) << 6;
-		Afe_write(state, 0x41E0 | (k << 9), reg_val);
-	}
-	/* register CMN_PLLSM0_USER_DEF_CTRL */
-	reg_val = set_reg_value(vco_ring_select);
-	Afe_write(state, 0x002F, reg_val);
-	/* register CMN_DIAG_PLL0_OVRD */
-	Afe_write(state, 0x01C2, 0x0000);
-	/* register CMN_DIAG_PLL0_V2I_TUNE */
-	reg_val = set_reg_value(voltage_to_current_coarse);
-	reg_val |= set_reg_value(voltage_to_current);
-	Afe_write(state, 0x01C5, reg_val);
-	/* register CMN_DIAG_PLL0_PTATIS_TUNE1 */
-	reg_val = set_reg_value(pmos_ctrl);
-	reg_val |= set_reg_value(ndac_ctrl);
-	Afe_write(state, 0x01C8, reg_val);
-	/* register CMN_DIAG_PLL0_PTATIS_TUNE2 */
-	reg_val = set_reg_value(ptat_ndac_ctrl);
-	Afe_write(state, 0x01C9, reg_val);
-	/* register CMN_DIAG_PLL0_CP_TUNE */
-	reg_val = set_reg_value(charge_pump_gain);
-	Afe_write(state, 0x01C6, reg_val);
-	/* register CMN_DIAG_PLL0_LF_PROG */
-	Afe_write(state, 0x01C7, 0x0008);
-	/* register XCVR_DIAG_PLLDRC_CTRL */
-	for (k = 0; k < num_lanes; k++) {
-		reg_val = Afe_read(state, 0x40E0 | (k << 9));
-		reg_val &= 0xBFFF;
-		Afe_write(state, 0x40E0 | (k << 9), reg_val);
-	}
-	if (pixel_clk_from_phy == 1) {
-		/* register CMN_DIAG_PLL0_PXL_DIVL */
-		reg_val = set_reg_value(cmnda_pll0_pxdiv_low);
-		Afe_write(state, 0x01CC, reg_val);
-		/* register CMN_DIAG_PLL0_PXL_DIVH */
-		reg_val = set_reg_value(cmnda_pll0_pxdiv_high);
-		reg_val |= (1 << 15);
-		Afe_write(state, 0x01CB, reg_val);
-
-		/* register CMN_PLL0_VCOCAL_START */
-		reg_val = Afe_read(state, 0x0081);
-		reg_val &= 0xFE00;
-		reg_val |= set_reg_value(vco_cal_code);
-		Afe_write(state, 0x0081, reg_val);
-	}
-
-	/* Back to task phy_cfg_hdp */
-
-	/* register PHY_PMA_CMN_CTRL1 */
-	reg_val = Afe_read(state, 0xC800);
-	reg_val &= 0xFF8F;
-	/* for single ended reference clock
-	 * on the cmn_ref_clk_int pin: PHY_PMA_CMN_CTRL1[6:4]=3'b011 */
-	/* for differential clock on the refclk_p and
-	 * refclk_m off chip pins: PHY_PMA_CMN_CTRL1[6:4]=3'b000 */
-	reg_val |= 0x0000;
-	Afe_write(state, 0xC800, reg_val);
-
-	/*register CMN_DIAG_ACYA */
-	/* for differential clock on the refclk_p and
-	 * refclk_m off chip pins: CMN_DIAG_ACYA[8]=1'b1 */
-	Afe_write(state, 0x01FF, 0x0100);
-
-	if (phy_reset_workaround) {
-		/* register PHY_ISO_CMN_CTRL */
-		/* Deassert PHY reset */
-		Afe_write(state, 0xC010, 0x0001);
-		/* register PHY_PMA_ISO_CMN_CTRL */
-		Afe_write(state, 0xC810, 0x0003);
-		for (k = 0; k < num_lanes; k++) {
-			/* register XCVR_PSM_RCTRL */
-			Afe_write(state, 0x4001 | (k << 9), 0xFEFC);
-		}
-		/* register PHY_PMA_ISO_CMN_CTRL */
-		/* Assert cmn_macro_pwr_en */
-		Afe_write(state, 0xC810, 0x0013);
-
-		/* PHY_PMA_ISO_CMN_CTRL */
-		/* wait for cmn_macro_pwr_en_ack */
-		while (!(Afe_read(state, 0xC810) & (1 << 5)));
-
-		/* PHY_PMA_CMN_CTRL1 */
-		/* wait for cmn_ready */
-		while (!(Afe_read(state, 0xC800) & (1 << 0)));
-	} else {
-		for (k = 0; k < num_lanes; k++)
-			/* register XCVR_PSM_RCTRL */
-			Afe_write(state, 0x4001 | (k << 9), 0xBEFC);
-	}
-	for (k = 0; k < num_lanes; k++) {
-		/* register TX_PSC_A0 */
-		Afe_write(state, 0x4100 | (k << 9), 0x6791);
-		/* register TX_PSC_A1 */
-		Afe_write(state, 0x4101 | (k << 9), 0x6790);
-		/* register TX_PSC_A2 */
-		Afe_write(state, 0x4102 | (k << 9), 0x0090);
-		/* register TX_PSC_A3 */
-		Afe_write(state, 0x4103 | (k << 9), 0x0090);
-		/* register RX_PSC_CAL */
-		reg_val = Afe_read(state, 0x8006 | (k << 9));
-		reg_val &= 0xFFBB;
-		Afe_write(state, 0x8006 | (k << 9), reg_val);
-		/* register RX_PSC_A0 */
-		reg_val = Afe_read(state, 0x8000 | (k << 9));
-		reg_val &= 0xFFBB;
-		Afe_write(state, 0x8000 | (k << 9), reg_val);
-	}
-
-	/* register PHY_HDP_MODE_CTL */
-	Afe_write(state, 0xC008, 0x0004);
-
-	return character_freq_khz;
-}
-
-int hdmi_tx_t28hpc_power_config_seq(state_struct *state, int num_lanes)
-{
-	unsigned char k;
-
-	/* Configure the power state.
-	 * register TX_DIAG_ACYA */
-	for (k = 0; k < num_lanes; k++) {
-		/* register XCVR_PSM_CAL_TMR */
-		Afe_write(state, 0x41FF | (k << 9), 0x0001);
-	}
-
-	/* register PHY_DP_MODE_CTL */
-	while (!(Afe_read(state, 0xC008) & (1 << 6)));
-
-	imx_arc_power_up(state);
-	imx_arc_calibrate(state);
-	imx_arc_config(state);
-
-	/* PHY_DP_MODE_CTL */
-	Afe_write(state, 0xC008, (((0x0F << num_lanes) & 0x0F) << 12) | 0x0101);
-
-	/* PHY_DP_MODE_CTL */
-	while (!(Afe_read(state, 0xC008) & (1 << 4)));
-
-	return 0;
-}
diff --git a/drivers/gpu/drm/panel/Kconfig b/drivers/gpu/drm/panel/Kconfig
index 450dc88958ef..1582b88839b4 100644
--- a/drivers/gpu/drm/panel/Kconfig
+++ b/drivers/gpu/drm/panel/Kconfig
@@ -348,7 +348,6 @@ config DRM_PANEL_TPO_TPG110
 	  400CH LTPS TFT LCD Single Chip Digital Driver for up to
 	  800x400 LCD panels.
 
-<<<<<<< HEAD
 config DRM_PANEL_TRULY_NT35597_WQXGA
 	tristate "Truly WQXGA"
 	depends on OF
@@ -356,7 +355,7 @@ config DRM_PANEL_TRULY_NT35597_WQXGA
 	help
 	  Say Y here if you want to enable support for Truly NT35597 WQXGA Dual DSI
 	  Video Mode panel
-=======
+
 config DRM_PANEL_TIANMA_TM050JDHC02
 	tristate "TianMa TM050JDHC02 FHD panel"
 	depends on OF
@@ -374,5 +373,4 @@ config DRM_PANEL_DATAIMAGE_5INCHLCM
 	help
 	  Say Y here if you want to enable support for DataImage 5InchLCM HD
 	  (1280x720) DSI panel.
->>>>>>> android_10_idt_dev_200527-2
 endmenu
diff --git a/drivers/gpu/drm/panel/Makefile b/drivers/gpu/drm/panel/Makefile
index 31d26e8eba09..cf13d47263d1 100644
--- a/drivers/gpu/drm/panel/Makefile
+++ b/drivers/gpu/drm/panel/Makefile
@@ -33,14 +33,10 @@ obj-$(CONFIG_DRM_PANEL_SHARP_LS037V7DW01) += panel-sharp-ls037v7dw01.o
 obj-$(CONFIG_DRM_PANEL_SHARP_LS043T1LE01) += panel-sharp-ls043t1le01.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7701) += panel-sitronix-st7701.o
 obj-$(CONFIG_DRM_PANEL_SITRONIX_ST7789V) += panel-sitronix-st7789v.o
-<<<<<<< HEAD
 obj-$(CONFIG_DRM_PANEL_SONY_ACX565AKM) += panel-sony-acx565akm.o
 obj-$(CONFIG_DRM_PANEL_TPO_TD028TTEC1) += panel-tpo-td028ttec1.o
 obj-$(CONFIG_DRM_PANEL_TPO_TD043MTEA1) += panel-tpo-td043mtea1.o
 obj-$(CONFIG_DRM_PANEL_TPO_TPG110) += panel-tpo-tpg110.o
 obj-$(CONFIG_DRM_PANEL_TRULY_NT35597_WQXGA) += panel-truly-nt35597.o
-=======
-obj-$(CONFIG_DRM_PANEL_RAYDIUM_RM67191) += panel-raydium-rm67191.o
 obj-$(CONFIG_DRM_PANEL_TIANMA_TM050JDHC02) += panel-ilitek-ili9881c_idt.o
 obj-$(CONFIG_DRM_PANEL_DATAIMAGE_5INCHLCM) += panel-himax-hx8394f.o
->>>>>>> android_10_idt_dev_200527-2
diff --git a/drivers/input/touchscreen/goodix.c b/drivers/input/touchscreen/goodix.c
index aa9c60f0efed..9012d0c60ed0 100644
--- a/drivers/input/touchscreen/goodix.c
+++ b/drivers/input/touchscreen/goodix.c
@@ -55,12 +55,9 @@ struct goodix_ts_data {
 	const char *cfg_name;
 	struct completion firmware_loading_complete;
 	unsigned long irq_flags;
-<<<<<<< HEAD
 	unsigned int contact_size;
-=======
 	unsigned irq_tmp;
 	unsigned rst_tmp;
->>>>>>> android_10_idt_dev_200527-2
 };
 
 #define GOODIX_GPIO_INT_NAME		"irq"
@@ -596,7 +593,9 @@ static int goodix_get_gpio_config(struct goodix_ts_data *ts)
 	if (!ts->client)
 		return -EINVAL;
 
-<<<<<<< HEAD
+	dev = &ts->client->dev;
+	np = dev->of_node;
+
 	ts->avdd28 = devm_regulator_get(dev, "AVDD28");
 	if (IS_ERR(ts->avdd28)) {
 		error = PTR_ERR(ts->avdd28);
@@ -615,10 +614,6 @@ static int goodix_get_gpio_config(struct goodix_ts_data *ts)
 		return error;
 	}
 
-=======
-	dev = &ts->client->dev;
-	np = dev->of_node;
->>>>>>> android_10_idt_dev_200527-2
 	/* Get the interrupt GPIO pin number */
 	gpiod = devm_gpiod_get_optional(dev, GOODIX_GPIO_INT_NAME, GPIOD_IN);
 	if (IS_ERR(gpiod)) {
diff --git a/drivers/misc/Kconfig b/drivers/misc/Kconfig
index 1e826c83580d..921bf8f4abee 100644
--- a/drivers/misc/Kconfig
+++ b/drivers/misc/Kconfig
@@ -382,25 +382,12 @@ config DS1682
 	  This driver can also be built as a module.  If so, the module
 	  will be called ds1682.
 
-<<<<<<< HEAD
-=======
-config SPEAR13XX_PCIE_GADGET
-	bool "PCIe gadget support for SPEAr13XX platform"
-	depends on ARCH_SPEAR13XX && BROKEN
-	default n
-	help
-	 This option enables gadget support for PCIe controller. If
-	 board file defines any controller as PCIe endpoint then a sysfs
-	 entry will be created for that controller. User can use these
-	 sysfs node to configure PCIe EP as per his requirements.
-
 config IDG_SPI
 	tristate "IDG SPI Communication Support"
 	help
 	  This driver supports IDG SPI from the idtech on
 	  Android platform.
 
->>>>>>> android_10_idt_dev_200527-2
 config VMWARE_BALLOON
 	tristate "VMware Balloon Driver"
 	depends on VMWARE_VMCI && X86 && HYPERVISOR_GUEST
diff --git a/drivers/net/phy/micrel.c b/drivers/net/phy/micrel.c
index c86b40eb5ead..954bb3d6fbc0 100644
--- a/drivers/net/phy/micrel.c
+++ b/drivers/net/phy/micrel.c
@@ -691,11 +691,7 @@ static int ksz9131_of_load_skew_values(struct phy_device *phydev,
 		return 0;
 
 	if (matches < numfields)
-<<<<<<< HEAD
 		newval = phy_read_mmd(phydev, 2, reg);
-=======
-		newval = ksz9031_extended_read(phydev, OP_DATA, 2, reg);
->>>>>>> android_10_idt_dev_200527-2
 	else
 		newval = 0;
 
@@ -709,11 +705,7 @@ static int ksz9131_of_load_skew_values(struct phy_device *phydev,
 					<< (field_sz * i));
 		}
 
-<<<<<<< HEAD
 	return phy_write_mmd(phydev, 2, reg, newval);
-=======
-	return ksz9031_extended_write(phydev, OP_DATA, 2, reg, newval);
->>>>>>> android_10_idt_dev_200527-2
 }
 
 static int ksz9131_config_init(struct phy_device *phydev)
@@ -732,10 +724,6 @@ static int ksz9131_config_init(struct phy_device *phydev)
 	char *control_skews[2] = {"txen-skew-psec", "rxdv-skew-psec"};
 	const struct device *dev_walker;
 	int ret;
-<<<<<<< HEAD
-=======
-	int reg;
->>>>>>> android_10_idt_dev_200527-2
 
 	dev_walker = &phydev->mdio.dev;
 	do {
@@ -770,11 +758,6 @@ static int ksz9131_config_init(struct phy_device *phydev)
 	if (ret < 0)
 		return ret;
 
-<<<<<<< HEAD
-	return 0;
-}
-
-=======
 	ret=phy_write_mmd(phydev, 0x2, 0x0004,0);
 	if (ret < 0)
 		return ret;
@@ -789,7 +772,6 @@ static int ksz9131_config_init(struct phy_device *phydev)
 }
 
 
->>>>>>> android_10_idt_dev_200527-2
 #define KSZ8873MLL_GLOBAL_CONTROL_4	0x06
 #define KSZ8873MLL_GLOBAL_CONTROL_4_DUPLEX	BIT(6)
 #define KSZ8873MLL_GLOBAL_CONTROL_4_SPEED	BIT(4)
diff --git a/drivers/spi/spidev.c b/drivers/spi/spidev.c
index cafacac7a960..bae7e942dc44 100644
--- a/drivers/spi/spidev.c
+++ b/drivers/spi/spidev.c
@@ -662,13 +662,10 @@ static const struct of_device_id spidev_dt_ids[] = {
 	{ .compatible = "lineartechnology,ltc2488" },
 	{ .compatible = "ge,achc" },
 	{ .compatible = "semtech,sx1301" },
-<<<<<<< HEAD
 	{ .compatible = "lwn,bk4" },
 	{ .compatible = "dh,dhcom-board" },
 	{ .compatible = "menlo,m53cpld" },
-=======
 	{ .compatible = "spidev" }, /* for device entry test */
->>>>>>> android_10_idt_dev_200527-2
 	{},
 };
 MODULE_DEVICE_TABLE(of, spidev_dt_ids);
diff --git a/drivers/usb/typec/Kconfig b/drivers/usb/typec/Kconfig
index 2832fa4a8a4d..4e1f6d737196 100644
--- a/drivers/usb/typec/Kconfig
+++ b/drivers/usb/typec/Kconfig
@@ -46,17 +46,7 @@ menuconfig TYPEC
 
 if TYPEC
 
-<<<<<<< HEAD
 source "drivers/usb/typec/tcpm/Kconfig"
-=======
-config TYPEC_TCPM
-	tristate "USB Type-C Port Controller Manager"
-	depends on USB
-	select USB_ROLE_SWITCH
-	select POWER_SUPPLY
-	help
-	  The Type-C Port Controller Manager provides a USB PD and USB Type-C
-	  state machine for use with Type-C Port Controllers.
 
 config TYPEC_HD3SS3220
 	tristate "TI HD3SS3220 Type-C DRP Port controller driver"
@@ -68,44 +58,6 @@ config TYPEC_HD3SS3220
 	  If you choose to build this driver as a dynamically linked module, the
 	  module will be called hd3ss3220.ko.
 
-if TYPEC_TCPM
-
-config TYPEC_TCPCI
-	tristate "Type-C Port Controller Interface driver"
-	depends on I2C
-	select REGMAP_I2C
-	select GPIOLIB
-	help
-	  Type-C Port Controller driver for TCPCI-compliant controller.
-
-config TYPEC_RT1711H
-	tristate "Richtek RT1711H Type-C chip driver"
-	depends on I2C
-	select TYPEC_TCPCI
-	help
-	  Richtek RT1711H Type-C chip driver that works with
-	  Type-C Port Controller Manager to provide USB PD and USB
-	  Type-C functionalities.
-
-source "drivers/usb/typec/fusb302/Kconfig"
-
-config TYPEC_WCOVE
-	tristate "Intel WhiskeyCove PMIC USB Type-C PHY driver"
-	depends on ACPI
-	depends on INTEL_SOC_PMIC
-	depends on INTEL_PMC_IPC
-	depends on BXT_WC_PMIC_OPREGION
-	help
-	  This driver adds support for USB Type-C detection on Intel Broxton
-	  platforms that have Intel Whiskey Cove PMIC. The driver can detect the
-	  role and cable orientation.
-
-	  To compile this driver as module, choose M here: the module will be
-	  called typec_wcove
-
-endif # TYPEC_TCPM
->>>>>>> android_10_idt_dev_200527-2
-
 source "drivers/usb/typec/ucsi/Kconfig"
 
 config TYPEC_TPS6598X
diff --git a/drivers/usb/typec/Makefile b/drivers/usb/typec/Makefile
index a004130b1ceb..c2453c6f7189 100644
--- a/drivers/usb/typec/Makefile
+++ b/drivers/usb/typec/Makefile
@@ -6,9 +6,4 @@ obj-$(CONFIG_TYPEC_TCPM)	+= tcpm/
 obj-$(CONFIG_TYPEC_UCSI)	+= ucsi/
 obj-$(CONFIG_TYPEC_TPS6598X)	+= tps6598x.o
 obj-$(CONFIG_TYPEC)		+= mux/
-<<<<<<< HEAD
-=======
-obj-$(CONFIG_TYPEC_TCPCI)	+= tcpci.o
-obj-$(CONFIG_TYPEC_RT1711H)	+= tcpci_rt1711h.o
 obj-$(CONFIG_TYPEC_HD3SS3220)	+= hd3ss3220.o
->>>>>>> android_10_idt_dev_200527-2
diff --git a/drivers/video/fbdev/core/fbcon.c b/drivers/video/fbdev/core/fbcon.c
index fdd53dec77e9..d77fae24bb06 100644
--- a/drivers/video/fbdev/core/fbcon.c
+++ b/drivers/video/fbdev/core/fbcon.c
@@ -88,7 +88,6 @@
 #  define DPRINTK(fmt, args...)
 #endif
 
-<<<<<<< HEAD
 /*
  * FIXME: Locking
  *
@@ -107,9 +106,7 @@
  *   fbmem.c cannot use locking asserts, and there's lots of callers which get
  *   the rules wrong, e.g. fbsysfs.c entirely missed fb_lock/unlock calls too.
  */
-=======
 #define CONSOLE_CURSOR_SHOWING		0	/* enable: 1, disable: 0 */
->>>>>>> android_10_idt_dev_200527-2
 
 enum {
 	FBCON_LOGO_CANSHOW	= -1,	/* the logo can be shown */
@@ -694,14 +691,11 @@ static void fbcon_prepare_logo(struct vc_data *vc, struct fb_info *info,
 		vc->vc_pos += logo_lines * vc->vc_size_row;
 		kfree(save);
 	}
-<<<<<<< HEAD
+#endif /* CONSOLE_CURSOR_SHOWING */
 
 	if (logo_shown == FBCON_LOGO_DONTSHOW)
 		return;
 
-=======
-#endif /* CONSOLE_CURSOR_SHOWING */
->>>>>>> android_10_idt_dev_200527-2
 	if (logo_lines > vc->vc_bottom) {
 		logo_shown = FBCON_LOGO_CANSHOW;
 		printk(KERN_INFO
diff --git a/drivers/video/fbdev/core/fbmem.c b/drivers/video/fbdev/core/fbmem.c
index 9bff9055555e..b309cde4f4dd 100644
--- a/drivers/video/fbdev/core/fbmem.c
+++ b/drivers/video/fbdev/core/fbmem.c
@@ -500,7 +500,6 @@ static int fb_show_logo_line(struct fb_info *info, int rotate,
 		image.data = logo_new;
 		fb_set_logo(info, logo, logo_new, fb_logo.depth);
 	}
-<<<<<<< HEAD
 
 	if (fb_center_logo) {
 		int xres = info->var.xres;
@@ -520,7 +519,6 @@ static int fb_show_logo_line(struct fb_info *info, int rotate,
 		image.dy = y;
 	}
 
-=======
 #ifdef CONFIG_SPLASH_SCREEN_CENTERED
 	/* To show logo at center layout */
 	image.dx = ((info->var.xres / 2) - (logo->width / 2));
@@ -529,7 +527,6 @@ static int fb_show_logo_line(struct fb_info *info, int rotate,
 	image.dx = 0;
 	image.dy = y;
 #endif /* CONFIG_SPLASH_SCREEN_CENTERED */
->>>>>>> android_10_idt_dev_200527-2
 	image.width = logo->width;
 	image.height = logo->height;
 
diff --git a/sound/soc/codecs/rt5640.c b/sound/soc/codecs/rt5640.c
index a01876cc2237..fc8f2ed5308b 100644
--- a/sound/soc/codecs/rt5640.c
+++ b/sound/soc/codecs/rt5640.c
@@ -2825,13 +2825,8 @@ static int rt5640_i2c_probe(struct i2c_client *i2c,
 	regmap_update_bits(rt5640->regmap, RT5640_DUMMY1,
 				RT5640_MCLK_DET, RT5640_MCLK_DET);
 
-<<<<<<< HEAD
 	rt5640->hp_mute = true;
 	rt5640->irq = i2c->irq;
-=======
-	rt5640->hp_mute = 1;
-	rt5640->irq = irq;
->>>>>>> android_10_idt_dev_200527-2
 	INIT_DELAYED_WORK(&rt5640->bp_work, rt5640_button_press_work);
 	INIT_WORK(&rt5640->jack_work, rt5640_jack_work);
 
diff --git a/sound/soc/fsl/Makefile b/sound/soc/fsl/Makefile
index e71f473ff3b2..d62594f2ba7a 100644
--- a/sound/soc/fsl/Makefile
+++ b/sound/soc/fsl/Makefile
@@ -120,14 +120,8 @@ obj-$(CONFIG_SND_SOC_IMX_MQS) += snd-soc-imx-mqs.o
 obj-$(CONFIG_SND_SOC_IMX_PDM_MIC) += snd-soc-imx-pdm.o
 obj-$(CONFIG_SND_SOC_IMX_AK4458) += snd-soc-imx-ak4458.o
 obj-$(CONFIG_SND_SOC_IMX_AK5558) += snd-soc-imx-ak5558.o
-<<<<<<< HEAD
 obj-$(CONFIG_SND_SOC_IMX_AK4497) += snd-soc-imx-ak4497.o
-=======
-obj-$(CONFIG_SND_SOC_IMX_CDNHDMI) += snd-soc-imx-cdnhdmi.o
-obj-$(CONFIG_SND_SOC_IMX_HDMI) += snd-soc-imx-hdmi.o
 obj-$(CONFIG_SND_SOC_IMX_RT5640) += snd-soc-imx-rt5640.o
-obj-$(CONFIG_SND_SOC_IMX_DSP) += snd-soc-imx-dsp.o
->>>>>>> android_10_idt_dev_200527-2
 obj-$(CONFIG_SND_SOC_IMX_MICFIL) += snd-soc-imx-micfil.o
 obj-$(CONFIG_SND_SOC_IMX_DSP) += snd-soc-imx-dsp.o
 obj-$(CONFIG_SND_SOC_IMX_SI476X) += snd-soc-imx-si476x.o
