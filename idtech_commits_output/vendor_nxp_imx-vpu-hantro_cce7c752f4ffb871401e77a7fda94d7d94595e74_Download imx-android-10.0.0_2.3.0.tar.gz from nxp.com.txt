cce7c75 jenkins 2020-07-17

Download imx-android-10.0.0_2.3.0.tar.gz from nxp.com

Change-Id: I2b9b372ecef1af25f367dca15672675610188e4f

diff --git a/Makefile_G1G2 b/Makefile_G1G2
index b63c608..8f83391 100755
--- a/Makefile_G1G2
+++ b/Makefile_G1G2
@@ -18,6 +18,10 @@ CFLAGS += -DDEC_MODULE_PATH=\"/dev/mxc_hantro\" -DUSE_FAKE_RFC_TABLE -DFIFO_DATA
            -DDEC_X170_OUTPUT_FORMAT=0 -DDEC_X170_TIMEOUT_LENGTH=-1 -DENABLE_HEVC_SUPPORT \
            -DENABLE_VP9_SUPPORT -DUSE_ION
 
+ifeq ($(CFG_SECURE_DATA_PATH), y)
+CFLAGS += -DCFG_SECURE_DATA_PATH
+endif
+
 #CFLAGS += -D_SW_DEBUG_PRINT -D_DWL_DEBUG
 #CFLAGS += -DCLEAR_HDRINFO_IN_SEEK
 CFLAGS += -DDWL_DISABLE_REG_PRINTS
diff --git a/Makefile_H1 b/Makefile_H1
index 961303e..30452b1 100755
--- a/Makefile_H1
+++ b/Makefile_H1
@@ -20,6 +20,10 @@ ENV += -DUSE_ION
 #ENV += -I$(LINUX_KERNEL_ROOT)/include/uapi -I$(LINUX_KERNEL_ROOT)/include
 ENV += -I$(SDKTARGETSYSROOT)/usr/include/imx
 
+ifeq ($(CFG_SECURE_DATA_PATH), y)
+ENV += -DCFG_SECURE_DATA_PATH
+endif
+
 LIBENCNAME = libcodec_enc
 LIBSENC = -L./ -lhantro_h1 -lpthread
 
@@ -50,7 +54,7 @@ $(LIBH1NAME).a:
 	$(AR) -rc $@ $(LIBH1_LIBS) 
 
 $(LIBH1NAME).so.$(SONAMEVERSION): $(LIBH1NAME).a
-	$(CC) -o $@ $(LDFLAGS) -shared -nostartfiles -Wl,-soname,$@ -Wl,--whole-archive $(LIBH1_LIBS) -Wl,--no-whole-archive
+	$(CC) -o $@ $(LDFLAGS) -shared -nostartfiles -Wl,-Bsymbolic -Wl,-soname,$@ -Wl,--whole-archive $(LIBH1_LIBS) -Wl,--no-whole-archive
 
 $(LIBH1NAME).so: $(LIBH1NAME).so.$(SONAMEVERSION)
 	ln -fs $< $@
diff --git a/decoder_sw/software/common/common.mk b/decoder_sw/software/common/common.mk
index c8ff0e9..936406a 100755
--- a/decoder_sw/software/common/common.mk
+++ b/decoder_sw/software/common/common.mk
@@ -251,6 +251,15 @@ endif
 
 # Enable WaitListNotInUse so that buffer can be released safely.
 #DEFINES += -DUSE_EXT_BUF_SAFE_RELEASE
+# Enable null pointer judgement for picture buffer in VSI environment.
+#DEFINES += -DUSE_NULL_POINTER_PROTECT
+
+# For some files/tools, customer and VSI have different method,
+# use this to fix conflict.
+#DEFINES += -DUSE_VSI_ENV
+
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
 
 #  DEFINES += -DCLEAR_OUT_BUFFER
 
diff --git a/decoder_sw/software/linux/dwl/dwl_linux.c b/decoder_sw/software/linux/dwl/dwl_linux.c
index 6de0c8a..b56c4b0 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux.c
@@ -39,7 +39,11 @@
 #include "dwl_defs.h"
 #include "dwl_linux.h"
 #include "dwl.h"
+#ifdef USE_VSI_ENV
+#include "hantrodec.h"
+#else
 #include <linux/hantrodec.h>
+#endif
 #ifdef USE_ION
 #include <linux/ion.h>
 #include <linux/dma-buf.h>
@@ -647,8 +651,9 @@ void DWLReadAsicConfig(DWLHwConfig *hw_cfg,u32 client_type) {
   unsigned long base;
   i32 core_id,idx=0;
   static struct asic_cfg_info asic_cfg_info[2]; /*idx 0:G1, idx 1:G2*/
-
-  //int fd = (-1);
+#ifdef USE_VSI_ENV
+  int fd = (-1);
+#endif
   int fd_dec = (-1);
 
   DWL_DEBUG("client_type=%d
",client_type);
@@ -677,12 +682,13 @@ void DWLReadAsicConfig(DWLHwConfig *hw_cfg,u32 client_type) {
   	}
   
   asic_cfg_info[idx].is_read = 1;
-
-  //fd = open("/dev/mem", O_RDONLY);
-  //if (fd == -1) {
-  //  DWL_DEBUG("%s","failed to open /dev/mem
");
-  //  goto end;
-  //}
+#ifdef USE_VSI_ENV
+  fd = open("/dev/mem", O_RDONLY);
+  if (fd == -1) {
+    DWL_DEBUG("%s","failed to open /dev/mem
");
+    goto end;
+  }
+#endif
   
   fd_dec = open(DEC_MODULE_PATH, O_RDONLY);
   if (fd_dec == -1) {
@@ -742,7 +748,9 @@ void DWLReadAsicConfig(DWLHwConfig *hw_cfg,u32 client_type) {
 #endif
 
 end:
-  //if (fd != -1) close(fd);
+#ifdef USE_VSI_ENV
+  if (fd != -1) close(fd);
+#endif
   if (fd_dec != -1) close(fd_dec);
   pthread_mutex_unlock(&dwl_asic_read_mutex);
   return;
@@ -753,18 +761,19 @@ void DWLReadMCAsicConfig(DWLHwConfig hw_cfg[MAX_ASIC_CORES]) {
   unsigned int reg_size;
   unsigned int n_cores, i;
   unsigned long mc_reg_base[MAX_ASIC_CORES];
-
-  //int fd = (-1);
+#ifdef USE_VSI_ENV
+  int fd = (-1);
+#endif
   int fd_dec = (-1);
 
   DWL_DEBUG("%s","
");
-
-  //fd = open("/dev/mem", O_RDONLY);
-  //if (fd == -1) {
-  //  DWL_DEBUG("%s","failed to open /dev/mem
");
-  //  goto end;
-  //}
-
+#ifdef USE_VSI_ENV
+  fd = open("/dev/mem", O_RDONLY);
+  if (fd == -1) {
+    DWL_DEBUG("%s","failed to open /dev/mem
");
+    goto end;
+  }
+#endif
   fd_dec = open(DEC_MODULE_PATH, O_RDONLY);
   if (fd_dec == -1) {
     DWL_DEBUG("failed to open %s
", DEC_MODULE_PATH);
@@ -817,7 +826,9 @@ void DWLReadMCAsicConfig(DWLHwConfig hw_cfg[MAX_ASIC_CORES]) {
   }
 
 end:
-  //if (fd != -1) close(fd);
+#ifdef USE_VSI_ENV
+  if (fd != -1) close(fd);
+#endif
   if (fd_dec != -1) close(fd_dec);
 }
 
@@ -834,20 +845,21 @@ void DWLReadAsicFuseStatus(struct DWLHwFuseStatus *hw_fuse_sts) {
 
   unsigned long base;
   unsigned int reg_size;
-
-  //int fd = (-1);
+#ifdef USE_VSI_ENV
+  int fd = (-1);
+#endif
   int fd_dec = (-1);
 
   DWL_DEBUG("%s","
");
 
   memset(hw_fuse_sts, 0, sizeof(*hw_fuse_sts));
-
-  //fd = open("/dev/mem", O_RDONLY);
-  //if (fd == -1) {
-  //  DWL_DEBUG("%s","failed to open /dev/mem
");
-  //  goto end;
-  //}
-
+#ifdef USE_VSI_ENV
+  fd = open("/dev/mem", O_RDONLY);
+  if (fd == -1) {
+    DWL_DEBUG("%s","failed to open /dev/mem
");
+    goto end;
+  }
+#endif
   fd_dec = open(DEC_MODULE_PATH, O_RDONLY);
   if (fd_dec == -1) {
     DWL_DEBUG("failed to open %s
", DEC_MODULE_PATH);
@@ -890,7 +902,9 @@ void DWLReadAsicFuseStatus(struct DWLHwFuseStatus *hw_fuse_sts) {
 #endif
 
 end:
-  //if (fd != -1) close(fd);
+#ifdef USE_VSI_ENV
+  if (fd != -1) close(fd);
+#endif
   if (fd_dec != -1) close(fd_dec);
 }
 
@@ -1248,7 +1262,53 @@ bail:
 
 #else  //USE_ION
 
-//non-ION not supported
+//non-ION not supported in customer env
+i32 DWLMallocLinear(const void *instance, u32 size, struct DWLLinearMem *info) {
+  struct HANTRODWL *dec_dwl = (struct HANTRODWL *)instance;
+
+  u32 pgsize = getpagesize();
+  MemallocParams params;
+
+  assert(dec_dwl != NULL);
+  assert(info != NULL);
+
+#ifdef MEMORY_USAGE_TRACE
+  printf("DWLMallocLinear	%8d bytes 
", size);
+#endif
+
+  info->logical_size = size;
+  info->size = NEXT_MULTIPLE(size, pgsize);
+  info->virtual_address = MAP_FAILED;
+  info->bus_address = 0;
+
+  params.size = info->size;
+
+  /* get memory linear memory buffers */
+  ioctl(dec_dwl->fd_memalloc, MEMALLOC_IOCXGETBUFFER, &params);
+  if (params.bus_address == 0) {
+    DWL_DEBUG("%s","ERROR! No linear buffer available
");
+    return DWL_ERROR;
+  }
+
+  /* The bus address for mmap and HW may be different. translation_offset
+   * is used to calculate the bus address for HW access. If no translation is
+   * needed memalloc-driver sets it to 0 */
+  info->bus_address = params.bus_address - params.translation_offset;
+
+  /* Map the bus address to virtual address */
+  info->virtual_address =
+    (u32 *)mmap(0, info->size, PROT_READ | PROT_WRITE, MAP_SHARED,
+                dec_dwl->fd_mem, params.bus_address);
+
+#ifdef MEMORY_USAGE_TRACE
+  printf("DWLMallocLinear 0x%08x virtual_address: 0x%08x (type %d)
", info->bus_address,
+         (unsigned)info->virtual_address, info->mem_type);
+#endif
+
+  if (info->virtual_address == MAP_FAILED) return DWL_ERROR;
+
+  return DWL_OK;
+}
 
 #endif //USE_ION
 
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_hw.c b/decoder_sw/software/linux/dwl/dwl_linux_hw.c
index 5c6c278..63d71c2 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_hw.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_hw.c
@@ -37,7 +37,11 @@
 #include "basetype.h"
 #include "dwl_linux.h"
 #include "dwl.h"
+#ifdef USE_VSI_ENV
+#include "hantrodec.h"
+#else
 #include <linux/hantrodec.h>
+#endif
 #include "memalloc.h"
 
 #include <assert.h>
@@ -127,13 +131,14 @@ const void *DWLInit(struct DWLInitParam *param) {
       goto err;
     }
   }
+#ifdef USE_VSI_ENV
+  dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
 
-  //dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
-
-  //if (dec_dwl->fd_mem == -1) {
-  //  DWL_DEBUG("failed to open: %s
", "/dev/mem");
-  //  goto err;
-  //}
+  if (dec_dwl->fd_mem == -1) {
+    DWL_DEBUG("failed to open: %s
", "/dev/mem");
+    goto err;
+  }
+#endif
 
   switch (dec_dwl->client_type) {
   case DWL_CLIENT_TYPE_H264_DEC:
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_mc.c b/decoder_sw/software/linux/dwl/dwl_linux_mc.c
index 8cf950f..3147955 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_mc.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_mc.c
@@ -216,13 +216,14 @@ const void *DWLInit(struct DWLInitParam * param) {
       goto err;
     }
   }
+#ifdef USE_VSI_ENV
+  dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
 
-  //dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
-
-  //if(dec_dwl->fd_mem == -1) {
-  //  DWL_DEBUG("failed to open: %s
", "/dev/mem");
-  //  goto err;
-  //}
+  if(dec_dwl->fd_mem == -1) {
+    DWL_DEBUG("failed to open: %s
", "/dev/mem");
+    goto err;
+  }
+#endif
 
   switch (dec_dwl->client_type) {
   case DWL_CLIENT_TYPE_H264_DEC:
diff --git a/decoder_sw/software/linux/dwl/dwl_linux_sc.c b/decoder_sw/software/linux/dwl/dwl_linux_sc.c
index 563402c..d1811f3 100755
--- a/decoder_sw/software/linux/dwl/dwl_linux_sc.c
+++ b/decoder_sw/software/linux/dwl/dwl_linux_sc.c
@@ -39,7 +39,11 @@
 #include "dwl_linux.h"
 #include "dwl.h"
 #include "dwlthread.h"
+#ifdef USE_VSI_ENV
+#include "hantrodec.h"
+#else
 #include <linux/hantrodec.h>
+#endif
 #include "memalloc.h"
 
 #include <assert.h>
@@ -118,14 +122,14 @@ const void *DWLInit(struct DWLInitParam * param) {
 	  goto err;
 	}
   }
+#ifdef USE_VSI_ENV
+  dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
 
-  //dec_dwl->fd_mem = open("/dev/mem", O_RDWR | O_SYNC);
-
-  //if(dec_dwl->fd_mem == -1) {
-  //	DWL_DEBUG("failed to open: %s
", "/dev/mem");
-  //	goto err;
-  //}
-
+  if(dec_dwl->fd_mem == -1) {
+	DWL_DEBUG("failed to open: %s
", "/dev/mem");
+	goto err;
+  }
+#endif
   switch (dec_dwl->client_type) {
   case DWL_CLIENT_TYPE_H264_DEC:
   case DWL_CLIENT_TYPE_MPEG4_DEC:
diff --git a/decoder_sw/software/linux/h264high/Makefile b/decoder_sw/software/linux/h264high/Makefile
index 9d102e9..556ff71 100755
--- a/decoder_sw/software/linux/h264high/Makefile
+++ b/decoder_sw/software/linux/h264high/Makefile
@@ -86,6 +86,8 @@ DEBFLAGS += -DENABLE_DPB_RECOVER
 
 # Enable WaitListNotInUse so that buffer can be released safely.
 #DEBFLAGS += -DUSE_EXT_BUF_SAFE_RELEASE
+# Enable null pointer judgement for picture buffer in VSI environment.
+#DEBFLAGS += -DUSE_NULL_POINTER_PROTECT
 
 # Discard the picture if vicious pic is found in ref pic list
 #DEBFLAGS += -DDISCARD_ERROR_PICTURE
diff --git a/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c b/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c
index 6b872f5..0d03b52 100755
--- a/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c
+++ b/decoder_sw/software/linux/mpeg4/mpeg4asicdbgtrace.c
@@ -133,10 +133,12 @@ void WriteAsicCtrl(DecContainer * dec_container) {
       p_mv = &dec_container->MbSetDesc.
              p_mv_data_addr[NBR_MV_WORDS_MB * j];
 
+#if 0
       for(tmp = 0; tmp > 1000; tmp++) {
         *(dec_container->MbSetDesc.
           p_dc_coeff_data_addr + tmp) = 0;
       }
+#endif
       /* HEX */
 
       /* invert bits for no RLC data */
diff --git a/decoder_sw/software/source/avs/avs_headers.c b/decoder_sw/software/source/avs/avs_headers.c
index b99ab89..ca1d5eb 100755
--- a/decoder_sw/software/source/avs/avs_headers.c
+++ b/decoder_sw/software/source/avs/avs_headers.c
@@ -284,16 +284,20 @@ u32 AvsStrmDec_DecodeIPictureHeader(DecContainer * dec_container) {
 
   if (p_hdr->profile_id == 0x48) { /* broadcast profile in avs+ */
     /* marker_bit, its value should be 1 */
+    (void) (tmp);
     tmp = AvsStrmDec_GetBits(dec_container, 1);
+    (void)(tmp);
     /* bbv_delay_extension */
     tmp = AvsStrmDec_GetBits(dec_container, 7);
   }
 
   /* time_code_flag */
+  (void) (tmp);
   tmp = AvsStrmDec_GetBits(dec_container, 1);
   if (tmp) {
     /* time_code */
     tmp = AvsStrmDec_GetBits(dec_container, 1); /* DropFrameFlag */
+    (void) (tmp);
     tmp = AvsStrmDec_GetBits(dec_container, 5); /* TimeCodeHours */
     p_hdr->time_code.hours = tmp;
     tmp = AvsStrmDec_GetBits(dec_container, 6); /* TimeCodeMinutes */
@@ -305,26 +309,36 @@ u32 AvsStrmDec_DecodeIPictureHeader(DecContainer * dec_container) {
   }
 
   tmp = AvsStrmDec_GetBits(dec_container, 1);
-
+  (void) (tmp);
   tmp = p_hdr->picture_distance = AvsStrmDec_GetBits(dec_container, 8);
 
-  if (p_hdr->low_delay)
+  if (p_hdr->low_delay) {
     /* bbv_check_times */
+    (void) (tmp);
     tmp = AvsDecodeExpGolombUnsigned(dec_container, &val);
+    (void) (tmp);
+  }
 
+  (void) (tmp);
   tmp = p_hdr->progressive_frame = AvsStrmDec_GetBits(dec_container, 1);
 
   if (!tmp) {
     tmp = p_hdr->picture_structure = AvsStrmDec_GetBits(dec_container, 1);
+    (void) (tmp);
   } else p_hdr->picture_structure = FRAMEPICTURE;
 
   tmp = p_hdr->top_field_first = AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = p_hdr->repeat_first_field = AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = p_hdr->fixed_picture_qp = AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = p_hdr->picture_qp = AvsStrmDec_GetBits(dec_container, 6);
 
-  if (p_hdr->progressive_frame == 0 && p_hdr->picture_structure == 0)
+  if (p_hdr->progressive_frame == 0 && p_hdr->picture_structure == 0) {
     tmp = p_hdr->skip_mode_flag = AvsStrmDec_GetBits(dec_container, 1);
+    (void) (tmp);
+  }
 
   /* reserved_bits, shall be '0000', not checked */
   tmp = AvsStrmDec_GetBits(dec_container, 4);
@@ -437,11 +451,14 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
 
   if (p_hdr->profile_id == 0x48) { /* broadcast profile in avs+ */
     /* marker_bit, its value should be 1 */
+    (void)(tmp);
     tmp = AvsStrmDec_GetBits(dec_container, 1);
     /* bbv_delay_extension */
+    (void)(tmp);
     tmp = AvsStrmDec_GetBits(dec_container, 7);
   }
 
+  (void)(tmp);
   tmp = p_hdr->pic_coding_type = AvsStrmDec_GetBits(dec_container, 2)+1;
   if (tmp != PFRAME && tmp != BFRAME)
     return (HANTRO_NOK);
@@ -452,18 +469,24 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
     /* bbv_check_times */
     tmp = AvsDecodeExpGolombUnsigned(dec_container, &val);
 
+  (void)(tmp);
   tmp = p_hdr->progressive_frame = AvsStrmDec_GetBits(dec_container, 1);
 
   if (!tmp) {
     tmp = p_hdr->picture_structure = AvsStrmDec_GetBits(dec_container, 1);
-    if (tmp == 0)
+    if (tmp == 0) {
       tmp = p_hdr->advanced_pred_mode_disable =
               AvsStrmDec_GetBits(dec_container, 1);
+      (void)(tmp);
+    }
   } else p_hdr->picture_structure = FRAMEPICTURE;
 
   tmp = p_hdr->top_field_first = AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = p_hdr->repeat_first_field = AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = p_hdr->fixed_picture_qp = AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = p_hdr->picture_qp = AvsStrmDec_GetBits(dec_container, 6);
 
   if (!(p_hdr->pic_coding_type == BFRAME && p_hdr->picture_structure == 1)) {
@@ -485,10 +508,13 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
     p_hdr->pb_field_enhanced_flag = 0;
   }
   /* reserved_bits, shall be '00', not checked */
+  (void)(tmp);
   tmp = AvsStrmDec_GetBits(dec_container, 2);
 
+  (void)(tmp);
   tmp = p_hdr->skip_mode_flag = AvsStrmDec_GetBits(dec_container, 1);
 
+  (void)(tmp);
   tmp = p_hdr->loop_filter_disable = AvsStrmDec_GetBits(dec_container, 1);
   if (!tmp) {
     tmp = AvsStrmDec_GetBits(dec_container, 1);
@@ -498,6 +524,7 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
       if (p_hdr->alpha_offset < -8 || p_hdr->alpha_offset > 8)
         return (HANTRO_NOK);
       tmp = AvsDecodeExpGolombSigned(dec_container, (i32*)&val);
+      (void)(tmp);
       p_hdr->beta_offset = (i32)val;
       if (p_hdr->beta_offset < -8 || p_hdr->beta_offset > 8)
         return (HANTRO_NOK);
@@ -516,6 +543,7 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
       /* reserved_bits, shall be '0', not checked */
       tmp = AvsStrmDec_GetBits(dec_container, 1);
       /* chroma_quant_param_disable */
+      (void)(tmp);
       tmp = AvsStrmDec_GetBits(dec_container, 1);
       p_hdr->chroma_quant_param_disable = tmp;
       if (tmp == 0x0) {
@@ -523,7 +551,9 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
         tmp = AvsDecodeExpGolombSigned(dec_container, (i32*)&val);
         p_hdr->chroma_quant_param_delta_cb = (i32)val;
         /* chroma_quant_param_delta_cr */
+        (void)(tmp);
         tmp = AvsDecodeExpGolombSigned(dec_container, (i32*)&val);
+        (void)(tmp);
         p_hdr->chroma_quant_param_delta_cr = (i32)val;
       }
 
@@ -536,6 +566,7 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
 
       if (p_hdr->weighting_quant_param_index == 0x1) {
         for(i=0; i<6; i++) {
+          (void) (tmp);
           tmp = AvsDecodeExpGolombSigned(dec_container, (i32*)&val);
           p_hdr->weighting_quant_param_delta1[i] = (i32)val;
         }
@@ -543,6 +574,7 @@ u32 AvsStrmDec_DecodePBPictureHeader(DecContainer * dec_container) {
 
       if (p_hdr->weighting_quant_param_index == 0x2) {
         for(i=0; i<6; i++) {
+          (void) (tmp);
           tmp = AvsDecodeExpGolombSigned(dec_container, (i32*)&val);
           p_hdr->weighting_quant_param_delta2[i] = (i32)val;
         }
@@ -615,30 +647,39 @@ u32 AvsStrmDec_DecodeSeqDisplayExtHeader(DecContainer * dec_container) {
 
   tmp = dec_container->Hdrs.video_format =
           AvsStrmDec_GetBits(dec_container, 3);
+  (void)(tmp);
   tmp = dec_container->Hdrs.sample_range =
           AvsStrmDec_GetBits(dec_container, 1);
+  (void)(tmp);
   tmp = dec_container->Hdrs.color_description =
           AvsStrmDec_GetBits(dec_container, 1);
 
   if(dec_container->Hdrs.color_description) {
+    (void)(tmp);
     tmp = dec_container->Hdrs.color_primaries =
             AvsStrmDec_GetBits(dec_container, 8);
+    (void)(tmp);
     tmp = dec_container->Hdrs.transfer_characteristics =
             AvsStrmDec_GetBits(dec_container, 8);
+    (void)(tmp);
     tmp = dec_container->Hdrs.matrix_coefficients =
             AvsStrmDec_GetBits(dec_container, 8);
   }
 
+  (void)(tmp);
   tmp = dec_container->Hdrs.display_horizontal_size =
           AvsStrmDec_GetBits(dec_container, 14);
 
   /* marker bit ==> flush */
+  (void)(tmp);
   tmp = AvsStrmDec_FlushBits(dec_container, 1);
 
+  (void)(tmp);
   tmp = dec_container->Hdrs.display_vertical_size =
           AvsStrmDec_GetBits(dec_container, 14);
 
   /* reserved_bits */
+  (void)(tmp);
   tmp = AvsStrmDec_GetBits(dec_container, 2);
 
   if(tmp == END_OF_STREAM)
diff --git a/decoder_sw/software/source/avs/avsdecapi.c b/decoder_sw/software/source/avs/avsdecapi.c
index 8bc62e0..ed90c1f 100755
--- a/decoder_sw/software/source/avs/avsdecapi.c
+++ b/decoder_sw/software/source/avs/avsdecapi.c
@@ -292,7 +292,7 @@ AvsDecRet AvsDecInit(AvsDecInst * dec_inst,
   DWLReadAsicConfig(&config,DWL_CLIENT_TYPE_AVS_DEC);
 
   if(!config.addr64_support && sizeof(void *) == 8) {
-    AVSDEC_DEBUG("AVSDecInit# ERROR: HW not support 64bit address!
");
+    AVSDEC_DEBUG(("AVSDecInit# ERROR: HW not support 64bit address!
"));
     return (AVSDEC_PARAM_ERROR);
   }
 
@@ -973,7 +973,7 @@ AvsDecRet AvsDecDecode(AvsDecInst dec_inst,
 #ifdef USE_OUTPUT_RELEASE
   if(dec_cont->pp_instance == NULL) {
     u32 tmpret;
-    AvsDecPicture output;
+    AvsDecPicture output = { 0 };
     if(ret == AVSDEC_PIC_DECODED) {
       do {
         tmpret = AvsDecNextPicture_INTERNAL(dec_cont, &output, 0);
@@ -3222,7 +3222,7 @@ void AvsPpControl(DecContainer * dec_container, u32 pipeline_off) {
 
           dec_container->ApiStorage.pp_pic_index = index_for_pp;
         } else {
-          index_for_pp = dec_container->StrmStorage.work_out;
+          //index_for_pp = dec_container->StrmStorage.work_out;
           index_for_pp = AVS_BUFFER_UNDEFINED;
           pc->input_bus_luma = 0;
         }
@@ -3772,7 +3772,10 @@ void AvsStateReset(DecContainer *dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_display);
-  FifoInit(32, &dec_cont->fifo_display);
+  if (FifoInit(32, &dec_cont->fifo_display) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
 }
 
diff --git a/decoder_sw/software/source/common/bqueue.c b/decoder_sw/software/source/common/bqueue.c
index 319861e..6be2616 100755
--- a/decoder_sw/software/source/common/bqueue.c
+++ b/decoder_sw/software/source/common/bqueue.c
@@ -192,10 +192,15 @@ u32 BqueueInit2( struct BufferQueue *bq, u32 num_buffers ) {
   }
 #endif
   bq->queue_size = num_buffers;
-  bq->ctr = 1;
-  bq->abort = 0;
+
   pthread_mutex_init(&bq->buf_release_mutex, NULL);
   pthread_cond_init(&bq->buf_release_cv, NULL);
+
+  pthread_mutex_lock(&bq->buf_release_mutex);
+  bq->ctr = 1;
+  bq->abort = 0;
+  pthread_mutex_unlock(&bq->buf_release_mutex);
+
 #ifndef USE_EXTERNAL_BUFFER
   bq->buf_used = (u32*)DWLmalloc( sizeof(u32)*num_buffers);
 #else
diff --git a/decoder_sw/software/source/common/commonconfig_g1.c b/decoder_sw/software/source/common/commonconfig_g1.c
index 6aa5ffb..074ab29 100755
--- a/decoder_sw/software/source/common/commonconfig_g1.c
+++ b/decoder_sw/software/source/common/commonconfig_g1.c
@@ -86,8 +86,9 @@ void SetCommonConfigRegs(u32 *regs,u32 client_type) {
     else
       apf_tmp_threshold = DEC_X170_REFBU_NONSEQ;
 
-    if( apf_tmp_threshold > 63 )
-      apf_tmp_threshold = 63;
+    /* above code always set apf_tmp_threshold = 8, below code cannot reach.*/
+    //if( apf_tmp_threshold > 63 )
+    //  apf_tmp_threshold = 63;
 
     SetDecRegister(regs, HWIF_APF_THRESHOLD, apf_tmp_threshold);
   }
diff --git a/decoder_sw/software/source/common/decapi.c b/decoder_sw/software/source/common/decapi.c
index 8e0c003..a81a8a1 100755
--- a/decoder_sw/software/source/common/decapi.c
+++ b/decoder_sw/software/source/common/decapi.c
@@ -94,15 +94,15 @@ struct Command {
 
 struct DecoderWrapper {
   void* inst;
-  enum DecRet (*init)(const void** inst, struct DecConfig config,
+  enum DecRet (*init)(const void** inst, struct DecConfig* config,
                       const void *dwl);
   enum DecRet (*GetInfo)(void* inst, struct DecSequenceInfo* info);
   enum DecRet (*Decode)(void* inst, struct DWLLinearMem input, struct DecOutput* output,
-                        u8* stream, u32 strm_len, struct DWL dwl, u32 pic_id);
+                        u8* stream, u32 strm_len, struct DWL* dwl, u32 pic_id);
   enum DecRet (*NextPicture)(void* inst, struct DecPicture* pic,
-                             struct DWL dwl);
-  enum DecRet (*PictureConsumed)(void* inst, struct DecPicture pic,
-                                 struct DWL dwl);
+                             struct DWL* dwl);
+  enum DecRet (*PictureConsumed)(void* inst, struct DecPicture* pic,
+                                 struct DWL* dwl);
   enum DecRet (*EndOfStream)(void* inst);
   void (*Release)(void* inst);
 #ifdef USE_EXTERNAL_BUFFER
@@ -158,15 +158,15 @@ static void SetState(DecoderInstance* inst, enum DecodingState state);
 
 /* Hevc codec wrappers. */
 #ifdef ENABLE_HEVC_SUPPORT
-static enum DecRet HevcInit(const void** inst, struct DecConfig config,
+static enum DecRet HevcInit(const void** inst, struct DecConfig* config,
                             const void *dwl);
 static enum DecRet HevcGetInfo(void* inst, struct DecSequenceInfo* info);
 static enum DecRet HevcDecode(void* inst, struct DWLLinearMem input, struct DecOutput* output,
-                              u8* stream, u32 strm_len, struct DWL dwl, u32 pic_id);
+                              u8* stream, u32 strm_len, struct DWL* dwl, u32 pic_id);
 static enum DecRet HevcNextPicture(void* inst, struct DecPicture* pic,
-                                   struct DWL dwl);
-static enum DecRet HevcPictureConsumed(void* inst, struct DecPicture pic,
-                                       struct DWL dwl);
+                                   struct DWL* dwl);
+static enum DecRet HevcPictureConsumed(void* inst, struct DecPicture* pic,
+                                       struct DWL* dwl);
 static enum DecRet HevcEndOfStream(void* inst);
 #ifdef USE_EXTERNAL_BUFFER
 static enum DecRet HevcGetBufferInfo(void *inst, struct DecBufferInfo *buf_info);
@@ -180,15 +180,15 @@ static void HevcStreamDecoded(void* inst);
 
 #ifdef ENABLE_VP9_SUPPORT
 /* VP9 codec wrappers. */
-static enum DecRet Vp9Init(const void** inst, struct DecConfig config,
+static enum DecRet Vp9Init(const void** inst, struct DecConfig* config,
                            const void *dwl);
 static enum DecRet Vp9GetInfo(void* inst, struct DecSequenceInfo* info);
 static enum DecRet Vp9Decode(void* inst, struct DWLLinearMem input, struct DecOutput* output,
-                             u8* stream, u32 strm_len, struct DWL dwl, u32 pic_id);
+                             u8* stream, u32 strm_len, struct DWL* dwl, u32 pic_id);
 static enum DecRet Vp9NextPicture(void* inst, struct DecPicture* pic,
-                                  struct DWL dwl);
-static enum DecRet Vp9PictureConsumed(void* inst, struct DecPicture pic,
-                                      struct DWL dwl);
+                                  struct DWL* dwl);
+static enum DecRet Vp9PictureConsumed(void* inst, struct DecPicture* pic,
+                                      struct DWL* dwl);
 static enum DecRet Vp9EndOfStream(void* inst);
 #ifdef USE_EXTERNAL_BUFFER
 static enum DecRet Vp9GetBufferInfo(void *inst, struct DecBufferInfo *buf_info);
@@ -212,7 +212,7 @@ struct DecSwHwBuild DecGetBuild(void) {
 }
 
 enum DecRet DecInit(enum DecCodec codec, DecInst* decoder,
-                    struct DecConfig config, struct DecClientHandle client) {
+                    struct DecConfig* config, struct DecClientHandle client) {
   if (decoder == NULL || client.Initialized == NULL ||
       client.HeadersDecoded == NULL || client.BufferDecoded == NULL ||
       client.PictureReady == NULL || client.EndOfStream == NULL ||
@@ -220,10 +220,10 @@ enum DecRet DecInit(enum DecCodec codec, DecInst* decoder,
     return DEC_PARAM_ERROR;
   }
 
-  DecoderInstance* inst = config.dwl.calloc(1, sizeof(DecoderInstance));
+  DecoderInstance* inst = config->dwl.calloc(1, sizeof(DecoderInstance));
   if (inst == NULL) return DEC_MEMFAIL;
-  inst->dwl = config.dwl;
-  inst->dwl_inst = config.dwl_inst;
+  inst->dwl = config->dwl;
+  inst->dwl_inst = config->dwl_inst;
   if (FifoInit(MAX_FIFO_CAPACITY, &inst->input_queue) != FIFO_OK) {
     inst->dwl.free(inst);
     return DEC_MEMFAIL;
@@ -278,8 +278,10 @@ enum DecRet DecInit(enum DecCodec codec, DecInst* decoder,
   SetState(inst, DECODER_WAITING_HEADERS);
   *decoder = inst;
   struct Command* command = inst->dwl.calloc(1, sizeof(struct Command));
+  if (command == NULL)
+    return DEC_MEMFAIL;
   command->id = COMMAND_INIT;
-  command->params.config = config;
+  command->params.config = *config;
   FifoPush(inst->input_queue, command, FIFO_EXCEPTION_DISABLE);
   return DEC_OK;
 }
@@ -297,6 +299,8 @@ enum DecRet DecDecode(DecInst dec_inst, struct DecInput* input) {
   case DECODER_DECODING:
   case DECODER_SHUTTING_DOWN: {
     struct Command* command = inst->dwl.calloc(1, sizeof(struct Command));
+    if (command == NULL)
+      return DEC_MEMFAIL;
     command->id = COMMAND_DECODE;
     inst->dwl.memcpy(&command->params.input, input, sizeof(struct DecInput));
     FifoPush(inst->input_queue, command, FIFO_EXCEPTION_DISABLE);
@@ -361,7 +365,7 @@ enum DecRet DecUseExtraFrmBuffers(DecInst dec_inst, u32 n) {
   return ret;
 }
 
-enum DecRet DecPictureConsumed(DecInst dec_inst, struct DecPicture picture) {
+enum DecRet DecPictureConsumed(DecInst dec_inst, struct DecPicture* picture) {
   if (dec_inst == NULL) {
     return DEC_PARAM_ERROR;
   }
@@ -371,7 +375,7 @@ enum DecRet DecPictureConsumed(DecInst dec_inst, struct DecPicture picture) {
   case DECODER_WAITING_RESOURCES:
   case DECODER_DECODING:
   case DECODER_SHUTTING_DOWN:
-    inst->dec.PictureConsumed(inst->dec.inst, picture, inst->dwl);
+    inst->dec.PictureConsumed(inst->dec.inst, picture, &(inst->dwl));
     return DEC_OK;
   default:
     return DEC_NOT_INITIALIZED;
@@ -391,6 +395,8 @@ enum DecRet DecEndOfStream(DecInst dec_inst) {
   case DECODER_DECODING:
   case DECODER_SHUTTING_DOWN:
     command = inst->dwl.calloc(1, sizeof(struct Command));
+    if (command == NULL)
+      return DEC_MEMFAIL;
     inst->dwl.memset(command, 0, sizeof(struct Command));
     command->id = COMMAND_END_OF_STREAM;
     FifoPush(inst->input_queue, command, FIFO_EXCEPTION_DISABLE);
@@ -407,6 +413,8 @@ void DecRelease(DecInst dec_inst) {
   /* Abort the current command (it may be long-lasting task). */
   SetState(inst, DECODER_SHUTTING_DOWN);
   struct Command* command = inst->dwl.calloc(1, sizeof(struct Command));
+  if (command == NULL)
+      return;
   inst->dwl.memset(command, 0, sizeof(struct Command));
   command->id = COMMAND_RELEASE;
   FifoPush(inst->input_queue, command, FIFO_EXCEPTION_DISABLE);
@@ -484,7 +492,7 @@ static void* DecodeLoop(void* arg) {
 static void Initialize(DecoderInstance* inst) {
   enum DecRet rv =
     inst->dec.init((const void**)&inst->dec.inst,
-                   inst->current_command->params.config, inst->dwl_inst);
+                   &(inst->current_command->params.config), inst->dwl_inst);
   if (rv == DEC_OK)
     inst->client.Initialized(inst->client.client);
   else
@@ -523,7 +531,7 @@ static void Decode(DecoderInstance* inst) {
     stream = inst->buffer_status.strm_curr_pos;
     strm_len = inst->buffer_status.data_left;
     rv = inst->dec.Decode(inst->dec.inst, buffer, &inst->buffer_status, stream,
-                          strm_len, inst->dwl, inst->num_of_decoded_pics + 1);
+                          strm_len, &(inst->dwl), inst->num_of_decoded_pics + 1);
     if (GetState(inst) == DECODER_SHUTTING_DOWN) {
       break;
     }
@@ -616,10 +624,10 @@ static void* OutputLoop(void* arg) {
       break;
     case DECODER_WAITING_HEADERS:
     case DECODER_DECODING:
-      while ((rv = inst->dec.NextPicture(inst->dec.inst, &pic, inst->dwl)) ==
+      while ((rv = inst->dec.NextPicture(inst->dec.inst, &pic, &(inst->dwl))) ==
              DEC_PIC_RDY) {
         inst->picture_in_display = 1;
-        inst->client.PictureReady(inst->client.client, pic);
+        inst->client.PictureReady(inst->client.client, &pic);
         inst->picture_in_display = 0;
       }
       if (rv == DEC_END_OF_STREAM) {
@@ -655,36 +663,37 @@ static void SetState(DecoderInstance* inst, enum DecodingState state) {
     "DECODER_DECODING",        "DECODER_SHUTTING_DOWN"
   };
   inst->dwl.pthread_mutex_lock(&inst->cs_mutex);
-  inst->dwl.printf("Decoder state change: %s => %s
", states[inst->state],
-                   states[state]);
+  if (states[inst->state] != states[state])
+    inst->dwl.printf("Decoder state change: %s => %s
", states[inst->state],
+                     states[state]);
   inst->state = state;
   inst->dwl.pthread_mutex_unlock(&inst->cs_mutex);
 }
 
 #ifdef ENABLE_HEVC_SUPPORT
-static enum DecRet HevcInit(const void** inst, struct DecConfig config,
+static enum DecRet HevcInit(const void** inst, struct DecConfig* config,
                             const void *dwl) {
-  struct HevcDecConfig dec_cfg;
+  struct HevcDecConfig dec_cfg = { 0 };
   enum DecRet ret;
-  dec_cfg.no_output_reordering = config.disable_picture_reordering;
-  dec_cfg.use_video_freeze_concealment = config.concealment_mode;
-  dec_cfg.use_video_compressor = config.use_video_compressor;
-  dec_cfg.use_fetch_one_pic = config.use_fetch_one_pic;
-  dec_cfg.use_ringbuffer = config.use_ringbuffer;
-  dec_cfg.output_format = config.output_format;
+  dec_cfg.no_output_reordering = config->disable_picture_reordering;
+  dec_cfg.use_video_freeze_concealment = config->concealment_mode;
+  dec_cfg.use_video_compressor = config->use_video_compressor;
+  dec_cfg.use_fetch_one_pic = config->use_fetch_one_pic;
+  dec_cfg.use_ringbuffer = config->use_ringbuffer;
+  dec_cfg.output_format = config->output_format;
 #ifdef USE_EXTERNAL_BUFFER
   dec_cfg.guard_size = 0;
   dec_cfg.use_adaptive_buffers = 0;
 #endif
-  if (config.use_8bits_output)
+  if (config->use_8bits_output)
     dec_cfg.pixel_format = DEC_OUT_PIXEL_CUT_8BIT;
-  else if (config.use_p010_output)
+  else if (config->use_p010_output)
     dec_cfg.pixel_format = DEC_OUT_PIXEL_P010;
-  else if (config.use_bige_output)
+  else if (config->use_bige_output)
     dec_cfg.pixel_format = DEC_OUT_PIXEL_CUSTOMER1;
   else
     dec_cfg.pixel_format = DEC_OUT_PIXEL_DEFAULT;
-  dec_cfg.dscale_cfg = config.dscale_cfg;
+  dec_cfg.dscale_cfg = config->dscale_cfg;
 
   START_SW_PERFORMANCE;
   ret=HevcDecInit(inst, dwl, &dec_cfg);
@@ -717,12 +726,12 @@ static enum DecRet HevcGetInfo(void* inst, struct DecSequenceInfo* info) {
 }
 
 static enum DecRet HevcDecode(void* inst, struct DWLLinearMem input, struct DecOutput* output,
-                              u8* stream, u32 strm_len, struct DWL dwl, u32 pic_id) {
+                              u8* stream, u32 strm_len, struct DWL* dwl, u32 pic_id) {
   enum DecRet rv;
   struct HevcDecInput hevc_input;
   struct HevcDecOutput hevc_output;
-  dwl.memset(&hevc_input, 0, sizeof(hevc_input));
-  dwl.memset(&hevc_output, 0, sizeof(hevc_output));
+  dwl->memset(&hevc_input, 0, sizeof(hevc_input));
+  dwl->memset(&hevc_output, 0, sizeof(hevc_output));
   hevc_input.stream = (u8*)stream;
   hevc_input.stream_bus_address = input.bus_address + ((addr_t)stream - (addr_t)input.virtual_address);
   hevc_input.data_len = strm_len;
@@ -742,11 +751,11 @@ static enum DecRet HevcDecode(void* inst, struct DWLLinearMem input, struct DecO
 }
 
 static enum DecRet HevcNextPicture(void* inst, struct DecPicture* pic,
-                                   struct DWL dwl) {
+                                   struct DWL* dwl) {
   enum DecRet rv;
   struct HevcDecPicture hpic;
   rv = HevcDecNextPicture(inst, &hpic);
-  dwl.memset(pic, 0, sizeof(struct DecPicture));
+  dwl->memset(pic, 0, sizeof(struct DecPicture));
   pic->luma.virtual_address = (u32*)hpic.output_picture;
   pic->luma.bus_address = hpic.output_picture_bus_address;
 #if 0
@@ -796,14 +805,14 @@ static enum DecRet HevcNextPicture(void* inst, struct DecPicture* pic,
   return rv;
 }
 
-static enum DecRet HevcPictureConsumed(void* inst, struct DecPicture pic,
-                                       struct DWL dwl) {
+static enum DecRet HevcPictureConsumed(void* inst, struct DecPicture* pic,
+                                       struct DWL* dwl) {
   struct HevcDecPicture hpic;
-  dwl.memset(&hpic, 0, sizeof(struct HevcDecPicture));
+  dwl->memset(&hpic, 0, sizeof(struct HevcDecPicture));
   /* TODO update chroma luma/chroma base */
-  hpic.output_picture = pic.luma.virtual_address;
-  hpic.output_picture_bus_address = pic.luma.bus_address;
-  hpic.is_idr_picture = pic.picture_info.pic_coding_type == DEC_PIC_TYPE_I;
+  hpic.output_picture = pic->luma.virtual_address;
+  hpic.output_picture_bus_address = pic->luma.bus_address;
+  hpic.is_idr_picture = pic->picture_info.pic_coding_type == DEC_PIC_TYPE_I;
   return HevcDecPictureConsumed(inst, &hpic);
 }
 
@@ -846,33 +855,33 @@ static void HevcStreamDecoded(void* dec_inst) {
 #endif /* ENABLE_HEVC_SUPPORT */
 
 #ifdef ENABLE_VP9_SUPPORT
-static enum DecRet Vp9Init(const void** inst, struct DecConfig config,
+static enum DecRet Vp9Init(const void** inst, struct DecConfig* config,
                            const void *dwl) {
-  enum DecPictureFormat format = config.output_format;
+  enum DecPictureFormat format = config->output_format;
   enum DecRet ret;
   struct Vp9DecConfig dec_cfg;
-  dec_cfg.use_video_freeze_concealment = config.concealment_mode;
+  dec_cfg.use_video_freeze_concealment = config->concealment_mode;
   dec_cfg.num_frame_buffers = 9;
   dec_cfg.dpb_flags = 4;
-  dec_cfg.use_video_compressor = config.use_video_compressor;
-  dec_cfg.use_fetch_one_pic = config.use_fetch_one_pic;
-  dec_cfg.use_ringbuffer = config.use_ringbuffer;
+  dec_cfg.use_video_compressor = config->use_video_compressor;
+  dec_cfg.use_fetch_one_pic = config->use_fetch_one_pic;
+  dec_cfg.use_ringbuffer = config->use_ringbuffer;
   dec_cfg.output_format = format;
   dec_cfg.use_cts_test = 0;
   dec_cfg.use_secure_mode = 0;
 #ifdef USE_EXTERNAL_BUFFER
   dec_cfg.use_adaptive_buffers = 0;
 #endif
-  if (config.use_8bits_output)
+  if (config->use_8bits_output)
     dec_cfg.pixel_format = DEC_OUT_PIXEL_CUT_8BIT;
-  else if (config.use_p010_output)
+  else if (config->use_p010_output)
     dec_cfg.pixel_format = DEC_OUT_PIXEL_P010;
-  else if (config.use_bige_output)
+  else if (config->use_bige_output)
     dec_cfg.pixel_format = DEC_OUT_PIXEL_CUSTOMER1;
   else
     dec_cfg.pixel_format = DEC_OUT_PIXEL_DEFAULT;
 
-  dec_cfg.dscale_cfg = config.dscale_cfg;
+  dec_cfg.dscale_cfg = config->dscale_cfg;
   
   START_SW_PERFORMANCE;
   ret=Vp9DecInit(inst, dwl, &dec_cfg);
@@ -957,12 +966,12 @@ static void ParseSuperframeIndex(const u8* data, size_t data_sz,
 }
 
 static enum DecRet Vp9Decode(void* inst, struct DWLLinearMem input, struct DecOutput* output,
-                             u8* stream, u32 strm_len, struct DWL dwl, u32 pic_id) {
+                             u8* stream, u32 strm_len, struct DWL* dwl, u32 pic_id) {
   enum DecRet rv = DEC_OK;
   struct Vp9DecInput vp9_input;
   struct Vp9DecOutput vp9_output;
-  dwl.memset(&vp9_input, 0, sizeof(vp9_input));
-  dwl.memset(&vp9_output, 0, sizeof(vp9_output));
+  dwl->memset(&vp9_input, 0, sizeof(vp9_input));
+  dwl->memset(&vp9_output, 0, sizeof(vp9_output));
   vp9_input.stream = (u8*)stream;
   vp9_input.stream_bus_address = input.bus_address + ((addr_t)stream - (addr_t)input.virtual_address);
   vp9_input.data_len = strm_len;
@@ -1097,11 +1106,11 @@ static enum DecRet Vp9Decode(void* inst, struct DWLLinearMem input, struct DecOu
 }
 
 static enum DecRet Vp9NextPicture(void* inst, struct DecPicture* pic,
-                                  struct DWL dwl) {
+                                  struct DWL* dwl) {
   enum DecRet rv;
   struct Vp9DecPicture vpic = {0};
   rv = Vp9DecNextPicture(inst, &vpic);
-  dwl.memset(pic, 0, sizeof(struct DecPicture));
+  dwl->memset(pic, 0, sizeof(struct DecPicture));
   pic->luma.virtual_address = (u32*)vpic.output_luma_base;
   pic->luma.bus_address = vpic.output_luma_bus_address;
   pic->luma.size = vpic.pic_stride * vpic.frame_height;
@@ -1127,7 +1136,7 @@ static enum DecRet Vp9NextPicture(void* inst, struct DecPicture* pic,
   pic->sequence_info.matrix_coefficients = 0;
   pic->sequence_info.is_mono_chrome = 0;
   pic->sequence_info.is_interlaced = 0;
-  pic->sequence_info.num_of_ref_frames = pic->sequence_info.num_of_ref_frames;
+  //pic->sequence_info.num_of_ref_frames = pic->sequence_info.num_of_ref_frames;
   pic->picture_info.format = vpic.output_format;
   pic->picture_info.pixel_format = vpic.pixel_format;
   pic->picture_info.pic_id = vpic.pic_id;
@@ -1139,14 +1148,14 @@ static enum DecRet Vp9NextPicture(void* inst, struct DecPicture* pic,
   return rv;
 }
 
-static enum DecRet Vp9PictureConsumed(void* inst, struct DecPicture pic,
-                                      struct DWL dwl) {
+static enum DecRet Vp9PictureConsumed(void* inst, struct DecPicture* pic,
+                                      struct DWL* dwl) {
   struct Vp9DecPicture vpic;
-  dwl.memset(&vpic, 0, sizeof(struct Vp9DecPicture));
+  dwl->memset(&vpic, 0, sizeof(struct Vp9DecPicture));
   /* TODO chroma base needed? */
-  vpic.output_luma_base = pic.luma.virtual_address;
-  vpic.output_luma_bus_address = pic.luma.bus_address;
-  vpic.is_intra_frame = pic.picture_info.pic_coding_type == DEC_PIC_TYPE_I;
+  vpic.output_luma_base = pic->luma.virtual_address;
+  vpic.output_luma_bus_address = pic->luma.bus_address;
+  vpic.is_intra_frame = pic->picture_info.pic_coding_type == DEC_PIC_TYPE_I;
   return Vp9DecPictureConsumed(inst, &vpic);
 }
 
diff --git a/decoder_sw/software/source/common/errorhandling.c b/decoder_sw/software/source/common/errorhandling.c
index baa5156..306bd5e 100755
--- a/decoder_sw/software/source/common/errorhandling.c
+++ b/decoder_sw/software/source/common/errorhandling.c
@@ -50,9 +50,12 @@ static u32 GetMbOffset(u32 mb_num, u32 vop_width, u32 vop_height);
 
 u32 GetMbOffset(u32 mb_num, u32 vop_width, u32 vop_height) {
   u32 mb_row, mb_col;
-  u32 offset;
+  u32 offset = 0;
   UNUSED(vop_height);
 
+  if(vop_width == 0)
+    return offset;
+
   mb_row = mb_num / vop_width;
   mb_col = mb_num % vop_width;
   offset = mb_row * 16 * 16 * vop_width + mb_col * 16;
diff --git a/decoder_sw/software/source/common/fifo_unittest.c b/decoder_sw/software/source/common/fifo_unittest.c
index e0f2a38..78a30e5 100755
--- a/decoder_sw/software/source/common/fifo_unittest.c
+++ b/decoder_sw/software/source/common/fifo_unittest.c
@@ -174,8 +174,10 @@ int main(int argc, char* argv[]) {
   if (GetParams(argc, argv, &params) != 0) return 1;
 
   /* Initialize the fifo queue. */
-  FifoInit(params.queue_size, &params.fifo);
-
+  if (FifoInit(params.queue_size, &params.fifo) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return -1;
+  }
   /* Create the exit timer if one is wanted. */
   if (CreateTimer(params.time_to_forced_exit.tv_nsec, &timerid)) {
     printf("Failed to create timer
");
diff --git a/decoder_sw/software/source/common/input_queue.c b/decoder_sw/software/source/common/input_queue.c
index 76c6479..7eccf5e 100755
--- a/decoder_sw/software/source/common/input_queue.c
+++ b/decoder_sw/software/source/common/input_queue.c
@@ -121,7 +121,9 @@ void InputQueueReset(InputQueue queue) {
     pthread_mutex_destroy(&q->buf_release_mutex);
     pthread_cond_destroy(&q->buf_release_cv);
   }
-  FifoInit(MAX_PIC_BUFFERS, &q->fifo_in);
+  ret = FifoInit(MAX_PIC_BUFFERS, &q->fifo_in);
+  if (FIFO_ERROR_MEMALLOC == ret)
+    return;
   assert(q->fifo_in);
 
 #ifdef USE_OMXIL_BUFFER
diff --git a/decoder_sw/software/source/common/raster_buffer_mgr.c b/decoder_sw/software/source/common/raster_buffer_mgr.c
index ac0f1be..8e9d4f7 100755
--- a/decoder_sw/software/source/common/raster_buffer_mgr.c
+++ b/decoder_sw/software/source/common/raster_buffer_mgr.c
@@ -111,7 +111,10 @@ struct DWLLinearMem RbmGetTiledBuffer(RasterBufferMgr instance,
 void RbmRelease(RasterBufferMgr instance) {
   RasterBufferMgrInst* inst = (RasterBufferMgrInst*)instance;
   for (int i = 0; i < inst->num_buffers; i++) {
-    DWLFreeLinear(inst->dwl, &inst->buffer_map[i].pp_buffer);
+#ifdef USE_NULL_POINTER_PROTECT
+    if (inst->buffer_map[i].pp_buffer.virtual_address != NULL)
+#endif
+      DWLFreeLinear(inst->dwl, &inst->buffer_map[i].pp_buffer);
   }
   DWLfree(inst->buffer_map);
   DWLfree(inst);
diff --git a/decoder_sw/software/source/common/refbuffer.c b/decoder_sw/software/source/common/refbuffer.c
index fcebeb0..b03a764 100755
--- a/decoder_sw/software/source/common/refbuffer.c
+++ b/decoder_sw/software/source/common/refbuffer.c
@@ -825,9 +825,15 @@ void RefbuMvStatistics( struct refBuffer *p_refbu, u32 *reg_base,
 
   p_refbu->coverage[2] = p_refbu->coverage[1];
   p_refbu->coverage[1] = p_refbu->coverage[0];
+  /* according line 791, direct_mvs_available is 0 */
+#if 0
   if(direct_mvs_available) {
     DirectMvStatistics( p_refbu, p_mv, num_intra_blk, big_endian );
   } else if(p_refbu->offset_support) {
+#else
+  (void)(p_mv);
+  if(p_refbu->offset_support) {
+#endif
     i32 inter_mvs;
     i32 sum;
     sum = GetDecRegister( reg_base, HWIF_REFBU_Y_MV_SUM );
@@ -1065,11 +1071,14 @@ void RefbuSetup( struct refBuffer *p_refbu, u32 *reg_base,
               use_adaptive_mode = 1;
               p_refbu->checkpoint /= p_refbu->thr_adj;
               thr2 = p_refbu->checkpoint ;
+              /* Coverity: multiple_ref_fields is 1 always */
+#if 0
             } else {
               /* Buffer both reference fields explicitly */
               use_double_mode = 1;
               p_refbu->checkpoint /= p_refbu->thr_adj;
               thr2 = p_refbu->checkpoint;
+#endif
             }
           } else if (force_adaptive_single) {
             use_adaptive_mode = 1;
diff --git a/decoder_sw/software/source/common/stream_corrupt.c b/decoder_sw/software/source/common/stream_corrupt.c
index b896f51..f56ad44 100755
--- a/decoder_sw/software/source/common/stream_corrupt.c
+++ b/decoder_sw/software/source/common/stream_corrupt.c
@@ -36,6 +36,7 @@
 
 #include "stream_corrupt.h"
 #include <stdlib.h>
+#include <stdio.h>
 #include <time.h>
 #include <string.h>
 #include <math.h>
@@ -256,7 +257,13 @@ u32 ParseOdds(char* odds, u32* dividend, u32* divisor) {
   char* ptr;
   u32 str_len = strlen(odds);
 
-  strcpy(odds_copy, odds);
+  if(sizeof(odds_copy) - 1 < strlen(odds)) {
+    fprintf(stderr, "The parameter odds size overflows buffer size in file %s at line # %d
",
+        __FILE__, __LINE__-1);
+    return 1;
+  } else {
+    strcpy(odds_copy, odds);
+  }
   ptr = odds_copy;
 
   /* minimum is "1 : 1" */
diff --git a/decoder_sw/software/source/common/sw_stream.c b/decoder_sw/software/source/common/sw_stream.c
index bcf5e1c..284d55b 100755
--- a/decoder_sw/software/source/common/sw_stream.c
+++ b/decoder_sw/software/source/common/sw_stream.c
@@ -98,12 +98,14 @@ u32 SwShowBits(const struct StrmData *stream, u32 num_bits) {
     return (0);
   }
 
-  tmp = SwTurnAround(stream->strm_curr_pos, stream->strm_buff_start,
-                     tmp_strm_buf, stream->strm_buff_size,
-                     num_bits + stream->bit_pos_in_word + 32);
+  if (stream->is_rb) {
+    tmp = SwTurnAround(stream->strm_curr_pos, stream->strm_buff_start,
+                       tmp_strm_buf, stream->strm_buff_size,
+                       num_bits + stream->bit_pos_in_word + 32);
 
-  if(tmp != NULL)
-    strm = tmp;
+    if(tmp != NULL)
+      strm = tmp;
+  }
 
   if (!stream->remove_emul3_byte) {
 
@@ -138,7 +140,8 @@ u32 SwShowBits(const struct StrmData *stream, u32 num_bits) {
         out |= (u32)DWLPrivateAreaReadByte(strm) << (24 - out_bits);
         strm++;
       } else {
-        out |= (u32)DWLPrivateAreaReadByte(strm) >> (out_bits - 24);
+        out |= (out_bits - 24) > 7 ? 0: 
+                   ((u32)DWLPrivateAreaReadByte(strm) >> (out_bits - 24));
         strm++;
       }
 
@@ -198,9 +201,12 @@ u32 SwFlushBits(struct StrmData *stream, u32 num_bits) {
   ASSERT(stream->bit_pos_in_word == (stream->strm_buff_read_bits & 0x7));
 
   /* used to copy stream data when ringbuffer turnaround */
-  tmp = SwTurnAround(stream->strm_curr_pos, stream->strm_buff_start,
-                     tmp_strm_buf, stream->strm_buff_size,
-                     num_bits + stream->bit_pos_in_word + 32);
+  if (stream->is_rb) {
+    tmp = SwTurnAround(stream->strm_curr_pos, stream->strm_buff_start,
+                       tmp_strm_buf, stream->strm_buff_size,
+                       num_bits + stream->bit_pos_in_word + 32);
+  } else
+    tmp = NULL;
 
   if (!stream->remove_emul3_byte) {
     if ((stream->strm_buff_read_bits + num_bits) >
diff --git a/decoder_sw/software/source/common/tiledref.c b/decoder_sw/software/source/common/tiledref.c
index 99044ab..f51be36 100755
--- a/decoder_sw/software/source/common/tiledref.c
+++ b/decoder_sw/software/source/common/tiledref.c
@@ -64,7 +64,7 @@ u32 DecCheckTiledMode( u32 tiled_mode_support, enum DecDpbMode dpb_mode,
                        u32 interlaced_stream ) {
 
   return 0;
-
+#if 0
   if(interlaced_stream) {
     if( (tiled_mode_support != TILED_SUPPORT_INTERLACED_8x4) ||
         (dpb_mode != DEC_DPB_INTERLACED_FIELD ))
@@ -75,6 +75,7 @@ u32 DecCheckTiledMode( u32 tiled_mode_support, enum DecDpbMode dpb_mode,
   }
 
   return 0;
+#endif
 }
 
 /*------------------------------------------------------------------------------
diff --git a/decoder_sw/software/source/h264high/h264decapi.c b/decoder_sw/software/source/h264high/h264decapi.c
index b9a83a3..602a309 100755
--- a/decoder_sw/software/source/h264high/h264decapi.c
+++ b/decoder_sw/software/source/h264high/h264decapi.c
@@ -239,8 +239,12 @@ H264DecRet H264DecInit(H264DecInst * dec_inst,
   (void) DWLmemset(dec_cont, 0, sizeof(decContainer_t));
   dec_cont->dwl = dwl;
 
+  pthread_mutex_init(&dec_cont->protect_mutex, NULL);
+
+  pthread_mutex_lock(&dec_cont->protect_mutex);
   h264bsdInit(&dec_cont->storage, no_output_reordering,
               use_display_smoothing);
+  pthread_mutex_unlock(&dec_cont->protect_mutex);
 
   dec_cont->dec_stat = H264DEC_INITIALIZED;
 
@@ -252,7 +256,6 @@ H264DecRet H264DecInit(H264DecInst * dec_inst,
   SetDecRegister(dec_cont->h264_regs, HWIF_PRED_BC_TAP_0_0, 1);
   SetDecRegister(dec_cont->h264_regs, HWIF_PRED_BC_TAP_0_1, (u32)(-5));
   SetDecRegister(dec_cont->h264_regs, HWIF_PRED_BC_TAP_0_2, 20);
-  pthread_mutex_init(&dec_cont->protect_mutex, NULL);
 
   /* save HW version so we dont need to check it all the time when deciding the control stuff */
   dec_cont->is8190 = (asic_id >> 16) != 0x8170U ? 1 : 0;
@@ -336,6 +339,9 @@ H264DecRet H264DecInit(H264DecInst * dec_inst,
   else if (error_handling == DEC_EC_PARTIAL_IGNORE)
     dec_cont->storage.partial_freeze = 2;
 #endif
+  if (error_handling == DEC_EC_NONE)
+    dec_cont->storage.no_freeze = 1;
+
   dec_cont->storage.picture_broken = HANTRO_FALSE;
 
   dec_cont->max_dec_pic_width = hw_cfg.max_dec_pic_width;    /* max decodable picture width */
@@ -2387,7 +2393,8 @@ end:
   /* erroneous picture which is not outputted. */
   if (return_value == H264DEC_PIC_DECODED &&
       dec_cont->storage.dpb->current_out->num_err_mbs &&
-      !dec_cont->storage.dpb->current_out->corrupted_second_field)
+      !dec_cont->storage.dpb->current_out->corrupted_second_field &&
+      !dec_cont->storage.no_freeze)
     return_value = H264DEC_PIC_CONSUMED;
 
   /* If just 1 field is decoded, return FIELD_DECODED intead of PIC_DECODED */
@@ -3617,16 +3624,16 @@ void h264CheckReleasePpAndHw(decContainer_t *dec_cont) {
 
 ------------------------------------------------------------------------------*/
 H264DecRet H264DecPeek(H264DecInst dec_inst, H264DecPicture * output) {
-  decContainer_t *dec_cont = (decContainer_t *) dec_inst;
-  dpbPicture_t *current_out = dec_cont->storage.dpb->current_out;
-
-  DEC_API_TRC("H264DecPeek#
");
-
   if(dec_inst == NULL || output == NULL) {
     DEC_API_TRC("H264DecPeek# ERROR: dec_inst or output is NULL
");
     return (H264DEC_PARAM_ERROR);
   }
 
+  decContainer_t *dec_cont = (decContainer_t *) dec_inst;
+  dpbPicture_t *current_out = dec_cont->storage.dpb->current_out;
+
+  DEC_API_TRC("H264DecPeek#
");
+
   /* Check for valid decoder instance */
   if(dec_cont->checksum != dec_cont) {
     DEC_API_TRC("H264DecPeek# ERROR: Decoder not initialized
");
@@ -3957,7 +3964,8 @@ H264DecRet H264DecNextPicture_INTERNAL(H264DecInst dec_inst,
 
     DEC_API_TRC("H264DecNextPicture_INTERNAL# H264DEC_PIC_RDY
");
 
-    if (output->nbr_of_err_mbs && !out_pic->corrupted_second_field)
+    if (output->nbr_of_err_mbs && !out_pic->corrupted_second_field &&
+        !dec_cont->storage.no_freeze)
       ClearOutput(&dec_cont->fb_list, out_pic->mem_idx);
     else
       PushOutputPic(&dec_cont->fb_list, output, out_pic->mem_idx);
diff --git a/decoder_sw/software/source/h264high/h264hwd_asic.c b/decoder_sw/software/source/h264high/h264hwd_asic.c
index 46901b8..1dc0055 100755
--- a/decoder_sw/software/source/h264high/h264hwd_asic.c
+++ b/decoder_sw/software/source/h264high/h264hwd_asic.c
@@ -1190,8 +1190,6 @@ void PrepareMvData(storage_t * storage, DecAsicBuffers_t * p_asic_buff) {
           }
         }
         break;
-        default:
-          ASSERT(0);
         }
       }
     }
@@ -1916,7 +1914,7 @@ void H264ErrorRecover(decContainer_t *dec_cont)
   u32 i;
   i32 idx = 0;
 
-  if (!dec_cont->rlc_mode) {
+  if (!dec_cont->rlc_mode && !dec_cont->storage.no_freeze) {
     u32 k = dpb->dpb_size + 1;
 
     /* find the buffer index of current image */
diff --git a/decoder_sw/software/source/h264high/h264hwd_decoder.c b/decoder_sw/software/source/h264high/h264hwd_decoder.c
index b5694dc..7b1b02d 100755
--- a/decoder_sw/software/source/h264high/h264hwd_decoder.c
+++ b/decoder_sw/software/source/h264high/h264hwd_decoder.c
@@ -362,7 +362,7 @@ u32 h264bsdDecode(decContainer_t * dec_cont, const u8 * byte_strm, u32 len,
 #endif
         }
       }
-
+      (void)(ret);
       ret = H264BSD_RDY;
       goto NEXT_NAL;
 
@@ -376,6 +376,7 @@ u32 h264bsdDecode(decContainer_t * dec_cont, const u8 * byte_strm, u32 len,
         FREE(pic_param_set.bottom_right);
         FREE(pic_param_set.slice_group_id);
         ret = H264BSD_ERROR;
+        (void)(ret);
       } else {
         tmp = h264bsdStorePicParamSet(storage, &pic_param_set);
          /* allocated new memory inside h264bsdStorePicParamSet */
@@ -386,6 +387,7 @@ u32 h264bsdDecode(decContainer_t * dec_cont, const u8 * byte_strm, u32 len,
         if(tmp != HANTRO_OK) {
           ERROR_PRINT("PIC_PARAM_SET allocation");
           ret = H264BSD_ERROR;
+          (void)(ret);
         }
       }
       ret = H264BSD_RDY;
@@ -1361,8 +1363,9 @@ u32 h264bsdFixFrameNum(u8 *stream, u32 strm_len, u32 frame_num, u32 max_frame_nu
 
 #define BIT 12
   u8 *p, *p_end;
-  u32 value, tmp, first = 1;
-  strmData_t strm_data;
+  u32 value, tmp;
+  //u32 first = 1;
+  strmData_t strm_data = { 0 };
   u32 frame_num_len = 0;
   u32 bit_pos;
   u32 loop = 0;
@@ -1418,8 +1421,8 @@ u32 h264bsdFixFrameNum(u8 *stream, u32 strm_len, u32 frame_num, u32 max_frame_nu
         return 0;
 
       /* start of frame */
-      if (value == 0 && !first)
-        return 0;
+      //if (value == 0 && !first)
+      //  return 0;
 
       /* skip slice_type */
       tmp = h264bsdDecodeExpGolombUnsigned(&strm_data, &value);
diff --git a/decoder_sw/software/source/h264high/h264hwd_dpb.c b/decoder_sw/software/source/h264high/h264hwd_dpb.c
index 059f2c8..70fdb0d 100755
--- a/decoder_sw/software/source/h264high/h264hwd_dpb.c
+++ b/decoder_sw/software/source/h264high/h264hwd_dpb.c
@@ -55,15 +55,15 @@
 
 /* Function style implementation for IS_REFERENCE() macro to fix compiler
  * warnings */
-static u32 IsReference( const dpbPicture_t a, const u32 f ) {
+static u32 IsReference( const dpbPicture_t* a, const u32 f ) {
   switch(f) {
   case TOPFIELD:
-    return a.status[0] && a.status[0] != EMPTY;
+    return a->status[0] && a->status[0] != EMPTY;
   case BOTFIELD:
-    return a.status[1] && a.status[1] != EMPTY;
+    return a->status[1] && a->status[1] != EMPTY;
   default:
-    return a.status[0] && a.status[0] != EMPTY &&
-           a.status[1] && a.status[1] != EMPTY;
+    return a->status[0] && a->status[0] != EMPTY &&
+           a->status[1] && a->status[1] != EMPTY;
   }
 }
 
@@ -235,7 +235,7 @@ i32 ComparePictures(const void *ptr1, const void *ptr2) {
   pic2 = (dpbPicture_t *) ptr2;
 
   /* both are non-reference pictures, check if needed for display */
-  if(!IS_REFERENCE(*pic1, FRAME) && !IS_REFERENCE(*pic2, FRAME)) {
+  if(!IS_REFERENCE(pic1, FRAME) && !IS_REFERENCE(pic2, FRAME)) {
     if(pic1->to_be_displayed && !pic2->to_be_displayed)
       return (-1);
     else if(!pic1->to_be_displayed && pic2->to_be_displayed)
@@ -244,10 +244,10 @@ i32 ComparePictures(const void *ptr1, const void *ptr2) {
       return (0);
   }
   /* only pic 1 needed for reference -> greater */
-  else if(!IS_REFERENCE(*pic2, FRAME))
+  else if(!IS_REFERENCE(pic2, FRAME))
     return (-1);
   /* only pic 2 needed for reference -> greater */
-  else if(!IS_REFERENCE(*pic1, FRAME))
+  else if(!IS_REFERENCE(pic1, FRAME))
     return (1);
   /* both are short term reference pictures -> check pic_num */
   else if(IS_SHORT_TERM(*pic1, FRAME) && IS_SHORT_TERM(*pic2, FRAME)) {
@@ -363,13 +363,13 @@ i32 ComparePicturesB(const void *ptr1, const void *ptr2, i32 curr_poc) {
   pic2 = (dpbPicture_t *) ptr2;
 
   /* both are non-reference pictures */
-  if(!IS_REFERENCE(*pic1, FRAME) && !IS_REFERENCE(*pic2, FRAME))
+  if(!IS_REFERENCE(pic1, FRAME) && !IS_REFERENCE(pic2, FRAME))
     return (0);
   /* only pic 1 needed for reference -> greater */
-  else if(!IS_REFERENCE(*pic2, FRAME))
+  else if(!IS_REFERENCE(pic2, FRAME))
     return (-1);
   /* only pic 2 needed for reference -> greater */
-  else if(!IS_REFERENCE(*pic1, FRAME))
+  else if(!IS_REFERENCE(pic1, FRAME))
     return (1);
   /* both are short term reference pictures -> check pic_order_cnt */
   else if(IS_SHORT_TERM(*pic1, FRAME) && IS_SHORT_TERM(*pic2, FRAME)) {
@@ -1428,8 +1428,8 @@ void h264DpbUpdateOutputList(dpbStorage_t * dpb) {
   if(dpb->current_out == dpb->buffer + dpb->dpb_size) {
     for(i = 0; i < dpb->dpb_size; i++) {
       if(!dpb->buffer[i].to_be_displayed &&
-          !IS_REFERENCE(dpb->buffer[i], 0) &&
-          !IS_REFERENCE(dpb->buffer[i], 1)) {
+          !IS_REFERENCE(&(dpb->buffer[i]), 0) &&
+          !IS_REFERENCE(&(dpb->buffer[i]), 1)) {
         dpbPicture_t tmp_pic = *dpb->current_out;
 
         *dpb->current_out = dpb->buffer[i];
@@ -1536,7 +1536,7 @@ void *h264bsdAllocateDpbImage(dpbStorage_t * dpb) {
 
   /*
    * ASSERT(!dpb->buffer[dpb->dpb_size].to_be_displayed &&
-   * !IS_REFERENCE(dpb->buffer[dpb->dpb_size]));
+   * !IS_REFERENCE(&(dpb->buffer[dpb->dpb_size])));
    * ASSERT(dpb->fullness <= dpb->dpb_size);
    */
 
@@ -2353,7 +2353,7 @@ u32 h264bsdCheckGapsInFrameNum(dpbStorage_t * dpb, u32 frame_num, u32 is_ref_pic
       /* add to end of list */
       /*
        * ASSERT(!dpb->buffer[dpb->dpb_size].to_be_displayed &&
-       * !IS_REFERENCE(dpb->buffer[dpb->dpb_size])); */
+       * !IS_REFERENCE(&(dpb->buffer[dpb->dpb_size]))); */
 #if 0
       (void)h264bsdAllocateDpbImage(dpb);
 #else
@@ -2714,14 +2714,19 @@ void h264bsdFreeDpb(
   (void)dwl;
 
   for(i = 0; i < dpb->tot_buffers; i++) {
-#ifdef USE_EXTERNAL_BUFFER
-    if (((storage_t *)(dpb->storage))->pp_enabled)
+#ifdef USE_NULL_POINTER_PROTECT
+    if(dpb->pic_buffers[i].virtual_address != NULL)
 #endif
     {
-      DWLFreeRefFrm(dwl, dpb->pic_buffers+i);
+#ifdef USE_EXTERNAL_BUFFER
+      if (((storage_t *)(dpb->storage))->pp_enabled)
+#endif
+      {
+        DWLFreeRefFrm(dwl, dpb->pic_buffers+i);
+      }
+      if(dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
+        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
     }
-    if(dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
-      ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
   }
 
   if(dpb->out_buf != NULL) {
@@ -3048,8 +3053,13 @@ void h264EmptyDpb(dpbStorage_t *dpb) {
 
 #ifdef USE_OMXIL_BUFFER
   for (i = 0; i < dpb->tot_buffers; i++) {
-    if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID) {
-      ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+#ifdef USE_NULL_POINTER_PROTECT
+    if (dpb->pic_buffers[i].virtual_address != NULL)
+#endif
+    {
+      if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID) {
+        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+      }
     }
   }
   dpb->fb_list->free_buffers = 0;
diff --git a/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c b/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c
index 277e464..573c2b9 100755
--- a/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c
+++ b/decoder_sw/software/source/h264high/h264hwd_dpb_lock.c
@@ -120,7 +120,9 @@ u32 AllocateIdUsed(FrameBufferList *fb_list, const void * data) {
     return FB_NOT_VALID_ID;
 
   fb_list->fb_stat[id].b_used = FB_ALLOCATED;
+  pthread_mutex_lock(&fb_list->ref_count_mutex);
   fb_list->fb_stat[id].n_ref_count = 0;
+  pthread_mutex_unlock(&fb_list->ref_count_mutex);
   fb_list->fb_stat[id].data = data;
 
   return id;
@@ -142,7 +144,9 @@ u32 AllocateIdFree(FrameBufferList *fb_list, const void * data) {
   fb_list->free_buffers++;
 
   fb_list->fb_stat[id].b_used = FB_FREE;
+  pthread_mutex_lock(&fb_list->ref_count_mutex);
   fb_list->fb_stat[id].n_ref_count = 0;
+  pthread_mutex_unlock(&fb_list->ref_count_mutex);
   fb_list->fb_stat[id].data = data;
   return id;
 }
@@ -168,7 +172,9 @@ void ReleaseId(FrameBufferList *fb_list, u32 id) {
   }
 
   fb_list->fb_stat[id].b_used = FB_UNALLOCATED;
+  pthread_mutex_lock(&fb_list->ref_count_mutex);
   fb_list->fb_stat[id].n_ref_count = 0;
+  pthread_mutex_unlock(&fb_list->ref_count_mutex);
   fb_list->fb_stat[id].data = NULL;
 }
 
@@ -740,7 +746,7 @@ void MarkIdAllocated(FrameBufferList *fb_list, u32 id) {
   DPB_TRACE(" id = %d
", id);
   pthread_mutex_lock(&fb_list->ref_count_mutex);
 
-  if (fb_list->fb_stat[id].b_used | FB_FREE) {
+  if (fb_list->fb_stat[id].b_used & FB_FREE) {
     fb_list->fb_stat[id].b_used &= ~FB_FREE;
     if (fb_list->fb_stat[id].n_ref_count == 0)
       fb_list->free_buffers--;
@@ -754,7 +760,7 @@ void MarkIdFree(FrameBufferList *fb_list, u32 id) {
   DPB_TRACE(" id = %d
", id);
   pthread_mutex_lock(&fb_list->ref_count_mutex);
 
-  if (fb_list->fb_stat[id].b_used | FB_ALLOCATED) {
+  if (fb_list->fb_stat[id].b_used & FB_ALLOCATED) {
     fb_list->fb_stat[id].b_used &= ~FB_ALLOCATED;
     if (fb_list->fb_stat[id].n_ref_count == 0)
       fb_list->free_buffers++;
@@ -788,9 +794,11 @@ void ClearAbortStatusInList(FrameBufferList *fb_list) {
 
 void ResetOutFifoInList(FrameBufferList *fb_list) {
   (void)DWLmemset(fb_list->out_fifo, 0, MAX_FRAME_BUFFER_NUMBER * sizeof(struct OutElement_));
+  pthread_mutex_lock(&fb_list->out_count_mutex);
   fb_list->wr_id = 0;
   fb_list->rd_id = 0;
   fb_list->num_out = 0;
+  pthread_mutex_unlock(&fb_list->out_count_mutex);
 }
 
 #endif
diff --git a/decoder_sw/software/source/h264high/h264hwd_storage.h b/decoder_sw/software/source/h264high/h264hwd_storage.h
index 45dfce5..dad5645 100755
--- a/decoder_sw/software/source/h264high/h264hwd_storage.h
+++ b/decoder_sw/software/source/h264high/h264hwd_storage.h
@@ -170,6 +170,7 @@ typedef struct {
 
   u32 intra_freeze;
   u32 partial_freeze;
+  u32 no_freeze;
   u32 picture_broken;
 
   u32 enable2nd_chroma;     /* by default set according to ENABLE_2ND_CHROMA
diff --git a/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c b/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
index 08b6e72..93136f1 100755
--- a/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
+++ b/decoder_sw/software/source/h264high/legacy/h264hwd_seq_param_set.c
@@ -263,8 +263,7 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
                                          &value);
     if (tmp != HANTRO_OK)
       return(tmp);
-    if( tmp > 1 )
-      return(HANTRO_NOK);
+
     p_seq_param_set->chroma_format_idc = value;
     if (p_seq_param_set->chroma_format_idc == 0)
       p_seq_param_set->mono_chrome = 1;
@@ -556,6 +555,7 @@ u32 h264bsdDecodeSeqParamSet(strmData_t *p_strm_data, seqParamSet_t *p_seq_param
     /* TODO: skip rest of the stuff if equal to 1 */
   }
 
+  (void)(tmp);
   tmp = h264bsdRbspTrailingBits(p_strm_data);
 
   /* ignore possible errors in trailing bits of parameters sets */
@@ -899,7 +899,7 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
 
   u32 tmp, i, j, k;
   u32 value, tmp_count, tmp_count1, tmp_count2;
-  hrdParameters_t hrd_params;
+  hrdParameters_t hrd_params = { 0 };
 
   /* Code */
 
@@ -992,6 +992,7 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
       /* applicable_op_temporal_id  */
       tmp = h264bsdGetBits(p_strm_data, 3);
       /* applicable_op_num_target_views_minus1 */
+      (void)(tmp);
       tmp = h264bsdDecodeExpGolombUnsigned(p_strm_data, &value);
       if (tmp != HANTRO_OK)
         return(tmp);
@@ -1001,6 +1002,7 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
         tmp = h264bsdDecodeExpGolombUnsigned(p_strm_data, &value);
       }
       /* applicable_op_num_views_minus1 */
+      (void)(tmp);
       tmp = h264bsdDecodeExpGolombUnsigned(p_strm_data, &value);
       if (tmp != HANTRO_OK)
         return(tmp);
@@ -1017,8 +1019,10 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
     tmp_count = value + 1;
     for (i = 0; i < tmp_count; i++) {
       /* vui_mvc_temporal_id  */
+      (void)(tmp);
       tmp = h264bsdGetBits(p_strm_data, 3);
       /* vui_mvc_num_target_output_views_minus1 */
+      (void)(tmp);
       tmp = h264bsdDecodeExpGolombUnsigned(p_strm_data, &value);
       if (tmp != HANTRO_OK)
         return(tmp);
@@ -1028,6 +1032,7 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
         tmp = h264bsdDecodeExpGolombUnsigned(p_strm_data, &value);
       }
       /* vui_mvc_timing_info_present_flag  */
+      (void)(tmp);
       tmp = h264bsdGetBits(p_strm_data, 1);
       if (tmp == 1) {
         /* vui_mvc_num_units_in_tick  */
@@ -1035,15 +1040,18 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
         if (h264bsdFlushBits(p_strm_data, 32) == END_OF_STREAM)
           return(END_OF_STREAM);
         /* vui_mvc_time_scale  */
+        (void)(tmp);
         tmp = h264bsdShowBits(p_strm_data,32);
         if (h264bsdFlushBits(p_strm_data, 32) == END_OF_STREAM)
           return(END_OF_STREAM);
         /* vui_mvc_fixed_frame_rate_flag */
+        (void)(tmp);
         tmp = h264bsdGetBits(p_strm_data, 1);
       }
 
       j = 0;
       /* vui_mvc_nal_hrd_parameters_present_flag */
+      (void)(tmp);
       tmp = h264bsdGetBits(p_strm_data, 1);
       if (tmp == 1) {
         j = 1;
@@ -1051,6 +1059,7 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
       }
 
       /* vui_mvc_vcl_hrd_parameters_present_flag */
+      (void)(tmp);
       tmp = h264bsdGetBits(p_strm_data, 1);
       if (tmp == 1) {
         j = 1;
@@ -1059,9 +1068,11 @@ u32 DecodeMvcExtension(strmData_t *p_strm_data, seqParamSet_t *p_seq_param_set)
 
       if (j) {
         /* vui_mvc_low_delay_hrd_flag */
+        (void)(tmp);
         tmp = h264bsdGetBits(p_strm_data, 1);
       }
       /* vui_mvc_pic_struct_present_flag */
+      (void)(tmp);
       tmp = h264bsdGetBits(p_strm_data, 1);
     }
 
diff --git a/decoder_sw/software/source/h264high/legacy/h264hwd_stream.c b/decoder_sw/software/source/h264high/legacy/h264hwd_stream.c
index 165cb5e..7e6087f 100755
--- a/decoder_sw/software/source/h264high/legacy/h264hwd_stream.c
+++ b/decoder_sw/software/source/h264high/legacy/h264hwd_stream.c
@@ -159,7 +159,7 @@ u32 h264bsdShowBits(strmData_t * p_strm_data, u32 num_bits) {
       if(out_bits <= 24)
         out |= (u32) (*p_strm++) << (24 - out_bits);
       else
-        out |= (u32) (*p_strm++) >> (out_bits - 24);
+        out |= (out_bits - 24) > 7 ? 0 : ((u32) (*p_strm++) >> (out_bits - 24));
 
       out_bits += 8;
       bits -= 8;
diff --git a/decoder_sw/software/source/hevc/hevc_decoder.c b/decoder_sw/software/source/hevc/hevc_decoder.c
index 0f4b346..fc6750e 100755
--- a/decoder_sw/software/source/hevc/hevc_decoder.c
+++ b/decoder_sw/software/source/hevc/hevc_decoder.c
@@ -226,11 +226,13 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
     if (tmp != HANTRO_OK) {
       ERROR_PRINT("SEQ_PARAM_SET decoding");
       ret = HEVC_ERROR;
+      (void)(ret);
     } else {
       tmp = HevcStoreSeqParamSet(storage, &seq_param_set);
       if (tmp != HANTRO_OK) {
         ERROR_PRINT("SEQ_PARAM_SET allocation");
         ret = HEVC_ERROR;
+        (void)(ret);
       }
     }
     ret = HEVC_RDY;
@@ -249,6 +251,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
         ret = HEVC_ERROR;
       }
     }
+    (void)(ret);
     ret = HEVC_RDY;
     goto NEXT_NAL;
 
@@ -265,6 +268,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
         ret = HEVC_ERROR;
       }
     }
+    (void)(ret);
     ret = HEVC_RDY;
     goto NEXT_NAL;
 
@@ -278,6 +282,7 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
       ERROR_PRINT("SEI decoding");
       ret = HEVC_ERROR;
     }
+    (void)(ret);
     ret = HEVC_RDY;
     goto NEXT_NAL;
 
@@ -424,8 +429,9 @@ u32 HevcDecode(struct HevcDecContainer *dec_cont, const u8 *byte_strm, u32 strm_
         storage->prev_bytes_consumed = strm.strm_data_size;
         *read_bytes = strm_len;
         return ret;
+#else
+      goto NEXT_NAL;
 #endif
-        goto NEXT_NAL;
       }
 
       if (nal_unit.nal_unit_type == NAL_CODED_SLICE_CRA &&
diff --git a/decoder_sw/software/source/hevc/hevc_dpb.c b/decoder_sw/software/source/hevc/hevc_dpb.c
index 566f9d9..ed20f83 100755
--- a/decoder_sw/software/source/hevc/hevc_dpb.c
+++ b/decoder_sw/software/source/hevc/hevc_dpb.c
@@ -46,8 +46,8 @@
 
 /* Function style implementation for IS_REFERENCE() macro to fix compiler
  * warnings */
-static u32 IsReference(const struct DpbPicture a) {
-  return (a.status && a.status != EMPTY);
+static u32 IsReference(const struct DpbPicture* a) {
+  return (a->status && a->status != EMPTY);
 }
 
 static u32 IsExisting(const struct DpbPicture *a) {
@@ -160,7 +160,7 @@ void *HevcAllocateDpbImage(struct DpbStorage *dpb, i32 pic_order_cnt,
 
   /* find first unused and not-to-be-displayed pic */
   for (i = 0; i <= dpb->dpb_size; i++) {
-    if (!dpb->buffer[i].to_be_displayed && !IS_REFERENCE(dpb->buffer[i])) break;
+    if (!dpb->buffer[i].to_be_displayed && !IS_REFERENCE(&dpb->buffer[i])) break;
   }
 
 
@@ -389,7 +389,7 @@ u32 HevcReInitDpb(const void *dec_inst, struct DpbStorage *dpb,
     for (i = old_dpb_size + 1; i < dpb->dpb_size + 1; i++) {
       /* Find a unused buffer j. */
       u32 j, id;
-      for (j = 0; j < MAX_FRAME_BUFFER_NUMBER; j++) {
+      for (j = 0; j < MAX_FRAME_BUFFER_NUMBER;) {
         u32 found = 0;
         for (u32 k = 0; k < i; k++) {
           if (dpb->pic_buffers[j].bus_address == dpb->buffer[k].data->bus_address) {
@@ -399,8 +399,13 @@ u32 HevcReInitDpb(const void *dec_inst, struct DpbStorage *dpb,
         }
         if (!found)
           break;
+        if(++j >= MAX_FRAME_BUFFER_NUMBER)
+          break;
       }
       ASSERT(j < MAX_FRAME_BUFFER_NUMBER);
+      /* if not found, j should be MAX_FRAME_BUFFER_NUMBER - 1 */
+      if (j >= MAX_FRAME_BUFFER_NUMBER)
+        j = MAX_FRAME_BUFFER_NUMBER - 1;
       dpb->buffer[i].data = dpb->pic_buffers + j;
       id = GetIdByData(fb_list, (void *)dpb->buffer[i].data);
       MarkIdAllocated(fb_list, id);
@@ -684,7 +689,7 @@ void HevcDpbMarkOlderUnused(struct DpbStorage *dpb, i32 pic_order_cnt, u32 hrd_p
   for (i = 0; i < MAX_DPB_SIZE; i++) {
 
     if (dpb->buffer[i].is_tsa_ref ||
-        (IS_REFERENCE(dpb->buffer[i]) &&
+        (IS_REFERENCE(&dpb->buffer[i]) &&
          GET_POC(dpb->buffer[i]) <= pic_order_cnt)) {
       SET_STATUS(dpb->buffer[i], UNUSED);
       if (dpb->buffer[i].to_be_displayed) {
@@ -817,7 +822,7 @@ u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
     else if (lt_count[i])
       SET_STATUS(dpb->buffer[i], LONG_TERM);
     /* picture marked as not used */
-    else if (IS_REFERENCE(dpb->buffer[i])) {
+    else if (IS_REFERENCE(&dpb->buffer[i])) {
       SET_STATUS(dpb->buffer[i], UNUSED);
       DpbBufFree(dpb, i);
     }
@@ -825,9 +830,9 @@ u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
   /* if last element (index dpb_size) is used as reference -> swap with an
    * unused element earlier in the list (probably not necessary if dpb_size
    * less than 16, but done anyway) */
-  if (IS_REFERENCE(dpb->buffer[dpb->dpb_size])) {
+  if (IS_REFERENCE(&dpb->buffer[dpb->dpb_size])) {
     for (i = 0; i < dpb->dpb_size; i++) {
-      if (!IS_REFERENCE(dpb->buffer[i])) {
+      if (!IS_REFERENCE(&dpb->buffer[i])) {
         idx = i;
         break;
       }
@@ -836,6 +841,8 @@ u32 HevcSetRefPics(struct DpbStorage *dpb, struct SliceHeader *slice_header,
     {
       struct DpbPicture tmp_pic = dpb->buffer[i];
 
+      if (idx < 0)
+        return DEC_PARAM_ERROR;
       dpb->buffer[idx] = dpb->buffer[dpb->dpb_size];
       dpb->buffer[dpb->dpb_size] = tmp_pic;
     }
@@ -863,7 +870,7 @@ static i32 FindDpbPic(struct DpbStorage *dpb, i32 poc) {
   while (i <= dpb->dpb_size) {
     if ((dpb->buffer[i].pic_order_cnt == poc ||
          dpb->buffer[i].pic_order_cnt_lsb == poc) &&
-        IS_REFERENCE(dpb->buffer[i])) {
+        IS_REFERENCE(&dpb->buffer[i])) {
       return i;
     }
     i++;
@@ -975,7 +982,7 @@ u32 OutputPicture(struct DpbStorage *dpb) {
   dpb->out_index_w++;
   if (dpb->out_index_w == MAX_DPB_SIZE + 1) dpb->out_index_w = 0;
 
-  if (!IS_REFERENCE(*tmp)) {
+  if (!IS_REFERENCE(tmp)) {
     if (dpb->fullness > 0)
       dpb->fullness--;
   }
@@ -1024,9 +1031,14 @@ void HevcFreeDpb(const void *dwl, struct DpbStorage *dpb) {
   ASSERT(dpb);
 
   for (i = 0; i < dpb->tot_buffers; i++) {
-    DWLFreeRefFrm(dwl, dpb->pic_buffers + i);
-    if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
-      ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+#ifdef USE_NULL_POINTER_PROTECT
+    if (dpb->pic_buffers[i].virtual_address != NULL)
+#endif
+    {
+      DWLFreeRefFrm(dwl, dpb->pic_buffers + i);
+      if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
+        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+    }
   }
 
   if (dpb->out_buf != NULL) {
@@ -1045,22 +1057,32 @@ i32 HevcFreeDpbExt(const void *dec_inst, struct DpbStorage *dpb) {
   if (IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, REFERENCE_BUFFER)) {
     /* Client will make sure external memory to be freed.*/
     for (i = 0; i < dpb->tot_buffers; i++) {
-      if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
-        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+#ifdef USE_NULL_POINTER_PROTECT
+      if (dpb->pic_buffers[i].virtual_address != NULL)
+#endif
+      {
+        if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
+          ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
         /*
-              dec_cont->buf_to_free = dpb->pic_buffers + i;
-              dec_cont->next_buf_size = 0;
+                dec_cont->buf_to_free = dpb->pic_buffers + i;
+                dec_cont->next_buf_size = 0;
 #ifdef ASIC_TRACE_SUPPORT
-              dec_cont->is_frame_buffer = 1;
+                dec_cont->is_frame_buffer = 1;
 #endif
-              return DEC_WAITING_FOR_BUFFER;
+                return DEC_WAITING_FOR_BUFFER;
         */
+      }
     }
   } else {
     for (i = 0; i < dpb->tot_buffers; i++) {
-      DWLFreeRefFrm(dec_cont->dwl, dpb->pic_buffers + i);
-      if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
-        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+#ifdef USE_NULL_POINTER_PROTECT
+      if (dpb->pic_buffers[i].virtual_address != NULL)
+#endif
+      {
+        DWLFreeRefFrm(dec_cont->dwl, dpb->pic_buffers + i);
+        if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
+          ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+      }
     }
   }
 
@@ -1075,10 +1097,15 @@ i32 HevcFreeDpb(const void *dec_inst, struct DpbStorage *dpb) {
   ASSERT(dpb);
 
   for (i = 0; i < dpb->tot_buffers; i++) {
-    if (!IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, REFERENCE_BUFFER))
-      DWLFreeRefFrm(dec_cont->dwl, dpb->pic_buffers + i);
-    if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
-      ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+#ifdef USE_NULL_POINTER_PROTECT
+    if (dpb->pic_buffers[i].virtual_address != NULL)
+#endif
+    {
+      if (!IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, REFERENCE_BUFFER))
+        DWLFreeRefFrm(dec_cont->dwl, dpb->pic_buffers + i);
+      if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID)
+        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+    }
   }
 
   if (dpb->out_buf != NULL) {
@@ -1108,7 +1135,7 @@ u32 HevcDpbMarkAllUnused(struct DpbStorage *dpb) {
   u32 i;
 
   for (i = 0; i < MAX_DPB_SIZE; i++) {
-    if (IS_REFERENCE(dpb->buffer[i])) {
+    if (IS_REFERENCE(&dpb->buffer[i])) {
       SET_STATUS(dpb->buffer[i], UNUSED);
       DpbBufFree(dpb, i);
     }
@@ -1220,7 +1247,7 @@ u32 HevcDpbHrdBumping(struct DpbStorage *dpb) {
   dpb->out_index_w++;
   if (dpb->out_index_w == MAX_DPB_SIZE + 1) dpb->out_index_w = 0;
 
-  if (!IS_REFERENCE(*tmp)) {
+  if (!IS_REFERENCE(tmp)) {
     if(dpb->fullness > 0)
       dpb->fullness--;
   }
@@ -1287,8 +1314,13 @@ void HevcEmptyDpb(const void *dec_inst, struct DpbStorage *dpb) {
 
   if (IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, REFERENCE_BUFFER)) {
     for (i = 0; i < dpb->tot_buffers; i++) {
-      if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID) {
-        ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+#ifdef USE_NULL_POINTER_PROTECT
+      if (dpb->pic_buffers[i].virtual_address != NULL)
+#endif
+      {
+        if (dpb->pic_buff_id[i] != FB_NOT_VALID_ID) {
+          ReleaseId(dpb->fb_list, dpb->pic_buff_id[i]);
+        }
       }
     }
     dpb->fb_list->free_buffers = 0;
diff --git a/decoder_sw/software/source/hevc/hevc_fb_mngr.c b/decoder_sw/software/source/hevc/hevc_fb_mngr.c
index 34d7650..84a832e 100755
--- a/decoder_sw/software/source/hevc/hevc_fb_mngr.c
+++ b/decoder_sw/software/source/hevc/hevc_fb_mngr.c
@@ -788,7 +788,9 @@ void ResetOutFifoInList(struct FrameBufferList *fb_list) {
   (void)DWLmemset(fb_list->out_fifo, 0, MAX_FRAME_BUFFER_NUMBER * sizeof(struct OutElement));
   fb_list->out_wr_id = 0;
   fb_list->out_rd_id = 0;
+  pthread_mutex_lock(&fb_list->out_count_mutex);
   fb_list->num_out = 0;
+  pthread_mutex_unlock(&fb_list->out_count_mutex);
 }
 
 
@@ -796,7 +798,7 @@ void MarkIdAllocated(struct FrameBufferList *fb_list, u32 id) {
   DPB_TRACE(" id = %d
", id);
   pthread_mutex_lock(&fb_list->ref_count_mutex);
 
-  if (fb_list->fb_stat[id].b_used | FB_FREE) {
+  if (fb_list->fb_stat[id].b_used & FB_FREE) {
     fb_list->fb_stat[id].b_used &= ~FB_FREE;
     if (fb_list->fb_stat[id].n_ref_count == 0)
       fb_list->free_buffers--;
@@ -811,7 +813,7 @@ void MarkIdFree(struct FrameBufferList *fb_list, u32 id)
   DPB_TRACE(" id = %d
", id);
   pthread_mutex_lock(&fb_list->ref_count_mutex);
 
-  if (fb_list->fb_stat[id].b_used | FB_ALLOCATED) {
+  if (fb_list->fb_stat[id].b_used & FB_ALLOCATED) {
     fb_list->fb_stat[id].b_used &= ~FB_ALLOCATED;
     if (fb_list->fb_stat[id].n_ref_count == 0)
       fb_list->free_buffers++;
diff --git a/decoder_sw/software/source/hevc/hevc_slice_header.c b/decoder_sw/software/source/hevc/hevc_slice_header.c
index f87cd06..393ec90 100755
--- a/decoder_sw/software/source/hevc/hevc_slice_header.c
+++ b/decoder_sw/software/source/hevc/hevc_slice_header.c
@@ -177,6 +177,7 @@ u32 HevcDecodeSliceHeader(struct StrmData* stream,
       u32 len;
 
       if (seq_param_set->num_long_term_ref_pics) {
+        (void)(tmp);
         tmp = HevcDecodeExpGolombUnsigned(stream, &value);
         if (tmp != HANTRO_OK) return (tmp);
         if (value > MAX_NUM_LT_REF_PICS_SPS) {
@@ -185,6 +186,7 @@ u32 HevcDecodeSliceHeader(struct StrmData* stream,
         }
         slice_header->num_long_term_sps = value;
       }
+      (void)(tmp);
       tmp = HevcDecodeExpGolombUnsigned(stream, &value);
       if (tmp != HANTRO_OK) return (tmp);
       if (value > MAX_NUM_LT_REF_PICS_SPS) {
@@ -241,11 +243,13 @@ u32 HevcDecodeSliceHeader(struct StrmData* stream,
     stream->emul_byte_count += tmp_count;
 
     if (seq_param_set->temporal_mvp_enable) {
+      (void)(tmp);
       tmp = SwGetBits(stream, 1);
       if (tmp == END_OF_STREAM) return(HANTRO_NOK);
     }
 
     if (seq_param_set->sample_adaptive_offset_enable) {
+      (void)(tmp);
       tmp = SwGetBits(stream, 1);
       if (tmp == END_OF_STREAM) return(HANTRO_NOK);
       tmp = SwGetBits(stream, 1);
@@ -253,6 +257,7 @@ u32 HevcDecodeSliceHeader(struct StrmData* stream,
     }
     if (IS_P_SLICE(slice_header->slice_type) ||
         IS_B_SLICE(slice_header->slice_type)) {
+      (void)(tmp);
       tmp = SwGetBits(stream, 1);
       if (tmp == END_OF_STREAM) return(HANTRO_NOK);
       if (tmp) {
diff --git a/decoder_sw/software/source/hevc/hevcdecapi.c b/decoder_sw/software/source/hevc/hevcdecapi.c
index eb1d3a7..1178ed3 100755
--- a/decoder_sw/software/source/hevc/hevcdecapi.c
+++ b/decoder_sw/software/source/hevc/hevcdecapi.c
@@ -1607,13 +1607,13 @@ void HevcGetHdr10MetaData(const struct Storage *storage,
 /* Get last decoded picture if any available. No pictures are removed
  * from output nor DPB buffers. */
 enum DecRet HevcDecPeek(HevcDecInst dec_inst, struct HevcDecPicture *output) {
-  struct HevcDecContainer *dec_cont = (struct HevcDecContainer *)dec_inst;
-  struct DpbPicture *current_out = dec_cont->storage.dpb->current_out;
-
   if (dec_inst == NULL || output == NULL) {
     return (DEC_PARAM_ERROR);
   }
 
+  struct HevcDecContainer *dec_cont = (struct HevcDecContainer *)dec_inst;
+  struct DpbPicture *current_out = dec_cont->storage.dpb->current_out;
+
   /* Check for valid decoder instance */
   if (dec_cont->checksum != dec_cont) {
     return (DEC_NOT_INITIALIZED);
diff --git a/decoder_sw/software/source/inc/decapi.h b/decoder_sw/software/source/inc/decapi.h
index a8c0d4f..d9590f0 100755
--- a/decoder_sw/software/source/inc/decapi.h
+++ b/decoder_sw/software/source/inc/decapi.h
@@ -59,7 +59,7 @@ typedef void ClientBufferDecoded(ClientInst inst, struct DecInput* input);
 /* Function to notify about picture that is ready to be outputted. Client is
  * expected to notify the decoder when it has finished processing the picture,
  * so decoder can reuse the picture buffer for another picture. */
-typedef void ClientPictureReady(ClientInst inst, struct DecPicture picture);
+typedef void ClientPictureReady(ClientInst inst, struct DecPicture* picture);
 /* Function to notify the client that all the pending pictures have been
  * outputted and decoder can be safely shut down. */
 typedef void ClientEndOfStream(ClientInst inst);
@@ -96,7 +96,7 @@ struct DecSwHwBuild DecGetBuild(void);
  * callbacks parameter must be valid until client has successfully executed
  * a call to DecRelease function. */
 enum DecRet DecInit(enum DecCodec codec, DecInst* decoder,
-                    struct DecConfig config, struct DecClientHandle callbacks);
+                    struct DecConfig* config, struct DecClientHandle callbacks);
 
 /* Function to dispatch a buffer containing video bitstream to be decoded by the
  * component. Buffer can be reused after the function has returned, during the
@@ -120,7 +120,7 @@ enum DecRet DecSetPictureBuffers(DecInst dec_inst,
 /* Function to tell the decoder that client has finished processing a specific
  * picture that was previously sent to client through the PictureReady callback.
  */
-enum DecRet DecPictureConsumed(DecInst dec_inst, struct DecPicture picture);
+enum DecRet DecPictureConsumed(DecInst dec_inst, struct DecPicture* picture);
 
 /* Function to tell the decoder that it should not be expecting any more input
  * stream and Finish decoding and outputting all the buffers that are currently
diff --git a/decoder_sw/software/source/inc/decapicommon.h b/decoder_sw/software/source/inc/decapicommon.h
index 9cc1453..0f02092 100755
--- a/decoder_sw/software/source/inc/decapicommon.h
+++ b/decoder_sw/software/source/inc/decapicommon.h
@@ -285,7 +285,8 @@ enum DecErrorHandling {
   DEC_EC_VIDEO_FREEZE = 1,
   DEC_EC_PARTIAL_FREEZE = 2,
   DEC_EC_PARTIAL_IGNORE = 3,
-  DEC_EC_FAST_FREEZE = 4
+  DEC_EC_FAST_FREEZE = 4,
+  DEC_EC_NONE = 5		/*no freeze: h264 only*/
 };
 
 struct DecDownscaleCfg {
diff --git a/decoder_sw/software/source/jpeg/jpegdecapi.c b/decoder_sw/software/source/jpeg/jpegdecapi.c
index f398b21..fa35e8c 100755
--- a/decoder_sw/software/source/jpeg/jpegdecapi.c
+++ b/decoder_sw/software/source/jpeg/jpegdecapi.c
@@ -1989,6 +1989,7 @@ JpegDecRet JpegDecDecode(JpegDecInst dec_inst, JpegDecInput * p_dec_in,
         if(PTR_JPGC->stream.bit_pos_in_byte) {
           /* delete stuffing bits */
           current_byte = (8 - PTR_JPGC->stream.bit_pos_in_byte);
+          (void)(current_byte);
           if(JpegDecFlushBits
               (&(PTR_JPGC->stream),
                8 - PTR_JPGC->stream.bit_pos_in_byte) == STRM_ERROR) {
diff --git a/decoder_sw/software/source/jpeg/jpegdecinternal.c b/decoder_sw/software/source/jpeg/jpegdecinternal.c
index 579b506..d1d03ef 100755
--- a/decoder_sw/software/source/jpeg/jpegdecinternal.c
+++ b/decoder_sw/software/source/jpeg/jpegdecinternal.c
@@ -1205,9 +1205,6 @@ static void JpegDecSetHwStrmParams(JpegDecContainer * jpeg_dec_cont) {
   case 7:
     JPG_STR.bit_pos_in_byte += 56;
     break;
-  default:
-    ASSERT(0);
-    break;
   }
 
   SetDecRegister(PTR_JPGC->jpeg_regs, HWIF_STRM_START_BIT,
@@ -2457,10 +2454,7 @@ static void JpegDecWriteTablesNonInterleaved(JpegDecContainer * jpeg_dec_cont) {
     }
 
     /* set pointer */
-    if(count == 3)
-      qp_table_base = 0;
-    else
-      qp_table_base = JPEGDEC_QP_BASE;
+    qp_table_base = JPEGDEC_QP_BASE;
 
     p_table_base =
       &PTR_JPGC->frame.p_table_base.virtual_address[JPEGDEC_AC1_BASE -
@@ -2511,10 +2505,7 @@ static void JpegDecWriteTablesNonInterleaved(JpegDecContainer * jpeg_dec_cont) {
     }
 
     /* set pointer */
-    if(count == 3)
-      qp_table_base = 0;
-    else
-      qp_table_base = JPEGDEC_QP_BASE;
+    qp_table_base = JPEGDEC_QP_BASE;
 
     p_table_base =
       &PTR_JPGC->frame.p_table_base.virtual_address[JPEGDEC_DC1_BASE -
@@ -2980,9 +2971,9 @@ static void JpegDecWriteLenBitsNonInterleaved(JpegDecContainer * jpeg_dec_cont)
 #define JPG_FRM     jpeg_dec_cont->frame
 
   VlcTable *p_table1 = NULL;
-  VlcTable *p_table2 = NULL;
+  //VlcTable *p_table2 = NULL;
 #ifdef NDEBUG
-  UNUSED(p_table2);
+  //UNUSED(p_table2);
 #endif
 
   /* first select the table we'll use */
@@ -2991,16 +2982,16 @@ static void JpegDecWriteLenBitsNonInterleaved(JpegDecContainer * jpeg_dec_cont)
   if(JPG_SCN.Ta[PTR_JPGC->info.component_id] == 0) {
 
     p_table1 = &(JPG_VLC.ac_table0);
-    p_table2 = &(JPG_VLC.ac_table1);
+    //p_table2 = &(JPG_VLC.ac_table1);
 
   } else {
 
     p_table1 = &(JPG_VLC.ac_table1);
-    p_table2 = &(JPG_VLC.ac_table0);
+    //p_table2 = &(JPG_VLC.ac_table0);
   }
 
   ASSERT(p_table1);
-  ASSERT(p_table2);
+  //ASSERT(p_table2);
 
   /* write AC table 1 (luma) */
 
@@ -3024,16 +3015,16 @@ static void JpegDecWriteLenBitsNonInterleaved(JpegDecContainer * jpeg_dec_cont)
   if(JPG_SCN.Td[PTR_JPGC->info.component_id] == 0) {
 
     p_table1 = &(JPG_VLC.dc_table0);
-    p_table2 = &(JPG_VLC.dc_table1);
+    //p_table2 = &(JPG_VLC.dc_table1);
 
   } else {
 
     p_table1 = &(JPG_VLC.dc_table1);
-    p_table2 = &(JPG_VLC.dc_table0);
+    //p_table2 = &(JPG_VLC.dc_table0);
   }
 
   ASSERT(p_table1);
-  ASSERT(p_table2);
+  //ASSERT(p_table2);
 
   /* write DC table 1 (luma) */
   SetDecRegister(PTR_JPGC->jpeg_regs, HWIF_DC1_CODE1_CNT, p_table1->bits[0]);
diff --git a/decoder_sw/software/source/jpeg/jpegdecscan.c b/decoder_sw/software/source/jpeg/jpegdecscan.c
index 9939151..48abe29 100755
--- a/decoder_sw/software/source/jpeg/jpegdecscan.c
+++ b/decoder_sw/software/source/jpeg/jpegdecscan.c
@@ -133,6 +133,8 @@ JpegDecRet JpegDecDecodeScanHeader(JpegDecContainer * p_dec_data) {
     return (JPEGDEC_STRM_ERROR);
 
   p_dec_data->scan.Ns = JpegDecGetByte(stream);
+  if (p_dec_data->scan.Ns > MAX_NUMBER_OF_COMPONENTS)
+    return (JPEGDEC_STRM_ERROR);
 
   p_dec_data->info.fill_x = p_dec_data->info.fill_y = 0;
   if(p_dec_data->scan.Ns == 1) {
@@ -143,6 +145,8 @@ JpegDecRet JpegDecDecodeScanHeader(JpegDecContainer * p_dec_data) {
 
     tmp = JpegDecGetByte(&(p_dec_data->stream));
     p_dec_data->frame.c_index = tmp - 1;
+    if (p_dec_data->frame.c_index >= MAX_NUMBER_OF_COMPONENTS)
+      return (JPEGDEC_STRM_ERROR);
     p_dec_data->info.component_id = p_dec_data->frame.c_index;
     p_dec_data->scan.Cs[p_dec_data->frame.c_index] = tmp;
     tmp = JpegDecGetByte(stream);
diff --git a/decoder_sw/software/source/mpeg2/mpeg2decapi.c b/decoder_sw/software/source/mpeg2/mpeg2decapi.c
index 3eeeca0..9e5f7f1 100755
--- a/decoder_sw/software/source/mpeg2/mpeg2decapi.c
+++ b/decoder_sw/software/source/mpeg2/mpeg2decapi.c
@@ -3669,7 +3669,7 @@ static void Mpeg2PpControl(DecContainer * dec_container, u32 pipeline_off) {
           dec_container->StrmStorage.p_pic_buf[index_for_pp].send_to_pp = 2;
         } else {
           MPEG2DEC_API_DEBUG(("PIPELINE OFF, DON*T SEND B TO PP
"));
-          index_for_pp = dec_container->StrmStorage.work_out;
+          //index_for_pp = dec_container->StrmStorage.work_out;
           index_for_pp = MPEG2_BUFFER_UNDEFINED;
           pc->input_bus_luma = 0;
         }
@@ -4353,7 +4353,10 @@ void Mpeg2StateReset(DecContainer *dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_display);
-  FifoInit(MPEG2_MAX_BUFFERS*2, &dec_cont->fifo_display);
+  if (FifoInit(MPEG2_MAX_BUFFERS*2, &dec_cont->fifo_display) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
 }
 
diff --git a/decoder_sw/software/source/mpeg2/mpeg2hwd_headers.c b/decoder_sw/software/source/mpeg2/mpeg2hwd_headers.c
index 7c28a44..1ded0b6 100755
--- a/decoder_sw/software/source/mpeg2/mpeg2hwd_headers.c
+++ b/decoder_sw/software/source/mpeg2/mpeg2hwd_headers.c
@@ -377,13 +377,16 @@ u32 mpeg2_strm_dec_decode_picture_header(DecContainer * dec_container) {
 
   tmp = dec_container->Hdrs.vbv_delay =
           mpeg2_strm_dec_get_bits(dec_container, 16);
+  (void) (tmp);
 
   if(dec_container->Hdrs.picture_coding_type == PFRAME ||
       dec_container->Hdrs.picture_coding_type == BFRAME) {
     tmp = dec_container->Hdrs.f_code[0][0] =
             mpeg2_strm_dec_get_bits(dec_container, 1);
+    (void) (tmp);
     tmp = dec_container->Hdrs.f_code[0][1] =
             mpeg2_strm_dec_get_bits(dec_container, 3);
+    (void) (tmp);
     if(dec_container->Hdrs.mpeg2_stream == MPEG1 &&
         dec_container->Hdrs.f_code[0][1] == 0) {
       return (HANTRO_NOK);
@@ -393,8 +396,10 @@ u32 mpeg2_strm_dec_decode_picture_header(DecContainer * dec_container) {
   if(dec_container->Hdrs.picture_coding_type == BFRAME) {
     tmp = dec_container->Hdrs.f_code[1][0] =
             mpeg2_strm_dec_get_bits(dec_container, 1);
+    (void) (tmp);
     tmp = dec_container->Hdrs.f_code[1][1] =
             mpeg2_strm_dec_get_bits(dec_container, 3);
+    (void) (tmp);
     if(dec_container->Hdrs.mpeg2_stream == MPEG1 &&
         dec_container->Hdrs.f_code[1][1] == 0)
       return (HANTRO_NOK);
@@ -708,24 +713,31 @@ u32 mpeg2_strm_dec_decode_seq_display_ext_header(DecContainer * dec_container) {
 
   tmp = dec_container->Hdrs.video_format =
           mpeg2_strm_dec_get_bits(dec_container, 3);
+  (void)(tmp);
   tmp = dec_container->Hdrs.color_description =
           mpeg2_strm_dec_get_bits(dec_container, 1);
 
   if(dec_container->Hdrs.color_description) {
+    (void)(tmp);
     tmp = dec_container->Hdrs.color_primaries =
             mpeg2_strm_dec_get_bits(dec_container, 8);
+    (void)(tmp);
     tmp = dec_container->Hdrs.transfer_characteristics =
             mpeg2_strm_dec_get_bits(dec_container, 8);
+    (void)(tmp);
     tmp = dec_container->Hdrs.matrix_coefficients =
             mpeg2_strm_dec_get_bits(dec_container, 8);
   }
 
+  (void)(tmp);
   tmp = dec_container->Hdrs.display_horizontal_size =
           mpeg2_strm_dec_get_bits(dec_container, 14);
 
   /* marker bit ==> flush */
+  (void)(tmp);
   tmp = mpeg2_strm_dec_flush_bits(dec_container, 1);
 
+  (void)(tmp);
   tmp = dec_container->Hdrs.display_vertical_size =
           mpeg2_strm_dec_get_bits(dec_container, 14);
   if(tmp == END_OF_STREAM)
@@ -765,11 +777,13 @@ u32 mpeg2_strm_dec_decode_qmatrix_ext_header(DecContainer * dec_container) {
   if(p_hdr->load_intra_matrix == 1) {
     /* load intra matrix */
     for(i = 0; i < 64; i++) {
+      (void)(tmp);
       tmp = p_hdr->q_table_intra[scan_order[ZIGZAG][i]] =
               mpeg2_strm_dec_get_bits(dec_container, 8);
     }
   }
 
+  (void)(tmp);
   tmp = p_hdr->load_non_intra_matrix = mpeg2_strm_dec_get_bits(dec_container, 1);
   if(tmp == END_OF_STREAM)
     return (END_OF_STREAM);
diff --git a/decoder_sw/software/source/mpeg2/mpeg2hwd_strm.c b/decoder_sw/software/source/mpeg2/mpeg2hwd_strm.c
index ab37c85..451176c 100755
--- a/decoder_sw/software/source/mpeg2/mpeg2hwd_strm.c
+++ b/decoder_sw/software/source/mpeg2/mpeg2hwd_strm.c
@@ -99,6 +99,7 @@ u32 mpeg2_strm_dec_decode(DecContainer * dec_container) {
     switch (start_code) {
     case SC_SEQUENCE:
       /* Sequence header */
+      (void)(status);
       status = mpeg2_strm_dec_decode_sequence_header(dec_container);
       dec_container->StrmStorage.valid_sequence = status == HANTRO_OK;
       if( dec_container->StrmStorage.new_headers_change_resolution)
@@ -107,11 +108,13 @@ u32 mpeg2_strm_dec_decode(DecContainer * dec_container) {
 
     case SC_GROUP:
       /* GOP header */
+      (void)(status);
       status = mpeg2_strm_dec_decode_gopheader(dec_container);
       break;
 
     case SC_EXTENSION:
       /* Extension headers */
+      (void)(status);
       status = mpeg2_strm_dec_decode_extension_header(dec_container);
       if(status == DEC_PIC_HDR_RDY_ERROR)
         return DEC_PIC_HDR_RDY_ERROR;
@@ -128,6 +131,7 @@ u32 mpeg2_strm_dec_decode(DecContainer * dec_container) {
         dec_container->StrmDesc.strm_curr_pos -= 4;
         return (DEC_HDRS_RDY);
       } else if(dec_container->StrmStorage.strm_dec_ready) {
+        (void)(status);
         status = mpeg2_strm_dec_decode_picture_header(dec_container);
         if(status != HANTRO_OK)
           return (DEC_PIC_HDR_RDY_ERROR);
diff --git a/decoder_sw/software/source/mpeg4/mp4decapi.c b/decoder_sw/software/source/mpeg4/mp4decapi.c
index 7cb3f68..d54cc45 100755
--- a/decoder_sw/software/source/mpeg4/mp4decapi.c
+++ b/decoder_sw/software/source/mpeg4/mp4decapi.c
@@ -1157,7 +1157,7 @@ MP4DecRet MP4DecDecode(MP4DecInst dec_inst,
 #ifdef USE_OUTPUT_RELEASE
   if(dec_cont->pp_instance == NULL) {
     u32 tmpret;
-    MP4DecPicture output;
+    MP4DecPicture output = { 0 };
     /*if(ret == MP4DEC_PIC_DECODED)*/ {
       do {
         tmpret = MP4DecNextPicture_INTERNAL(dec_cont, &output, 0);
@@ -3075,7 +3075,7 @@ MP4DecRet MP4DecPictureConsumed(MP4DecInst dec_inst, MP4DecPicture * picture) {
 MP4DecRet MP4DecEndOfStream(MP4DecInst dec_inst, u32 strm_end_flag) {
   DecContainer *dec_cont = (DecContainer *) dec_inst;
   MP4DecRet ret;
-  MP4DecPicture output;
+  MP4DecPicture output = { 0 };
 
   MP4_API_TRC("MP4DecEndOfStream#
");
 
@@ -4689,7 +4689,10 @@ void MP4StateReset(DecContainer *dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_display);
-  FifoInit(MP4_MAX_BUFFERS*2, &dec_cont->fifo_display);
+  if (FifoInit(MP4_MAX_BUFFERS*2, &dec_cont->fifo_display) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
 }
 
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_headers.c b/decoder_sw/software/source/mpeg4/mp4dechwd_headers.c
index f821ee5..e5ae4d1 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_headers.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_headers.c
@@ -165,6 +165,7 @@ u32 StrmDec_DecodeHdrs(DecContainer * dec_container, u32 mode) {
     if(tmp) {
       tmp = dec_container->Hdrs.visual_object_verid =
               StrmDec_GetBits(dec_container, 4);
+      (void)(tmp);
       dec_container->Hdrs.visual_object_priority =
         StrmDec_GetBits(dec_container, 3);
     } else
@@ -260,6 +261,8 @@ u32 StrmDec_DecodeHdrs(DecContainer * dec_container, u32 mode) {
 #ifdef HANTRO_PEDANTIC_MODE
       if(tmp == 0)
         return (HANTRO_NOK);
+#else
+      (void)(tmp);
 #endif
     }
 #ifdef HANTRO_PEDANTIC_MODE
@@ -327,10 +330,12 @@ u32 StrmDec_DecodeHdrs(DecContainer * dec_container, u32 mode) {
       MP4DecSetLowDelay(dec_container);
     }
 
+    (void)(tmp);
     tmp = dec_container->Hdrs.video_object_layer_shape =
             StrmDec_GetBits(dec_container, 2);
     if((tmp != RECTANGULAR) && (tmp != END_OF_STREAM))
       return (HANTRO_NOK);
+    (void)(marker_bit);
     marker_bit = StrmDec_GetBits(dec_container, 1);
 #ifdef HANTRO_PEDANTIC_MODE
     if(!marker_bit)
@@ -405,13 +410,16 @@ u32 StrmDec_DecodeHdrs(DecContainer * dec_container, u32 mode) {
         return (HANTRO_NOK);
 #else
         tmp = StrmDec_GetBits(dec_container, 6);
+        (void)(tmp);
         tmp = StrmDec_GetBits(dec_container, 2);
+        (void)(tmp);
         tmp = StrmDec_GetBits(dec_container, 1);
 #endif
 
       }
     }
 
+    (void)(tmp);
     tmp = dec_container->Hdrs.not8_bit =
             StrmDec_GetBits(dec_container, 1);
     if(tmp && (tmp != END_OF_STREAM))
@@ -460,6 +468,7 @@ u32 StrmDec_DecodeHdrs(DecContainer * dec_container, u32 mode) {
 #else
     (void) StrmDec_GetBits(dec_container, 1);
 #endif
+    (void)(tmp);
     tmp = dec_container->Hdrs.data_partitioned =
             StrmDec_GetBits(dec_container, 1);
 #ifdef ASIC_TRACE_SUPPORT
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_motiontexture.c b/decoder_sw/software/source/mpeg4/mp4dechwd_motiontexture.c
index 3601d82..8dcf3a3 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_motiontexture.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_motiontexture.c
@@ -463,6 +463,7 @@ u32 StrmDec_DecodePartitionedPVop(DecContainer * dec_container) {
       control_bits |= ((u32) 0x1 << (ASICPOS_MBTYPE));
     }
 
+    (void)(pu32);
     pu32 = dec_container->MbSetDesc.p_ctrl_data_addr
            + NBR_OF_WORDS_MB * i;
     if(dec_container->StrmStorage.coded_bits[i] != MB_NOT_CODED) {
@@ -550,6 +551,7 @@ u32 StrmDec_DecodePartitionedPVop(DecContainer * dec_container) {
       }
       /* write asic control bits */
       *pu32 = control_bits;
+      (void)(pu32);
       pu32 += NBR_OF_WORDS_MB;
 
     }
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_rvlc.c b/decoder_sw/software/source/mpeg4/mp4dechwd_rvlc.c
index 1b6654b..0bae4c6 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_rvlc.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_rvlc.c
@@ -599,7 +599,6 @@ u32 RvlcTableSearch(DecContainer * dec_container, u32 input, u32 mb_number,
   u32 index;
   i32 level;
   u32 length;
-  u32 tmp = 0;
   u32 last_bit = 0;
   u32 sign = 0;
 
@@ -647,9 +646,7 @@ u32 RvlcTableSearch(DecContainer * dec_container, u32 input, u32 mb_number,
       return (ERROR);
     }
     *plen = length;
-    if(tmp == END_OF_STREAM) {
-      return (tmp);
-    }
+
     if(!sign) {
       return (rlc);
     } else {
@@ -682,9 +679,7 @@ u32 RvlcTableSearch(DecContainer * dec_container, u32 input, u32 mb_number,
     }
 
     *plen = length;
-    if(tmp == END_OF_STREAM) {
-      return (tmp);
-    }
+
     if(!sign) {
       return (rlc);
     } else {
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_shortvideo.c b/decoder_sw/software/source/mpeg4/mp4dechwd_shortvideo.c
index a83be92..4cbf8c3 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_shortvideo.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_shortvideo.c
@@ -858,20 +858,25 @@ static u32 StrmDec_DecodeSVHPlusHeader(DecContainer * dec_container) {
       /* par width */
       tmp = dec_container->Hdrs.par_width =
               StrmDec_GetBits(dec_container, 8);
+      (void)(tmp);
       /* par height */
       tmp = dec_container->Hdrs.par_height =
               StrmDec_GetBits(dec_container, 8);
     }
 
     /* custom picture clock frequency used, read code */
-    if (dec_container->SvDesc.cpcf)
+    if (dec_container->SvDesc.cpcf) {
+      (void)(tmp);
       tmp = dec_container->SvDesc.cpcfc =
               StrmDec_GetBits(dec_container, 8);
+    }
   }
 
   /* extended temporal reference if custom picture clock frequency */
-  if (dec_container->SvDesc.cpcf)
+  if (dec_container->SvDesc.cpcf) {
+    (void)(tmp);
     tmp = dec_container->SvDesc.etr = StrmDec_GetBits(dec_container, 2);
+  }
 
   /* QP */
   dec_container->VopDesc.q_p = StrmDec_GetBits(dec_container, 5);
@@ -1060,8 +1065,10 @@ u32 StrmDec_DecodeSorensonSparkHeader(DecContainer * dec_container) {
       dec_container->SvDesc.source_format == 1) {
     tmp = StrmDec_GetBits(dec_container,
                           8*(dec_container->SvDesc.source_format+1)); /* width */
+    (void)(tmp);
     tmp = StrmDec_GetBits(dec_container,
                           8*(dec_container->SvDesc.source_format+1)); /* height */
+    (void)(tmp);
   }
 
   tmp = StrmDec_GetBits(dec_container, 2);
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_utils.c b/decoder_sw/software/source/mpeg4/mp4dechwd_utils.c
index 7d467e8..7a2cf7b 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_utils.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_utils.c
@@ -852,11 +852,15 @@ u32 StrmDec_ProcessBvopExtraResync(DecContainer *dec_cont) {
       dec_cont->StrmStorage.vp_mb_number =
         StrmDec_CheckNextVpMbNumber( dec_cont );
       tmp = StrmDec_DecodeVideoPacketHeader( dec_cont );
-      if( tmp != HANTRO_OK )
+      if( tmp != HANTRO_OK ) {
+        dec_cont->StrmStorage.vp_mb_number = prev_vp_mb_num;
         return tmp;
+      }
       tmp = StrmDec_GetStuffing( dec_cont );
-      if( tmp != HANTRO_OK )
+      if( tmp != HANTRO_OK ) {
+        dec_cont->StrmStorage.vp_mb_number = prev_vp_mb_num;
         return tmp;
+      }
 
       dec_cont->StrmStorage.vp_mb_number = prev_vp_mb_num;
 
diff --git a/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c b/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c
index 1d84cf8..31a24e7 100755
--- a/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c
+++ b/decoder_sw/software/source/mpeg4/mp4dechwd_vlc.c
@@ -1190,12 +1190,22 @@ u32 StrmDec_DecodeMv(DecContainer * dec_container, u32 mb_num) {
       tmp = buffer >> (32 - rsize);
 
       if(hor_mv > 0) {
-        hor_mv = ((hor_mv - 1) << rsize) + tmp + 1;
+        /* add this judgement to avoid bad bit shift operation */
+        if(rsize > 31)
+          hor_mv = 0 + tmp + 1;
+        else
+          hor_mv = ((hor_mv - 1) << rsize) + tmp + 1;
       } else {
-        hor_mv = -((-hor_mv - 1) << rsize) - tmp - 1;
+        if(rsize > 31)
+          hor_mv = 0 - tmp - 1;
+        else
+          hor_mv = -((-hor_mv - 1) << rsize) - tmp - 1;
       }
       len -= rsize;
-      buffer <<= rsize;
+      if(rsize > 31)
+        buffer = 0;
+      else
+        buffer <<= rsize;
     }
     if(len < 13) {
       if(StrmDec_FlushBits(dec_container, 32 - len) == END_OF_STREAM)
@@ -1222,12 +1232,22 @@ u32 StrmDec_DecodeMv(DecContainer * dec_container, u32 mb_num) {
       tmp = buffer >> (32 - rsize);
 
       if(ver_mv > 0) {
-        ver_mv = ((ver_mv - 1) << rsize) + tmp + 1;
+        /* add this judgement to avoid bad bit shift operation */
+        if(rsize > 31)
+          ver_mv = 0 + tmp + 1;
+        else
+          ver_mv = ((ver_mv - 1) << rsize) + tmp + 1;
       } else {
-        ver_mv = -((-ver_mv - 1) << rsize) - tmp - 1;
+        if(rsize > 31)
+          ver_mv = 0 - tmp - 1;
+        else
+          ver_mv = -((-ver_mv - 1) << rsize) - tmp - 1;
       }
       len -= rsize;
-      buffer <<= rsize;
+      if(rsize > 31)
+        buffer = 0;
+      else
+        buffer <<= rsize;
     }
 
     /* limit motion vectors to range [-992,992] before writing to asic */
diff --git a/decoder_sw/software/source/rv/rv_rpr.c b/decoder_sw/software/source/rv/rv_rpr.c
index 17266f5..ebd17c6 100755
--- a/decoder_sw/software/source/rv/rv_rpr.c
+++ b/decoder_sw/software/source/rv/rv_rpr.c
@@ -355,6 +355,7 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
   u32 last_col, last_row;
   u32 m,n;
   u32 tmp;
+  i32 tmp_i;
   u32 D;
   const u32 P = 16;
   u32 Hprime, Vprime;
@@ -382,8 +383,11 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
     tmp >>= 1;
   }
   /* check for case when inp_w is power of two */
-  if (inp_w == (u32)(1<<(m-1))) m--;
-  Hprime = 1<<m;
+  if (inp_w == (u32)((m-1) > 31 ? 0 : (1<<(m-1)))) m--;
+  if (m > 31)
+    Hprime = 0;
+  else
+    Hprime = 1<<m;
   D = (64*Hprime)/P;
 
   n = 0;
@@ -393,12 +397,16 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
     tmp >>= 1;
   }
   /* check for case when inp_h is power of two */
-  if (inp_h == (u32)(1<<(n-1))) n--;
-  Vprime = 1<<n;
+  /* add 31 check to avoid bad bit shift*/
+  if (inp_h == (u32)((n-1) > 31 ? 0 : (1<<(n-1)))) n--;
+  if (n > 31)
+    Vprime = 0;
+  else
+    Vprime = 1<<n;
 
   /* uxl and uxr are independent of row, so compute once only */
   uxl = 0;
-  uxr = (outp_w - Hprime)*uxl + ((((inp_w - outp_w)<<1))<<(4+m));    /* numerator part */
+  uxr = (outp_w - Hprime)*uxl + ((4+m) > 31 ? 0 : (((inp_w - outp_w)<<1))<<(4+m));    /* numerator part */
   /* complete uxr init by dividing by H with rounding to nearest integer, */
   /* half-integers away from 0 */
   if (uxr >= 0)
@@ -416,7 +424,7 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
   /* compute once only */
   uy00 = 0;
   uy0_v = ((inp_h - outp_h)<<1)<<4;
-  uyl_b = outp_h*uy00 + ((uy0_v - uy00)<<n); /* numerator */
+  uyl_b = outp_h*uy00 + (n > 31 ? 0 : (uy0_v - uy00)<<n); /* numerator */
   /* complete uyl_b by dividing by V with rounding to nearest integer, */
   /* half-integers away from 0 */
   if (uyl_b >= 0)
@@ -436,7 +444,8 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
   }
   for( i = 0 ; i < outp_w ; ++i ) {
     i32 x0, x1;
-    x0 = ax >> (m+6);
+    x0 = ax >= 0 ? ((m+6) > 31 ?  0 : ax >> (m+6)) :
+                   ((m+6) > 31 ? -1 : ax >> (m+6));
     x1 = x0 + 1;
     if( x0 < 0 ) {
       x0 = 0;
@@ -451,7 +460,8 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
     }
     if( x0 != x1 ) {
       p_src_col[j] = luma_coeffs ? x0 : 2*x0;
-      p_coeff_x[j] = (ax >> (m+2)) & 0xf;
+      p_coeff_x[j] = (ax >= 0 ? ((m+2) > 31 ?  0 : ax >> (m+2)) :
+                                ((m+2) > 31 ? -1 : ax >> (m+2)))& 0xf;
       j++;
     }
     ax += ax_increment;
@@ -463,11 +473,15 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
     i32 y0, y1;
     /* ay var is constant for all columns */
 
-    add = (uyl_num >> (n + luma_coeffs))
-          << (m + luma_coeffs);
+    tmp_i = (uyl_num >= 0 ? ((n + luma_coeffs) > 31 ?  0 : (uyl_num >> (n + luma_coeffs))) :
+                            ((n + luma_coeffs) > 31 ? -1 : (uyl_num >> (n + luma_coeffs))));
+    add = (tmp_i >= 0 ? ((m + luma_coeffs) > 31 ? 0 : (tmp_i << (m + luma_coeffs))) :
+                        ((m + luma_coeffs) > 31 ? -1 : (tmp_i << (m + luma_coeffs))));
+
     ay_row = ay + add;
 
-    y0 = ( ay_row ) >> (m+6);
+    y0 = (ay_row >= 0 ? ((m+6) > 31 ?  0 : ay_row  >> (m+6)) :
+                        ((m+6) > 31 ? -1 : ay_row  >> (m+6))) ;
     y1 = y0 + 1;
     if( y0 < 0 )                y0 = 0;
     else if ( y0 > (i32)last_row )    y0 = last_row;
@@ -475,7 +489,8 @@ void CoeffTables( u32 inp_w, u32 inp_h, u32 outp_w, u32 outp_h,
     else if ( y1 > (i32)last_row )    y1 = last_row;
     *p_src_row_buf++ = inp + y0*inp_wfrm;
     *p_src_row_buf++ = inp + y1*inp_wfrm;
-    p_coeff_y[i] = ((ay_row) >> (m+2)) & 0xf;
+    p_coeff_y[i] = (ay_row >= 0 ? ((m+2) > 31 ?  0 : (ay_row) >> (m+2)) :
+                                  ((m+2) > 31 ? -1 : (ay_row) >> (m+2))) & 0xf;
 
     ay += ay_increment;
     uyl_num += uyl_inc;
diff --git a/decoder_sw/software/source/rv/rv_strm.c b/decoder_sw/software/source/rv/rv_strm.c
index 71b6bb6..949e39f 100755
--- a/decoder_sw/software/source/rv/rv_strm.c
+++ b/decoder_sw/software/source/rv/rv_strm.c
@@ -102,9 +102,6 @@ u32 rv_StrmDecode(DecContainer * dec_container) {
         return DEC_PIC_HDR_RDY_ERROR;
 
       break;
-
-    default:
-      break;
     }
 
   } while(0);
diff --git a/decoder_sw/software/source/rv/rvdecapi.c b/decoder_sw/software/source/rv/rvdecapi.c
index 116c49b..f1568da 100755
--- a/decoder_sw/software/source/rv/rvdecapi.c
+++ b/decoder_sw/software/source/rv/rvdecapi.c
@@ -2530,7 +2530,7 @@ void RvPpControl(DecContainer * dec_container, u32 pipeline_off) {
           dec_container->StrmStorage.p_pic_buf[index_for_pp].send_to_pp = 2;
         } else {
           RVDEC_API_DEBUG(("PIPELINE OFF, DON*T SEND B TO PP
"));
-          index_for_pp = dec_container->StrmStorage.work_out;
+          //index_for_pp = dec_container->StrmStorage.work_out;
           index_for_pp = RV_BUFFER_UNDEFINED;
           pc->input_bus_luma = 0;
         }
@@ -2894,10 +2894,7 @@ void RvSetExternalBufferInfo(DecContainer * dec_cont) {
     ext_buffer_size = pp_buff_size;
   }
 
-  if (dec_cont->pp_enabled)
-    dec_cont->tot_buffers = dec_cont->buf_num =  buffers;
-  else
-    dec_cont->tot_buffers = dec_cont->buf_num =  buffers;
+  dec_cont->tot_buffers = dec_cont->buf_num =  buffers;
   dec_cont->next_buf_size = ext_buffer_size;
 }
 
@@ -2978,6 +2975,10 @@ RvDecRet RvDecAddBuffer(RvDecInst dec_inst, struct DWLLinearMem *info) {
 
   u32 i = dec_cont->buffer_index;
 
+  if (dec_cont->buffer_index >= 16)
+    /* Too much buffers added. */
+    return RVDEC_EXT_BUFFER_REJECTED;
+
   dec_cont->n_ext_buf_size = info->size;
   dec_cont->ext_buffers[dec_cont->ext_buffer_num] = *info;
   dec_cont->ext_buffer_num++;
@@ -3125,7 +3126,10 @@ void RvStateReset(DecContainer *dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_display);
-  FifoInit(32, &dec_cont->fifo_display);
+  if (FifoInit(32, &dec_cont->fifo_display) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
 }
 
diff --git a/decoder_sw/software/source/rv/rvdecapi_internal.c b/decoder_sw/software/source/rv/rvdecapi_internal.c
index 14dcdca..50c023a 100755
--- a/decoder_sw/software/source/rv/rvdecapi_internal.c
+++ b/decoder_sw/software/source/rv/rvdecapi_internal.c
@@ -530,6 +530,7 @@ RvDecRet rvAllocateRprBuffer(DecContainer * dec_cont) {
    *  - u8*width for x coeffs
    *  - u8*height for y coeffs
    */
+  (void)(size_tmp);
   size_tmp = 2*sizeof(u8*)*dec_cont->StrmStorage.max_frame_height +
              sizeof(u16)*dec_cont->StrmStorage.max_frame_width +
              sizeof(u8)*dec_cont->StrmStorage.max_frame_width +
diff --git a/decoder_sw/software/source/vc1/vc1decapi.c b/decoder_sw/software/source/vc1/vc1decapi.c
index a595a4a..941587b 100755
--- a/decoder_sw/software/source/vc1/vc1decapi.c
+++ b/decoder_sw/software/source/vc1/vc1decapi.c
@@ -2815,7 +2815,10 @@ void VC1StateReset(decContainer_t *dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_display);
-  FifoInit(32, &dec_cont->fifo_display);
+  if (FifoInit(32, &dec_cont->fifo_display) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
 }
 
diff --git a/decoder_sw/software/source/vc1/vc1hwd_bitplane.c b/decoder_sw/software/source/vc1/vc1hwd_bitplane.c
index a2dc796..9d89e2a 100644
--- a/decoder_sw/software/source/vc1/vc1hwd_bitplane.c
+++ b/decoder_sw/software/source/vc1/vc1hwd_bitplane.c
@@ -521,6 +521,8 @@ u16x DecodeNormal6( strmData_t * const strm_data, const u16x col_mb,
       for( i = 0 ; i < colskip ; ++i ) {
         if( vc1hwdGetBits( strm_data, 1 ) == 0 ) {
           /* Process inverted columns */
+          /* Coverity: code can not reach statement*/
+#if 0
           if(invert) {
             k = row_mb;
             p_tmp = p_data + i;
@@ -529,6 +531,7 @@ u16x DecodeNormal6( strmData_t * const strm_data, const u16x col_mb,
               p_tmp += col_mb;
             }
           }
+#endif
           continue;
         }
         p_tmp = p_data + i;
@@ -580,6 +583,8 @@ u16x DecodeNormal6( strmData_t * const strm_data, const u16x col_mb,
         }
       } else {
         /* Process inverted row */
+        /* Coverity: code can not reach statement*/
+#if 0
         if( invert ) {
           k = col_mb - colskip;
           p_tmp = p_data + colskip;
@@ -588,6 +593,7 @@ u16x DecodeNormal6( strmData_t * const strm_data, const u16x col_mb,
             p_tmp++;
           }
         }
+#endif
       }
     }
   } else {
diff --git a/decoder_sw/software/source/vc1/vc1hwd_decoder.c b/decoder_sw/software/source/vc1/vc1hwd_decoder.c
index 56836a3..1f5b64f 100755
--- a/decoder_sw/software/source/vc1/vc1hwd_decoder.c
+++ b/decoder_sw/software/source/vc1/vc1hwd_decoder.c
@@ -1201,6 +1201,7 @@ u32 vc1hwdSeekFrameStart(swStrmStorage_t * storage,
                                  p_strm_data->strm_buff_size;
   }
 
+  (void)(rv);
   if (vc1hwdIsExhausted(p_strm_data))
     rv = END_OF_STREAM;
   else
diff --git a/decoder_sw/software/source/vc1/vc1hwd_stream.c b/decoder_sw/software/source/vc1/vc1hwd_stream.c
index b90ef38..9d0ce88 100755
--- a/decoder_sw/software/source/vc1/vc1hwd_stream.c
+++ b/decoder_sw/software/source/vc1/vc1hwd_stream.c
@@ -167,7 +167,7 @@ u32 vc1hwdShowBits(strmData_t *p_strm_data, u32 num_bits ) {
     if (out_bits <= 24)
       out |= (u32)(*p_strm++) << (24 - out_bits);
     else
-      out |= (u32)(*p_strm++) >> (out_bits-24);
+      out |= (out_bits - 24) > 7 ? 0 : ((u32)(*p_strm++) >> (out_bits-24));
     out_bits += 8;
 
     tmp_read_bits += 8;
diff --git a/decoder_sw/software/source/vp6/vp6hwd_api.c b/decoder_sw/software/source/vp6/vp6hwd_api.c
index d28887e..b245568 100755
--- a/decoder_sw/software/source/vp6/vp6hwd_api.c
+++ b/decoder_sw/software/source/vp6/vp6hwd_api.c
@@ -1170,7 +1170,7 @@ VP6DecRet VP6DecPictureConsumed(VP6DecInst dec_inst, VP6DecPicture * output) {
 VP6DecRet VP6DecEndOfStream(VP6DecInst dec_inst, u32 strm_end_flag) {
   VP6DecContainer_t *dec_cont = (VP6DecContainer_t *)dec_inst;
   VP6DecRet ret;
-  VP6DecPicture output;
+  VP6DecPicture output = { 0 };
 
   DEC_API_TRC("VP6DecEndOfStream#
");
 
@@ -1225,7 +1225,7 @@ VP6DecRet VP6DecEndOfStream(VP6DecInst dec_inst, u32 strm_end_flag) {
 
 static VP6DecRet VP6PushOutput(VP6DecContainer_t* dec_cont) {
   VP6DecRet ret;
-  VP6DecPicture output;
+  VP6DecPicture output = { 0 };
 
   /* Sample dec_cont->out_count for Peek */
   dec_cont->fullness = dec_cont->out_count;
@@ -1465,7 +1465,10 @@ void VP6StateReset(VP6DecContainer_t *dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_display);
-  FifoInit(16, &dec_cont->fifo_display);
+  if (FifoInit(16, &dec_cont->fifo_display) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
   (void)buffers;
 }
diff --git a/decoder_sw/software/source/vp8/vp8decapi.c b/decoder_sw/software/source/vp8/vp8decapi.c
index fd847f7..049d83f 100755
--- a/decoder_sw/software/source/vp8/vp8decapi.c
+++ b/decoder_sw/software/source/vp8/vp8decapi.c
@@ -1070,7 +1070,9 @@ VP8DecRet VP8DecDecode(VP8DecInst dec_inst,
   /* If in asynchronous mode, just return OK  */
   if (asic_status == VP8HWDEC_ASYNC_MODE) {
     /* find first free buffer and use it as next output */
-    if (!error_concealment || dec_cont->intra_only) {
+    /* Coverity:!error_concealment must be ture */
+    //if (!error_concealment || dec_cont->intra_only) 
+    {
       p_asic_buff->prev_out_buffer = p_asic_buff->out_buffer;
       p_asic_buff->prev_out_buffer_i = p_asic_buff->out_buffer_i;
       p_asic_buff->out_buffer = NULL;
@@ -1835,7 +1837,7 @@ VP8DecRet VP8DecPictureConsumed(VP8DecInst dec_inst,
 ------------------------------------------------------------------------------*/
 VP8DecRet VP8DecEndOfStream(VP8DecInst dec_inst, u32 strm_end_flag) {
   VP8DecContainer_t *dec_cont = (VP8DecContainer_t *)dec_inst;
-  VP8DecPicture output;
+  VP8DecPicture output = { 0 };
   VP8DecRet ret;
 
   if (dec_inst == NULL) {
@@ -2297,7 +2299,7 @@ static i32 FindIndex(VP8DecContainer_t* dec_cont, const u32* address) {
 #ifdef USE_OUTPUT_RELEASE
 static VP8DecRet VP8PushOutput(VP8DecContainer_t* dec_cont) {
   u32 ret = VP8DEC_OK;
-  VP8DecPicture output;
+  VP8DecPicture output = { 0 };
 
   /* Sample dec_cont->out_count for Peek */
   dec_cont->fullness = dec_cont->out_count;
@@ -2541,7 +2543,10 @@ void VP8StateReset(VP8DecContainer_t* dec_cont) {
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->fifo_display)
     FifoRelease(dec_cont->fifo_out);
-  FifoInit(VP8DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_out);
+  if (FifoInit(VP8DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_out) != FIFO_OK) {
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return;
+  }
 #endif
   (void)buffers;
 }
diff --git a/decoder_sw/software/source/vp8/vp8decmcapi.c b/decoder_sw/software/source/vp8/vp8decmcapi.c
index ad0a92a..d969c1f 100755
--- a/decoder_sw/software/source/vp8/vp8decmcapi.c
+++ b/decoder_sw/software/source/vp8/vp8decmcapi.c
@@ -270,7 +270,7 @@ VP8DecRet VP8DecMCEndOfStream(VP8DecInst dec_inst) {
     Argument        : VP8DecContainer_t *
 ------------------------------------------------------------------------------*/
 i32 NextOutput(VP8DecContainer_t *dec_cont) {
-  i32 i;
+  addr_t i;
   u32 j;
   i32 output_i = -1;
   u32 size;
diff --git a/decoder_sw/software/source/vp8/vp8hwd_buffer_queue.c b/decoder_sw/software/source/vp8/vp8hwd_buffer_queue.c
index 59e72fd..2aa7ff7 100755
--- a/decoder_sw/software/source/vp8/vp8hwd_buffer_queue.c
+++ b/decoder_sw/software/source/vp8/vp8hwd_buffer_queue.c
@@ -321,10 +321,10 @@ i32 VP8HwdBufferQueueGetBuffer(BufferQueue queue) {
     while(q->buf_used[i] && !q->abort)
       pthread_cond_wait(&q->buf_release_cv, &q->buf_release_mutex);
     pthread_mutex_unlock(&q->buf_release_mutex);
-#endif
 
     if(q->abort)
       return ((i32)0xFFFFFFFF);
+#endif
   }
 #else
   FifoPop(q->empty_fifo, &j, FIFO_EXCEPTION_DISABLE);
diff --git a/decoder_sw/software/source/vp8/vp8hwd_headers.c b/decoder_sw/software/source/vp8/vp8hwd_headers.c
index f63e507..dc23c4d 100755
--- a/decoder_sw/software/source/vp8/vp8hwd_headers.c
+++ b/decoder_sw/software/source/vp8/vp8hwd_headers.c
@@ -467,8 +467,10 @@ u32 DecodeVp7FrameHeader( vpBoolCoder_t*bc, vp8_decoder_t* dec ) {
 
         if(feature_bits[i]) {
           for( j = 0 ; j < 4 ; ++j ) {
-            if( vp8hwdReadBits( bc, 1 ) )
+            if( vp8hwdReadBits( bc, 1 ) ) {
+              (void)(tmp);
               tmp = vp8hwdReadBits( bc, feature_bits[i] );
+            }
           }
         }
 
diff --git a/decoder_sw/software/source/vp9/vp9hwd_asic.c b/decoder_sw/software/source/vp9/vp9hwd_asic.c
index 2567d12..a02a7b6 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_asic.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_asic.c
@@ -1126,7 +1126,9 @@ i32 Vp9GetRefFrm(struct Vp9DecContainer *dec_cont, u32 id) {
         //asic_buff->out_buffer_i = Vp9BufferQueueGetBuffer(dec_cont->bq, limit);
       }
 
-      if (asic_buff->out_buffer_i < 0)
+      /* add "asic_buff->out_buffer_i >= VP9DEC_MAX_PIC_BUFFERS" to */
+      /* just fix coverity warning */
+      if (asic_buff->out_buffer_i < 0 || asic_buff->out_buffer_i >= VP9DEC_MAX_PIC_BUFFERS)
         return HANTRO_OK;
 #ifdef USE_VP9_EC
       asic_buff->picture_info[asic_buff->out_buffer_i].nbr_of_err_mbs = 0;
@@ -1147,6 +1149,11 @@ i32 Vp9GetRefFrm(struct Vp9DecContainer *dec_cont, u32 id) {
           return DEC_NO_DECODING_BUFFER;
         }
 #endif
+        else if (asic_buff->out_pp_buffer_i < 0) {
+          /* pp buffer should be allocate when reference buffer return DEC_WAITING_FOR_BUFFER,*/
+          /* this code just for removing negative value warning. */
+          return DEC_WAITING_FOR_BUFFER;
+        }
       }
       asic_buff->pp_buffer_map[asic_buff->out_buffer_i] = asic_buff->out_pp_buffer_i;
     }
diff --git a/decoder_sw/software/source/vp9/vp9hwd_buffer_queue.c b/decoder_sw/software/source/vp9/vp9hwd_buffer_queue.c
index 70a4916..408bc4b 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_buffer_queue.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_buffer_queue.c
@@ -456,7 +456,9 @@ void Vp9BufferQueueReset(BufferQueue queue) {
   pthread_mutex_destroy(&q->cs);
   pthread_mutex_init(&q->cs, NULL);
 
-  FifoInit(VP9DEC_MAX_PIC_BUFFERS, &q->empty_fifo);
+  ret = FifoInit(VP9DEC_MAX_PIC_BUFFERS, &q->empty_fifo);
+  if (FIFO_ERROR_MEMALLOC == ret)
+    return;
   assert(q->empty_fifo);
 #ifdef USE_OMXIL_BUFFER
   q->n_buffers = 0;
diff --git a/decoder_sw/software/source/vp9/vp9hwd_headers.c b/decoder_sw/software/source/vp9/vp9hwd_headers.c
index d99853c..0067003 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_headers.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_headers.c
@@ -250,6 +250,7 @@ u32 Vp9DecodeFrameTag(const u8 *strm, u32 data_len,
     } else {
       if (dec->vp_version == 1) {
         dec->subsampling_x = dec->subsampling_y = 0;
+        (void)(tmp);
         tmp = SwGetBits(&rb, 1);
         STREAM_TRACE("Alpha plane", tmp);
       } else {
@@ -302,6 +303,7 @@ u32 Vp9DecodeFrameTag(const u8 *strm, u32 data_len,
           if (dec->vp_version == 1) {
             dec->subsampling_x = SwGetBits(&rb, 1);
             dec->subsampling_y = SwGetBits(&rb, 1);
+            (void)(tmp);
             tmp = SwGetBits(&rb, 1);
             STREAM_TRACE("Subsampling X", dec->subsampling_x);
             STREAM_TRACE("Subsampling Y", dec->subsampling_y);
@@ -312,6 +314,7 @@ u32 Vp9DecodeFrameTag(const u8 *strm, u32 data_len,
         } else {
           if (dec->vp_version == 1) {
             dec->subsampling_x = dec->subsampling_y = 0;
+            (void)(tmp);
             tmp = SwGetBits(&rb, 1);
             STREAM_TRACE("Alpha plane", tmp);
           } else {
@@ -425,6 +428,7 @@ u32 Vp9DecodeFrameTag(const u8 *strm, u32 data_len,
   /* Tile dimensions */
   GetTileNBits(dec, &dec->log2_tile_columns, &delta_log2_tiles);
   while (delta_log2_tiles--) {
+    (void)(tmp);
     tmp = SwGetBits(&rb, 1);
     if (tmp == END_OF_STREAM) return HANTRO_NOK;
     if (tmp) {
diff --git a/decoder_sw/software/source/vp9/vp9hwd_output.c b/decoder_sw/software/source/vp9/vp9hwd_output.c
index 5e3e5d5..3cfa4e4 100755
--- a/decoder_sw/software/source/vp9/vp9hwd_output.c
+++ b/decoder_sw/software/source/vp9/vp9hwd_output.c
@@ -45,6 +45,7 @@
 #include "vp9hwd_asic.h"
 #include "vp9hwd_container.h"
 #include "vp9hwd_output.h"
+#include "stdio.h"
 
 #define EOS_MARKER   (-1)
 #define ABORT_MARKER (-2)
@@ -756,11 +757,13 @@ i32 VP9SyncAndOutput(struct Vp9DecContainer *dec_cont) {
     /* Store prev out info */
 #ifdef USE_VP9_EC
     if (!error_concealment)
+    {
 #else
     if (!error_concealment || dec_cont->intra_only || dec_cont->pic_number==1)
-#endif
     {
       if (error_concealment) Vp9ConstantConcealment(dec_cont, 128);
+#endif
+
       asic_buff->prev_out_buffer_i = asic_buff->out_buffer_i;
 
       Vp9PicToOutput(dec_cont);
@@ -881,8 +884,10 @@ void Vp9ResetDecState(struct Vp9DecContainer *dec_cont) {
   DWLmemset(dec_cont->pic_callback_arg, 0, sizeof(struct PicCallbackArg));
   if (dec_cont->fifo_out) FifoRelease(dec_cont->fifo_out);
   if (dec_cont->fifo_display) FifoRelease(dec_cont->fifo_display);
-  FifoInit(VP9DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_out);
-  FifoInit(VP9DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_display);
+  if (FifoInit(VP9DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_out) != FIFO_OK)
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+  if (FifoInit(VP9DEC_MAX_PIC_BUFFERS, &dec_cont->fifo_display) != FIFO_OK)
+    fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 #ifdef USE_OMXIL_BUFFER
   if (dec_cont->bq && IS_EXTERNAL_BUFFER(dec_cont->ext_buffer_config, REFERENCE_BUFFER)) {
      dec_cont->num_buffers = dec_cont->num_buffers_reserved;
@@ -907,16 +912,16 @@ void Vp9ResetDecState(struct Vp9DecContainer *dec_cont) {
 }
 
 enum DecRet Vp9DecAbort(Vp9DecInst dec_inst) {
+  if (dec_inst == NULL) {
+    return DEC_PARAM_ERROR;
+  }
+
   struct Vp9DecContainer *dec_cont = (struct Vp9DecContainer *)dec_inst;
   enum FifoRet ret;
   FifoObject tmp;
   BufferQueue queue;
   FifoInst fifo = dec_cont->fifo_display;
 
-  if (dec_inst == NULL) {
-    return DEC_PARAM_ERROR;
-  }
-
   pthread_mutex_lock(&dec_cont->protect_mutex);
 
   /* Before entering abort, remove all the pending output buffer from output/display fifo,
diff --git a/decoder_sw/software/test/avs/Makefile b/decoder_sw/software/test/avs/Makefile
index 27e692a..96a8b6b 100755
--- a/decoder_sw/software/test/avs/Makefile
+++ b/decoder_sw/software/test/avs/Makefile
@@ -67,6 +67,9 @@ MODLIB = lib8170hw.a
 
 TARGET_ENV=
 
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
+
 ifeq ($(USE_MD5SUM), y)
         MD5SUM = -DMD5SUM
 endif
diff --git a/decoder_sw/software/test/avs/avsdectest.c b/decoder_sw/software/test/avs/avsdectest.c
index db5875b..3609466 100755
--- a/decoder_sw/software/test/avs/avsdectest.c
+++ b/decoder_sw/software/test/avs/avsdectest.c
@@ -103,6 +103,23 @@ void trace_perf() {
 #define AVS_FRAME_BUFFER_SIZE ((1280 * 720 * 3) / 2)  /* 720p frame */
 #define AVS_NUM_BUFFERS 3 /* number of output buffers for ext alloc */
 
+/* Debug prints */
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+
+
 /* Function prototypes */
 
 void printTimeCode(AvsDecTime * timecode);
@@ -238,10 +255,10 @@ static void *AddBufferThread(void *arg) {
 
 void ReleaseExtBuffers() {
   int i;
-  printf("Releasing %d external frame buffers
", num_buffers);
+  PRINT(("Releasing %d external frame buffers
", num_buffers));
   pthread_mutex_lock(&ext_buffer_contro);
   for(i=0; i<num_buffers; i++) {
-    printf("Freeing buffer %p
", ext_buffers[i].virtual_address);
+    PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
     if (pp_enabled)
       DWLFreeLinear(dwl_inst, &ext_buffers[i]);
     else
@@ -349,25 +366,26 @@ static void* avs_output_thread(void* arg) {
         pic_display_number++;
 
         /* printf info */
-        printf("PIC %d, %s", DecPic.pic_id,
+        DEBUG_PRINT(("PIC %d, %s", DecPic.pic_id,
                DecPic.key_picture ? "key picture,    " :
-               "non key picture,");
+               "non key picture,"));
 
         /* pic coding type */
         printAvsPicCodingType(DecPic.pic_coding_type);
 
-        if(DecPic.field_picture)
-          printf(" %s ", DecPic.top_field ?
-                 "top field.   " : "bottom field.");
-        else
-          printf(" frame picture. ");
+        if(DecPic.field_picture) {
+          DEBUG_PRINT((" %s ", DecPic.top_field ?
+                 "top field.   " : "bottom field."));
+        } else {
+          DEBUG_PRINT((" frame picture. "));
+        }
 
         printTimeCode(&(DecPic.time_code));
         if(DecPic.number_of_err_mbs) {
-          printf(", %d/%d error mbs
",
+          DEBUG_PRINT((", %d/%d error mbs
",
                  DecPic.number_of_err_mbs,
                  (DecPic.frame_width >> 4) *
-                 (DecPic.frame_height >> 4));
+                 (DecPic.frame_height >> 4)));
           cumulative_error_mbs += DecPic.number_of_err_mbs;
         }
 
@@ -376,7 +394,7 @@ static void* avs_output_thread(void* arg) {
 
         pic_size = DecPic.frame_width * DecPic.frame_height * 3 / 2;
 
-        printf("DecPic.first_field %d
", DecPic.first_field);
+        DEBUG_PRINT(("DecPic.first_field %d
", DecPic.first_field));
         WriteOutput(out_file_name, out_file_name_tiled, image_data,
                     pic_display_number - 1,
                     ((DecPic.frame_width + 15) & ~15),
@@ -528,31 +546,31 @@ int main(int argc, char **argv) {
 #ifndef PP_PIPELINE_ENABLED
   if(argc < 2) {
 
-    printf("
8170 AVS Decoder Testbench

");
-    printf("USAGE:
%s [options] stream.avs
", argv[0]);
-    printf("-Ooutfile write output to \"outfile\" (default out.yuv)
");
-    printf("-Nn to decode only first n frames of the stream
");
-    printf("-P write planar output
");
-    printf("-E use tiled reference frame format.
");
-    printf("-G convert tiled output pictures to raster scan
");
-    printf("-X to not to write output picture
");
-    printf("-W whole stream mode - give stream to decoder in one chunk
");
-    printf
-    ("-T write tiled output (out_tiled.yuv) by converting raster scan output
");
-    printf("-Y Write output as Interlaced Fields (instead of Frames).
");
-    printf("-Bn to use n frame buffers in decoder
");
-    printf("-Q Skip decoding non-reference pictures.
");
-    printf("-Z output pictures using AvsDecPeek() function
");
-    printf("--separate-fields-in-dpb DPB stores interlaced content"\
-           " as fields (default: frames)
");
-    printf
-    ("-C crop output picture to real picture dimensions (only planar)
");
-    printf("--output-frame-dpb Convert output to frame mode even if"\
-           " field DPB mode used
");
+    PRINT(("
8170 AVS Decoder Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.avs
", argv[0]));
+    PRINT(("-Ooutfile write output to \"outfile\" (default out.yuv)
"));
+    PRINT(("-Nn to decode only first n frames of the stream
"));
+    PRINT(("-P write planar output
"));
+    PRINT(("-E use tiled reference frame format.
"));
+    PRINT(("-G convert tiled output pictures to raster scan
"));
+    PRINT(("-X to not to write output picture
"));
+    PRINT(("-W whole stream mode - give stream to decoder in one chunk
"));
+    PRINT
+    (("-T write tiled output (out_tiled.yuv) by converting raster scan output
"));
+    PRINT(("-Y Write output as Interlaced Fields (instead of Frames).
"));
+    PRINT(("-Bn to use n frame buffers in decoder
"));
+    PRINT(("-Q Skip decoding non-reference pictures.
"));
+    PRINT(("-Z output pictures using AvsDecPeek() function
"));
+    PRINT(("--separate-fields-in-dpb DPB stores interlaced content"\
+           " as fields (default: frames)
"));
+    PRINT
+    (("-C crop output picture to real picture dimensions (only planar)
"));
+    PRINT(("--output-frame-dpb Convert output to frame mode even if"\
+           " field DPB mode used
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("-A add extra external buffer randomly
");
+    PRINT(("-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("-a add extra external buffer in ouput thread
");
+    PRINT(("-a add extra external buffer in ouput thread
"));
 #endif
 #endif
     printAvsVersion();
@@ -562,7 +580,13 @@ int main(int argc, char **argv) {
   max_num_frames = 0;
   for(i = 1; i < argc - 1; i++) {
     if(strncmp(argv[i], "-O", 2) == 0) {
-      strcpy(out_file_name, argv[i] + 2);
+      /* -1 to accomodate for the null tern=minator */
+      if (sizeof(out_file_name) - 1 < strlen(argv[i] + 2)) {
+        PRINT(("The output file name size overflows buffer size(256)!
"));
+        return 1;
+      }  else {
+        strcpy(out_file_name, argv[i] + 2);
+      }
     } else if(strncmp(argv[i], "-N", 2) == 0) {
       max_num_frames = atoi(argv[i] + 2);
     } else if (strncmp(argv[i], "-E", 2) == 0)
@@ -614,11 +638,11 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
-      printf("UNKNOWN PARAMETER: %s
", argv[i]);
+      PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
       return 1;
     }
   }
@@ -627,25 +651,25 @@ int main(int argc, char **argv) {
   /* open data file */
   f_in = fopen(argv[argc - 1], "rb");
   if(f_in == NULL) {
-    printf("Unable to open input file %s
", argv[argc - 1]);
+    PRINT(("Unable to open input file %s
", argv[argc - 1]));
     exit(100);
   }
 #else
   if(argc < 3) {
-    printf("
Avs Decoder PP Pipelined Testbench

");
-    printf("USAGE:
%s [options] stream.avs pp.cfg
", argv[0]);
-    printf("-Nn to decode only first n vops of the stream
");
-    printf("-E use tiled reference frame format.
");
-    printf("-Bn to use n frame buffers in decoder
");
-    printf("-X to not to write output picture
");
-    printf("-W whole stream mode - give stream to decoder in one chunk
");
-    printf("-Q Skip decoding non-reference pictures.
");
-    printf("--separate-fields-in-dpb DPB stores interlaced content"\
-           " as fields (default: frames)
");
+    PRINT(("
Avs Decoder PP Pipelined Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.avs pp.cfg
", argv[0]));
+    PRINT(("-Nn to decode only first n vops of the stream
"));
+    PRINT(("-E use tiled reference frame format.
"));
+    PRINT(("-Bn to use n frame buffers in decoder
"));
+    PRINT(("-X to not to write output picture
"));
+    PRINT(("-W whole stream mode - give stream to decoder in one chunk
"));
+    PRINT(("-Q Skip decoding non-reference pictures.
"));
+    PRINT(("--separate-fields-in-dpb DPB stores interlaced content"\
+           " as fields (default: frames)
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("-A add extra external buffer randomly
");
+    PRINT(("-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("-a add extra external buffer in output thread
");
+    PRINT(("-a add extra external buffer in output thread
"));
 #endif
 #endif
     exit(100);
@@ -693,7 +717,7 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
@@ -706,7 +730,7 @@ int main(int argc, char **argv) {
   /* open data file */
   f_in = fopen(argv[argc - 2], "rb");
   if(f_in == NULL) {
-    printf("Unable to open input file %s
", argv[argc - 2]);
+    PRINT(("Unable to open input file %s
", argv[argc - 2]));
     exit(100);
   }
 
@@ -724,8 +748,8 @@ int main(int argc, char **argv) {
   TBSetDefaultCfg(&tb_cfg);
   f_tbcfg = fopen("tb.cfg", "r");
   if(f_tbcfg == NULL) {
-    printf("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
");
-    printf("USING DEFAULT CONFIGURATION
");
+    PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if(TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
@@ -749,13 +773,13 @@ int main(int argc, char **argv) {
   printf("Decoder Output Picture Endian forced to %d
",
          output_picture_endian);
 #endif
-  printf("Decoder Clock Gating %d
", clock_gating);
-  printf("Decoder Data Discard %d
", data_discard);
-  printf("Decoder Latency Compensation %d
", latency_comp);
-  printf("Decoder Output Picture Endian %d
", output_picture_endian);
-  printf("Decoder Bus Burst Length %d
", bus_burst_length);
-  printf("Decoder Asic Service Priority %d
", asic_service_priority);
-  printf("Decoder Output Format %d
", output_format);
+  PRINT(("Decoder Clock Gating %d
", clock_gating));
+  PRINT(("Decoder Data Discard %d
", data_discard));
+  PRINT(("Decoder Latency Compensation %d
", latency_comp));
+  PRINT(("Decoder Output Picture Endian %d
", output_picture_endian));
+  PRINT(("Decoder Bus Burst Length %d
", bus_burst_length));
+  PRINT(("Decoder Asic Service Priority %d
", asic_service_priority));
+  PRINT(("Decoder Output Format %d
", output_format));
 
   seed_rnd = tb_cfg.tb_params.seed_rnd;
   stream_header_corrupt = TBGetTBStreamHeaderCorrupt(&tb_cfg);
@@ -775,14 +799,14 @@ int main(int argc, char **argv) {
     stream_packet_loss = 0;
   }
   disable_resync = TBGetTBPacketByPacket(&tb_cfg);
-  printf("TB Slice by slice %d
", disable_resync);
-  printf("TB Seed Rnd %d
", seed_rnd);
-  printf("TB Stream Truncate %d
", stream_truncate);
-  printf("TB Stream Header Corrupt %d
", stream_header_corrupt);
-  printf("TB Stream Bit Swap %d; odds %s
",
-         stream_bit_swap, tb_cfg.tb_params.stream_bit_swap);
-  printf("TB Stream Packet Loss %d; odds %s
",
-         stream_packet_loss, tb_cfg.tb_params.stream_packet_loss);
+  DEBUG_PRINT(("TB Slice by slice %d
", disable_resync));
+  DEBUG_PRINT(("TB Seed Rnd %d
", seed_rnd));
+  DEBUG_PRINT(("TB Stream Truncate %d
", stream_truncate));
+  DEBUG_PRINT(("TB Stream Header Corrupt %d
", stream_header_corrupt));
+  DEBUG_PRINT(("TB Stream Bit Swap %d; odds %s
",
+         stream_bit_swap, tb_cfg.tb_params.stream_bit_swap));
+  DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
",
+         stream_packet_loss, tb_cfg.tb_params.stream_packet_loss));
 
   /* allocate memory for stream buffer. if unsuccessful -> exit */
   stream_mem.virtual_address = NULL;
@@ -796,19 +820,22 @@ int main(int argc, char **argv) {
   TBInitializeRandom(seed_rnd);
 
   /* check size of the input file -> length of the stream in bytes */
-  fseek(f_in, 0L, SEEK_END);
+  if (fseek(f_in, 0L, SEEK_END) != 0) {
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    return -1;
+  }
   stream_size = (u32) ftell(f_in);
   rewind(f_in);
 
   /* sets the stream length to random value */
   if(stream_truncate && !disable_resync) {
-    printf("stream_size %d
", stream_size);
+    DEBUG_PRINT(("stream_size %d
", stream_size));
     ret = TBRandomizeU32(&stream_size);
     if(ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return -1;
     }
-    printf("Randomized stream_size %d
", stream_size);
+    DEBUG_PRINT(("Randomized stream_size %d
", stream_size));
   }
 
 #ifdef ASIC_TRACE_SUPPORT
@@ -846,7 +873,7 @@ int main(int argc, char **argv) {
   decsw_performance();
 
   if(ret != AVSDEC_OK) {
-    printf("Could not initialize decoder
");
+    PRINT(("Could not initialize decoder
"));
     goto end2;
   }
 
@@ -866,13 +893,13 @@ int main(int argc, char **argv) {
 #endif
 
   if(ret != AVSDEC_OK) {
-    printf("Could not initialize decoder
");
+    PRINT(("Could not initialize decoder
"));
     goto end2;
   }
 
   if(DWLMallocLinear(((DecContainer *) decoder)->dwl,
                      STREAMBUFFER_BLOCKSIZE, &stream_mem) != DWL_OK) {
-    printf(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
     goto end2;
   }
 
@@ -888,7 +915,7 @@ int main(int argc, char **argv) {
   DecIn.stream_bus_address = stream_mem.bus_address;
 
   if(byte_strm_start == NULL) {
-    printf(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
     goto end2;
   }
 
@@ -948,15 +975,16 @@ int main(int argc, char **argv) {
   DecIn.data_len = stream_len;
   DecOut.data_left = 0;
 
-  printf("Start decoding
");
+  PRINT(("Start decoding
"));
   do {
-    printf("DecIn.data_len %d
", DecIn.data_len);
+    DEBUG_PRINT(("DecIn.data_len %d
", DecIn.data_len));
     DecIn.pic_id = pic_id;
     if(ret != AVSDEC_STRM_PROCESSED &&
         ret != AVSDEC_BUF_EMPTY &&
         ret != AVSDEC_NO_DECODING_BUFFER &&
-        ret != AVSDEC_NONREF_PIC_SKIPPED)
-      printf("
Starting to decode picture ID %d
", pic_id);
+        ret != AVSDEC_NONREF_PIC_SKIPPED) {
+      DEBUG_PRINT(("
Starting to decode picture ID %d
", pic_id));
+    }
 
     /* If enabled, break the stream */
     if(stream_bit_swap) {
@@ -968,12 +996,12 @@ int main(int argc, char **argv) {
                                            tb_cfg.tb_params.
                                            stream_bit_swap);
           if(ret != 0) {
-            printf("RANDOM STREAM ERROR FAILED
");
+            PRINT(("RANDOM STREAM ERROR FAILED
"));
             goto end2;
           }
 
           corrupted_bytes = DecIn.data_len;
-          printf("corrupted_bytes %d
", corrupted_bytes);
+          PRINT(("corrupted_bytes %d
", corrupted_bytes));
         }
       }
     }
@@ -999,9 +1027,9 @@ int main(int argc, char **argv) {
       /* Set a flag to indicate that headers are ready */
 #ifdef USE_EXTERNAL_BUFFER
       rv = AvsDecGetBufferInfo(decoder, &hbuf);
-      printf("AvsDecGetBufferInfo ret %d
", rv);
-      printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+      PRINT(("AvsDecGetBufferInfo ret %d
", rv));
+      PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 #endif
       hdrs_rdy = 1;
       TBSetRefbuMemModel( &tb_cfg,
@@ -1023,8 +1051,9 @@ int main(int argc, char **argv) {
       outp_byte_size =
         (Decinfo.frame_width * Decinfo.frame_height * 3) >> 1;
 
-      if (Decinfo.interlaced_sequence)
-        printf("INTERLACED SEQUENCE
");
+      if (Decinfo.interlaced_sequence) {
+        PRINT(("INTERLACED SEQUENCE
"));
+      }
 #ifdef USE_EXTERNAL_BUFFER
       if(Decinfo.pic_buff_size != min_buffer_num ||
           (Decinfo.frame_width * Decinfo.frame_height > prev_width * prev_height)) {
@@ -1044,30 +1073,30 @@ int main(int argc, char **argv) {
 #endif
 
       if(!frame_number) {
-        printf("Size %dx%d
", Decinfo.frame_width, Decinfo.frame_height);
-        printf("Profile and level %x %x
",
-               Decinfo.profile_id, Decinfo.level_id);
+        PRINT(("Size %dx%d
", Decinfo.frame_width, Decinfo.frame_height));
+        PRINT(("Profile and level %x %x
",
+               Decinfo.profile_id, Decinfo.level_id));
         switch (Decinfo.display_aspect_ratio) {
         case AVSDEC_1_1:
-          printf("Display Aspect ratio 1:1
");
+          PRINT(("Display Aspect ratio 1:1
"));
           break;
         case AVSDEC_4_3:
-          printf("Display Aspect ratio 4:3
");
+          PRINT(("Display Aspect ratio 4:3
"));
           break;
         case AVSDEC_16_9:
-          printf("Display Aspect ratio 16:9
");
+          PRINT(("Display Aspect ratio 16:9
"));
           break;
         case AVSDEC_2_21_1:
-          printf("Display Aspect ratio 2.21:1
");
+          PRINT(("Display Aspect ratio 2.21:1
"));
           break;
         }
-        printf("Output format %s
",
+        PRINT(("Output format %s
",
                Decinfo.output_format == AVSDEC_SEMIPLANAR_YUV420
                ? "AVSDEC_SEMIPLANAR_YUV420" :
-               "AVSDEC_TILED_YUV420");
+               "AVSDEC_TILED_YUV420"));
       }
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      DEBUG_PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1112,9 +1141,9 @@ int main(int argc, char **argv) {
 #ifdef USE_EXTERNAL_BUFFER
     case AVSDEC_WAITING_FOR_BUFFER:
       rv = AvsDecGetBufferInfo(decoder, &hbuf);
-      printf("AvsDecGetBufferInfo ret %d
", rv);
-      printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+      PRINT(("AvsDecGetBufferInfo ret %d
", rv));
+      PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
       if (hbuf.buf_to_free.virtual_address != NULL && res_changed) {
         add_extra_flag = 0;
         ReleaseExtBuffers();
@@ -1134,7 +1163,7 @@ int main(int argc, char **argv) {
           else
             DWLMallocRefFrm(dwl_inst, hbuf.next_buf_size, &mem);
           rv = AvsDecAddBuffer(decoder, &mem);
-          printf("AvsDecAddBuffer ret %d
", rv);
+          PRINT(("AvsDecAddBuffer ret %d
", rv));
           if(rv != AVSDEC_OK && rv != AVSDEC_WAITING_FOR_BUFFER) {
             if (pp_enabled)
               DWLFreeLinear(dwl_inst, &mem);
@@ -1199,9 +1228,9 @@ int main(int argc, char **argv) {
           AvsDecPeek(decoder, &DecPic) == AVSDEC_PIC_RDY) {
         pic_display_number++;
         /* printf info */
-        printf("PIC %d, %s", DecPic.pic_id,
+        DEBUG_PRINT(("PIC %d, %s", DecPic.pic_id,
                DecPic.key_picture ? "key picture,    " :
-               "non key picture,");
+               "non key picture,"));
 
         /* pic coding type */
         printAvsPicCodingType(DecPic.pic_coding_type);
@@ -1241,25 +1270,26 @@ int main(int argc, char **argv) {
             pic_display_number++;
 
             /* printf info */
-            printf("PIC %d, %s", DecPic.pic_id,
+            DEBUG_PRINT(("PIC %d, %s", DecPic.pic_id,
                    DecPic.key_picture ? "key picture,    " :
-                   "non key picture,");
+                   "non key picture,"));
 
             /* pic coding type */
             printAvsPicCodingType(DecPic.pic_coding_type);
 
-            if(DecPic.field_picture)
-              printf(" %s ", DecPic.top_field ?
-                     "top field.   " : "bottom field.");
-            else
-              printf(" frame picture. ");
+            if(DecPic.field_picture) {
+              DEBUG_PRINT((" %s ", DecPic.top_field ?
+                     "top field.   " : "bottom field."));
+            } else {
+              DEBUG_PRINT((" frame picture. "));
+            }
 
             printTimeCode(&(DecPic.time_code));
             if(DecPic.number_of_err_mbs) {
-              printf(", %d/%d error mbs
",
+              DEBUG_PRINT((", %d/%d error mbs
",
                      DecPic.number_of_err_mbs,
                      (DecPic.frame_width >> 4) *
-                     (DecPic.frame_height >> 4));
+                     (DecPic.frame_height >> 4)));
               cumulative_error_mbs += DecPic.number_of_err_mbs;
             }
 
@@ -1269,7 +1299,7 @@ int main(int argc, char **argv) {
             pic_size = DecPic.frame_width * DecPic.frame_height * 3 / 2;
 
 #ifndef PP_PIPELINE_ENABLED
-            printf("DecPic.first_field %d
", DecPic.first_field);
+            DEBUG_PRINT(("DecPic.first_field %d
", DecPic.first_field));
             WriteOutput(out_file_name, out_file_name_tiled, image_data,
                         pic_display_number - 1,
                         ((Decinfo.frame_width + 15) & ~15),
@@ -1302,7 +1332,7 @@ int main(int argc, char **argv) {
       }
 #endif
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      DEBUG_PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1332,7 +1362,7 @@ int main(int argc, char **argv) {
       }
 
       if(max_num_frames && (frame_number >= max_num_frames)) {
-        printf("

Max num of pictures reached

");
+        PRINT(("

Max num of pictures reached

"));
         DecIn.data_len = 0;
         goto end2;
       }
@@ -1378,7 +1408,7 @@ int main(int argc, char **argv) {
        *   the function call.
        */
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      DEBUG_PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1410,14 +1440,14 @@ int main(int argc, char **argv) {
       break;
 
     case AVSDEC_PARAM_ERROR:
-      printf("INCORRECT STREAM PARAMS
");
+      PRINT(("INCORRECT STREAM PARAMS
"));
       goto end2;
       break;
 
     case AVSDEC_STRM_ERROR:
-      printf("STREAM ERROR
");
+      PRINT(("STREAM ERROR
"));
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1470,26 +1500,27 @@ end2:
     pic_display_number++;
 
     /* printf info */
-    printf("PIC %d, %s", DecPic.pic_id,
+    DEBUG_PRINT(("PIC %d, %s", DecPic.pic_id,
            DecPic.key_picture ? "key picture,    " :
-           "non key picture,");
+           "non key picture,"));
 
     /* pic coding type */
     printAvsPicCodingType(DecPic.pic_coding_type);
 
-    if(DecPic.field_picture)
-      printf(" %s ",
+    if(DecPic.field_picture) {
+      DEBUG_PRINT((" %s ",
              DecPic.
-             top_field ? "top field.   " : "bottom field.");
-    else
-      printf(" frame picture. ");
+             top_field ? "top field.   " : "bottom field."));
+    } else {
+      DEBUG_PRINT((" frame picture. "));
+    }
 
     printTimeCode(&(DecPic.time_code));
     if(DecPic.number_of_err_mbs) {
-      printf(", %d/%d error mbs
",
+      DEBUG_PRINT((", %d/%d error mbs
",
              DecPic.number_of_err_mbs,
              (DecPic.frame_width >> 4) *
-             (DecPic.frame_height >> 4));
+             (DecPic.frame_height >> 4)));
       cumulative_error_mbs += DecPic.number_of_err_mbs;
     }
 #ifndef PP_PIPELINE_ENABLED
@@ -1529,7 +1560,8 @@ end2:
 
   START_SW_PERFORMANCE;
   decsw_performance();
-  AvsDecGetInfo(decoder, &Decinfo);
+  info_ret = AvsDecGetInfo(decoder, &Decinfo);
+  (void)(info_ret);
   END_SW_PERFORMANCE;
   decsw_performance();
 
@@ -1555,22 +1587,22 @@ end2:
   END_SW_PERFORMANCE;
   decsw_performance();
 
-  if(Decinfo.frame_width < 1921)
-    printf("
Width %d Height %d
", Decinfo.frame_width,
-           Decinfo.frame_height);
+  if(Decinfo.frame_width < 1921) {
+    PRINT(("
Width %d Height %d
", Decinfo.frame_width,
+           Decinfo.frame_height));
+  }
   if(cumulative_error_mbs) {
-    printf("Cumulative errors: %d/%d macroblocks, ",
+    PRINT(("Cumulative errors: %d/%d macroblocks, ",
            cumulative_error_mbs,
            (Decinfo.frame_width >> 4) * (Decinfo.frame_height >> 4) *
-           frame_number);
+           frame_number));
   }
-  printf("decoded %d pictures
", frame_number);
+  PRINT(("decoded %d pictures
", frame_number));
 
   if(fout)
     fclose(fout);
 
-  if(f_in)
-    fclose(f_in);
+  fclose(f_in);
 
 #ifdef ASIC_TRACE_SUPPORT
   trace_SequenceCtrl(hw_dec_pic_count, b_frames);
@@ -1584,19 +1616,20 @@ end2:
   if(NULL == fout) {
     stream_len = 0;
   } else {
-    fseek(fout, 0L, SEEK_END);
+    if (fseek(fout, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     stream_len = (u32) ftell(fout);
     fclose(fout);
   }
 
 #ifndef PP_PIPELINE_ENABLED
-  printf("output size %d
", stream_len);
+  PRINT(("output size %d
", stream_len));
 #endif
 
   FINALIZE_SW_PERFORMANCE;
 
   if(cumulative_error_mbs || !frame_number) {
-    printf("ERRORS FOUND
");
+    PRINT(("ERRORS FOUND
"));
     return (1);
   } else
     return (0);
@@ -1619,7 +1652,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
   StartCode = 0;
 
   if(stop_decoding) {
-    printf("Truncated stream size reached -> stop decoding
");
+    PRINT(("Truncated stream size reached -> stop decoding
"));
     return 0;
   }
 
@@ -1630,7 +1663,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
     ret =
       TBRandomizePacketLoss(tb_cfg.tb_params.stream_packet_loss, &next_packet);
     if(ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return 0;
     }
   }
@@ -1718,7 +1751,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
     /* stop reading if truncated stream size is reached */
     if(stream_truncate && !disable_resync) {
       if(previous_used + idx >= stream_size) {
-        printf("Stream truncated at %d bytes
", previous_used + idx);
+        PRINT(("Stream truncated at %d bytes
", previous_used + idx));
         stop_decoding = 1;   /* next call return 0 size -> exit decoding main loop */
         break;
       }
@@ -1728,28 +1761,29 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
   previous_used += idx;
 
   if (buff_bytes) {
-    fseek(fp, -(i32)buff_bytes, SEEK_CUR);
+    if (fseek(fp, -(i32)buff_bytes, SEEK_CUR) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
 
   /* If we skip this packet */
   if(pic_rdy && next_packet && ((hdrs_rdy && !stream_header_corrupt) || stream_header_corrupt)) {
     /* Get the next packet */
-    printf("Packet Loss
");
+    DEBUG_PRINT(("Packet Loss
"));
     return readDecodeUnit(fp, frame_buffer);
   } else {
     /*printf("READ DECODE UNIT %d
", idx); */
-    printf("No Packet Loss
");
+    DEBUG_PRINT(("No Packet Loss
"));
     if (disable_resync && pic_rdy && stream_truncate
         && ((hdrs_rdy && !stream_header_corrupt) || stream_header_corrupt)) {
       i32 ret;
-      printf("Original packet size %d
", idx);
+      PRINT(("Original packet size %d
", idx));
       ret = TBRandomizeU32(&idx);
       if(ret != 0) {
-        printf("RANDOM STREAM ERROR FAILED
");
+        PRINT(("RANDOM STREAM ERROR FAILED
"));
         stop_decoding = 1;   /* next call return 0 size -> exit decoding main loop */
         return 0;
       }
-      printf("Randomized packet size %d
", idx);
+      PRINT(("Randomized packet size %d
", idx));
     }
     return (idx);
   }
@@ -1765,12 +1799,12 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
 
 void printTimeCode(AvsDecTime * timecode) {
 
-  fprintf(stdout, "hours %u, "
+  DEBUG_PRINT(("hours %u, "
           "minutes %u, "
           "seconds %u, "
           "time_pictures %u 
",
           timecode->hours,
-          timecode->minutes, timecode->seconds, timecode->pictures);
+          timecode->minutes, timecode->seconds, timecode->pictures));
 }
 
 /*------------------------------------------------------------------------------
@@ -1780,68 +1814,86 @@ void printTimeCode(AvsDecTime * timecode) {
 
 void decRet(AvsDecRet ret) {
 
-  printf("Decode result: ");
-
   switch (ret) {
   case AVSDEC_OK:
-    printf("AVSDEC_OK
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("AVSDEC_OK
"));
     break;
   case AVSDEC_NONREF_PIC_SKIPPED:
-    printf("AVSDEC_NONREF_PIC_SKIPPED
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_NONREF_PIC_SKIPPED
"));
     break;
   case AVSDEC_STRM_PROCESSED:
-    printf("AVSDEC_STRM_PROCESSED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("AVSDEC_STRM_PROCESSED
"));
     break;
   case AVSDEC_BUF_EMPTY:
-    printf("AVSDEC_BUF_EMPTY
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_BUF_EMPTY
"));
     break;
   case AVSDEC_NO_DECODING_BUFFER:
-    printf("AVSDEC_NO_DECODING_BUFFER
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("AVSDEC_NO_DECODING_BUFFER
"));
     break;
   case AVSDEC_PIC_RDY:
-    printf("AVSDEC_PIC_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("AVSDEC_PIC_RDY
"));
     break;
   case AVSDEC_HDRS_RDY:
-    printf("AVSDEC_HDRS_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("AVSDEC_HDRS_RDY
"));
     break;
   case AVSDEC_PIC_DECODED:
-    printf("AVSDEC_PIC_DECODED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("AVSDEC_PIC_DECODED
"));
     break;
   case AVSDEC_PIC_CONSUMED:
-    printf("AVSDEC_PIC_CONSUMED
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_PIC_CONSUMED
"));
     break;
   case AVSDEC_PARAM_ERROR:
-    printf("AVSDEC_PARAM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_PARAM_ERROR
"));
     break;
   case AVSDEC_STRM_ERROR:
-    printf("AVSDEC_STRM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_STRM_ERROR
"));
     break;
   case AVSDEC_NOT_INITIALIZED:
-    printf("AVSDEC_NOT_INITIALIZED
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_NOT_INITIALIZED
"));
     break;
   case AVSDEC_MEMFAIL:
-    printf("AVSDEC_MEMFAIL
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_MEMFAIL
"));
     break;
   case AVSDEC_DWL_ERROR:
-    printf("AVSDEC_DWL_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_DWL_ERROR
"));
     break;
   case AVSDEC_HW_BUS_ERROR:
-    printf("AVSDEC_HW_BUS_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_HW_BUS_ERROR
"));
     break;
   case AVSDEC_SYSTEM_ERROR:
-    printf("AVSDEC_SYSTEM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_SYSTEM_ERROR
"));
     break;
   case AVSDEC_HW_TIMEOUT:
-    printf("AVSDEC_HW_TIMEOUT
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_HW_TIMEOUT
"));
     break;
   case AVSDEC_HDRS_NOT_RDY:
-    printf("AVSDEC_HDRS_NOT_RDY
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_HDRS_NOT_RDY
"));
     break;
   case AVSDEC_STREAM_NOT_SUPPORTED:
-    printf("AVSDEC_STREAM_NOT_SUPPORTED
");
+    PRINT(("Decode result: "));
+    PRINT(("AVSDEC_STREAM_NOT_SUPPORTED
"));
     break;
   default:
-    printf("Other %d
", ret);
+    PRINT(("Decode result: "));
+    PRINT(("Other %d
", ret));
     break;
   }
 }
@@ -1851,7 +1903,7 @@ void decRet(AvsDecRet ret) {
         Description : Print out NextPicture return values
 ------------------------------------------------------------------------------*/
 void decNextPictureRet(AvsDecRet ret) {
-  printf("next picture returns: ");
+  DEBUG_PRINT(("next picture returns: "));
 
   decRet(ret);
 }
@@ -1866,16 +1918,16 @@ void decNextPictureRet(AvsDecRet ret) {
 void printAvsPicCodingType(u32 pic_type) {
   switch (pic_type) {
   case DEC_PIC_TYPE_I:
-    printf(" DEC_PIC_TYPE_I,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_I,"));
     break;
   case DEC_PIC_TYPE_P:
-    printf(" DEC_PIC_TYPE_P,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_P,"));
     break;
   case DEC_PIC_TYPE_B:
-    printf(" DEC_PIC_TYPE_B,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_B,"));
     break;
   default:
-    printf("Other %d
", pic_type);
+    DEBUG_PRINT(("Other %d
", pic_type));
     break;
   }
 }
@@ -1895,11 +1947,11 @@ void printAvsVersion(void) {
    */
 
   dec_version = AvsDecGetAPIVersion();
-  printf("
Api version:  %d.%d, ", dec_version.major, dec_version.minor);
+  PRINT(("
Api version:  %d.%d, ", dec_version.major, dec_version.minor));
 
   dec_build = AvsDecGetBuild();
-  printf("sw build nbr: %d, hw build nbr: %x

",
-         dec_build.sw_build, dec_build.hw_build);
+  PRINT(("sw build nbr: %d, hw build nbr: %x

",
+         dec_build.sw_build, dec_build.hw_build));
 
 }
 
@@ -1927,7 +1979,7 @@ i32 AllocatePicBuffers(AvsDecLinearMem * buffer, DecContainer * container) {
   if(DWLMallocRefFrm(((DecContainer *) container)->dwl,
                      offset * AVS_NUM_BUFFERS,
                      (struct DWLLinearMem *) buffer) != DWL_OK) {
-    printf(("UNABLE TO ALLOCATE OUTPUT BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE OUTPUT BUFFER MEMORY
"));
     return 1;
   }
 
@@ -1938,8 +1990,8 @@ i32 AllocatePicBuffers(AvsDecLinearMem * buffer, DecContainer * container) {
   buffer[2].bus_address = buffer[1].bus_address + offset;
 
   for(i = 0; i < AVS_NUM_BUFFERS; i++) {
-    printf("buff %d vir %lx bus %lx
", i,
-         (unsigned long)buffer[i].virtual_address, buffer[i].bus_address);
+    PRINT(("buff %d vir %lx bus %lx
", i,
+         (unsigned long)buffer[i].virtual_address, buffer[i].bus_address));
   }
 
 #endif
@@ -2014,7 +2066,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
     if(strcmp(filename, "none") != 0) {
       fout = fopen(filename, "wb");
       if(fout == NULL) {
-        printf("UNABLE TO OPEN OUTPUT FILE
");
+        PRINT(("UNABLE TO OPEN OUTPUT FILE
"));
         if(raster_scan)
           free(raster_scan);
 
@@ -2087,7 +2139,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
 
       if((DecPicture.field_picture && !first_field) ||
           !DecPicture.field_picture) {
-        printf("Output picture %d
", frame_id);
+        DEBUG_PRINT(("Output picture %d
", frame_id));
         /* Decoder without pp does not write out fields but a
          * frame containing both fields */
         /* PP output is written field by field */
@@ -2096,7 +2148,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
         if(output_picture_endian == DEC_X170_BIG_ENDIAN) {
           pic_copy = (u8 *) malloc(pic_size);
           if(NULL == pic_copy) {
-            printf("MALLOC FAILED @ %s %d", __FILE__, __LINE__);
+            PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
             if(raster_scan)
               free(raster_scan);
             return;
diff --git a/decoder_sw/software/test/common/Makefile b/decoder_sw/software/test/common/Makefile
index 79e1c67..9b7bb21 100755
--- a/decoder_sw/software/test/common/Makefile
+++ b/decoder_sw/software/test/common/Makefile
@@ -103,7 +103,7 @@ OMX_LIB_G2_DWL          = libdwlg2.a
 OMX_LIB_G2_COMMON       = libg2common.a
 OMX_LIB_G2_HEVC         = libg2hevc.a
 OMX_LIB_G2_VP9          = libg2vp9.a
-OMX_LIB_G2_HW           = lib/libg2hw.a
+OMX_LIB_G2_HW           = libg2hw.a
 OMX_LIB_G2_TBCOMMON     = libg2tbcommon.a
 
 libdwlg2.a: $(sort $(patsubst %,$(OBJDIR)/%,$(DWL_SRCS:.c=.o)))
diff --git a/decoder_sw/software/test/common/bytestream_parser.c b/decoder_sw/software/test/common/bytestream_parser.c
index 8e70644..c478a74 100755
--- a/decoder_sw/software/test/common/bytestream_parser.c
+++ b/decoder_sw/software/test/common/bytestream_parser.c
@@ -94,9 +94,19 @@ BSParserInst ByteStreamParserOpen(const char* fname, u32 mode) {
     free(inst);
     return NULL;
   }
-  fseeko(inst->file, 0, SEEK_END);
+  if (fseeko(inst->file, 0, SEEK_END) != 0) {
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    free(inst);
+    return NULL;
+  }
   inst->size = ftello(inst->file);
-  fseeko(inst->file, 0, SEEK_SET);
+  if (inst->size == -1L)
+    fprintf(stderr, "ftell() failed in file %s at line # %d
", __FILE__, __LINE__-2);
+  if (fseeko(inst->file, 0, SEEK_SET) != 0) {
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    free(inst);
+    return NULL;
+  }
   return inst;
 }
 
@@ -115,8 +125,13 @@ u32 CheckAccessUnitBoundary(FILE* file, off_t nal_begin) {
   u32 nal_type, val;
 
   off_t start = ftello(file);
+  if (start == -1L) {
+    fprintf(stderr, "ftell() failed in file %s at line # %d
", __FILE__, __LINE__-2);
+    return is_boundary;
+  }
 
-  fseeko(file, nal_begin + 1, SEEK_SET);
+  if (fseeko(file, nal_begin + 1, SEEK_SET) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   nal_type = (getc(file) & 0x7E) >> 1;
 
   if (nal_type > NAL_CODED_SLICE_CRA)
@@ -128,7 +143,8 @@ u32 CheckAccessUnitBoundary(FILE* file, off_t nal_begin) {
     if (val & 0x80) is_boundary = BSPARSER_BOUNDARY;
   }
 
-  fseeko(file, start, SEEK_SET);
+  if (fseeko(file, start, SEEK_SET) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   return is_boundary;
 }
 
@@ -180,7 +196,8 @@ int ByteStreamParserReadFrame(BSParserInst instance, u8* buffer,
   if (end == begin) {
     return 0; /* End of stream */
   }
-  fseeko(inst->file, begin, SEEK_SET);
+  if (fseeko(inst->file, begin, SEEK_SET) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   if (*size < end - begin) {
     *size = end - begin;
     return -1; /* Insufficient buffer size */
diff --git a/decoder_sw/software/test/common/command_line_parser.c b/decoder_sw/software/test/common/command_line_parser.c
index b4ac507..9e8f544 100755
--- a/decoder_sw/software/test/common/command_line_parser.c
+++ b/decoder_sw/software/test/common/command_line_parser.c
@@ -178,10 +178,12 @@ int ParseParams(int argc, char* argv[], struct TestParams* params) {
                 "exclusive!
");
         return 1;
       }
+#ifdef SDL_ENABLED
       if (flag_s) {
         fprintf(stderr, "ERROR: SDL sink supports only -P!
");
         return 1;
       }
+#endif
       flag_S = 1;
       params->format = DEC_OUT_FRM_RASTER_SCAN;
       break;
@@ -253,10 +255,12 @@ int ParseParams(int argc, char* argv[], struct TestParams* params) {
                 "exclusive!
");
         return 1;
       }
+#ifdef SDL_ENABLED
       if (flag_s) {
         fprintf(stderr, "ERROR: SDL sink supports only -P!
");
         return 1;
       }
+#endif
       flag_T = 1;
       params->format = DEC_OUT_FRM_TILED_4X4;
       break;
diff --git a/decoder_sw/software/test/common/dectestbench.c b/decoder_sw/software/test/common/dectestbench.c
index 0765e93..e204c71 100755
--- a/decoder_sw/software/test/common/dectestbench.c
+++ b/decoder_sw/software/test/common/dectestbench.c
@@ -74,7 +74,20 @@
 #define ASSERT(expr)
 #endif
 
-#define DEBUG_PRINT(str) printf str
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
 
 #define MAX_BUFFERS 32
 
@@ -82,7 +95,7 @@
 
 /* Generic yuv writing interface. */
 typedef const void* YuvsinkOpenFunc(const char* fname);
-typedef void YuvsinkWritePictureFunc(const void* inst, struct DecPicture pic);
+typedef void YuvsinkWritePictureFunc(const void* inst, const struct DecPicture* pic);
 typedef void YuvsinkCloseFunc(const void* inst);
 typedef struct YuvSink_ {
   const void* inst;
@@ -132,7 +145,7 @@ static void HeadersDecodedCb(ClientInst inst,
 static void BufferRequestCb(ClientInst inst);
 #endif
 static void BufferDecodedCb(ClientInst inst, struct DecInput* buffer);
-static void PictureReadyCb(ClientInst inst, struct DecPicture picture);
+static void PictureReadyCb(ClientInst inst, struct DecPicture* picture);
 static void EndOfStreamCb(ClientInst inst);
 static void ReleasedCb(ClientInst inst);
 static void NotifyErrorCb(ClientInst inst, u32 pic_id, enum DecRet rv);
@@ -211,14 +224,14 @@ int main(int argc, char* argv[]) {
 #endif
   struct DWLInitParam dwl_params = {DWL_CLIENT_TYPE_HEVC_DEC};
 
-  printf("
Hantro G2 decoder command line interface

");
+  PRINT(("
Hantro G2 decoder command line interface

"));
   SetupDefaultParams(&client.test_params);
   if (argc < 2) {
     PrintUsage(argv[0]);
     return 0;
   }
   if (ParseParams(argc, argv, &client.test_params)) {
-    printf("Failed to parse params.

");
+    PRINT(("Failed to parse params.

"));
     PrintUsage(argv[0]);
     return 1;
   }
@@ -226,30 +239,35 @@ int main(int argc, char* argv[]) {
   OpenTestHooks(&client);
 
   struct DecSwHwBuild build = DecGetBuild();
-  printf("Hardware build: 0x%x, Software build: 0x%x
", build.hw_build,
-         build.sw_build);
-  printf("VP9 %s
", build.hw_config[0].vp9_support ? "enabled" : "disabled");
-  printf("HEVC %s
", build.hw_config[0].hevc_support ? "enabled" : "disabled");
-  printf("PP %s
", build.hw_config[0].pp_support ? "enabled" : "disabled");
+  PRINT(("Hardware build: 0x%x, Software build: 0x%x
", build.hw_build,
+         build.sw_build));
+  PRINT(("VP9 %s
", build.hw_config[0].vp9_support ? "enabled" : "disabled"));
+  PRINT(("HEVC %s
", build.hw_config[0].hevc_support ? "enabled" : "disabled"));
+  PRINT(("PP %s
", build.hw_config[0].pp_support ? "enabled" : "disabled"));
   if (!build.hw_config[0].max_dec_pic_width ||
       !build.hw_config[0].max_dec_pic_height) {
-    printf("Maximum supported picture width, height unspecified");
-    printf(" (hw config reports %d, %d)

", build.hw_config[0].max_dec_pic_width,
-           build.hw_config[0].max_dec_pic_height);
-  } else
-    printf("Maximum supported picture width %d, height %d

",
+    PRINT(("Maximum supported picture width, height unspecified"));
+    PRINT((" (hw config reports %d, %d)

", build.hw_config[0].max_dec_pic_width,
+           build.hw_config[0].max_dec_pic_height));
+  } else {
+    PRINT(("Maximum supported picture width %d, height %d

",
            build.hw_config[0].max_dec_pic_width,
-           build.hw_config[0].max_dec_pic_height);
+           build.hw_config[0].max_dec_pic_height));
+  }
 
   client.demuxer.inst = CreateDemuxer(&client);
   if (client.demuxer.inst == NULL) {
-    printf("Failed to open demuxer (file missing or of wrong type?)
");
+    PRINT(("Failed to open demuxer (file missing or of wrong type?)
"));
     return -1;
   }
 
   if (client.test_params.extra_output_thread)
     /* Create the fifo to enable parallel output processing */
-    FifoInit(2, &client.pic_fifo);
+    if (FifoInit(2, &client.pic_fifo) != FIFO_OK) {
+      fprintf(stderr, "FifoInit() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+      sem_destroy(&client.dec_done);
+      return -1;
+    }
 
   sem_init(&client.dec_done, 0, 0);
 
@@ -303,10 +321,10 @@ int main(int argc, char* argv[]) {
     DWLRelease(client.dwl);
     return -1;
   }
-  printf("Configuring hardware to output: %s
",
+  PRINT(("Configuring hardware to output: %s
",
          config.output_format == DEC_OUT_FRM_RASTER_SCAN
          ? "Semiplanar YCbCr 4:2:0 (four_cc 'NV12')"
-         : "4x4 tiled YCbCr 4:2:0");
+         : "4x4 tiled YCbCr 4:2:0"));
   config.dwl = dwl;
   config.dwl_inst = client.dwl;
   config.max_num_pics_to_decode = client.test_params.num_of_decoded_pics;
@@ -319,7 +337,7 @@ int main(int argc, char* argv[]) {
   config.use_bige_output = client.test_params.bigendian_output;
 
   /* Initialize the decoder. */
-  if (DecInit(codec, &client.decoder, config, client_if) != DEC_OK) {
+  if (DecInit(codec, &client.decoder, &config, client_if) != DEC_OK) {
     sem_destroy(&client.dec_done);
     return -1;
   }
@@ -354,7 +372,7 @@ static void DispatchBufferForDecoding(struct Client* client,
        sufficient size. */
     if (size > buffer->buffer.size) {
       i32 i;
-      DEBUG_PRINT(("Trying to reallocate buffer to fit next buffer.
"));
+      PRINT(("Trying to reallocate buffer to fit next buffer.
"));
       for (i = 0; i < GetStreamBufferCount(client); i++) {
         if (client->buffers[i].buffer.virtual_address ==
             buffer->buffer.virtual_address) {
@@ -428,16 +446,16 @@ static void InitializedCb(ClientInst inst) {
 
 static void HeadersDecodedCb(ClientInst inst, struct DecSequenceInfo info) {
   struct Client* client = (struct Client*)inst;
-  DEBUG_PRINT(
+  PRINT(
     ("Headers: Width %d Height %d
", info.pic_width, info.pic_height));
-  DEBUG_PRINT(
+  PRINT(
     ("Headers: Cropping params: (%d, %d) %dx%d
",
      info.crop_params.crop_left_offset, info.crop_params.crop_top_offset,
      info.crop_params.crop_out_width, info.crop_params.crop_out_height));
-  DEBUG_PRINT(("Headers: MonoChrome = %d
", info.is_mono_chrome));
-  DEBUG_PRINT(("Headers: Pictures in DPB = %d
", info.num_of_ref_frames));
-  DEBUG_PRINT(("Headers: video_range %d
", info.video_range));
-  DEBUG_PRINT(("Headers: matrix_coefficients %d
", info.matrix_coefficients));
+  PRINT(("Headers: MonoChrome = %d
", info.is_mono_chrome));
+  PRINT(("Headers: Pictures in DPB = %d
", info.num_of_ref_frames));
+  PRINT(("Headers: video_range %d
", info.video_range));
+  PRINT(("Headers: matrix_coefficients %d
", info.matrix_coefficients));
 
   if (client->yuvsink.inst == NULL) {
     if (client->test_params.out_file_name == NULL) {
@@ -600,7 +618,7 @@ static void BufferDecodedCb(ClientInst inst, struct DecInput* buffer) {
   }
 }
 
-static void PictureReadyCb(ClientInst inst, struct DecPicture picture) {
+static void PictureReadyCb(ClientInst inst, struct DecPicture* picture) {
   static char* pic_types[] = {"        IDR", "Non-IDR (P)", "Non-IDR (B)"};
   struct Client* client = (struct Client*)inst;
   client->num_of_output_pics++;
@@ -608,28 +626,28 @@ static void PictureReadyCb(ClientInst inst, struct DecPicture picture) {
   client->num_pics_to_display++;
 #endif
   DEBUG_PRINT(("PIC %2d/%2d, type %s,", client->num_of_output_pics,
-               picture.picture_info.pic_id,
-               pic_types[picture.picture_info.pic_coding_type]));
-  if (picture.picture_info.cycles_per_mb) {
-    client->cycle_count += picture.picture_info.cycles_per_mb;
-    DEBUG_PRINT((" %4d cycles / mb,", picture.picture_info.cycles_per_mb));
+               picture->picture_info.pic_id,
+               pic_types[picture->picture_info.pic_coding_type]));
+  if (picture->picture_info.cycles_per_mb) {
+    client->cycle_count += picture->picture_info.cycles_per_mb;
+    DEBUG_PRINT((" %4d cycles / mb,", picture->picture_info.cycles_per_mb));
   }
   DEBUG_PRINT((" %d x %d, Crop: (%d, %d), %d x %d %s
",
-               picture.sequence_info.pic_width,
-               picture.sequence_info.pic_height,
-               picture.sequence_info.crop_params.crop_left_offset,
-               picture.sequence_info.crop_params.crop_top_offset,
-               picture.sequence_info.crop_params.crop_out_width,
-               picture.sequence_info.crop_params.crop_out_height,
-               picture.picture_info.is_corrupted ? "CORRUPT" : ""));
+               picture->sequence_info.pic_width,
+               picture->sequence_info.pic_height,
+               picture->sequence_info.crop_params.crop_left_offset,
+               picture->sequence_info.crop_params.crop_top_offset,
+               picture->sequence_info.crop_params.crop_out_width,
+               picture->sequence_info.crop_params.crop_out_height,
+               picture->picture_info.is_corrupted ? "CORRUPT" : ""));
   if (client->test_params.extra_output_thread) {
     struct DecPicture* copy = malloc(sizeof(struct DecPicture));
     if (copy == NULL)
       return;
-    *copy = picture;
+    *copy = *picture;
     FifoPush(client->pic_fifo, copy, FIFO_EXCEPTION_DISABLE);
   } else {
-    PostProcessPicture(client, &picture);
+    PostProcessPicture(client, picture);
   }
 #ifdef USE_EXTERNAL_BUFFER
   client->num_pics_to_display--;
@@ -655,8 +673,9 @@ static void ReleasedCb(ClientInst inst) {
       DWLFreeLinear(client->dwl, &client->buffers[i].buffer);
     }
   }
-  if(client->cycle_count && client->num_of_output_pics)
-    DEBUG_PRINT(("
Average cycles/MB: %4d", client->cycle_count/client->num_of_output_pics));
+  if(client->cycle_count && client->num_of_output_pics) {
+    PRINT(("
Average cycles/MB: %4d", client->cycle_count/client->num_of_output_pics));
+  }
   ReleaseSink(client);
 
 #ifdef USE_EXTERNAL_BUFFER
@@ -773,7 +792,7 @@ static void PostProcessPicture(struct Client* client,
   }
 
   YuvfilterPrepareOutput(&copy);
-  client->yuvsink.WritePicture(client->yuvsink.inst, copy);
+  client->yuvsink.WritePicture(client->yuvsink.inst, &copy);
 
   free(copy.luma.virtual_address);
   free(copy.chroma.virtual_address);
@@ -810,7 +829,7 @@ static void PostProcessPicture(struct Client* client,
 #endif
 
 PIC_CONSUMED:
-  DecPictureConsumed(client->decoder, *picture);
+  DecPictureConsumed(client->decoder, picture);
 }
 
 static void* ParallelOutput(void* arg) {
@@ -819,7 +838,7 @@ static void* ParallelOutput(void* arg) {
   do {
     FifoPop(client->pic_fifo, (void**)&pic, FIFO_EXCEPTION_DISABLE);
     if (pic == NULL) {
-      DEBUG_PRINT(("END-OF-STREAM received in output thread
"));
+      PRINT(("END-OF-STREAM received in output thread
"));
       return NULL;
     }
     PostProcessPicture(client, pic);
@@ -964,8 +983,8 @@ static void OpenTestHooks(struct Client* client) {
   TBSetDefaultCfg(&tb_cfg);
   FILE* f_tbcfg = fopen("tb.cfg", "r");
   if (f_tbcfg == NULL) {
-    DEBUG_PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
-    DEBUG_PRINT(("USING DEFAULT CONFIGURATION
"));
+    PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if (TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE) return;
@@ -998,10 +1017,10 @@ static void OpenTestHooks(struct Client* client) {
   if (client->test_params.trace_target) tb_cfg.tb_params.extra_cu_ctrl_eof = 1;
 
   if (client->test_params.hw_traces) {
-    if (!OpenTraceFiles())
-      DEBUG_PRINT(
-        ("UNABLE TO OPEN TRACE FILE(S) Do you have a trace.cfg "
+    if (!OpenTraceFiles()) {
+      PRINT(("UNABLE TO OPEN TRACE FILE(S) Do you have a trace.cfg "
          "file?
"));
+    }
   }
 
   if (f_tbcfg != NULL) {
@@ -1065,15 +1084,15 @@ static int HwconfigOverride(DecInst dec_inst, struct TBCfg* tbcfg) {
   u32 output_format = TBGetDecOutputFormat(&tb_cfg);
   u32 service_merge_disable = TBGetDecServiceMergeDisable(&tb_cfg);
 
-  DEBUG_PRINT(("TBCfg: Decoder Data Discard %d
", data_discard));
-  DEBUG_PRINT(("TBCfg: Decoder Latency Compensation %d
", latency_comp));
-  DEBUG_PRINT(
+  PRINT(("TBCfg: Decoder Data Discard %d
", data_discard));
+  PRINT(("TBCfg: Decoder Latency Compensation %d
", latency_comp));
+  PRINT(
     ("TBCfg: Decoder Output Picture Endian %d
", output_picture_endian));
-  DEBUG_PRINT(("TBCfg: Decoder Bus Burst Length %d
", bus_burst_length));
-  DEBUG_PRINT(
+  PRINT(("TBCfg: Decoder Bus Burst Length %d
", bus_burst_length));
+  PRINT(
     ("TBCfg: Decoder Asic Service Priority %d
", asic_service_priority));
-  DEBUG_PRINT(("TBCfg: Decoder Output Format %d
", output_format));
-  DEBUG_PRINT(
+  PRINT(("TBCfg: Decoder Output Format %d
", output_format));
+  PRINT(
     ("TBCfg: Decoder Service Merge Disable %d
", service_merge_disable));
 
   /* TODO(vmr): Enable these, remove what's not needed, add what's needed.
diff --git a/decoder_sw/software/test/common/file_sink.c b/decoder_sw/software/test/common/file_sink.c
index 2fee187..e014798 100755
--- a/decoder_sw/software/test/common/file_sink.c
+++ b/decoder_sw/software/test/common/file_sink.c
@@ -56,7 +56,13 @@ const void* FilesinkOpen(const char* fname) {
     free(inst);
     return NULL;
   }
-  strcpy(inst->filename, fname);
+  if (sizeof(inst->filename) - 1 < strlen(fname)) {
+    fclose(inst->file);
+    free(inst);
+    return NULL;
+  } else {
+    strcpy(inst->filename, fname);
+  }
   return inst;
 }
 
@@ -65,10 +71,13 @@ void FilesinkClose(const void* inst) {
   if (output->file != NULL) {
     /* Close the file and if it is empty, remove it. */
     off_t file_size;
-    fseeko(output->file, 0, SEEK_END);
+    if (fseeko(output->file, 0, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     file_size = ftello(output->file);
     fclose(output->file);
-    if (file_size == 0) remove(output->filename);
+    if (file_size == 0)
+      if (remove(output->filename) != 0)
+        fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
   if (output->frame_pic != NULL) {
     free(output->frame_pic);
@@ -76,15 +85,15 @@ void FilesinkClose(const void* inst) {
   free(output);
 }
 
-void FilesinkWritePic(const void* inst, struct DecPicture pic) {
+void FilesinkWritePic(const void* inst, const struct DecPicture* pic) {
   struct FileSink* output = (struct FileSink*)inst;
 #ifdef TB_PP
   u32 w, h, num_of_pixels;
-  u8 pixel_bytes = ((pic.sequence_info.bit_depth_luma == 8 && pic.sequence_info.bit_depth_chroma == 8) ||
-                    pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 1 : 2;
-  u8* p = (u8*)pic.luma.virtual_address;
-  w = pic.sequence_info.pic_width;
-  h = pic.sequence_info.pic_height;
+  u8 pixel_bytes = ((pic->sequence_info.bit_depth_luma == 8 && pic->sequence_info.bit_depth_chroma == 8) ||
+                    pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 1 : 2;
+  u8* p = (u8*)pic->luma.virtual_address;
+  w = pic->sequence_info.pic_width;
+  h = pic->sequence_info.pic_height;
   num_of_pixels = w * h;
   fwrite(p, pixel_bytes, num_of_pixels, output->file);
   p += num_of_pixels;
@@ -92,23 +101,23 @@ void FilesinkWritePic(const void* inst, struct DecPicture pic) {
   if (w & 1) w += 1;
   if (h & 1) h += 1;
   num_of_pixels = w * h;
-  fwrite(pic.chroma.virtual_address, pixel_bytes, num_of_pixels / 2, output->file);
+  fwrite(pic->chroma.virtual_address, pixel_bytes, num_of_pixels / 2, output->file);
 #else
-  u8 pixel_width = ((pic.sequence_info.bit_depth_luma == 8 && pic.sequence_info.bit_depth_chroma == 8) ||
-                    pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 8 :
-                   (pic.picture_info.pixel_format == DEC_OUT_PIXEL_P010) ? 16 : 10;
-  u8* p = (u8*)pic.luma.virtual_address;
-  u32 s = pic.sequence_info.pic_stride;
-  u32 w = pic.sequence_info.pic_width * pixel_width / 8;
-  u32 h = pic.sequence_info.pic_height;
+  u8 pixel_width = ((pic->sequence_info.bit_depth_luma == 8 && pic->sequence_info.bit_depth_chroma == 8) ||
+                    pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 8 :
+                   (pic->picture_info.pixel_format == DEC_OUT_PIXEL_P010) ? 16 : 10;
+  u8* p = (u8*)pic->luma.virtual_address;
+  u32 s = pic->sequence_info.pic_stride;
+  u32 w = pic->sequence_info.pic_width * pixel_width / 8;
+  u32 h = pic->sequence_info.pic_height;
   u32 extra_bits = pic.sequence_info.pic_width * pixel_width & 7;
   if (pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUSTOMER1) {
     /* In customized format, fill 0 of padding bytes/bits in last 128-bit burst. */
     u32 padding_bytes, padding_bits, bursts, fill_bits;
     u8 *last_burst;
-    bursts = pic.sequence_info.pic_width * pixel_width / 128;
+    bursts = pic->sequence_info.pic_width * pixel_width / 128;
     fill_bits = NEXT_MULTIPLE(pic.sequence_info.pic_width * pixel_width, 128)
-                - pic.sequence_info.pic_width * pixel_width;
+                - pic->sequence_info.pic_width * pixel_width;
     padding_bytes = fill_bits / 8;
     padding_bits = fill_bits & 7;
     for (u32 i = 0; i < h; i++) {
@@ -137,7 +146,7 @@ void FilesinkWritePic(const void* inst, struct DecPicture pic) {
     extra_bits = 0;
   }
 
-  p = (u8*)pic.luma.virtual_address;
+  p = (u8*)pic->luma.virtual_address;
   for (u32 i = 0; i < h; i++) {
     fwrite(p, 1, w, output->file);
     if (extra_bits) {
@@ -148,7 +157,7 @@ void FilesinkWritePic(const void* inst, struct DecPicture pic) {
     p += s;
   }
   /* round odd picture dimensions to next multiple of two for chroma */
-  p = (u8*)pic.chroma.virtual_address;
+  p = (u8*)pic->chroma.virtual_address;
   for (u32 i = 0; i < h / 2; i++) {
     fwrite(p, 1, w, output->file);
     if (extra_bits) {
@@ -161,27 +170,27 @@ void FilesinkWritePic(const void* inst, struct DecPicture pic) {
 #endif
 }
 
-void FilesinkWriteSinglePic(const void* inst, struct DecPicture pic) {
+void FilesinkWriteSinglePic(const void* inst, const struct DecPicture* pic) {
   static int frame_num = 0;
   char name[FILENAME_MAX];
   FILE* fp = NULL;
 
   memset(name, 0, sizeof(name));
   frame_num++;
-  sprintf(name, "out_%03d_%dx%d.yuv", frame_num, pic.sequence_info.pic_width,
-          pic.sequence_info.pic_height);
+  sprintf(name, "out_%03d_%dx%d.yuv", frame_num, pic->sequence_info.pic_width,
+          pic->sequence_info.pic_height);
 
   fp = fopen(name, "wb");
   if (fp) {
-    u32 w = pic.sequence_info.pic_width;
-    u32 h = pic.sequence_info.pic_height;
+    u32 w = pic->sequence_info.pic_width;
+    u32 h = pic->sequence_info.pic_height;
     u32 num_of_pixels = w * h;
-    fwrite(pic.luma.virtual_address, 1, num_of_pixels, fp);
+    fwrite(pic->luma.virtual_address, 1, num_of_pixels, fp);
     /* round odd picture dimensions to next multiple of two for chroma */
     if (w & 1) w += 1;
     if (h & 1) h += 1;
     num_of_pixels = w * h;
-    fwrite(pic.chroma.virtual_address, 1, num_of_pixels / 2, fp);
+    fwrite(pic->chroma.virtual_address, 1, num_of_pixels / 2, fp);
     fclose(fp);
   }
 }
diff --git a/decoder_sw/software/test/common/file_sink.h b/decoder_sw/software/test/common/file_sink.h
index 38a267f..f19a95d 100755
--- a/decoder_sw/software/test/common/file_sink.h
+++ b/decoder_sw/software/test/common/file_sink.h
@@ -46,8 +46,9 @@ extern "C" {
 
 const void* FilesinkOpen(const char* fname);
 void FilesinkClose(const void* inst);
-void FilesinkWritePic(const void* inst, struct DecPicture pic);
-void FilesinkWriteSinglePic(const void* inst, struct DecPicture pic);
+void FilesinkWritePic(const void* inst, const struct DecPicture* pic);
+void FilesinkWriteSinglePic(const void* inst, const struct DecPicture* pic);
+
 
 #ifdef __cplusplus
 }
diff --git a/decoder_sw/software/test/common/md5_sink.c b/decoder_sw/software/test/common/md5_sink.c
index 17c134d..62ff0ae 100755
--- a/decoder_sw/software/test/common/md5_sink.c
+++ b/decoder_sw/software/test/common/md5_sink.c
@@ -57,7 +57,14 @@ const void* Md5sinkOpen(const char* fname) {
     free(inst);
     return NULL;
   }
-  strcpy(inst->filename, fname);
+  if(sizeof(inst->filename) - 1 < strlen(fname)) {
+    fprintf(stderr, "strcpy() parameters error!
");
+    fclose(inst->file);
+    free(inst);
+    return NULL;
+  } else {
+    strcpy(inst->filename, fname);
+  }
   MD5Init(&inst->ctx);
   return inst;
 }
@@ -74,45 +81,48 @@ void Md5sinkClose(const void* inst) {
     fprintf(md5sink->file, "  %s
", md5sink->filename);
     fflush(md5sink->file);
     /* Close the file and if it is empty, remove it. */
-    fseek(md5sink->file, 0, SEEK_END);
+    if (fseek(md5sink->file, 0, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     file_size = ftell(md5sink->file);
     fclose(md5sink->file);
-    if (file_size == 0) remove(md5sink->filename);
+     if (file_size == 0)
+      if (remove(md5sink->filename) != 0)
+        fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
   free(md5sink);
 }
 
-void Md5sinkWritePic(const void* inst, struct DecPicture pic) {
+void Md5sinkWritePic(const void* inst, const struct DecPicture* pic) {
   struct MD5Sink* md5sink = (struct MD5Sink*)inst;
 #ifdef TB_PP
-  u32 w = pic.sequence_info.pic_width;
-  u32 h = pic.sequence_info.pic_height;
-  u8 pixel_bytes = ((pic.sequence_info.bit_depth_luma == 8 && pic.sequence_info.bit_depth_chroma == 8) ||
-                    pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 1 : 2;
+  u32 w = pic->sequence_info.pic_width;
+  u32 h = pic->sequence_info.pic_height;
+  u8 pixel_bytes = ((pic->sequence_info.bit_depth_luma == 8 && pic->sequence_info.bit_depth_chroma == 8) ||
+                    pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 1 : 2;
   u32 num_of_pixels = w * h;
-  MD5Update(&md5sink->ctx, pic.luma.virtual_address, num_of_pixels * pixel_bytes);
+  MD5Update(&md5sink->ctx, pic->luma.virtual_address, num_of_pixels * pixel_bytes);
   /* round odd picture dimensions to next multiple of two for chroma */
   if (w & 1) w += 1;
   if (h & 1) h += 1;
   num_of_pixels = w * h;
-  MD5Update(&md5sink->ctx, pic.chroma.virtual_address, num_of_pixels / 2 * pixel_bytes);
+  MD5Update(&md5sink->ctx, pic->chroma.virtual_address, num_of_pixels / 2 * pixel_bytes);
 #else
-  u8 pixel_width = ((pic.sequence_info.bit_depth_luma == 8 && pic.sequence_info.bit_depth_chroma == 8) ||
-                    pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 8 :
-                   (pic.picture_info.pixel_format == DEC_OUT_PIXEL_P010) ? 16 : 10;
-  u8* p = (u8*)pic.luma.virtual_address;
-  u32 s = pic.sequence_info.pic_stride;
-  u32 w = pic.sequence_info.pic_width * pixel_width / 8;
-  u32 h = pic.sequence_info.pic_height;
-  u32 extra_bits = pic.sequence_info.pic_width * pixel_width & 7;
+  u8 pixel_width = ((pic->sequence_info.bit_depth_luma == 8 && pic->sequence_info.bit_depth_chroma == 8) ||
+                    pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 8 :
+                   (pic->picture_info.pixel_format == DEC_OUT_PIXEL_P010) ? 16 : 10;
+  u8* p = (u8*)pic->luma.virtual_address;
+  u32 s = pic->sequence_info.pic_stride;
+  u32 w = pic->sequence_info.pic_width * pixel_width / 8;
+  u32 h = pic->sequence_info.pic_height;
+  u32 extra_bits = pic->sequence_info.pic_width * pixel_width & 7;
 
-  if (pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUSTOMER1) {
+  if (pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUSTOMER1) {
     /* In customized format, fill 0 of padding bytes/bits in last 128-bit burst. */
     u32 padding_bytes, padding_bits, bursts, fill_bits;
     u8 *last_burst;
-    bursts = pic.sequence_info.pic_width * pixel_width / 128;
-    fill_bits = NEXT_MULTIPLE(pic.sequence_info.pic_width * pixel_width, 128)
-                - pic.sequence_info.pic_width * pixel_width;
+    bursts = pic->sequence_info.pic_width * pixel_width / 128;
+    fill_bits = NEXT_MULTIPLE(pic->sequence_info.pic_width * pixel_width, 128)
+                - pic->sequence_info.pic_width * pixel_width;
     padding_bytes = fill_bits / 8;
     padding_bits = fill_bits & 7;
     for (u32 i = 0; i < h; i++) {
@@ -125,7 +135,7 @@ void Md5sinkWritePic(const void* inst, struct DecPicture pic) {
       }
       p += s;
     }
-    p = (u8*)pic.chroma.virtual_address;
+    p = (u8*)pic->chroma.virtual_address;
     for (u32 i = 0; i < h / 2; i++) {
       last_burst = p + bursts * 16;
       memset(last_burst, 0, padding_bytes);
@@ -137,11 +147,11 @@ void Md5sinkWritePic(const void* inst, struct DecPicture pic) {
       p += s;
     }
 
-    w = NEXT_MULTIPLE(pic.sequence_info.pic_width * pixel_width, 128) / 8;
+    w = NEXT_MULTIPLE(pic->sequence_info.pic_width * pixel_width, 128) / 8;
     extra_bits = 0;
   }
 
-  p = (u8*)pic.luma.virtual_address;
+  p = (u8*)pic->luma.virtual_address;
   for (u32 i = 0; i < h; i++) {
     MD5Update(&md5sink->ctx, p, w);
     if (extra_bits) {
@@ -152,7 +162,7 @@ void Md5sinkWritePic(const void* inst, struct DecPicture pic) {
     p += s;
   }
   /* round odd picture dimensions to next multiple of two for chroma */
-  p = (u8*)pic.chroma.virtual_address;
+  p = (u8*)pic->chroma.virtual_address;
   for (u32 i = 0; i < h / 2; i++) {
     MD5Update(&md5sink->ctx, p, w);
     if (extra_bits) {
@@ -173,7 +183,14 @@ const void* md5perpicsink_open(const char* fname) {
     free(inst);
     return NULL;
   }
-  strcpy(inst->filename, fname);
+  if(sizeof(inst->filename) - 1 < strlen(fname)) {
+    fprintf(stderr, "strcpy() parameters error!
");
+    fclose(inst->file);
+    free(inst);
+    return NULL;
+  } else {
+    strcpy(inst->filename, fname);
+  }
   return inst;
 }
 
@@ -182,50 +199,53 @@ void md5perpicsink_close(const void* inst) {
   if (md5sink->file != NULL) {
     /* Close the file and if it is empty, remove it. */
     u32 file_size;
-    fseek(md5sink->file, 0, SEEK_END);
+    if (fseek(md5sink->file, 0, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     file_size = ftell(md5sink->file);
     fclose(md5sink->file);
-    if (file_size == 0) remove(md5sink->filename);
+     if (file_size == 0)
+      if (remove(md5sink->filename) != 0)
+        fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
   free(md5sink);
 }
 
-void md5perpicsink_write_pic(const void* inst, struct DecPicture pic) {
+void md5perpicsink_write_pic(const void* inst, const struct DecPicture* pic) {
   struct MD5Sink* md5sink = (struct MD5Sink*)inst;
   struct MD5Context ctx;
 #ifdef TB_PP
-  u32 w = pic.sequence_info.pic_width;
-  u32 h = pic.sequence_info.pic_height;
+  u32 w = pic->sequence_info.pic_width;
+  u32 h = pic->sequence_info.pic_height;
   u32 num_of_pixels = w * h;
   unsigned char digest[16];
-  u8 pixel_bytes = ((pic.sequence_info.bit_depth_luma == 8 && pic.sequence_info.bit_depth_chroma == 8) ||
-                    pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 1 : 2;
+  u8 pixel_bytes = ((pic->sequence_info.bit_depth_luma == 8 && pic->sequence_info.bit_depth_chroma == 8) ||
+                    pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 1 : 2;
   MD5Init(&ctx);
-  MD5Update(&ctx, pic.luma.virtual_address, num_of_pixels * pixel_bytes);
+  MD5Update(&ctx, pic->luma.virtual_address, num_of_pixels * pixel_bytes);
   /* round odd picture dimensions to next multiple of two for chroma */
   if (w & 1) w += 1;
   if (h & 1) h += 1;
   num_of_pixels = w * h;
-  MD5Update(&ctx, pic.chroma.virtual_address, num_of_pixels / 2 * pixel_bytes);
+  MD5Update(&ctx, pic->chroma.virtual_address, num_of_pixels / 2 * pixel_bytes);
   MD5Final(digest, &ctx);
 #else
-  u8 pixel_width = ((pic.sequence_info.bit_depth_luma == 8 && pic.sequence_info.bit_depth_chroma == 8) ||
-                    pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 8 :
-                   (pic.picture_info.pixel_format == DEC_OUT_PIXEL_P010) ? 16 : 10;
-  u8* p = (u8*)pic.luma.virtual_address;
-  u32 s = pic.sequence_info.pic_stride;
-  u32 w = pic.sequence_info.pic_width * pixel_width / 8;
-  u32 h = pic.sequence_info.pic_height;
-  u32 extra_bits = pic.sequence_info.pic_width * pixel_width & 7;
+  u8 pixel_width = ((pic->sequence_info.bit_depth_luma == 8 && pic->sequence_info.bit_depth_chroma == 8) ||
+                    pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUT_8BIT) ? 8 :
+                   (pic->picture_info.pixel_format == DEC_OUT_PIXEL_P010) ? 16 : 10;
+  u8* p = (u8*)pic->luma.virtual_address;
+  u32 s = pic->sequence_info.pic_stride;
+  u32 w = pic->sequence_info.pic_width * pixel_width / 8;
+  u32 h = pic->sequence_info.pic_height;
+  u32 extra_bits = pic->sequence_info.pic_width * pixel_width & 7;
   unsigned char digest[16];
 
-  if (pic.picture_info.pixel_format == DEC_OUT_PIXEL_CUSTOMER1) {
+  if (pic->picture_info.pixel_format == DEC_OUT_PIXEL_CUSTOMER1) {
     /* In customized format, fill 0 of padding bytes/bits in last 128-bit burst. */
     u32 padding_bytes, padding_bits, bursts, fill_bits;
     u8 *last_burst;
-    bursts = pic.sequence_info.pic_width * pixel_width / 128;
-    fill_bits = NEXT_MULTIPLE(pic.sequence_info.pic_width * pixel_width, 128)
-                - pic.sequence_info.pic_width * pixel_width;
+    bursts = pic->sequence_info.pic_width * pixel_width / 128;
+    fill_bits = NEXT_MULTIPLE(pic->sequence_info.pic_width * pixel_width, 128)
+                - pic->sequence_info.pic_width * pixel_width;
     padding_bytes = fill_bits / 8;
     padding_bits = fill_bits & 7;
     for (u32 i = 0; i < h; i++) {
@@ -238,7 +258,7 @@ void md5perpicsink_write_pic(const void* inst, struct DecPicture pic) {
       }
       p += s;
     }
-    p = (u8*)pic.chroma.virtual_address;
+    p = (u8*)pic->chroma.virtual_address;
     for (u32 i = 0; i < h / 2; i++) {
       last_burst = p + bursts * 16;
       memset(last_burst, 0, padding_bytes);
@@ -250,13 +270,13 @@ void md5perpicsink_write_pic(const void* inst, struct DecPicture pic) {
       p += s;
     }
 
-    w = NEXT_MULTIPLE(pic.sequence_info.pic_width * pixel_width, 128) / 8;
+    w = NEXT_MULTIPLE(pic->sequence_info.pic_width * pixel_width, 128) / 8;
     extra_bits = 0;
   }
 
   MD5Init(&ctx);
 
-  p = (u8*)pic.luma.virtual_address;
+  p = (u8*)pic->luma.virtual_address;
   for (u32 i = 0; i < h; i++) {
     MD5Update(&ctx, p, w);
     if (extra_bits) {
@@ -267,7 +287,7 @@ void md5perpicsink_write_pic(const void* inst, struct DecPicture pic) {
     p += s;
   }
   /* round odd picture dimensions to next multiple of two for chroma */
-  p = (u8*)pic.chroma.virtual_address;
+  p = (u8*)pic->chroma.virtual_address;
   for (u32 i = 0; i < h / 2; i++) {
     MD5Update(&ctx, p, w);
     if (extra_bits) {
diff --git a/decoder_sw/software/test/common/md5_sink.h b/decoder_sw/software/test/common/md5_sink.h
index e472524..d08a063 100755
--- a/decoder_sw/software/test/common/md5_sink.h
+++ b/decoder_sw/software/test/common/md5_sink.h
@@ -47,12 +47,12 @@ extern "C" {
 /* MD5 sink functions for calculating sequence checksum. */
 const void* Md5sinkOpen(const char* fname);
 void Md5sinkClose(const void* inst);
-void Md5sinkWritePic(const void* inst, struct DecPicture pic);
+void Md5sinkWritePic(const void* inst, const struct DecPicture* pic);
 
 /* MD5 sink functions for calculating per picture checksums. */
 const void* md5perpicsink_open(const char* fname);
 void md5perpicsink_close(const void* inst);
-void md5perpicsink_write_pic(const void* inst, struct DecPicture pic);
+void md5perpicsink_write_pic(const void* inst, const struct DecPicture* pic);
 
 #ifdef __cplusplus
 }
diff --git a/decoder_sw/software/test/common/null_sink.c b/decoder_sw/software/test/common/null_sink.c
index 9b8372e..fd61ff1 100755
--- a/decoder_sw/software/test/common/null_sink.c
+++ b/decoder_sw/software/test/common/null_sink.c
@@ -47,7 +47,7 @@ const void* NullsinkOpen(const char* fname) {
   return malloc(sizeof(struct NullSink));
 }
 
-void NullsinkWrite(const void* inst, struct DecPicture pic) {}
+void NullsinkWrite(const void* inst, const struct DecPicture* pic) {}
 
 void NullsinkClose(const void* inst) {
   free((void*)inst);
diff --git a/decoder_sw/software/test/common/null_sink.h b/decoder_sw/software/test/common/null_sink.h
index c66dbf9..7ae4db2 100755
--- a/decoder_sw/software/test/common/null_sink.h
+++ b/decoder_sw/software/test/common/null_sink.h
@@ -41,7 +41,7 @@
 
 /* NULL yuv sink for g2 decoder testbench. */
 const void* NullsinkOpen(const char* fname);
-void NullsinkWrite(const void* inst, struct DecPicture pic);
+void NullsinkWrite(const void* inst, const struct DecPicture* pic);
 void NullsinkClose(const void* inst);
 
 #endif /* __NULL_SINK_H__ */
diff --git a/decoder_sw/software/test/common/sdl_sink.c b/decoder_sw/software/test/common/sdl_sink.c
index 424be15..0c41787 100755
--- a/decoder_sw/software/test/common/sdl_sink.c
+++ b/decoder_sw/software/test/common/sdl_sink.c
@@ -94,12 +94,12 @@ const void* SdlSinkOpen(const char* fname) {
   return calloc(sizeof(struct SDLSink), 1);
 }
 
-void SdlSinkWrite(const void* inst, struct DecPicture pic) {
+void SdlSinkWrite(const void* inst, const struct DecPicture* pic) {
   struct SDLSink* this = (struct SDLSink*)inst;
   /* Displays full decoded image size, cropped output dimensions
    * are in pic.sequence_info.crop_params. */
-  u32 w = pic.sequence_info.pic_width;
-  u32 h = pic.sequence_info.pic_height;
+  u32 w = pic->sequence_info.pic_width;
+  u32 h = pic->sequence_info.pic_height;
   if (w != this->rect.w || h != this->rect.w) {
     DeInit(this);
     this->rect.w = w;
@@ -111,13 +111,13 @@ void SdlSinkWrite(const void* inst, struct DecPicture pic) {
   UpdateCaption(this);
   this->pic_num++;
   SDL_LockYUVOverlay(this->overlay);
-  memcpy(this->overlay->pixels[0], pic.luma.virtual_address, w * h);
+  memcpy(this->overlay->pixels[0], pic->luma.virtual_address, w * h);
   /* round odd picture dimensions to next multiple of two for chroma */
   if (w & 1) w += 1;
   if (h & 1) h += 1;
-  memcpy(this->overlay->pixels[1], pic.chroma.virtual_address, w * h / 4);
+  memcpy(this->overlay->pixels[1], pic->chroma.virtual_address, w * h / 4);
   memcpy(this->overlay->pixels[2],
-         ((u8*)pic.chroma.virtual_address) + w * h / 4, w * h / 4);
+         ((u8*)pic->chroma.virtual_address) + w * h / 4, w * h / 4);
   SDL_UnlockYUVOverlay(this->overlay);
   SDL_DisplayYUVOverlay(this->overlay, &this->rect);
   SDL_Flip(this->screen);
diff --git a/decoder_sw/software/test/common/sdl_sink.h b/decoder_sw/software/test/common/sdl_sink.h
index 2db1fc4..fba0bee 100755
--- a/decoder_sw/software/test/common/sdl_sink.h
+++ b/decoder_sw/software/test/common/sdl_sink.h
@@ -41,7 +41,7 @@
 
 /* SDL yuv sink for g2 decoder testbench. */
 const void* SdlSinkOpen(const char* fname);
-void SdlSinkWrite(const void* inst, struct DecPicture pic);
+void SdlSinkWrite(const void* inst, const struct DecPicture* pic);
 void SdlSinkClose(const void* inst);
 
 #endif /* __SDL_SINK_H__ */
diff --git a/decoder_sw/software/test/common/swhw/tb_cfg.c b/decoder_sw/software/test/common/swhw/tb_cfg.c
index 953fb13..b407036 100755
--- a/decoder_sw/software/test/common/swhw/tb_cfg.c
+++ b/decoder_sw/software/test/common/swhw/tb_cfg.c
@@ -87,6 +87,7 @@ static enum ParseResult ParseBlock(FILE *fid, char *block, u32 *line,
   enum TBCfgCallbackResult cb_result;
   char blk[1024] = {0};
   char val[1024] = {0};
+  int c;
   char escape;
   i32 blk_len = 0;
   i32 val_len = 0;
@@ -95,7 +96,11 @@ static enum ParseResult ParseBlock(FILE *fid, char *block, u32 *line,
   ASSERT(callback);
 
   while (!feof(fid)) {
-    char ch = fgetc(fid); /* read char from file */
+    char ch;
+    if ((c = fgetc(fid)) != EOF) /* read char from file */
+      ch = (char)c;
+    else
+      break;
     /* Check for comments, if we are not parsing for a key value.
        If 1st comment start mark encountered, check that next
        mark is OK also. Otherwise roll back. */
@@ -105,7 +110,8 @@ static enum ParseResult ParseBlock(FILE *fid, char *block, u32 *line,
         mode = CFG_MODE_EAT_COMMENT; /* comment eating mode */
         continue;
       } else
-        fseek(fid, -1, SEEK_CUR); /* rollback */
+        if (fseek(fid, -1, SEEK_CUR) != 0) /* rollback */
+          fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     }
 
     switch (mode) {
@@ -191,17 +197,24 @@ static enum ParseResult ParseBlock(FILE *fid, char *block, u32 *line,
       if (val_len == 0 && isspace(ch)) {
         continue;
       } else if (ch == '\') {/* escape char */
-        escape = fgetc(fid);
-        switch (escape) {
-        case '\': /* back-slash */
-          val[val_len++] = '\';
-          break;
-        case '
': /* line continuation */
-          (*line)++;
-          break;
-        default:
-          fseek(fid, -1, SEEK_CUR); /* rollback */
-          break;
+        c = fgetc(fid);
+        if (c != EOF) {
+          escape = c;
+          switch (escape) {
+          case '\': /* back-slash */
+            val[val_len++] = '\';
+            break;
+          case '
': /* line continuation */
+            (*line)++;
+            break;
+          default:
+            if (fseek(fid, -1, SEEK_CUR) != 0) /* rollback */
+              fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+            break;
+          }
+        } else {
+          if (fseek(fid, -1, SEEK_CUR) != 0) /* rollback */
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         }
       } else if (ch == '
') {
         fprintf(stderr, "Unexpected line break, line %d
", *line);
@@ -236,7 +249,8 @@ static enum ParseResult ParseBlock(FILE *fid, char *block, u32 *line,
         if (fgetc(fid) == '/')
           mode = prev_mode;
         else /* Comment doesn't end, rollback */
-          fseek(fid, -1, SEEK_CUR);
+          if (fseek(fid, -1, SEEK_CUR) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
       }
       break;
     }
diff --git a/decoder_sw/software/test/common/swhw/tb_params.c b/decoder_sw/software/test/common/swhw/tb_params.c
index 70365b5..78f5153 100755
--- a/decoder_sw/software/test/common/swhw/tb_params.c
+++ b/decoder_sw/software/test/common/swhw/tb_params.c
@@ -216,7 +216,7 @@
 ------------------------------------------------------------------------------*/
 #define IMPLEMENT_PARAM_STRING(b, k, tgt)     \
   if (!strcmp(block, b) && !strcmp(key, k)) { \
-    strncpy(tgt, value, sizeof(tgt));         \
+    strncpy(tgt, value, sizeof(tgt) - 1);         \
   }
 
 /*------------------------------------------------------------------------------
diff --git a/decoder_sw/software/test/common/swhw/tb_params_g1.c b/decoder_sw/software/test/common/swhw/tb_params_g1.c
index 829f09c..3a6b116 100755
--- a/decoder_sw/software/test/common/swhw/tb_params_g1.c
+++ b/decoder_sw/software/test/common/swhw/tb_params_g1.c
@@ -180,7 +180,7 @@
 ------------------------------------------------------------------------------*/
 #define IMPLEMENT_PARAM_STRING( b, k, tgt) \
     if(!strcmp(block, b) && !strcmp(key, k)) { \
-        strncpy(tgt, value, sizeof(tgt)); \
+        strncpy(tgt, value, sizeof(tgt) - 1); \
     }
 
 /*------------------------------------------------------------------------------
diff --git a/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c b/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c
index 7fff9e0..f9b0351 100755
--- a/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c
+++ b/decoder_sw/software/test/common/swhw/tb_stream_corrupt.c
@@ -36,6 +36,7 @@
 
 #include "tb_stream_corrupt.h"
 #include <stdlib.h>
+#include <stdio.h>
 #include <time.h>
 #include <string.h>
 #include <math.h>
@@ -260,7 +261,13 @@ u32 ParseOdds(char* odds, u32* dividend, u32* divisor) {
   char* ptr;
   u32 str_len = strlen(odds);
 
-  strcpy(odds_copy, odds);
+  if(sizeof(odds_copy) - 1 < strlen(odds)) {
+    fprintf(stderr, "The parameter odds size overflows buffer size in file %s at line # %d
",
+        __FILE__, __LINE__-1);
+    return 1;
+  } else {
+    strcpy(odds_copy, odds);
+  }
   ptr = odds_copy;
 
   /* minimum is "1 : 1" */
diff --git a/decoder_sw/software/test/common/vpxfilereader.c b/decoder_sw/software/test/common/vpxfilereader.c
index 224b6ce..1fb9415 100755
--- a/decoder_sw/software/test/common/vpxfilereader.c
+++ b/decoder_sw/software/test/common/vpxfilereader.c
@@ -135,6 +135,10 @@ int VpxRdrReadFrame(VpxReaderInst inst, u8* buffer, u8 *stream[2], i32* size, u8
   }
 
   frame_header_pos = ftello(fin);
+  if (frame_header_pos == -1L) {
+    fprintf(stderr, "ftell() failed in file %s at line # %d
", __FILE__, __LINE__-2);
+    return -1;
+  }
   /* Read VPx IVF frame header */
   if (ff->format == FF_VP8 || ff->format == FF_VP9) {
     tmp = ReadIvfFrameHeader(fin, &frame_size);
@@ -149,12 +153,17 @@ int VpxRdrReadFrame(VpxReaderInst inst, u8* buffer, u8 *stream[2], i32* size, u8
     char signature[] = "WEBP";
     char format[] = "VP8 ";
     char tmp[4];
-    fseeko(fin, 8, SEEK_CUR);
-    if (!fread(tmp, sizeof(u8), 4, fin)) return -1;
+    size_t ret_code;
+    if (fseeko(fin, 8, SEEK_CUR) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    ret_code = fread(tmp, sizeof(u8), 4, fin);
+    if (ret_code == 0) return -1;
     if (strncmp(signature, tmp, 4)) return -1;
-    if (!fread(tmp, sizeof(u8), 4, fin)) return -1;
+    ret_code = fread(tmp, sizeof(u8), 4, fin);
+    if (ret_code == 0) return -1;
     if (strncmp(format, tmp, 4)) return -1;
-    if (!fread(tmp, sizeof(u8), 4, fin)) return -1;
+    ret_code = fread(tmp, sizeof(u8), 4, fin);
+    if (ret_code == 0) return -1;
     frame_size = tmp[0] + (tmp[1] << 8) + (tmp[2] << 16) + (tmp[3] << 24);
   }
 #ifdef WEBM_ENABLED
@@ -220,7 +229,8 @@ int VpxRdrReadFrame(VpxReaderInst inst, u8* buffer, u8 *stream[2], i32* size, u8
 
   if (frame_size > *size) {
     fprintf(stderr, "Frame size %d > buffer size %d
", frame_size, *size);
-    fseeko(fin, frame_header_pos, SEEK_SET);
+    if (fseeko(fin, frame_header_pos, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     *size = frame_size;
     return -1;
   }
@@ -313,14 +323,18 @@ static i32 FfCheckFormat(struct FfReader* ff) {
 #endif
   {
     if (!strncmp(id, string, 5)) {
-      fseeko(ff->file, 8, SEEK_SET);
-      if (!fread(string, 1, 4, ff->file)) return 0;
-      if (!strncmp("VP8 ", string, 4)) {
-        ff->format = FF_VP8;
-        format = BITSTREAM_VP8;
-      } else if (!strncmp("VP90", string, 4)) {
-        ff->format = FF_VP9;
-        format = BITSTREAM_VP9;
+      if (fseeko(ff->file, 8, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+      if (fread(string, 1, 4, ff->file) == 4) {
+        if (!strncmp("VP8 ", string, 4)) {
+          ff->format = FF_VP8;
+          format = BITSTREAM_VP8;
+        } else if (!strncmp("VP90", string, 4)) {
+          ff->format = FF_VP9;
+          format = BITSTREAM_VP9;
+        }
+      } else {
+        return 0;
       }
     } else if (!strncmp(id2, string, 4)) {
       ff->format = FF_WEBP;
@@ -376,9 +390,11 @@ static int FileIsWebm(struct InputCtx* input, FILE* infile,
   nestegg_video_params params;
 
   /* Get the file size for nestegg. */
-  fseeko(infile, 0, SEEK_END);
+  if (fseeko(infile, 0, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   file_size = ftello(infile);
-  fseeko(infile, 0, SEEK_SET);
+  if (fseeko(infile, 0, SEEK_SET) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
   if (nestegg_init(&input->nestegg_ctx, io, NULL, file_size)) goto fail;
 
diff --git a/decoder_sw/software/test/h264high/Makefile b/decoder_sw/software/test/h264high/Makefile
index ec76f94..9399002 100755
--- a/decoder_sw/software/test/h264high/Makefile
+++ b/decoder_sw/software/test/h264high/Makefile
@@ -91,6 +91,8 @@ CC=$(CROSS)gcc
 
 # Enable SW performance  measurement
 #CFLAGS = -DSW_PERFORMANCE
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
 
 # code does not support 64-bits!!!
 ifeq ($(shell uname -m),x86_64)
diff --git a/decoder_sw/software/test/h264high/bytestream_parser.c b/decoder_sw/software/test/h264high/bytestream_parser.c
index c2b3b29..65bbef1 100755
--- a/decoder_sw/software/test/h264high/bytestream_parser.c
+++ b/decoder_sw/software/test/h264high/bytestream_parser.c
@@ -98,11 +98,13 @@ u32 NextNALFromFile(FILE *finput, u8 *stream_buff, u32 buff_size) {
 
   if (eof) {
     /* last NAL of the stream */
-    fseeko(finput, 0, SEEK_END);
+    if (fseeko(finput, 0, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     next_nal_start = ftello(finput);
   }
 
-  fseeko(finput, nal_start, SEEK_SET);
+  if (fseeko(finput, nal_start, SEEK_SET) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
   nal_size = next_nal_start - nal_start;
 
diff --git a/decoder_sw/software/test/h264high/dectestbench.c b/decoder_sw/software/test/h264high/dectestbench.c
index ff98ced..a0f547b 100755
--- a/decoder_sw/software/test/h264high/dectestbench.c
+++ b/decoder_sw/software/test/h264high/dectestbench.c
@@ -77,7 +77,20 @@
 
 /* Debug prints */
 #undef DEBUG_PRINT
-#define DEBUG_PRINT(argv) printf argv
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+
 
 #define NUM_RETRY   100 /* how many retries after HW timeout */
 #define MAX_BUFFERS 34
@@ -532,10 +545,11 @@ int main(int argc, char **argv) {
   u32 i, tmp;
   u32 max_num_pics = 0;
   u8 *image_data;
-  long int strm_len;
+  long int pos = 0;
+  u32 strm_len;
   H264DecRet ret;
-  H264DecInput dec_input;
-  H264DecOutput dec_output;
+  H264DecInput dec_input = { 0 };
+  H264DecOutput dec_output = { 0 };
   H264DecPicture dec_picture;
 #if defined(PP_PIPELINE_ENABLED) || !defined(USE_OUTPUT_RELEASE)
   u32 pic_size = 0;
@@ -697,7 +711,13 @@ int main(int argc, char **argv) {
     if(strncmp(argv[i], "-N", 2) == 0) {
       max_num_pics = (u32) atoi(argv[i] + 2);
     } else if(strncmp(argv[i], "-O", 2) == 0) {
-      strcpy(out_file_name, argv[i] + 2);
+      /* -1 to accomodate for the null tern=minator */
+      if (sizeof(out_file_name) - 1 < strlen(argv[i] + 2)) {
+        DEBUG_PRINT(("The output file name size overflows buffer size(256)!
"));
+        return 1;
+      } else {
+        strcpy(out_file_name, argv[i] + 2);
+      }
     } else if(strcmp(argv[i], "-X") == 0) {
       disable_output_writing = 1;
     } else if(strcmp(argv[i], "-C") == 0) {
@@ -746,10 +766,10 @@ int main(int argc, char **argv) {
     else if(strcmp(argv[i], "-F") == 0) {
       g_hw_ver = 8170;
       h264_high_support = 0;
-      printf("

Force 8170 mode to HW model!!!

");
+      PRINT(("

Force 8170 mode to HW model!!!

"));
     } else if(strcmp(argv[i], "-B") == 0) {
       h264_high_support = 0;
-      printf("

Force Baseline configuration to 8190 HW model!!!

");
+      PRINT(("

Force Baseline configuration to 8190 HW model!!!

"));
     }
 #endif
     else if(strcmp(argv[i], "-Z") == 0) {
@@ -872,10 +892,10 @@ int main(int argc, char **argv) {
     else if(strcmp(argv[i], "-F") == 0) {
       g_hw_ver = 8170;
       h264_high_support = 0;
-      printf("

Force 8170 mode to HW model!!!

");
+      PRINT(("

Force 8170 mode to HW model!!!

"));
     } else if(strcmp(argv[i], "-B") == 0) {
       h264_high_support = 0;
-      printf("

Force Baseline configuration to 8190 HW model!!!

");
+      PRINT(("

Force Baseline configuration to 8190 HW model!!!

"));
     }
 #endif
     else if(strcmp(argv[i], "-M") == 0) {
@@ -1007,14 +1027,22 @@ int main(int argc, char **argv) {
   DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
", stream_packet_loss,
                tb_cfg.tb_params.stream_packet_loss));
 
+#ifdef ASIC_TRACE_SUPPORT
   {
-    remove("regdump.txt");
-    remove("mbcontrol.hex");
-    remove("intra4x4_modes.hex");
-    remove("motion_vectors.hex");
-    remove("rlc.hex");
-    remove("picture_ctrl_dec.trc");
+    if (remove("regdump.txt") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("mbcontrol.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("intra4x4_modes.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("motion_vectors.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("rlc.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("picture_ctrl_dec.trc") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
+#endif
 
 #ifdef ASIC_TRACE_SUPPORT
   /* open tracefiles */
@@ -1050,7 +1078,7 @@ int main(int argc, char **argv) {
                   dwl_inst,
 #endif
                   disable_output_reordering,
-                  TBGetDecErrorConcealment( &tb_cfg ),
+                  /*TBGetDecErrorConcealment( &tb_cfg )*/DEC_EC_NONE,
                   use_display_smoothing, flags, 0, 0, 0,
                   &dscale_cfg );
   }
@@ -1122,8 +1150,15 @@ int main(int argc, char **argv) {
   TBInitializeRandom(seed_rnd);
 
   /* check size of the input file -> length of the stream in bytes */
-  fseek(finput, 0L, SEEK_END);
-  strm_len = ftell(finput);
+  if (fseek(finput, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+  pos = ftell(finput);
+  if (pos == -1L) {
+    fprintf(stderr, "ftell() failed in file %s at line # %d
", __FILE__, __LINE__-2);
+    goto end;
+  } else {
+    strm_len = (u32)pos;
+  }
   rewind(finput);
 
   dec_input.skip_non_reference = skip_non_reference;
@@ -1143,13 +1178,13 @@ int main(int argc, char **argv) {
 
     /* sets the stream length to random value */
     if(stream_truncate && !packetize && !nal_unit_stream) {
-      DEBUG_PRINT(("strm_len %ld
", strm_len));
+      DEBUG_PRINT(("strm_len %d
", strm_len));
       ret = TBRandomizeU32((u32 *)&strm_len);
       if(ret != 0) {
         DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
         goto end;
       }
-      DEBUG_PRINT(("Randomized strm_len %ld
", strm_len));
+      DEBUG_PRINT(("Randomized strm_len %d
", strm_len));
     }
 
     /* NOTE: The DWL should not be used outside decoder SW.
@@ -1247,7 +1282,8 @@ int main(int argc, char **argv) {
           DEBUG_PRINT(("STREAM WILL END
"));
           stream_will_end = 1;
         } else {
-          fseek(findex, -2, SEEK_CUR);
+          if (fseek(findex, -2, SEEK_CUR) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         }
       }
 
@@ -1445,8 +1481,8 @@ int main(int argc, char **argv) {
       save_flag = 0;
       /* Set a flag to indicate that headers are ready */
       hdrs_rdy = 1;
-      printf("sizeof(dpb) = %ld
", sizeof(dpbStorage_t));
-      printf("offset of dpbs = %ld
", (long)((u8 *)((decContainer_t *) dec_inst)->storage.dpbs-(u8 *)&(((decContainer_t *) dec_inst)->storage)));
+      PRINT(("sizeof(dpb) = %ld
", sizeof(dpbStorage_t)));
+      PRINT(("offset of dpbs = %ld
", (long)((u8 *)((decContainer_t *) dec_inst)->storage.dpbs-(u8 *)&(((decContainer_t *) dec_inst)->storage))));
       TBSetRefbuMemModel( &tb_cfg,
                           ((decContainer_t *) dec_inst)->h264_regs,
                           &((decContainer_t *) dec_inst)->ref_buffer_ctrl );
@@ -1476,12 +1512,13 @@ int main(int argc, char **argv) {
       DEBUG_PRINT(("DPB mode   = %d
", dec_info.dpb_mode));
       DEBUG_PRINT(("Pictures in DPB = %d
", dec_info.pic_buff_size));
       DEBUG_PRINT(("Pictures in Multibuffer PP = %d
", dec_info.multi_buff_pp_size));
-      if(dec_info.output_format == H264DEC_TILED_YUV420)
+      if(dec_info.output_format == H264DEC_TILED_YUV420) {
         DEBUG_PRINT(("Output format = H264DEC_TILED_YUV420
"));
-      else if(dec_info.output_format == H264DEC_YUV400)
+      } else if(dec_info.output_format == H264DEC_YUV400) {
         DEBUG_PRINT(("Output format = H264DEC_YUV400
"));
-      else
+      } else {
         DEBUG_PRINT(("Output format = H264DEC_SEMIPLANAR_YUV420
"));
+      }
       H264DecConfig dec_cfg;
       dec_cfg.dpb_flags = 0;
       if( tiled_output )   dec_cfg.dpb_flags |= DEC_REF_FRM_TILED_DEFAULT;
@@ -1589,7 +1626,7 @@ int main(int argc, char **argv) {
       if(pic_decode_number == max_num_pics)
         dec_input.data_len = 0;
 
-      printf("DECODED PICTURE %d
", pic_decode_number);
+      DEBUG_PRINT(("DECODED PICTURE %d
", pic_decode_number));
       /* Increment decoding number for every decoded picture */
       pic_decode_number++;
 
@@ -1901,7 +1938,7 @@ int main(int argc, char **argv) {
 
         tmp = ftell(finput);
         dec_input.data_len = NextPacket((u8 **) (&dec_input.stream));
-        printf("NextPacket = %d at %d
", dec_input.data_len, tmp);
+        PRINT(("NextPacket = %d at %d
", dec_input.data_len, tmp));
 
         dec_input.stream_bus_address +=
           (addr_t) (dec_input.stream - ptmpstream);
@@ -2090,14 +2127,15 @@ end:
   if(NULL == foutput) {
     strm_len = 0;
   } else {
-    fseek(foutput, 0L, SEEK_END);
+    if (fseek(foutput, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     strm_len = (u32) ftell(foutput);
     fclose(foutput);
   }
 
   DEBUG_PRINT(("Output file: %s
", out_file_name));
 
-  DEBUG_PRINT(("OUTPUT_SIZE %ld
", strm_len));
+  DEBUG_PRINT(("OUTPUT_SIZE %d
", strm_len));
 
   FINALIZE_SW_PERFORMANCE;
 
@@ -2151,7 +2189,12 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 pic_size,
   /* foutput is global file pointer */
   if(*fout == NULL) {
     if (view && mvc_separate_views) {
-      strcpy(alt_file_name, filename);
+      if (sizeof(alt_file_name) - 1 < strlen(filename)) {
+        DEBUG_PRINT(("TOO LONG FILE NAME!
"));
+        return;
+      }  else {
+        strcpy(alt_file_name, filename);
+      }
       if (strlen(alt_file_name) >= 256 - 12) {
         DEBUG_PRINT(("TOO LONG FILE NAME!
"));
         return;
@@ -2359,7 +2402,8 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 pic_size,
 
   if(raster_scan)
     free(raster_scan);
-
+  if(pic_big_endian)
+    free(pic_big_endian);
 
 }
 
@@ -2681,7 +2725,8 @@ u32 NextPacketFromFile(u8 ** p_strm) {
     /* check position */
     f_pos = ftell(finput);
     if(f_pos != cur_index) {
-      fseeko64(finput, cur_index - f_pos, SEEK_CUR);
+      if (fseeko64(finput, cur_index - f_pos, SEEK_CUR) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     }
 
     if(nal_unit_stream) {
@@ -2864,53 +2909,71 @@ void H264DecTrace(const char *string) {
 ------------------------------------------------------------------------------*/
 static void printDecodeReturn(i32 retval) {
 
-  DEBUG_PRINT(("TB: H264DecDecode returned: "));
   switch (retval) {
 
   case H264DEC_OK:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_OK
"));
     break;
   case H264DEC_NONREF_PIC_SKIPPED:
-    DEBUG_PRINT(("H264DEC_NONREF_PIC_SKIPPED
"));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("H264DEC_NONREF_PIC_SKIPPED
"));
     break;
   case H264DEC_STRM_PROCESSED:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_STRM_PROCESSED
"));
     break;
   case H264DEC_BUF_EMPTY:
-    DEBUG_PRINT(("H264DEC_BUF_EMPTY
"));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("H264DEC_BUF_EMPTY
"));
     break;
   case H264DEC_NO_DECODING_BUFFER:
-    DEBUG_PRINT((""));//DEBUG_PRINT(("H264DEC_NO_DECODING_BUFFER
"));
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
+    DEBUG_PRINT(("H264DEC_NO_DECODING_BUFFER
"));
     break;
   case H264DEC_PIC_RDY:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_PIC_RDY
"));
     break;
   case H264DEC_PIC_DECODED:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_PIC_DECODED
"));
     break;
   case H264DEC_PIC_CONSUMED:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_PIC_CONSUMED
"));
     break;
   case H264DEC_ADVANCED_TOOLS:
-    DEBUG_PRINT(("H264DEC_ADVANCED_TOOLS
"));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("H264DEC_ADVANCED_TOOLS
"));
     break;
   case H264DEC_HDRS_RDY:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_HDRS_RDY
"));
     break;
   case H264DEC_STREAM_NOT_SUPPORTED:
-    DEBUG_PRINT(("H264DEC_STREAM_NOT_SUPPORTED
"));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("H264DEC_STREAM_NOT_SUPPORTED
"));
     break;
   case H264DEC_DWL_ERROR:
-    DEBUG_PRINT(("H264DEC_DWL_ERROR
"));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("H264DEC_DWL_ERROR
"));
     break;
   case H264DEC_HW_TIMEOUT:
-    DEBUG_PRINT(("H264DEC_HW_TIMEOUT
"));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("H264DEC_HW_TIMEOUT
"));
     break;
   case H264DEC_PENDING_FLUSH:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
     DEBUG_PRINT(("H264DEC_PENDING_FLUSH
"));
     break;
+  case H264DEC_FIELD_DECODED:
+    DEBUG_PRINT(("TB: H264DecDecode returned: "));
+    DEBUG_PRINT(("H264DEC_FIELD_DECODED
"));
+    break;
   default:
-    DEBUG_PRINT(("Other %d
", retval));
+    PRINT(("TB: H264DecDecode returned: "));
+    PRINT(("Other %d
", retval));
     break;
   }
 }
@@ -2923,34 +2986,34 @@ static void printDecodeReturn(i32 retval) {
 
 ------------------------------------------------------------------------------*/
 void printH264PicCodingType(u32 *pic_type) {
-  printf("Coding type ");
+  DEBUG_PRINT(("Coding type "));
   switch (pic_type[0]) {
   case DEC_PIC_TYPE_I:
-    printf("[I:");
+    DEBUG_PRINT(("[I:"));
     break;
   case DEC_PIC_TYPE_P:
-    printf("[P:");
+    DEBUG_PRINT(("[P:"));
     break;
   case DEC_PIC_TYPE_B:
-    printf("[B:");
+    DEBUG_PRINT(("[B:"));
     break;
   default:
-    printf("[Other %d:", pic_type[0]);
+    DEBUG_PRINT(("[Other %d:", pic_type[0]));
     break;
   }
 
   switch (pic_type[1]) {
   case DEC_PIC_TYPE_I:
-    printf("I]");
+    DEBUG_PRINT(("I]"));
     break;
   case DEC_PIC_TYPE_P:
-    printf("P]");
+    DEBUG_PRINT(("P]"));
     break;
   case DEC_PIC_TYPE_B:
-    printf("B]");
+    DEBUG_PRINT(("B]"));
     break;
   default:
-    printf("Other %d]", pic_type[1]);
+    DEBUG_PRINT(("Other %d]", pic_type[1]));
     break;
   }
 }
@@ -2960,7 +3023,8 @@ u32 fillBuffer(const u8 *stream) {
   u32 data_len = 0;
   int ret;
   if(cur_index != ftell(finput)) {
-    fseeko64(finput, cur_index, SEEK_SET);
+    if (fseeko64(finput, cur_index, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
 
   /* read next index */
diff --git a/decoder_sw/software/test/h264high/mcdectestbench.c b/decoder_sw/software/test/h264high/mcdectestbench.c
index e0af84d..5c12495 100755
--- a/decoder_sw/software/test/h264high/mcdectestbench.c
+++ b/decoder_sw/software/test/h264high/mcdectestbench.c
@@ -848,14 +848,22 @@ int main(int argc, char **argv) {
   DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
", stream_packet_loss,
                tb_cfg.tb_params.stream_packet_loss));
 
+#ifdef ASIC_TRACE_SUPPORT
   {
-    remove("regdump.txt");
-    remove("mbcontrol.hex");
-    remove("intra4x4_modes.hex");
-    remove("motion_vectors.hex");
-    remove("rlc.hex");
-    remove("picture_ctrl_dec.trc");
+    if (remove("regdump.txt") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("mbcontrol.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("intra4x4_modes.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("motion_vectors.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("rlc.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("picture_ctrl_dec.trc") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
+#endif
 
 #ifdef ASIC_TRACE_SUPPORT
   /* open tracefiles */
@@ -1342,7 +1350,8 @@ end:
   if(NULL == foutput) {
     strm_len = 0;
   } else {
-    fseek(foutput, 0L, SEEK_END);
+    if (fseek(foutput, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     strm_len = (u32) ftell(foutput);
     fclose(foutput);
   }
diff --git a/decoder_sw/software/test/hevc/dectestbench.c b/decoder_sw/software/test/hevc/dectestbench.c
index 3140c47..17ae1a9 100755
--- a/decoder_sw/software/test/hevc/dectestbench.c
+++ b/decoder_sw/software/test/hevc/dectestbench.c
@@ -787,14 +787,22 @@ int main(int argc, char **argv) {
   DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
", stream_packet_loss,
                tb_cfg.tb_params.stream_packet_loss));
 
+#ifdef ASIC_TRACE_SUPPORT
   {
-    remove("regdump.txt");
-    remove("mbcontrol.hex");
-    remove("intra4x4_modes.hex");
-    remove("motion_vectors.hex");
-    remove("rlc.hex");
-    remove("picture_ctrl_dec.trc");
+    if (remove("regdump.txt") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("mbcontrol.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("intra4x4_modes.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("motion_vectors.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("rlc.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("picture_ctrl_dec.trc") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
+#endif
 
   if (trace_target) tb_cfg.tb_params.extra_cu_ctrl_eof = 1;
 
@@ -936,7 +944,8 @@ int main(int argc, char **argv) {
   TBInitializeRandom(seed_rnd);
 
   /* check size of the input file -> length of the stream in bytes */
-  fseek(finput, 0L, SEEK_END);
+  if (fseek(finput, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   strm_len = ftell(finput);
   rewind(finput);
 
@@ -1040,7 +1049,8 @@ int main(int argc, char **argv) {
           DEBUG_PRINT(("STREAM WILL END
"));
           stream_will_end = 1;
         } else {
-          fseek(findex, -2, SEEK_CUR);
+          if (fseek(findex, -2, SEEK_CUR) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         }
       }
 
@@ -1428,7 +1438,8 @@ end:
 
   strm_len = 0;
   if (foutput) {
-    fseek(foutput, 0L, SEEK_END);
+    if (fseek(foutput, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     strm_len = (u32)ftell(foutput);
     fclose(foutput);
   }
@@ -2131,7 +2142,8 @@ u32 NextPacketFromFile(u8 **strm) {
     /* check position */
     f_pos = ftell(finput);
     if (f_pos != cur_index) {
-      fseeko64(finput, cur_index - f_pos, SEEK_CUR);
+      if (fseeko64(finput, cur_index - f_pos, SEEK_CUR) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     }
 
     if (nal_unit_stream) {
@@ -2305,7 +2317,8 @@ u32 fill_buffer(u8 *stream) {
   u32 data_len = 0;
 
   if (cur_index != ftell(finput)) {
-    fseeko64(finput, cur_index, SEEK_SET);
+    if (fseeko64(finput, cur_index, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
 
   /* read next index */
diff --git a/decoder_sw/software/test/jpeg/dectestbench.c b/decoder_sw/software/test/jpeg/dectestbench.c
index 87b689e..a3bae00 100755
--- a/decoder_sw/software/test/jpeg/dectestbench.c
+++ b/decoder_sw/software/test/jpeg/dectestbench.c
@@ -484,17 +484,28 @@ int main(int argc, char *argv[]) {
   printf("TB Stream Bit Swap %d; odds %s
", stream_bit_swap,
          tb_cfg.tb_params.stream_bit_swap);
 
+#ifdef ASIC_TRACE_SUPPORT
   {
-    remove("output.hex");
-    remove("registers.hex");
-    remove("picture_ctrl.hex");
-    remove("picture_ctrl.trc");
-    remove("jpeg_tables.hex");
-    remove("out.yuv");
-    remove("out_chroma.yuv");
-    remove("out_tn.yuv");
-    remove("out_chroma_tn.yuv");
+    if (remove("output.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("registers.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("picture_ctrl.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("picture_ctrl.trc") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("jpeg_tables.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("out.yuv") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("out_chroma.yuv") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("out_tn.yuv") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("out_chroma_tn.yuv") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
+#endif
 
   /* after thumnails done ==> decode full images */
 start_full_decode:
@@ -590,7 +601,8 @@ reallocate_input_buffer:
 #endif
 
   /* file i/o pointer to full */
-  fseek(f_in, 0L, SEEK_END);
+  if (fseek(f_in, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   len = ftell(f_in);
   rewind(f_in);
 
@@ -663,7 +675,8 @@ reallocate_input_buffer:
 #endif
 
   /* file i/o pointer to full */
-  fseek(f_in, 0L, SEEK_END);
+  if (fseek(f_in, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   len = ftell(f_in);
   rewind(f_in);
 
@@ -726,7 +739,8 @@ reallocate_input_buffer:
 
   /* file i/o pointer to full */
   if(prev_ret == JPEGDEC_FRAME_READY)
-    fseek(f_in, stream_seek_len, SEEK_SET);
+    if (fseek(f_in, stream_seek_len, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
   /* read input stream from file to buffer and close input file */
   ret = fread(byte_strm_start, sizeof(u8), len, f_in);
@@ -1153,7 +1167,8 @@ decode:
 #endif
 
       /* file i/o pointer to full */
-      fseek(f_in, stream_seek_len, SEEK_SET);
+      if (fseek(f_in, stream_seek_len, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
       /* read input stream from file to buffer and close input file */
       ret = fread(byte_strm_start, sizeof(u8), len, f_in);
       fclose(f_in);
@@ -1391,7 +1406,8 @@ error:
 #endif
 
         /* file i/o pointer to full */
-        fseek(f_in, stream_seek_len, SEEK_SET);
+        if (fseek(f_in, stream_seek_len, SEEK_SET) != 0)
+          fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         /* read input stream from file to buffer and close input file */
         ret = fread(byte_strm_start, sizeof(u8), len, f_in);
         fclose(f_in);
@@ -1446,7 +1462,8 @@ error:
 #endif
 
     /* file i/o pointer to full */
-    fseek(f_in, stream_seek_len, SEEK_SET);
+    if (fseek(f_in, stream_seek_len, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     /* read input stream from file to buffer and close input file */
     ret = fread(byte_strm_start, sizeof(u8), len, f_in);
     fclose(f_in);
@@ -1875,6 +1892,7 @@ void WriteFullOutput(u32 pic_mode) {
   FILE *foutput = NULL;
   u8 *p_yuv_out_chroma = NULL;
   FILE *f_input_chroma = NULL;
+  long int pos = 0;
   u32 length = 0;
   u32 chroma_len = 0;
   int ret;
@@ -1901,8 +1919,15 @@ void WriteFullOutput(u32 pic_mode) {
     }
 
     /* file i/o pointer to full */
-    fseek(f_input_chroma, 0L, SEEK_END);
-    length = ftell(f_input_chroma);
+    if (fseek(f_input_chroma, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    pos = ftell(f_input_chroma);
+    if (pos == -1L) {
+      fprintf(stderr, "ftell() failed in file %s at line # %d
", __FILE__, __LINE__-2);
+      exit(-1);
+    } else {
+      length = (u32)pos;
+    }
     rewind(f_input_chroma);
 
     /* check length */
@@ -1912,8 +1937,7 @@ void WriteFullOutput(u32 pic_mode) {
 
     if (!p_yuv_out_chroma) {
       fprintf(stdout, "UNABLE TO MALLOC OUTPUT BUFFER
");
-      if (f_input_chroma) 
-        fclose(f_input_chroma);
+      fclose(f_input_chroma);
       return;
     }
     /* read output stream from file to buffer and close input file */
diff --git a/decoder_sw/software/test/mpeg2/Makefile b/decoder_sw/software/test/mpeg2/Makefile
index 2fbefd4..2967ab1 100755
--- a/decoder_sw/software/test/mpeg2/Makefile
+++ b/decoder_sw/software/test/mpeg2/Makefile
@@ -67,6 +67,9 @@ TBLIB = libtbcommon.a
 MODLIB = lib8170hw.a
 TARGET_ENV=
 
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
+
 ifeq ($(USE_MD5SUM), y)
         MD5SUM = -DMD5SUM
 endif
diff --git a/decoder_sw/software/test/mpeg2/mpeg2dectest.c b/decoder_sw/software/test/mpeg2/mpeg2dectest.c
index 5c37db6..1ef9b8f 100755
--- a/decoder_sw/software/test/mpeg2/mpeg2dectest.c
+++ b/decoder_sw/software/test/mpeg2/mpeg2dectest.c
@@ -87,6 +87,21 @@
 #define MPEG2_NUM_BUFFERS 3 /* number of output buffers for ext alloc */
 #define ASSERT(expr) assert(expr)
 
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+
 /* Function prototypes */
 
 void printTimeCode(Mpeg2DecTime * timecode);
@@ -238,10 +253,10 @@ static void *AddBufferThread(void *arg) {
 
 void ReleaseExtBuffers() {
   int i;
-  printf("Releasing %d external frame buffers
", num_buffers);
+  PRINT(("Releasing %d external frame buffers
", num_buffers));
   pthread_mutex_lock(&ext_buffer_contro);
   for(i=0; i<num_buffers; i++) {
-    printf("Freeing buffer %p
", ext_buffers[i].virtual_address);
+    PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
     if (pp_enabled)
       DWLFreeLinear(dwl_inst, &ext_buffers[i]);
     else
@@ -345,9 +360,9 @@ static void* mpeg2_output_thread(void* arg) {
         /* print result */
         decNextPictureRet(ret);
         /* printf info */
-        printf("PIC %d, %s", DecPic.pic_id,
+        DEBUG_PRINT(("PIC %d, %s", DecPic.pic_id,
                DecPic.key_picture ? "key picture,    " :
-               "non key picture,");
+               "non key picture,"));
 
         if(DecPic.field_picture) {
           /* pic coding type */
@@ -355,19 +370,19 @@ static void* mpeg2_output_thread(void* arg) {
             printMpeg2PicCodingType(DecPic.pic_coding_type[0]);
           else
             printMpeg2PicCodingType(DecPic.pic_coding_type[1]);
-          printf(" %s ", DecPic.top_field ?
-                 "top field.   " : "bottom field.");
+          DEBUG_PRINT((" %s ", DecPic.top_field ?
+                 "top field.   " : "bottom field."));
         } else {
           printMpeg2PicCodingType(DecPic.pic_coding_type[0]);
-          printf(" frame picture. ");
+          DEBUG_PRINT((" frame picture. "));
         }
 
         printTimeCode(&(DecPic.time_code));
         if(DecPic.number_of_err_mbs) {
-          printf(", %d/%d error mbs
",
+          DEBUG_PRINT((", %d/%d error mbs
",
                  DecPic.number_of_err_mbs,
                  (DecPic.frame_width >> 4) *
-                 (DecPic.frame_height >> 4));
+                 (DecPic.frame_height >> 4)));
           cumulative_error_mbs += DecPic.number_of_err_mbs;
         }
 
@@ -376,7 +391,7 @@ static void* mpeg2_output_thread(void* arg) {
 
         pic_size = DecPic.frame_width * DecPic.frame_height * 3 / 2;
 
-        printf("DecPic.first_field %d
", DecPic.first_field);
+        DEBUG_PRINT(("DecPic.first_field %d
", DecPic.first_field));
         WriteOutput(out_file_name, out_file_name_tiled, image_data,
                     pic_display_number - 1,
                     ((DecPic.frame_width + 15) & ~15),
@@ -541,46 +556,50 @@ int main(int argc, char **argv) {
 #ifndef PP_PIPELINE_ENABLED
   if(argc < 2) {
 
-    printf("
8170 MPEG-2 Decoder Testbench

");
-    printf("USAGE:
%s [options] stream.mpeg2
", argv[0]);
-    printf("-Ooutfile write output to \"outfile\" (default out.yuv)
");
-    printf("-Nn to decode only first n frames of the stream
");
-    printf("-X to not to write output picture
");
-    printf("-Bn to use n frame buffers in decoder
");
-    printf("-E use tiled reference frame format.
");
-    printf("-G convert tiled output pictures to raster scan
");
-    printf("-Sfile.hex stream control trace file
");
+    PRINT(("
8170 MPEG-2 Decoder Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.mpeg2
", argv[0]));
+    PRINT(("-Ooutfile write output to \"outfile\" (default out.yuv)
"));
+    PRINT(("-Nn to decode only first n frames of the stream
"));
+    PRINT(("-X to not to write output picture
"));
+    PRINT(("-Bn to use n frame buffers in decoder
"));
+    PRINT(("-E use tiled reference frame format.
"));
+    PRINT(("-G convert tiled output pictures to raster scan
"));
+    PRINT(("-Sfile.hex stream control trace file
"));
 #if defined(ASIC_TRACE_SUPPORT) || defined(SYSTEM_VERIFICATION)
-    printf("-R use reference decoder IDCT (sw/sw integration only)
");
-#endif
-    printf("-W whole stream mode - give stream to decoder in one chunk
");
-    printf("-I save index file
");
-    printf
-    ("-T write tiled output (out_tiled.yuv) by converting raster scan output
");
-    printf("-Y Write output as Interlaced Fields (instead of Frames).
");
-    printf
-    ("-C crop output picture to real picture dimensions (only planar)
");
-    printf("-Q Skip decoding non-reference pictures.
");
-    printf("-Z output pictures using Mpeg2DecPeek() function
");
-    printf("--separate-fields-in-dpb DPB stores interlaced content"\
-           " as fields (default: frames)
");
-    printf("--output-frame-dpb Convert output to frame mode even if"\
-           " field DPB mode used
");
+    PRINT(("-R use reference decoder IDCT (sw/sw integration only)
"));
+#endif
+    PRINT(("-W whole stream mode - give stream to decoder in one chunk
"));
+    PRINT(("-I save index file
"));
+    PRINT
+    (("-T write tiled output (out_tiled.yuv) by converting raster scan output
"));
+    PRINT(("-Y Write output as Interlaced Fields (instead of Frames).
"));
+    PRINT
+    (("-C crop output picture to real picture dimensions (only planar)
"));
+    PRINT(("-Q Skip decoding non-reference pictures.
"));
+    PRINT(("-Z output pictures using Mpeg2DecPeek() function
"));
+    PRINT(("--separate-fields-in-dpb DPB stores interlaced content"\
+           " as fields (default: frames)
"));
+    PRINT(("--output-frame-dpb Convert output to frame mode even if"\
+           " field DPB mode used
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("-A add extra external buffer randomly
");
+    PRINT(("-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("-a add extra external buffer in ouput thread
");
+    PRINT(("-a add extra external buffer in ouput thread
"));
 #endif
 #endif
     printMpeg2Version();
     exit(100);
   }
 
-  remove("pp_out.yuv");
   max_num_frames = 0;
   for(i = 1; i < argc - 1; i++) {
     if(strncmp(argv[i], "-O", 2) == 0) {
-      strcpy(out_file_name, argv[i] + 2);
+      if (sizeof(out_file_name) - 1 < strlen(argv[i] + 2)) {
+        PRINT(("The output file name size overflows buffer size(256)!
"));
+        return 1;
+      } else {
+        strcpy(out_file_name, argv[i] + 2);
+      }
     } else if(strncmp(argv[i], "-N", 2) == 0) {
       max_num_frames = atoi(argv[i] + 2);
     } else if (strncmp(argv[i], "-E", 2) == 0)
@@ -642,11 +661,11 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
-      printf("UNKNOWN PARAMETER: %s
", argv[i]);
+      PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
       return 1;
     }
   }
@@ -655,32 +674,31 @@ int main(int argc, char **argv) {
   /* open data file */
   f_in = fopen(argv[argc - 1], "rb");
   if(f_in == NULL) {
-    printf("Unable to open input file %s
", argv[argc - 1]);
+    PRINT(("Unable to open input file %s
", argv[argc - 1]));
     exit(100);
   }
 #else
   if(argc < 3) {
-    printf("
Mpeg-2 Decoder PP Pipelined Testbench

");
-    printf("USAGE:
%s [options] stream.mpeg2 pp.cfg
", argv[0]);
-    printf("-Nn to decode only first n vops of the stream
");
-    printf("-E use tiled reference frame format.
");
-    printf("-Bn to use n frame buffers in decoder
");
-    printf("-X to not to write output picture
");
-    printf("-W whole stream mode - give stream to decoder in one chunk
");
-    printf("-I save index file
");
-    printf("-Q Skip decoding non-reference pictures.
");
-    printf("--separate-fields-in-dpb DPB stores interlaced content"\
-           " as fields (default: frames)
");
+    PRINT(("
Mpeg-2 Decoder PP Pipelined Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.mpeg2 pp.cfg
", argv[0]));
+    PRINT(("-Nn to decode only first n vops of the stream
"));
+    PRINT(("-E use tiled reference frame format.
"));
+    PRINT(("-Bn to use n frame buffers in decoder
"));
+    PRINT(("-X to not to write output picture
"));
+    PRINT(("-W whole stream mode - give stream to decoder in one chunk
"));
+    PRINT(("-I save index file
"));
+    PRINT(("-Q Skip decoding non-reference pictures.
"));
+    PRINT(("--separate-fields-in-dpb DPB stores interlaced content"\
+           " as fields (default: frames)
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("-A add extra external buffer randomly
");
+    PRINT(("-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("-a add extra external buffer in output thread
");
+    PRINT(("-a add extra external buffer in output thread
"));
 #endif
 #endif
     exit(100);
   }
 
-  remove("pp_out.yuv");
   max_num_frames = 0;
   /* read cmdl parameters */
   for(i = 1; i < argc - 2; i++) {
@@ -725,7 +743,7 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
@@ -738,7 +756,7 @@ int main(int argc, char **argv) {
   /* open data file */
   f_in = fopen(argv[argc - 2], "rb");
   if(f_in == NULL) {
-    printf("Unable to open input file %s
", argv[argc - 2]);
+    PRINT(("Unable to open input file %s
", argv[argc - 2]));
     exit(100);
   }
 
@@ -756,7 +774,7 @@ int main(int argc, char **argv) {
   if(save_index) {
     findex = fopen("stream.cfg", "w");
     if(findex == NULL) {
-      printf("UNABLE TO OPEN INDEX FILE
");
+      PRINT(("UNABLE TO OPEN INDEX FILE
"));
       if (f_in)
         fclose(f_in);
       return -1;
@@ -772,8 +790,8 @@ int main(int argc, char **argv) {
   TBSetDefaultCfg(&tb_cfg);
   f_tbcfg = fopen("tb.cfg", "r");
   if(f_tbcfg == NULL) {
-    printf("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
");
-    printf("USING DEFAULT CONFIGURATION
");
+    PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if(TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
@@ -795,13 +813,13 @@ int main(int argc, char **argv) {
       printf("Decoder Output Picture Endian forced to %d
",
              output_picture_endian);
   #endif*/
-  printf("Decoder Clock Gating %d
", clock_gating);
-  printf("Decoder Data Discard %d
", data_discard);
-  printf("Decoder Latency Compensation %d
", latency_comp);
-  printf("Decoder Output Picture Endian %d
", output_picture_endian);
-  printf("Decoder Bus Burst Length %d
", bus_burst_length);
-  printf("Decoder Asic Service Priority %d
", asic_service_priority);
-  printf("Decoder Output Format %d
", output_format);
+  PRINT(("Decoder Clock Gating %d
", clock_gating));
+  PRINT(("Decoder Data Discard %d
", data_discard));
+  PRINT(("Decoder Latency Compensation %d
", latency_comp));
+  PRINT(("Decoder Output Picture Endian %d
", output_picture_endian));
+  PRINT(("Decoder Bus Burst Length %d
", bus_burst_length));
+  PRINT(("Decoder Asic Service Priority %d
", asic_service_priority));
+  PRINT(("Decoder Output Format %d
", output_format));
 
   seed_rnd = tb_cfg.tb_params.seed_rnd;
   stream_header_corrupt = TBGetTBStreamHeaderCorrupt(&tb_cfg);
@@ -821,14 +839,14 @@ int main(int argc, char **argv) {
     stream_packet_loss = 0;
   }
   disable_resync = TBGetTBPacketByPacket(&tb_cfg);
-  printf("TB Slice by slice %d
", disable_resync);
-  printf("TB Seed Rnd %d
", seed_rnd);
-  printf("TB Stream Truncate %d
", stream_truncate);
-  printf("TB Stream Header Corrupt %d
", stream_header_corrupt);
-  printf("TB Stream Bit Swap %d; odds %s
",
-         stream_bit_swap, tb_cfg.tb_params.stream_bit_swap);
-  printf("TB Stream Packet Loss %d; odds %s
",
-         stream_packet_loss, tb_cfg.tb_params.stream_packet_loss);
+  DEBUG_PRINT(("TB Slice by slice %d
", disable_resync));
+  DEBUG_PRINT(("TB Seed Rnd %d
", seed_rnd));
+  DEBUG_PRINT(("TB Stream Truncate %d
", stream_truncate));
+  DEBUG_PRINT(("TB Stream Header Corrupt %d
", stream_header_corrupt));
+  DEBUG_PRINT(("TB Stream Bit Swap %d; odds %s
",
+         stream_bit_swap, tb_cfg.tb_params.stream_bit_swap));
+  DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
",
+         stream_packet_loss, tb_cfg.tb_params.stream_packet_loss));
 
   /* allocate memory for stream buffer. if unsuccessful -> exit */
   stream_mem.virtual_address = NULL;
@@ -842,25 +860,26 @@ int main(int argc, char **argv) {
   TBInitializeRandom(seed_rnd);
 
   /* check size of the input file -> length of the stream in bytes */
-  fseek(f_in, 0L, SEEK_END);
+  if (fseek(f_in, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   stream_size = (u32) ftell(f_in);
   rewind(f_in);
 
   /* sets the stream length to random value */
   if(stream_truncate && !disable_resync) {
-    printf("stream_size %d
", stream_size);
+    PRINT(("stream_size %d
", stream_size));
     ret = TBRandomizeU32(&stream_size);
     if(ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return -1;
     }
-    printf("Randomized stream_size %d
", stream_size);
+    PRINT(("Randomized stream_size %d
", stream_size));
   }
 
 #ifdef ASIC_TRACE_SUPPORT
   tmp = openTraceFiles();
   if(!tmp) {
-    printf("UNABLE TO OPEN TRACE FILES(S)
");
+    PRINT(("UNABLE TO OPEN TRACE FILES(S)
"));
   }
 #endif
 
@@ -909,7 +928,7 @@ int main(int argc, char **argv) {
 #endif
 
   if(ret != MPEG2DEC_OK) {
-    printf("Could not initialize decoder
");
+    PRINT(("Could not initialize decoder
"));
     goto end2;
   }
 
@@ -918,7 +937,7 @@ int main(int argc, char **argv) {
 
   if(DWLMallocLinear(((DecContainer *) decoder)->dwl,
                      STREAMBUFFER_BLOCKSIZE, &stream_mem) != DWL_OK) {
-    printf(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
     goto end2;
   }
 
@@ -934,7 +953,7 @@ int main(int argc, char **argv) {
   DecIn.stream_bus_address = stream_mem.bus_address;
 
   if(byte_strm_start == NULL) {
-    printf(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
     goto end2;
   }
 
@@ -985,15 +1004,16 @@ int main(int argc, char **argv) {
   DecIn.data_len = stream_len;
   DecOut.data_left = 0;
 
-  printf("Start decoding
");
+  PRINT(("Start decoding
"));
   do {
-    printf("DecIn.data_len %d
", DecIn.data_len);
+    DEBUG_PRINT(("DecIn.data_len %d
", DecIn.data_len));
     DecIn.pic_id = pic_id;
     if(ret != MPEG2DEC_STRM_PROCESSED &&
         ret != MPEG2DEC_BUF_EMPTY &&
         ret != MPEG2DEC_NO_DECODING_BUFFER &&
-        ret != MPEG2DEC_NONREF_PIC_SKIPPED )
-      printf("
Starting to decode picture ID %d
", pic_id);
+        ret != MPEG2DEC_NONREF_PIC_SKIPPED ) {
+      DEBUG_PRINT(("
Starting to decode picture ID %d
", pic_id));
+    }
 
     /* If enabled, break the stream */
     if(stream_bit_swap) {
@@ -1005,12 +1025,12 @@ int main(int argc, char **argv) {
                                            tb_cfg.tb_params.
                                            stream_bit_swap);
           if(ret != 0) {
-            printf("RANDOM STREAM ERROR FAILED
");
+            PRINT(("RANDOM STREAM ERROR FAILED
"));
             goto end2;
           }
 
           corrupted_bytes = DecIn.data_len;
-          printf("corrupted_bytes %d
", corrupted_bytes);
+          PRINT(("corrupted_bytes %d
", corrupted_bytes));
         }
       }
     }
@@ -1051,8 +1071,9 @@ int main(int argc, char **argv) {
       outp_byte_size =
         (Decinfo.frame_width * Decinfo.frame_height * 3) >> 1;
 
-      if (Decinfo.interlaced_sequence)
-        printf("INTERLACED SEQUENCE
");
+      if (Decinfo.interlaced_sequence) {
+        PRINT(("INTERLACED SEQUENCE
"));
+      }
 #ifdef USE_EXTERNAL_BUFFER
       if(Decinfo.pic_buff_size != min_buffer_num ||
           (Decinfo.frame_width * Decinfo.frame_height > prev_width * prev_height)) {
@@ -1084,34 +1105,35 @@ int main(int argc, char **argv) {
 
       if(!frame_number) {
         /*disable_resync = 0; */
-        if(Decinfo.stream_format == MPEG2)
-          printf("MPEG-2 stream
");
-        else
-          printf("MPEG-1 stream
");
+        if(Decinfo.stream_format == MPEG2) {
+          PRINT(("MPEG-2 stream
"));
+        } else {
+          PRINT(("MPEG-1 stream
"));
+        }
 
-        printf("Profile and level %d
",
-               Decinfo.profile_and_level_indication);
+        PRINT(("Profile and level %d
",
+               Decinfo.profile_and_level_indication));
         switch (Decinfo.display_aspect_ratio) {
         case MPEG2DEC_1_1:
-          printf("Display Aspect ratio 1:1
");
+          PRINT(("Display Aspect ratio 1:1
"));
           break;
         case MPEG2DEC_4_3:
-          printf("Display Aspect ratio 4:3
");
+          PRINT(("Display Aspect ratio 4:3
"));
           break;
         case MPEG2DEC_16_9:
-          printf("Display Aspect ratio 16:9
");
+          PRINT(("Display Aspect ratio 16:9
"));
           break;
         case MPEG2DEC_2_21_1:
-          printf("Display Aspect ratio 2.21:1
");
+          PRINT(("Display Aspect ratio 2.21:1
"));
           break;
         }
-        printf("Output format %s
",
+        PRINT(("Output format %s
",
                Decinfo.output_format == MPEG2DEC_SEMIPLANAR_YUV420
                ? "MPEG2DEC_SEMIPLANAR_YUV420" :
-               "MPEG2DEC_TILED_YUV420");
+               "MPEG2DEC_TILED_YUV420"));
       }
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      DEBUG_PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1168,9 +1190,9 @@ int main(int argc, char **argv) {
 #ifdef USE_EXTERNAL_BUFFER
     case MPEG2DEC_WAITING_FOR_BUFFER:
       rv = Mpeg2DecGetBufferInfo(decoder, &hbuf);
-      printf("MREG2DecGetBufferInfo ret %d
", rv);
-      printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+      PRINT(("MREG2DecGetBufferInfo ret %d
", rv));
+      PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
       if (hbuf.buf_to_free.virtual_address != NULL && res_changed) {
         add_extra_flag = 0;
         ReleaseExtBuffers();
@@ -1190,7 +1212,7 @@ int main(int argc, char **argv) {
           else
             DWLMallocRefFrm(dwl_inst, hbuf.next_buf_size, &mem);
           rv = Mpeg2DecAddBuffer(decoder, &mem);
-          printf("Mpeg2DecAddBuffer ret %d
", rv);
+          PRINT(("Mpeg2DecAddBuffer ret %d
", rv));
           if(rv != MPEG2DEC_OK && rv != MPEG2DEC_WAITING_FOR_BUFFER) {
             if (pp_enabled)
               DWLFreeLinear(dwl_inst, &mem);
@@ -1251,9 +1273,9 @@ int main(int argc, char **argv) {
       if (use_peek_output &&
           Mpeg2DecPeek(decoder, &DecPic) == MPEG2DEC_PIC_RDY) {
         pic_display_number++;
-        printf("DECPIC %d, %s", DecPic.pic_id,
+        DEBUG_PRINT(("DECPIC %d, %s", DecPic.pic_id,
                DecPic.key_picture ? "key picture,    " :
-               "non key picture,");
+               "non key picture,"));
 
         /* pic coding type */
         printMpeg2PicCodingType(DecPic.pic_coding_type[0]);
@@ -1291,9 +1313,9 @@ int main(int argc, char **argv) {
 
           if(info_ret == MPEG2DEC_PIC_RDY) {
             /* printf info */
-            printf("PIC %d, %s", DecPic.pic_id,
+            DEBUG_PRINT(("PIC %d, %s", DecPic.pic_id,
                    DecPic.key_picture ? "key picture,    " :
-                   "non key picture,");
+                   "non key picture,"));
 
             if(DecPic.field_picture) {
               /* pic coding type */
@@ -1301,19 +1323,19 @@ int main(int argc, char **argv) {
                 printMpeg2PicCodingType(DecPic.pic_coding_type[0]);
               else
                 printMpeg2PicCodingType(DecPic.pic_coding_type[1]);
-              printf(" %s ", DecPic.top_field ?
-                     "top field.   " : "bottom field.");
+              DEBUG_PRINT((" %s ", DecPic.top_field ?
+                     "top field.   " : "bottom field."));
             } else {
               printMpeg2PicCodingType(DecPic.pic_coding_type[0]);
-              printf(" frame picture. ");
+              DEBUG_PRINT((" frame picture. "));
             }
 
             printTimeCode(&(DecPic.time_code));
             if(DecPic.number_of_err_mbs) {
-              printf(", %d/%d error mbs
",
+              DEBUG_PRINT((", %d/%d error mbs
",
                      DecPic.number_of_err_mbs,
                      (DecPic.frame_width >> 4) *
-                     (DecPic.frame_height >> 4));
+                     (DecPic.frame_height >> 4)));
               cumulative_error_mbs += DecPic.number_of_err_mbs;
             }
 
@@ -1323,7 +1345,7 @@ int main(int argc, char **argv) {
             pic_size = DecPic.frame_width * DecPic.frame_height * 3 / 2;
 
 #ifndef PP_PIPELINE_ENABLED
-            printf("DecPic.first_field %d
", DecPic.first_field);
+            DEBUG_PRINT(("DecPic.first_field %d
", DecPic.first_field));
             WriteOutput(out_file_name, out_file_name_tiled, image_data,
                         pic_display_number - 1,
                         ((Decinfo.frame_width + 15) & ~15),
@@ -1351,7 +1373,7 @@ int main(int argc, char **argv) {
         pthread_create(&add_buffer_thread, NULL, AddBufferThread, NULL);
       }
 #endif
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      DEBUG_PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1381,7 +1403,7 @@ int main(int argc, char **argv) {
       }
 
       if(max_num_frames && (frame_number >= max_num_frames)) {
-        printf("

Max num of pictures reached

");
+        PRINT(("

Max num of pictures reached

"));
         DecIn.data_len = 0;
         goto end2;
       }
@@ -1392,8 +1414,7 @@ int main(int argc, char **argv) {
     case MPEG2DEC_PIC_CONSUMED:
     case MPEG2DEC_BUF_EMPTY:
     case MPEG2DEC_NONREF_PIC_SKIPPED:
-      fprintf(stdout,
-              "TB: Frame Number: %u, pic: %d
", vp_num++, frame_number);
+      DEBUG_PRINT(("TB: Frame Number: %u, pic: %d
", vp_num++, frame_number));
     /* Used to indicate that picture decoding needs to
      * finalized prior to corrupting next picture */
 #ifdef GET_FREE_BUFFER_NON_BLOCK
@@ -1430,7 +1451,7 @@ int main(int argc, char **argv) {
        *   the function call.
        */
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      DEBUG_PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1462,14 +1483,14 @@ int main(int argc, char **argv) {
       break;
 
     case MPEG2DEC_PARAM_ERROR:
-      printf("INCORRECT STREAM PARAMS
");
+      PRINT(("INCORRECT STREAM PARAMS
"));
       goto end2;
       break;
 
     case MPEG2DEC_STRM_ERROR:
-      printf("STREAM ERROR
");
+      PRINT(("STREAM ERROR
"));
 
-      printf("DecOut.data_left %d 
", DecOut.data_left);
+      PRINT(("DecOut.data_left %d 
", DecOut.data_left));
       if(DecOut.data_left) {
         corrupted_bytes -= (DecIn.data_len - DecOut.data_left);
         DecIn.data_len = DecOut.data_left;
@@ -1580,19 +1601,20 @@ end2:
   END_SW_PERFORMANCE;
   decsw_performance();
 
-  if(Decinfo.frame_width < 1921)
-    printf("
Width %d Height %d
", Decinfo.frame_width,
-           Decinfo.frame_height);
+  if(Decinfo.frame_width < 1921) {
+    PRINT(("
Width %d Height %d
", Decinfo.frame_width,
+           Decinfo.frame_height));
+  }
   if(cumulative_error_mbs) {
-    printf("Cumulative errors: %d/%d macroblocks, ",
+    PRINT(("Cumulative errors: %d/%d macroblocks, ",
            cumulative_error_mbs,
            (Decinfo.frame_width >> 4) * (Decinfo.frame_height >> 4) *
-           frame_number);
+           frame_number));
   }
-  printf("decoded %d pictures
", frame_number);
+  PRINT(("decoded %d pictures
", frame_number));
 
-  if(f_in)
-    fclose(f_in);
+
+  fclose(f_in);
 
   if(fout)
     fclose(fout);
@@ -1608,7 +1630,8 @@ end2:
 #endif
 
   if(save_index || use_index) {
-    fclose(findex);
+    if (findex)
+      fclose(findex);
   }
 
   /* Calculate the output size and print it  */
@@ -1616,19 +1639,20 @@ end2:
   if(NULL == fout) {
     stream_len = 0;
   } else {
-    fseek(fout, 0L, SEEK_END);
+    if (fseek(fout, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     stream_len = (u32) ftell(fout);
     fclose(fout);
   }
 
 #ifndef PP_PIPELINE_ENABLED
-  printf("output size %d
", stream_len);
+  PRINT(("output size %d
", stream_len));
 #endif
 
   FINALIZE_SW_PERFORMANCE;
 
   if(cumulative_error_mbs || !frame_number) {
-    printf("ERRORS FOUND
");
+    PRINT(("ERRORS FOUND
"));
     return (1);
   } else
     return (0);
@@ -1649,7 +1673,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
   StartCode = 0;
 
   if(stop_decoding) {
-    printf("Truncated stream size reached -> stop decoding
");
+    PRINT(("Truncated stream size reached -> stop decoding
"));
     return 0;
   }
 
@@ -1660,7 +1684,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
     ret =
       TBRandomizePacketLoss(tb_cfg.tb_params.stream_packet_loss, &next_packet);
     if(ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return 0;
     }
   }
@@ -1678,7 +1702,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
 
     /* read data */
     if (amount > DEC_X170_MAX_STREAM) {
-      printf("FILE ERROR
");
+      PRINT(("FILE ERROR
"));
       return 0;
     }
     idx = fread(frame_buffer, 1, amount, fp);
@@ -1775,7 +1799,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
       /* stop reading if truncated stream size is reached */
       if(stream_truncate && !disable_resync) {
         if(previous_used + idx >= stream_size) {
-          printf("Stream truncated at %d bytes
", previous_used + idx);
+          PRINT(("Stream truncated at %d bytes
", previous_used + idx));
           stop_decoding = 1;   /* next call return 0 size -> exit decoding main loop */
           break;
         }
@@ -1797,22 +1821,22 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
   /* If we skip this packet */
   if(pic_rdy && next_packet && ((hdrs_rdy && !stream_header_corrupt) || stream_header_corrupt)) {
     /* Get the next packet */
-    printf("Packet Loss
");
+    DEBUG_PRINT(("Packet Loss
"));
     return readDecodeUnit(fp, frame_buffer);
   } else {
     /*printf("READ DECODE UNIT %d
", idx); */
-    printf("No Packet Loss
");
+    DEBUG_PRINT(("No Packet Loss
"));
     if (disable_resync && pic_rdy && stream_truncate
         && ((hdrs_rdy && !stream_header_corrupt) || stream_header_corrupt)) {
       i32 ret;
-      printf("Original packet size %d
", idx);
+      PRINT(("Original packet size %d
", idx));
       ret = TBRandomizeU32(&idx);
       if(ret != 0) {
-        printf("RANDOM STREAM ERROR FAILED
");
+        PRINT(("RANDOM STREAM ERROR FAILED
"));
         stop_decoding = 1;   /* next call return 0 size -> exit decoding main loop */
         return 0;
       }
-      printf("Randomized packet size %d
", idx);
+      PRINT(("Randomized packet size %d
", idx));
     }
     return (idx);
   }
@@ -1825,12 +1849,12 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer) {
 
 void printTimeCode(Mpeg2DecTime * timecode) {
 
-  fprintf(stdout, "hours %u, "
+  DEBUG_PRINT(("hours %u, "
           "minutes %u, "
           "seconds %u, "
           "time_pictures %u 
",
           timecode->hours,
-          timecode->minutes, timecode->seconds, timecode->pictures);
+          timecode->minutes, timecode->seconds, timecode->pictures));
 }
 
 /*------------------------------------------------------------------------------
@@ -1840,68 +1864,86 @@ void printTimeCode(Mpeg2DecTime * timecode) {
 
 void decRet(Mpeg2DecRet ret) {
 
-  printf("Decode result: ");
-
   switch (ret) {
   case MPEG2DEC_OK:
-    printf("MPEG2DEC_OK
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_OK
"));
     break;
   case MPEG2DEC_STRM_PROCESSED:
-    printf("MPEG2DEC_STRM_PROCESSED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_STRM_PROCESSED
"));
     break;
   case MPEG2DEC_BUF_EMPTY:
-    printf("MPEG2DEC_BUF_EMPTY
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_BUF_EMPTY
"));
     break;
   case MPEG2DEC_NO_DECODING_BUFFER:
-    printf("MPEG2DEC_NO_DECODING_BUFFER
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_NO_DECODING_BUFFER
"));
     break;
   case MPEG2DEC_NONREF_PIC_SKIPPED:
-    printf("MPEG2DEC_NONREF_PIC_SKIPPED
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_NONREF_PIC_SKIPPED
"));
     break;
   case MPEG2DEC_PIC_RDY:
-    printf("MPEG2DEC_PIC_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_PIC_RDY
"));
     break;
   case MPEG2DEC_HDRS_RDY:
-    printf("MPEG2DEC_HDRS_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_HDRS_RDY
"));
     break;
   case MPEG2DEC_PIC_DECODED:
-    printf("MPEG2DEC_PIC_DECODED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_PIC_DECODED
"));
     break;
   case MPEG2DEC_PIC_CONSUMED:
-    printf("MPEG2DEC_PIC_CONSUMED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MPEG2DEC_PIC_CONSUMED
"));
     break;
   case MPEG2DEC_PARAM_ERROR:
-    printf("MPEG2DEC_PARAM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_PARAM_ERROR
"));
     break;
   case MPEG2DEC_STRM_ERROR:
-    printf("MPEG2DEC_STRM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_STRM_ERROR
"));
     break;
   case MPEG2DEC_NOT_INITIALIZED:
-    printf("MPEG2DEC_NOT_INITIALIZED
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_NOT_INITIALIZED
"));
     break;
   case MPEG2DEC_MEMFAIL:
-    printf("MPEG2DEC_MEMFAIL
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_MEMFAIL
"));
     break;
   case MPEG2DEC_DWL_ERROR:
-    printf("MPEG2DEC_DWL_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_DWL_ERROR
"));
     break;
   case MPEG2DEC_HW_BUS_ERROR:
-    printf("MPEG2DEC_HW_BUS_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_HW_BUS_ERROR
"));
     break;
   case MPEG2DEC_SYSTEM_ERROR:
-    printf("MPEG2DEC_SYSTEM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_SYSTEM_ERROR
"));
     break;
   case MPEG2DEC_HW_TIMEOUT:
-    printf("MPEG2DEC_HW_TIMEOUT
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_HW_TIMEOUT
"));
     break;
   case MPEG2DEC_HDRS_NOT_RDY:
-    printf("MPEG2DEC_HDRS_NOT_RDY
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_HDRS_NOT_RDY
"));
     break;
   case MPEG2DEC_STREAM_NOT_SUPPORTED:
-    printf("MPEG2DEC_STREAM_NOT_SUPPORTED
");
+    PRINT(("Decode result: "));
+    PRINT(("MPEG2DEC_STREAM_NOT_SUPPORTED
"));
     break;
   default:
-    printf("Other %d
", ret);
+    PRINT(("Decode result: "));
+    PRINT(("Other %d
", ret));
     break;
   }
 }
@@ -1911,7 +1953,7 @@ void decRet(Mpeg2DecRet ret) {
         Description : Print out NextPicture return values
 ------------------------------------------------------------------------------*/
 void decNextPictureRet(Mpeg2DecRet ret) {
-  printf("next picture returns: ");
+  DEBUG_PRINT(("next picture returns: "));
 
   decRet(ret);
 }
@@ -1926,19 +1968,19 @@ void decNextPictureRet(Mpeg2DecRet ret) {
 void printMpeg2PicCodingType(u32 pic_type) {
   switch (pic_type) {
   case DEC_PIC_TYPE_I:
-    printf(" DEC_PIC_TYPE_I,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_I,"));
     break;
   case DEC_PIC_TYPE_P:
-    printf(" DEC_PIC_TYPE_P,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_P,"));
     break;
   case DEC_PIC_TYPE_B:
-    printf(" DEC_PIC_TYPE_B,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_B,"));
     break;
   case DEC_PIC_TYPE_D:
-    printf(" DEC_PIC_TYPE_D,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_D,"));
     break;
   default:
-    printf("Other %d
", pic_type);
+    DEBUG_PRINT(("Other %d
", pic_type));
     break;
   }
 }
@@ -1959,11 +2001,11 @@ void printMpeg2Version(void) {
    */
 
   dec_version = Mpeg2DecGetAPIVersion();
-  printf("
Api version:  %d.%d, ", dec_version.major, dec_version.minor);
+  PRINT(("
Api version:  %d.%d, ", dec_version.major, dec_version.minor));
 
   dec_build = Mpeg2DecGetBuild();
-  printf("sw build nbr: %d, hw build nbr: %x

",
-         dec_build.sw_build, dec_build.hw_build);
+  PRINT(("sw build nbr: %d, hw build nbr: %x

",
+         dec_build.sw_build, dec_build.hw_build));
 
 }
 
@@ -1991,7 +2033,7 @@ i32 AllocatePicBuffers(Mpeg2DecLinearMem * buffer, DecContainer * container) {
   if(DWLMallocRefFrm(((DecContainer *) container)->dwl,
                      offset * MPEG2_NUM_BUFFERS,
                      (struct DWLLinearMem *) buffer) != DWL_OK) {
-    printf(("UNABLE TO ALLOCATE OUTPUT BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE OUTPUT BUFFER MEMORY
"));
     return 1;
   }
 
@@ -2002,8 +2044,8 @@ i32 AllocatePicBuffers(Mpeg2DecLinearMem * buffer, DecContainer * container) {
   buffer[2].bus_address = buffer[1].bus_address + offset;
 
   for(i = 0; i < MPEG2_NUM_BUFFERS; i++) {
-    printf("buff %d vir %p bus %lx
", i,
-           buffer[i].virtual_address, buffer[i].bus_address);
+    PRINT(("buff %d vir %p bus %lx
", i,
+           buffer[i].virtual_address, buffer[i].bus_address));
   }
 
 #endif
@@ -2079,7 +2121,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
     if(strcmp(filename, "none") != 0) {
       fout = fopen(filename, "wb");
       if(fout == NULL) {
-        printf("UNABLE TO OPEN OUTPUT FILE
");
+        PRINT(("UNABLE TO OPEN OUTPUT FILE
"));
         if(raster_scan)
           free(raster_scan);
         return;
@@ -2167,7 +2209,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
 
       if((DecPicture.field_picture && !first_field) ||
           !DecPicture.field_picture) {
-        printf("Output picture %d
", frame_id);
+        DEBUG_PRINT(("Output picture %d
", frame_id));
         /* Decoder without pp does not write out fields but a
          * frame containing both fields */
         /* PP output is written field by field */
@@ -2176,7 +2218,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data,
         if(output_picture_endian == DEC_X170_BIG_ENDIAN) {
           pic_copy = (u8 *) malloc(pic_size);
           if(NULL == pic_copy) {
-            printf("MALLOC FAILED @ %s %d", __FILE__, __LINE__);
+            PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
             if(raster_scan)
               free(raster_scan);
             return;
diff --git a/decoder_sw/software/test/mpeg4/Makefile b/decoder_sw/software/test/mpeg4/Makefile
index 93ed5c7..0b1b034 100755
--- a/decoder_sw/software/test/mpeg4/Makefile
+++ b/decoder_sw/software/test/mpeg4/Makefile
@@ -74,6 +74,8 @@ TARGET_ENV=
 
 # Enable SW performance  measurement
 #CFLAGS = -DSW_PERFORMANCE
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
 
 ifeq ($(USE_EFENCE), y)
         EFENCE= -DUSE_EFENCE -L/afs/hantro.com/projects/adder/users/mahe/efence_2_4_13 \
diff --git a/decoder_sw/software/test/mpeg4/mpeg4dectest.c b/decoder_sw/software/test/mpeg4/mpeg4dectest.c
index 7e39810..4d86ccd 100755
--- a/decoder_sw/software/test/mpeg4/mpeg4dectest.c
+++ b/decoder_sw/software/test/mpeg4/mpeg4dectest.c
@@ -82,6 +82,22 @@
 #define STREAMBUFFER_BLOCKSIZE 2*2097151
 #define MP4_WHOLE_STREAM_SAFETY_LIMIT (10*10*1024)
 
+/* Debug prints */
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+
 /* local function prototypes */
 
 void printTimeCode(MP4DecTime * timecode);
@@ -235,10 +251,10 @@ static void *AddBufferThread(void *arg) {
 
 void ReleaseExtBuffers() {
   u32 i;
-  printf("Releasing %d external frame buffers
", num_buffers);
+  PRINT(("Releasing %d external frame buffers
", num_buffers));
   pthread_mutex_lock(&ext_buffer_contro);
   for(i=0; i<num_buffers; i++) {
-    printf("Freeing buffer %p
", ext_buffers[i].virtual_address);
+    PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
     if (pp_enabled)
       DWLFreeLinear(dwl_inst, &ext_buffers[i]);
     else
@@ -346,30 +362,31 @@ static void* mpeg4_output_thread(void* arg) {
     ret = MP4DecNextPicture(decoder, &DecPicture, 0);
     if(ret == MP4DEC_PIC_RDY) {
       if(!use_peek_output) {
-        printf("next picture returns:");
+        DEBUG_PRINT(("next picture returns:"));
         decRet(ret);
 
-        printf("PIC %d, %s", DecPicture.pic_id,
+        DEBUG_PRINT(("PIC %d, %s", DecPicture.pic_id,
                DecPicture.
-               key_picture ? "key picture,    " : "non key picture,");
+               key_picture ? "key picture,    " : "non key picture,"));
 
         /* pic coding type */
         printMpeg4PicCodingType(DecPicture.pic_coding_type);
 
-        if(DecPicture.field_picture)
-          printf(" %s ",
-                 DecPicture.top_field ? "top field.   " : "bottom field.");
-        else
-          printf(" frame picture. ");
+        if(DecPicture.field_picture) {
+          DEBUG_PRINT((" %s ",
+                 DecPicture.top_field ? "top field.   " : "bottom field."));
+        } else {
+          DEBUG_PRINT((" frame picture. "));
+        }
 
         printTimeCode(&(DecPicture.time_code));
         if(DecPicture.nbr_of_err_mbs) {
-          printf(", %d/%d error mbs
",
+          DEBUG_PRINT((", %d/%d error mbs
",
                  DecPicture.nbr_of_err_mbs,
-                 (DecPicture.frame_width >> 4) * (DecPicture.frame_height >> 4));
+                 (DecPicture.frame_width >> 4) * (DecPicture.frame_height >> 4)));
           cumulative_error_mbs += DecPicture.nbr_of_err_mbs;
         } else {
-          printf("
");
+          DEBUG_PRINT(("
"));
 
         }
         /* Write output picture to file */
@@ -528,36 +545,36 @@ int main(int argc, char **argv) {
 #ifndef PP_PIPELINE_ENABLED
   if(argc < 2) {
 
-    printf("
x170 MPEG-4 Decoder Testbench

");
-    printf("USAGE:
%s [options] stream.mpeg4
", argv[0]);
-    printf("-Ooutfile write output to \"outfile\" (default out.yuv)
");
-    printf("-Nn to decode only first n vops of the stream
");
-    printf("-X to not to write output picture
");
-    printf("-Bn to use n frame buffers in decoder
");
-    printf("-Sfile.hex stream control trace file
");
+    PRINT(("
x170 MPEG-4 Decoder Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.mpeg4
", argv[0]));
+    PRINT(("-Ooutfile write output to \"outfile\" (default out.yuv)
"));
+    PRINT(("-Nn to decode only first n vops of the stream
"));
+    PRINT(("-X to not to write output picture
"));
+    PRINT(("-Bn to use n frame buffers in decoder
"));
+    PRINT(("-Sfile.hex stream control trace file
"));
 #if defined(ASIC_TRACE_SUPPORT) || defined(SYSTEM_VERIFICATION)
-    printf("-R use reference decoder IDCT (sw/sw integration only)
");
-#endif
-    printf("-W whole stream mode - give stream to decoder in one chunk
");
-    printf("-P write planar output
");
-    printf("-I save index file
");
-    printf("-E use tiled reference frame format.
");
-    printf("-G convert tiled output pictures to raster scan
");
-    printf("-F decode Sorenson Spark stream
");
-    printf
-    ("-C crop output picture to real picture dimensions (only planar)
");
-    printf("-J decode DivX4 or DivX5 stream
");
-    printf("-D<width>x<height> decode DivX3 stream of resolution width x height
");
-    printf("-Q Skip decoding non-reference pictures.
");
-    printf("-Z output pictures using MP4DecPeek() function
");
-    printf("--separate-fields-in-dpb DPB stores interlaced content"\
-           " as fields (default: frames)
");
-    printf("--output-frame-dpb Convert output to frame mode even if"\
-           " field DPB mode used
");
+    PRINT(("-R use reference decoder IDCT (sw/sw integration only)
"));
+#endif
+    PRINT(("-W whole stream mode - give stream to decoder in one chunk
"));
+    PRINT(("-P write planar output
"));
+    PRINT(("-I save index file
"));
+    PRINT(("-E use tiled reference frame format.
"));
+    PRINT(("-G convert tiled output pictures to raster scan
"));
+    PRINT(("-F decode Sorenson Spark stream
"));
+    PRINT
+    (("-C crop output picture to real picture dimensions (only planar)
"));
+    PRINT(("-J decode DivX4 or DivX5 stream
"));
+    PRINT(("-D<width>x<height> decode DivX3 stream of resolution width x height
"));
+    PRINT(("-Q Skip decoding non-reference pictures.
"));
+    PRINT(("-Z output pictures using MP4DecPeek() function
"));
+    PRINT(("--separate-fields-in-dpb DPB stores interlaced content"\
+           " as fields (default: frames)
"));
+    PRINT(("--output-frame-dpb Convert output to frame mode even if"\
+           " field DPB mode used
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("-A add extra external buffer randomly
");
+    PRINT(("-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("-a allocate extra external buffer in output thread
");
+    PRINT(("-a allocate extra external buffer in output thread
"));
 #endif
 #endif
     printMP4Version();
@@ -567,7 +584,12 @@ int main(int argc, char **argv) {
   max_num_vops = 0;
   for(i = 1; i < (u32)argc - 1; i++) {
     if(strncmp(argv[i], "-O", 2) == 0) {
-      strcpy(out_file_name, argv[i] + 2);
+      if (sizeof(out_file_name) - 1 < strlen(argv[i] + 2)) {
+        PRINT(("The output file name size overflows buffer size(256)!
"));
+        return 1;
+      } else {
+        strcpy(out_file_name, argv[i] + 2);
+      }
     } else if(strncmp(argv[i], "-N", 2) == 0) {
       max_num_vops = atoi(argv[i] + 2);
     } else if(strncmp(argv[i], "-X", 2) == 0) {
@@ -606,7 +628,7 @@ int main(int argc, char **argv) {
       no_start_codes = 1;
       tmp = sscanf(argv[i]+2, "%ux%u", &custom_width, &custom_height );
       if( tmp != 2 ) {
-        printf("MALFORMED WIDTHxHEIGHT: %s
", argv[i]+2);
+        PRINT(("MALFORMED WIDTHxHEIGHT: %s
", argv[i]+2));
         return 1;
       }
       strm_offset = 0;
@@ -654,11 +676,11 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
-      printf("UNKNOWN PARAMETER: %s
", argv[i]);
+      PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
       return 1;
     }
   }
@@ -667,35 +689,34 @@ int main(int argc, char **argv) {
   /* open data file */
   f_in = fopen(argv[argc - 1], "rb");
   if(f_in == NULL) {
-    printf("Unable to open input file %s
", argv[argc - 1]);
+    PRINT(("Unable to open input file %s
", argv[argc - 1]));
     exit(100);
   }
 #else
   if(argc < 3) {
-    printf("
Mpeg-4 Decoder PP Pipelined Testbench

");
-    printf("USAGE:
%s [options] stream.mpeg4 pp.cfg
", argv[0]);
-    printf("-Nn to decode only first n vops of the stream
");
-    printf("-X to not to write output picture
");
-    printf("-W whole stream mode - give stream to decoder in one chunk
");
-    printf("-Bn to use n frame buffers in decoder
");
-    printf("-I save index file
");
-    printf("-E use tiled reference frame format.
");
-    printf("-F decode Sorenson Spark stream
");
-    printf("-J decode DivX4 or DivX5 stream
");
-    printf("-D<width>x<height> decode DivX3 stream of resolution width x height
");
-    printf("-Q Skip decoding non-reference pictures.
");
-    printf("--separate-fields-in-dpb DPB stores interlaced content"\
-           " as fields (default: frames)
");
+    PRINT(("
Mpeg-4 Decoder PP Pipelined Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.mpeg4 pp.cfg
", argv[0]));
+    PRINT(("-Nn to decode only first n vops of the stream
"));
+    PRINT(("-X to not to write output picture
"));
+    PRINT(("-W whole stream mode - give stream to decoder in one chunk
"));
+    PRINT(("-Bn to use n frame buffers in decoder
"));
+    PRINT(("-I save index file
"));
+    PRINT(("-E use tiled reference frame format.
"));
+    PRINT(("-F decode Sorenson Spark stream
"));
+    PRINT(("-J decode DivX4 or DivX5 stream
"));
+    PRINT(("-D<width>x<height> decode DivX3 stream of resolution width x height
"));
+    PRINT(("-Q Skip decoding non-reference pictures.
"));
+    PRINT(("--separate-fields-in-dpb DPB stores interlaced content"\
+           " as fields (default: frames)
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("-A add extra external buffer randomly
");
+    PRINT(("-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("-a allocate extra external buffer in output thread
");
+    PRINT(("-a allocate extra external buffer in output thread
"));
 #endif
 #endif
     exit(100);
   }
 
-  remove("pp_out.yuv");
   max_num_vops = 0;
   /* read cmdl parameters */
   for(i = 1; i < argc - 2; i++) {
@@ -723,7 +744,7 @@ int main(int argc, char **argv) {
       no_start_codes = 1;
       tmp = sscanf(argv[i]+2, "%dx%d", &custom_width, &custom_height );
       if( tmp != 2 ) {
-        printf("MALFORMED WIDTHxHEIGHT: %s
", argv[i]+2);
+        PRINT(("MALFORMED WIDTHxHEIGHT: %s
", argv[i]+2));
         return 1;
       }
       strm_offset = 0;
@@ -764,7 +785,7 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
@@ -777,7 +798,7 @@ int main(int argc, char **argv) {
   /* open data file */
   f_in = fopen(argv[argc - 2], "rb");
   if(f_in == NULL) {
-    printf("Unable to open input file %s
", argv[argc - 2]);
+    PRINT(("Unable to open input file %s
", argv[argc - 2]));
     exit(100);
   }
 
@@ -795,7 +816,7 @@ int main(int argc, char **argv) {
   if(save_index) {
     findex = fopen("stream.cfg", "w");
     if(findex == NULL) {
-      printf("UNABLE TO OPEN INDEX FILE
");
+      PRINT(("UNABLE TO OPEN INDEX FILE
"));
       return -1;
     }
   } else {
@@ -810,8 +831,8 @@ int main(int argc, char **argv) {
   TBSetDefaultCfg(&tb_cfg);
   f_tbcfg = fopen("tb.cfg", "r");
   if(f_tbcfg == NULL) {
-    printf("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
");
-    printf("USING DEFAULT CONFIGURATION
");
+    PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if(TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
@@ -834,14 +855,14 @@ int main(int argc, char **argv) {
       printf("Decoder Output Picture Endian forced to %d
",
              output_picture_endian);
   #endif*/
-  printf("Decoder RLC %d
", rlc_mode);
-  printf("Decoder Clock Gating %d
", clock_gating);
-  printf("Decoder Data Discard %d
", data_discard);
-  printf("Decoder Latency Compensation %d
", latency_comp);
-  printf("Decoder Output Picture Endian %d
", output_picture_endian);
-  printf("Decoder Bus Burst Length %d
", bus_burst_length);
-  printf("Decoder Asic Service Priority %d
", asic_service_priority);
-  printf("Decoder Output Format %d
", output_format);
+  PRINT(("Decoder RLC %d
", rlc_mode));
+  PRINT(("Decoder Clock Gating %d
", clock_gating));
+  PRINT(("Decoder Data Discard %d
", data_discard));
+  PRINT(("Decoder Latency Compensation %d
", latency_comp));
+  PRINT(("Decoder Output Picture Endian %d
", output_picture_endian));
+  PRINT(("Decoder Bus Burst Length %d
", bus_burst_length));
+  PRINT(("Decoder Asic Service Priority %d
", asic_service_priority));
+  PRINT(("Decoder Output Format %d
", output_format));
 
   seed_rnd = tb_cfg.tb_params.seed_rnd;
   stream_header_corrupt = TBGetTBStreamHeaderCorrupt(&tb_cfg);
@@ -861,14 +882,14 @@ int main(int argc, char **argv) {
     stream_packet_loss = 0;
   }
   disable_resync = !TBGetTBPacketByPacket(&tb_cfg);
-  printf("TB Packet by Packet  %d
", !disable_resync);
-  printf("TB Seed Rnd %d
", seed_rnd);
-  printf("TB Stream Truncate %d
", stream_truncate);
-  printf("TB Stream Header Corrupt %d
", stream_header_corrupt);
-  printf("TB Stream Bit Swap %d; odds %s
",
-         stream_bit_swap, tb_cfg.tb_params.stream_bit_swap);
-  printf("TB Stream Packet Loss %d; odds %s
",
-         stream_packet_loss, tb_cfg.tb_params.stream_packet_loss);
+  DEBUG_PRINT(("TB Packet by Packet  %d
", !disable_resync));
+  DEBUG_PRINT(("TB Seed Rnd %d
", seed_rnd));
+  DEBUG_PRINT(("TB Stream Truncate %d
", stream_truncate));
+  DEBUG_PRINT(("TB Stream Header Corrupt %d
", stream_header_corrupt));
+  DEBUG_PRINT(("TB Stream Bit Swap %d; odds %s
",
+         stream_bit_swap, tb_cfg.tb_params.stream_bit_swap));
+  DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
",
+         stream_packet_loss, tb_cfg.tb_params.stream_packet_loss));
 
   /* allocate memory for stream buffer. if unsuccessful -> exit */
   stream_mem.virtual_address = NULL;
@@ -882,26 +903,27 @@ int main(int argc, char **argv) {
   TBInitializeRandom(seed_rnd);
 
   /* check size of the input file -> length of the stream in bytes */
-  fseek(f_in, 0L, SEEK_END);
+  if (fseek(f_in, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   stream_size = (u32) ftell(f_in);
   rewind(f_in);
 
   /* sets the stream length to random value */
   if(stream_truncate && disable_resync) {
-    printf("stream_size %d
", stream_size);
+    PRINT(("stream_size %d
", stream_size));
     ret = TBRandomizeU32(&stream_size);
     if(ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return -1;
     }
-    printf("Randomized stream_size %d
", stream_size);
+    PRINT(("Randomized stream_size %d
", stream_size));
   }
 
 #ifdef ASIC_TRACE_SUPPORT
   tmp = openTraceFiles();
 #endif
   if(!tmp) {
-    printf("UNABLE TO OPEN TRACE FILES(S)
");
+    PRINT(("UNABLE TO OPEN TRACE FILES(S)
"));
   }
 #ifdef USE_EXTERNAL_BUFFER
   dwl_init.client_type = DWL_CLIENT_TYPE_MPEG4_DEC;
@@ -934,7 +956,7 @@ int main(int argc, char **argv) {
 
   if(ret != MP4DEC_OK) {
     decoder = NULL;
-    printf("Could not initialize decoder
");
+    PRINT(("Could not initialize decoder
"));
     goto end;
   }
 
@@ -974,7 +996,7 @@ int main(int argc, char **argv) {
 
   if(DWLMallocLinear(((DecContainer *) decoder)->dwl,
                      STREAMBUFFER_BLOCKSIZE, &stream_mem) != DWL_OK) {
-    printf(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
     goto end;
   }
 
@@ -1009,7 +1031,7 @@ int main(int argc, char **argv) {
                  service_merge_disable);
 
   if(rlc_mode) {
-    printf("RLC mode forced
");
+    PRINT(("RLC mode forced
"));
     /*Force the decoder into RLC mode */
     ((DecContainer *) decoder)->rlc_mode = 1;
   }
@@ -1072,18 +1094,19 @@ int main(int argc, char **argv) {
     stream_len -= 4;
   DecIn.data_len = stream_len;
   DecOut.data_left = 0;
-  printf("Start decoding
");
+  PRINT(("Start decoding
"));
   do {
     /*printf("DecIn.data_len %d
", DecIn.data_len);*/
     DecIn.pic_id = pic_id;
     if(ret != MP4DEC_STRM_PROCESSED &&
         ret != MP4DEC_BUF_EMPTY &&
         ret != MP4DEC_NO_DECODING_BUFFER &&
-        ret != MP4DEC_NONREF_PIC_SKIPPED)
-      printf("Starting to decode picture ID %d
", pic_id);
+        ret != MP4DEC_NONREF_PIC_SKIPPED) {
+      DEBUG_PRINT(("Starting to decode picture ID %d
", pic_id));
+    }
 
     if(rlc_mode) {
-      printf("RLC mode forced 
");
+      PRINT(("RLC mode forced 
"));
       /*Force the decoder into RLC mode */
       ((DecContainer *) decoder)->rlc_mode = 1;
     }
@@ -1098,12 +1121,12 @@ int main(int argc, char **argv) {
                                            tb_cfg.tb_params.
                                            stream_bit_swap);
           if(ret != 0) {
-            printf("RANDOM STREAM ERROR FAILED
");
+            PRINT(("RANDOM STREAM ERROR FAILED
"));
             goto end2;
           }
 
           corrupted_bytes = DecIn.data_len;
-          printf("corrupted_bytes %d
", corrupted_bytes);
+          PRINT(("corrupted_bytes %d
", corrupted_bytes));
         }
       }
     }
@@ -1128,9 +1151,9 @@ int main(int argc, char **argv) {
       /* Set a flag to indicate that headers are ready */
 #ifdef USE_EXTERNAL_BUFFER
       rv = MP4DecGetBufferInfo(decoder, &hbuf);
-      printf("Mpeg4DecGetBufferInfo ret %d
", rv);
-      printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+      PRINT(("Mpeg4DecGetBufferInfo ret %d
", rv));
+      PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 #endif
       hdrs_rdy = 1;
       TBSetRefbuMemModel( &tb_cfg, ((DecContainer *) decoder)->mp4_regs,
@@ -1151,8 +1174,9 @@ int main(int argc, char **argv) {
       outp_byte_size =
         (Decinfo.frame_width * Decinfo.frame_height * 3) >> 1;
 
-      if (Decinfo.interlaced_sequence)
-        printf("INTERLACED SEQUENCE
");
+      if (Decinfo.interlaced_sequence) {
+        PRINT(("INTERLACED SEQUENCE
"));
+      }
 
       /* If -O option not used, generate default file name */
       if(out_file_name[0] == 0) {
@@ -1167,20 +1191,21 @@ int main(int argc, char **argv) {
       if(!vop_number) {
         /*disable_resync = 1; */
         disable_h263 = !Decinfo.stream_format;
-        if(Decinfo.stream_format)
-          printf("%s stream
",
+        if(Decinfo.stream_format) {
+          PRINT(("%s stream
",
                  Decinfo.stream_format ==
-                 1 ? "MPEG-4 short video" : "h.263");
-        else
-          printf("MPEG-4 stream
");
+                 1 ? "MPEG-4 short video" : "h.263"));
+        } else {
+          PRINT(("MPEG-4 stream
"));
+        }
 
-        printf("Profile and level %d
",
-               Decinfo.profile_and_level_indication);
-        printf("Pixel Aspect ratio %d : %d
",
-               Decinfo.par_width, Decinfo.par_height);
-        printf("Output format %s
",
+        PRINT(("Profile and level %d
",
+               Decinfo.profile_and_level_indication));
+        PRINT(("Pixel Aspect ratio %d : %d
",
+               Decinfo.par_width, Decinfo.par_height));
+        PRINT(("Output format %s
",
                Decinfo.output_format == MP4DEC_SEMIPLANAR_YUV420
-               ? "MP4DEC_SEMIPLANAR_YUV420" : "MP4DEC_TILED_YUV420");
+               ? "MP4DEC_SEMIPLANAR_YUV420" : "MP4DEC_TILED_YUV420"));
       } else {
 #if defined(PP_PIPELINE_ENABLED) || !defined(USE_OUTPUT_RELEASE)
         tmp_ret = writeOutputPicture(out_file_name, out_file_name_tiled, decoder,
@@ -1264,10 +1289,11 @@ int main(int argc, char **argv) {
       }
 #endif
       DecIn.enable_deblock = pp_mpeg4_filter_used();
-      if(DecIn.enable_deblock == 1)
-        printf("Deblocking filter enabled
");
-      else if(DecIn.enable_deblock == 0)
-        printf("Deblocking filter disabled
");
+      if(DecIn.enable_deblock == 1) {
+        PRINT(("Deblocking filter enabled
"));
+      } else if(DecIn.enable_deblock == 0) {
+        PRINT(("Deblocking filter disabled
"));
+      }
 
       /* If unspecified at cmd line, use minimum # of buffers, otherwise
        * use specified amount. */
@@ -1281,9 +1307,9 @@ int main(int argc, char **argv) {
 #ifdef USE_EXTERNAL_BUFFER
     case MP4DEC_WAITING_FOR_BUFFER:
       rv = MP4DecGetBufferInfo(decoder, &hbuf);
-      printf("MREG4DecGetBufferInfo ret %d
", rv);
-      printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+      PRINT(("MREG4DecGetBufferInfo ret %d
", rv));
+      PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
       if (hbuf.buf_to_free.virtual_address != NULL && res_changed) {
         add_extra_flag = 0;
         ReleaseExtBuffers();
@@ -1303,7 +1329,7 @@ int main(int argc, char **argv) {
           else
             DWLMallocRefFrm(dwl_inst, hbuf.next_buf_size, &mem);
           rv = MP4DecAddBuffer(decoder, &mem);
-          printf("MP4DecAddBuffer ret %d
", rv);
+          PRINT(("MP4DecAddBuffer ret %d
", rv));
           if(rv != MP4DEC_OK && rv != MP4DEC_WAITING_FOR_BUFFER) {
             if (pp_enabled)
               DWLFreeLinear(dwl_inst, &mem);
@@ -1366,30 +1392,31 @@ int main(int argc, char **argv) {
       if (use_peek_output &&
           MP4DecPeek(decoder, &DecPicture) == MP4DEC_PIC_RDY) {
 
-        printf("next picture returns:");
+        DEBUG_PRINT(("next picture returns:"));
         decRet(ret);
 
-        printf("PIC %d, %s", DecPicture.pic_id,
+        DEBUG_PRINT(("PIC %d, %s", DecPicture.pic_id,
                DecPicture.
-               key_picture ? "key picture,    " : "non key picture,");
+               key_picture ? "key picture,    " : "non key picture,"));
 
         /* pic coding type */
         printMpeg4PicCodingType(DecPicture.pic_coding_type);
 
-        if(DecPicture.field_picture)
-          printf(" %s ",
-                 DecPicture.top_field ? "top field.   " : "bottom field.");
-        else
-          printf(" frame picture. ");
+        if(DecPicture.field_picture) {
+          DEBUG_PRINT((" %s ",
+                 DecPicture.top_field ? "top field.   " : "bottom field."));
+        } else {
+          DEBUG_PRINT((" frame picture. "));
+        }
 
         printTimeCode(&(DecPicture.time_code));
         if(DecPicture.nbr_of_err_mbs) {
-          printf(", %d/%d error mbs
",
+          DEBUG_PRINT((", %d/%d error mbs
",
                  DecPicture.nbr_of_err_mbs,
-                 (DecPicture.frame_width >> 4) * (DecPicture.frame_height >> 4));
+                 (DecPicture.frame_width >> 4) * (DecPicture.frame_height >> 4)));
           cumulative_error_mbs += DecPicture.nbr_of_err_mbs;
         } else {
-          printf("
");
+          DEBUG_PRINT(("
"));
 
         }
 
@@ -1462,7 +1489,7 @@ int main(int argc, char **argv) {
       }
 
       if(max_num_vops && (vop_number >= max_num_vops)) {
-        printf("

Max num of pictures reached

");
+        PRINT(("

Max num of pictures reached

"));
         DecIn.data_len = 0;
         goto end2;
       }
@@ -1556,7 +1583,7 @@ int main(int argc, char **argv) {
       break;
 
     case MP4DEC_VOS_END:
-      printf("Video object seq end
");
+      PRINT(("Video object seq end
"));
       /*DecIn.data_len = 0;*/
       /*printf("DecOut.data_left %d 
", DecOut.data_left);*/
       {
@@ -1590,7 +1617,7 @@ int main(int argc, char **argv) {
       break;
 
     case MP4DEC_PARAM_ERROR:
-      printf("INCORRECT STREAM PARAMS
");
+      PRINT(("INCORRECT STREAM PARAMS
"));
       goto end2;
       break;
 
@@ -1598,7 +1625,7 @@ int main(int argc, char **argv) {
       /* Used to indicate that picture decoding needs to
        * finalized prior to corrupting next picture
       pic_rdy = 0;*/
-      printf("STREAM ERROR
");
+      PRINT(("STREAM ERROR
"));
       *(u32 *) p_strm_data = StartCode;
       DecIn.stream = (u8 *) p_strm_data;
       DecIn.stream_bus_address = stream_mem.bus_address;
@@ -1683,22 +1710,22 @@ end:
   END_SW_PERFORMANCE;
   decsw_performance();
 
-  if(Decinfo.frame_width < 1921)
-    printf("
Width %d Height %d (Cropped %dx%d)
", Decinfo.frame_width,
-           Decinfo.frame_height, Decinfo.coded_width, Decinfo.coded_height);
+  if(Decinfo.frame_width < 1921) {
+    PRINT(("
Width %d Height %d (Cropped %dx%d)
", Decinfo.frame_width,
+           Decinfo.frame_height, Decinfo.coded_width, Decinfo.coded_height));
+  }
 
   if(cumulative_error_mbs) {
-    printf("Cumulative errors: %d/%d macroblocks, ",
+    PRINT(("Cumulative errors: %d/%d macroblocks, ",
            cumulative_error_mbs,
            (Decinfo.frame_width >> 4) * (Decinfo.frame_height >> 4) *
-           vop_number);
+           vop_number));
   }
-  printf("decoded %d pictures
", vop_number);
+  PRINT(("decoded %d pictures
", vop_number));
 
-  printf( "Output file: %s
", out_file_name);
+  PRINT(( "Output file: %s
", out_file_name));
 
-  if(f_in)
-    fclose(f_in);
+  fclose(f_in);
 
   if(fout)
     fclose(fout);
@@ -1714,7 +1741,8 @@ end:
 #endif
 
   if(save_index || use_index) {
-    fclose(findex);
+    if (findex)
+      fclose(findex);
   }
 
   /* Calculate the output size and print it  */
@@ -1722,7 +1750,8 @@ end:
   if(NULL == fout) {
     stream_len = 0;
   } else {
-    fseek(fout, 0L, SEEK_END);
+    if (fseek(fout, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     stream_len = (u32) ftell(fout);
     fclose(fout);
   }
@@ -1730,7 +1759,7 @@ end:
   FINALIZE_SW_PERFORMANCE;
 
   if(cumulative_error_mbs || !vop_number) {
-    printf("ERRORS FOUND
");
+    PRINT(("ERRORS FOUND
"));
     return (1);
   } else
     return (0);
@@ -1760,8 +1789,9 @@ static u32 readDecodeUnitNoSc(FILE * fp, u8 * frame_buffer, void *dec_inst) {
       return 0;
     }
 
-    if(ftello64(fp) != next_index) {
-      fseek(fp, next_index, SEEK_SET);
+    if(ftello64(fp) != (off64_t)next_index) {
+      if (fseek(fp, next_index, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     }
 
     ret = fread(&size_tmp, sizeof(u8), 4, fp);
@@ -1770,7 +1800,8 @@ static u32 readDecodeUnitNoSc(FILE * fp, u8 * frame_buffer, void *dec_inst) {
     /* skip "00dc" from frame beginning (may signal video chunk start code).
      * also skip "0000" in case stream contains zero-size packets */
     for(;;) {
-      fseeko64( fp, offset, SEEK_SET );
+      if (fseeko64( fp, offset, SEEK_SET ) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
       if (fread( &size_tmp, sizeof(u8), 4, fp ) != 4)
         break;
       if( ( size_tmp[0] == '0' &&
@@ -1805,11 +1836,15 @@ static u32 readDecodeUnitNoSc(FILE * fp, u8 * frame_buffer, void *dec_inst) {
     fprintf(findex, "%llu
", offset);
 #endif
   }
-
-  tmp = fread( frame_buffer, sizeof(u8), size, fp );
-  if( size != tmp ) {
+  if (size > DEC_X170_MAX_STREAM) {
     strm_end = 1;
     return 0;
+  } else {
+    tmp = fread( frame_buffer, sizeof(u8), size, fp );
+    if( size != tmp ) {
+      strm_end = 1;
+      return 0;
+    }
   }
 
   offset += size + 4;
@@ -1837,7 +1872,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
   StartCode = 0;
 
   if(stop_decoding) {
-    printf("Truncated stream size reached -> stop decoding
");
+    PRINT(("Truncated stream size reached -> stop decoding
"));
     return 0;
   }
 
@@ -1848,7 +1883,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
     ret =
       TBRandomizePacketLoss(tb_cfg.tb_params.stream_packet_loss, &next_packet);
     if(ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return 0;
     }
   }
@@ -1865,7 +1900,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
     amount = next_index - cur_index;
 
     if (amount > DEC_X170_MAX_STREAM) {
-      printf("FILE ERROR
");
+      PRINT(("FILE ERROR
"));
       return 0;
     }
     idx = fread(frame_buffer, 1, amount, fp);
@@ -1966,13 +2001,15 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
                 resync_marker_length = MP4GetResyncLength(dec_inst,
                                        frame_buffer);
               }
-              if((frame_buffer[idx - 1] >> (24 - resync_marker_length))
-                  == 0x1) {
-                VopStart = 1;
-                StartCode = ((frame_buffer[idx] << 24) |
-                             (frame_buffer[idx - 1] << 16) |
-                             (frame_buffer[idx - 2] << 8) |
-                             frame_buffer[idx - 3]);
+              if (24 - resync_marker_length <= 7) {
+                if((frame_buffer[idx - 1] >> (24 - resync_marker_length))
+                    == 0x1) {
+                  VopStart = 1;
+                  StartCode = ((frame_buffer[idx] << 24) |
+                               (frame_buffer[idx - 1] << 16) |
+                               (frame_buffer[idx - 2] << 8) |
+                               frame_buffer[idx - 3]);
+                }
               }
             }
           }
@@ -2008,7 +2045,7 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
       /* stop reading if truncated stream size is reached */
       if(stream_truncate && disable_resync) {
         if(previous_used + idx >= stream_size) {
-          printf("Stream truncated at %d bytes
", previous_used + idx);
+          PRINT(("Stream truncated at %d bytes
", previous_used + idx));
           stop_decoding = 1;   /* next call return 0 size -> exit decoding main loop */
           break;
         }
@@ -2030,20 +2067,20 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
   /* If we skip this packet */
   if(pic_rdy && next_packet && ((hdrs_rdy && !stream_header_corrupt) || stream_header_corrupt)) {
     /* Get the next packet */
-    printf("Packet Loss
");
+    PRINT(("Packet Loss
"));
     return readDecodeUnit(fp, frame_buffer, dec_inst);
   } else {
     /*printf("No Packet Loss
");*/
     if (!disable_resync && pic_rdy && stream_truncate && ((hdrs_rdy && !stream_header_corrupt) || stream_header_corrupt)) {
       i32 ret;
-      printf("Original packet size %d
", idx);
+      PRINT(("Original packet size %d
", idx));
       ret = TBRandomizeU32(&idx);
       if(ret != 0) {
-        printf("RANDOM STREAM ERROR FAILED
");
+        PRINT(("RANDOM STREAM ERROR FAILED
"));
         stop_decoding = 1;   /* next call return 0 size -> exit decoding main loop */
         return 0;
       }
-      printf("Randomized packet size %d
", idx);
+      PRINT(("Randomized packet size %d
", idx));
     }
     return (idx);
   }
@@ -2056,14 +2093,14 @@ static u32 readDecodeUnit(FILE * fp, u8 * frame_buffer, void *dec_inst) {
 
 void printTimeCode(MP4DecTime * timecode) {
 
-  fprintf(stdout, "hours %u, "
+  DEBUG_PRINT(("hours %u, "
           "minutes %u, "
           "seconds %u, "
           "time_incr %u, "
           "time_res %u",
           timecode->hours,
           timecode->minutes,
-          timecode->seconds, timecode->time_incr, timecode->time_res);
+          timecode->seconds, timecode->time_incr, timecode->time_res));
 }
 
 /*------------------------------------------------------------------------------
@@ -2073,76 +2110,96 @@ void printTimeCode(MP4DecTime * timecode) {
 
 void decRet(MP4DecRet ret) {
 
-  printf("Decode result: ");
-
   switch (ret) {
   case MP4DEC_OK:
-    printf("MP4DEC_OK
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_OK
"));
     break;
   case MP4DEC_STRM_PROCESSED:
-    printf("MP4DEC_STRM_PROCESSED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_STRM_PROCESSED
"));
     break;
 #ifdef GET_FREE_BUFFER_NON_BLOCK
   case MP4DEC_NO_DECODING_BUFFER:
-    printf("MP4DEC_NO_DECODING_BUFFER
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_NO_DECODING_BUFFER
"));
     break;
 #endif
   case MP4DEC_BUF_EMPTY:
-    printf("MP4DEC_BUF_EMPTY
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_BUF_EMPTY
"));
     break;
   case MP4DEC_NONREF_PIC_SKIPPED:
-    printf("MP4DEC_NONREF_PIC_SKIPPED
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_NONREF_PIC_SKIPPED
"));
     break;
   case MP4DEC_PIC_RDY:
-    printf("MP4DEC_PIC_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_PIC_RDY
"));
     break;
   case MP4DEC_HDRS_RDY:
-    printf("MP4DEC_HDRS_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_HDRS_RDY
"));
     break;
   case MP4DEC_DP_HDRS_RDY:
-    printf("MP4DEC_DP_HDRS_RDY
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_DP_HDRS_RDY
"));
     break;
   case MP4DEC_PARAM_ERROR:
-    printf("MP4DEC_PARAM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_PARAM_ERROR
"));
     break;
   case MP4DEC_STRM_ERROR:
-    printf("MP4DEC_STRM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_STRM_ERROR
"));
     break;
   case MP4DEC_NOT_INITIALIZED:
-    printf("MP4DEC_NOT_INITIALIZED
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_NOT_INITIALIZED
"));
     break;
   case MP4DEC_MEMFAIL:
-    printf("MP4DEC_MEMFAIL
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_MEMFAIL
"));
     break;
   case MP4DEC_DWL_ERROR:
-    printf("MP4DEC_DWL_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_DWL_ERROR
"));
     break;
   case MP4DEC_HW_BUS_ERROR:
-    printf("MP4DEC_HW_BUS_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_HW_BUS_ERROR
"));
     break;
   case MP4DEC_SYSTEM_ERROR:
-    printf("MP4DEC_SYSTEM_ERROR
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_SYSTEM_ERROR
"));
     break;
   case MP4DEC_HW_TIMEOUT:
-    printf("MP4DEC_HW_TIMEOUT
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_HW_TIMEOUT
"));
     break;
   case MP4DEC_HDRS_NOT_RDY:
-    printf("MP4DEC_HDRS_NOT_RDY
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_HDRS_NOT_RDY
"));
     break;
   case MP4DEC_PIC_DECODED:
-    printf("MP4DEC_PIC_DECODED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_PIC_DECODED
"));
     break;
   case MP4DEC_PIC_CONSUMED:
-    printf("MP4DEC_PIC_CONSUMED
");
+    DEBUG_PRINT(("Decode result: "));
+    DEBUG_PRINT(("MP4DEC_PIC_CONSUMED
"));
     break;
   case MP4DEC_FORMAT_NOT_SUPPORTED:
-    printf("MP4DEC_FORMAT_NOT_SUPPORTED
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_FORMAT_NOT_SUPPORTED
"));
     break;
   case MP4DEC_STRM_NOT_SUPPORTED:
-    printf("MP4DEC_STRM_NOT_SUPPORTED
");
+    PRINT(("Decode result: "));
+    PRINT(("MP4DEC_STRM_NOT_SUPPORTED
"));
     break;
   default:
-    printf("Other %d
", ret);
+    PRINT(("Decode result: "));
+    PRINT(("Other %d
", ret));
     break;
   }
 }
@@ -2157,16 +2214,16 @@ void decRet(MP4DecRet ret) {
 void printMpeg4PicCodingType(u32 pic_type) {
   switch (pic_type) {
   case DEC_PIC_TYPE_I:
-    printf(" DEC_PIC_TYPE_I,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_I,"));
     break;
   case DEC_PIC_TYPE_P:
-    printf(" DEC_PIC_TYPE_P,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_P,"));
     break;
   case DEC_PIC_TYPE_B:
-    printf(" DEC_PIC_TYPE_B,");
+    DEBUG_PRINT((" DEC_PIC_TYPE_B,"));
     break;
   default:
-    printf("Other %d
", pic_type);
+    DEBUG_PRINT(("Other %d
", pic_type));
     break;
   }
 }
@@ -2194,11 +2251,11 @@ void printMP4Version(void) {
    */
 
   dec_version = MP4DecGetAPIVersion();
-  printf("
Api version:  %d.%d, ", dec_version.major, dec_version.minor);
+  PRINT(("
Api version:  %d.%d, ", dec_version.major, dec_version.minor));
 
   dec_build = MP4DecGetBuild();
-  printf("sw build nbr: %d, hw build nbr: %x

",
-         dec_build.sw_build, dec_build.hw_build);
+  PRINT(("sw build nbr: %d, hw build nbr: %x

",
+         dec_build.sw_build, dec_build.hw_build));
 
 }
 
@@ -2228,14 +2285,14 @@ void GetUserData(MP4DecInst dec_inst,
   /* get info from the decoder */
   tmp = MP4DecGetInfo(dec_inst, &dec_info);
   if(tmp != 0) {
-    printf(("ERROR, exiting...
"));
+    PRINT(("ERROR, exiting...
"));
   }
   switch (type) {
   case MP4DEC_USER_DATA_VOS:
     size = dec_info.user_data_voslen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
     if (data == NULL) {
-      printf(("ERROR, calloc failed!
"));
+      PRINT(("ERROR, calloc failed!
"));
       return;
     }
     user_data_config.p_user_data_vos = data;
@@ -2245,7 +2302,7 @@ void GetUserData(MP4DecInst dec_inst,
     size = dec_info.user_data_visolen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
     if (data == NULL) {
-      printf(("ERROR, calloc failed!
"));
+      PRINT(("ERROR, calloc failed!
"));
       return;
     }
     user_data_config.p_user_data_viso = data;
@@ -2255,7 +2312,7 @@ void GetUserData(MP4DecInst dec_inst,
     size = dec_info.user_data_vollen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
     if (data == NULL) {
-      printf(("ERROR, calloc failed!
"));
+      PRINT(("ERROR, calloc failed!
"));
       return;
     }
     user_data_config.p_user_data_vol = data;
@@ -2265,13 +2322,13 @@ void GetUserData(MP4DecInst dec_inst,
     size = dec_info.user_data_govlen;
     data = (u8 *) calloc(size + 1, sizeof(u8));
     if (data == NULL) {
-      printf(("ERROR, calloc failed!
"));
+      PRINT(("ERROR, calloc failed!
"));
       return;
     }
     user_data_config.p_user_data_gov = data;
     user_data_config.user_data_govmax_len = size;
 
-    printf("VOS user data size: %d
", size);
+    PRINT(("VOS user data size: %d
", size));
     break;
   default:
     break;
@@ -2281,19 +2338,18 @@ void GetUserData(MP4DecInst dec_inst,
   /* get user data */
   tmp = MP4DecGetUserData(dec_inst, &DecIn, &user_data_config);
   if(tmp != 0) {
-    printf("ERROR, exiting...
");
+    PRINT(("ERROR, exiting...
"));
   }
 
   /* print user data */
-  if(type == MP4DEC_USER_DATA_VOS)
-    printf("VOS user data: %s
", data);
-  else if(type == MP4DEC_USER_DATA_VISO)
-    printf("VISO user data: %s
", data);
-  else if(type == MP4DEC_USER_DATA_VOL)
-    printf("VOL user data: %s
", data);
-  else if(type == MP4DEC_USER_DATA_GOV) {
-    printf("
Gov user data: %s
", data);
-    fflush(stdout);
+  if(type == MP4DEC_USER_DATA_VOS) {
+    PRINT(("VOS user data: %s
", data));
+  } else if(type == MP4DEC_USER_DATA_VISO) {
+    PRINT(("VISO user data: %s
", data));
+  } else if(type == MP4DEC_USER_DATA_VOL) {
+    PRINT(("VOL user data: %s
", data));
+  } else if(type == MP4DEC_USER_DATA_GOV) {
+    PRINT(("
Gov user data: %s
", data));
   }
   /* free allocated memory */
   if(data)
@@ -2339,7 +2395,7 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
       tmp_ret = MP4DecNextPicture(decoder, &DecPicture, end ? 1 : 0);
     decsw_performance();
 
-    printf("next picture returns:");
+    DEBUG_PRINT(("next picture returns:"));
     decRet(tmp_ret);
 #ifdef USE_EXTERNAL_BUFFER
     temp_addr = (u32*)(DecPicture.output_picture);
@@ -2351,7 +2407,7 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
       if(strcmp(filename, "none") != 0) {
         fout = fopen(filename, "wb");
         if(fout == NULL) {
-          printf("UNABLE TO OPEN OUTPUT FILE
");
+          PRINT(("UNABLE TO OPEN OUTPUT FILE
"));
           return MP4DEC_PARAM_ERROR;
         }
       }
@@ -2407,26 +2463,27 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
       continue;
 
     if(tmp_ret == MP4DEC_PIC_RDY) {
-      printf("PIC %d, %s", DecPicture.pic_id,
+      DEBUG_PRINT(("PIC %d, %s", DecPicture.pic_id,
              DecPicture.
-             key_picture ? "key picture,    " : "non key picture,");
+             key_picture ? "key picture,    " : "non key picture,"));
       /* pic coding type */
       printMpeg4PicCodingType(DecPicture.pic_coding_type);
 
-      if(DecPicture.field_picture)
-        printf(" %s ",
-               DecPicture.top_field ? "top field.   " : "bottom field.");
-      else
-        printf(" frame picture. ");
+      if(DecPicture.field_picture) {
+        DEBUG_PRINT((" %s ",
+               DecPicture.top_field ? "top field.   " : "bottom field."));
+      } else {
+        DEBUG_PRINT((" frame picture. "));
+      }
 
       printTimeCode(&(DecPicture.time_code));
       if(DecPicture.nbr_of_err_mbs) {
-        printf(", %d/%d error mbs
",
+        DEBUG_PRINT((", %d/%d error mbs
",
                DecPicture.nbr_of_err_mbs,
-               (frame_width >> 4) * (frame_height >> 4));
+               (frame_width >> 4) * (frame_height >> 4)));
         cumulative_error_mbs += DecPicture.nbr_of_err_mbs;
       } else {
-        printf("
");
+        DEBUG_PRINT(("
"));
 
       }
 
@@ -2455,7 +2512,7 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
               DEC_X170_BIG_ENDIAN) {
             pic_copy = (u8 *) malloc(outp_byte_size);
             if(NULL == pic_copy) {
-              printf("MALLOC FAILED @ %s %d", __FILE__, __LINE__);
+              PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
               if(raster_scan)
                 free(raster_scan);
               return MP4DEC_PARAM_ERROR;
@@ -2467,8 +2524,9 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
 #endif
           /* Write  MD5 checksum instead of the frame */
 #ifdef MD5SUM
-          TBWriteFrameMD5Sum(fout, p_yuv_out,
-                             outp_byte_size, vop_number);
+          if (fout)
+            TBWriteFrameMD5Sum(fout, p_yuv_out,
+                               outp_byte_size, vop_number);
 
           /* tiled */
 #if 0
@@ -2483,7 +2541,8 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
 #endif
 #else
           if(!planar_output) {
-            fwrite(p_yuv_out, 1, outp_byte_size, fout);
+            if (fout)
+              fwrite(p_yuv_out, 1, outp_byte_size, fout);
             /* tiled */
             if(tiled_output) {
               assert(frame_width % 16 == 0);
@@ -2496,11 +2555,13 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
             }
           } else if(!crop_output) {
             tmp = outp_byte_size * 2 / 3;
-            fwrite(p_yuv_out, 1, tmp, fout);
-            for(i = 0; i < tmp / 4; i++)
-              fwrite(p_yuv_out + tmp + i * 2, 1, 1, fout);
-            for(i = 0; i < tmp / 4; i++)
-              fwrite(p_yuv_out + tmp + 1 + i * 2, 1, 1, fout);
+            if (fout) {
+              fwrite(p_yuv_out, 1, tmp, fout);
+              for(i = 0; i < tmp / 4; i++)
+                fwrite(p_yuv_out + tmp + i * 2, 1, 1, fout);
+              for(i = 0; i < tmp / 4; i++)
+                fwrite(p_yuv_out + tmp + 1 + i * 2, 1, 1, fout);
+            }
           } else {
             u32 j;
             u8 *p;
@@ -2508,19 +2569,22 @@ MP4DecRet writeOutputPicture(char *filename, char *filename_tiled,
             tmp = outp_byte_size * 2 / 3;
             p = p_yuv_out;
             for(i = 0; i < DecPicture.coded_height; i++) {
-              fwrite(p, 1, DecPicture.coded_width, fout);
+              if (fout)
+                fwrite(p, 1, DecPicture.coded_width, fout);
               p += DecPicture.frame_width;
             }
             p = p_yuv_out + tmp;
             for(i = 0; i < DecPicture.coded_height / 2; i++) {
               for(j = 0; j < DecPicture.coded_width / 2; j++)
-                fwrite(p + 2 * j, 1, 1, fout);
+                if (fout)
+                  fwrite(p + 2 * j, 1, 1, fout);
               p += DecPicture.frame_width;
             }
             p = p_yuv_out + tmp + 1;
             for(i = 0; i < DecPicture.coded_height / 2; i++) {
               for(j = 0; j < DecPicture.coded_width / 2; j++)
-                fwrite(p + 2 * j, 1, 1, fout);
+                if (fout)
+                  fwrite(p + 2 * j, 1, 1, fout);
               p += DecPicture.frame_width;
             }
           }
@@ -2589,7 +2653,7 @@ void WriteOutput(char *filename, char *filename_tiled,
     if(strcmp(filename, "none") != 0) {
       fout = fopen(filename, "wb");
       if(fout == NULL) {
-        printf("UNABLE TO OPEN OUTPUT FILE
");
+        PRINT(("UNABLE TO OPEN OUTPUT FILE
"));
         return;
       }
     }
@@ -2664,7 +2728,7 @@ void WriteOutput(char *filename, char *filename_tiled,
         DEC_X170_BIG_ENDIAN) {
       pic_copy = (u8 *) malloc(pic_size);
       if(NULL == pic_copy) {
-        printf("MALLOC FAILED @ %s %d", __FILE__, __LINE__);
+        PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
         if(raster_scan)
           free(raster_scan);
         return;
diff --git a/decoder_sw/software/test/vc1/Makefile b/decoder_sw/software/test/vc1/Makefile
index 4af01c5..4596733 100755
--- a/decoder_sw/software/test/vc1/Makefile
+++ b/decoder_sw/software/test/vc1/Makefile
@@ -69,6 +69,8 @@ TARGET_ENV=integrator
 
 # Enable SW performance  measurement
 #CFLAGS = -DSW_PERFORMANCE
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
 
 ifeq ($(USE_MD5SUM), y)
         MD5SUM = -DMD5SUM
diff --git a/decoder_sw/software/test/vc1/dectestbench.c b/decoder_sw/software/test/vc1/dectestbench.c
index 8b362d4..81c66b0 100755
--- a/decoder_sw/software/test/vc1/dectestbench.c
+++ b/decoder_sw/software/test/vc1/dectestbench.c
@@ -85,8 +85,20 @@ Module defines
 
 #define VC1_MAX_STREAM_SIZE  DEC_X170_MAX_STREAM>>1
 
-/* Debug prints */
-#define DEBUG_PRINT(argv) printf argv
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
 
 /*void decsw_performance(void)  __attribute__((noinline));*/
 void decsw_performance(void);
@@ -113,7 +125,7 @@ FILE *finput;
 
 i32 DecodeRCV(u8 *stream, u32 strm_len, VC1DecMetaData *meta_data);
 u32 DecodeFrameLayerData(u8 *stream);
-static void vc1DecPrintReturnValue(VC1DecRet ret);
+static void vc1DecPrintReturnValue(VC1DecRet ret, char *str);
 static u32 GetNextDuSize(const u8* stream, const u8* stream_start,
                          u32 strm_len, u32 *skipped_bytes);
 void printVc1PicCodingType(u32 *pic_type);
@@ -229,10 +241,10 @@ static void *AddBufferThread(void *arg) {
 
 void ReleaseExtBuffers() {
   int i;
-  printf("Releasing %d external frame buffers
", num_buffers);
+  PRINT(("Releasing %d external frame buffers
", num_buffers));
   pthread_mutex_lock(&ext_buffer_contro);
   for(i=0; i<num_buffers; i++) {
-    printf("Freeing buffer %p
", ext_buffers[i].virtual_address);
+    PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
     if (pp_enabled)
       DWLFreeLinear(dwl_inst, &ext_buffers[i]);
     else
@@ -340,8 +352,7 @@ static void* vc1_output_thread(void* arg) {
     ret = VC1DecNextPicture(dec_inst, &dec_picture, 0);
     if(ret == VC1DEC_PIC_RDY) {
       if(!use_peek_output) {
-        DEBUG_PRINT(("VC1DecNextPicture returned: "));
-        vc1DecPrintReturnValue(ret);
+        vc1DecPrintReturnValue(ret, "VC1DecNextPicture returned: ");
 
         /* Increment display number for every displayed picture */
         pic_display_number++;
@@ -351,12 +362,13 @@ static void* vc1_output_thread(void* arg) {
                      dec_picture.coded_height, dec_picture.number_of_err_mbs,
                      dec_picture.key_picture ? "(KEYFRAME)" : ""));
 
-        if (dec_picture.interlaced && dec_picture.field_picture)
+        if (dec_picture.interlaced && dec_picture.field_picture) {
           DEBUG_PRINT(("Interlaced field %s, ", dec_picture.top_field ? "(Top)" : "(Bottom)"));
-        else if (dec_picture.interlaced && !dec_picture.field_picture)
+        } else if (dec_picture.interlaced && !dec_picture.field_picture) {
           DEBUG_PRINT(("Interlaced frame, "));
-        else
+        } else {
           DEBUG_PRINT(("Progressive, "));
+        }
 
         /* pic coding type */
         printVc1PicCodingType(dec_picture.pic_coding_type);
@@ -585,42 +597,43 @@ int main(int argc, char **argv) {
                   "HW Supports video decoding up to %d pixels,
",
                   hw_config.max_dec_pic_width));
 
-    if(hw_config.pp_support)
+    if(hw_config.pp_support) {
       DEBUG_PRINT((
                     "Maximum Post-processor output size %d pixels

",
                     hw_config.max_pp_out_pic_width));
-    else
+    } else {
       DEBUG_PRINT(("Post-Processor not supported

"));
+    }
   }
 
 #ifndef PP_PIPELINE_ENABLED
   /* Check that enough command line arguments given, if not -> print usage
   * information out */
   if(argc < 2) {
-    DEBUG_PRINT(("Usage: %s [options] file.rcv
", argv[0]));
-    DEBUG_PRINT(("	-Nn forces decoding to stop after n pictures
"));
-    DEBUG_PRINT(("	-Ooutfile write output to \"outfile\" (default out_wxxxhyyy.yuv)
"));
-    DEBUG_PRINT(("	-X Disable output file writing
"));
-    DEBUG_PRINT(("	-C display cropped image (default decoded image)
"));
-    DEBUG_PRINT(("	-Sfile.hex stream control trace file
"));
-    DEBUG_PRINT(("	-L enable support for long streams.
"));
-    DEBUG_PRINT(("	-P write planar output.
"));
-    DEBUG_PRINT(("	-Bn to use n frame buffers in decoder
"));
-    DEBUG_PRINT(("	-I save index file
"));
-    DEBUG_PRINT(("	-E use tiled reference frame format.
"));
-    DEBUG_PRINT(("	-G convert tiled output pictures to raster scan
"));
-    DEBUG_PRINT(("	-Y Write output as Interlaced Fields (instead of Frames).
"));
-    DEBUG_PRINT(("	-F Enable frame picture writing in multiresolutin output.
"));
-    DEBUG_PRINT(("	-Q Skip decoding non-reference pictures.
"));
-    DEBUG_PRINT(("	-Z output pictures using VC1DecPeek() function
"));
-    DEBUG_PRINT(("	--separate-fields-in-dpb DPB stores interlaced content"\
+    PRINT(("Usage: %s [options] file.rcv
", argv[0]));
+    PRINT(("	-Nn forces decoding to stop after n pictures
"));
+    PRINT(("	-Ooutfile write output to \"outfile\" (default out_wxxxhyyy.yuv)
"));
+    PRINT(("	-X Disable output file writing
"));
+    PRINT(("	-C display cropped image (default decoded image)
"));
+    PRINT(("	-Sfile.hex stream control trace file
"));
+    PRINT(("	-L enable support for long streams.
"));
+    PRINT(("	-P write planar output.
"));
+    PRINT(("	-Bn to use n frame buffers in decoder
"));
+    PRINT(("	-I save index file
"));
+    PRINT(("	-E use tiled reference frame format.
"));
+    PRINT(("	-G convert tiled output pictures to raster scan
"));
+    PRINT(("	-Y Write output as Interlaced Fields (instead of Frames).
"));
+    PRINT(("	-F Enable frame picture writing in multiresolutin output.
"));
+    PRINT(("	-Q Skip decoding non-reference pictures.
"));
+    PRINT(("	-Z output pictures using VC1DecPeek() function
"));
+    PRINT(("	--separate-fields-in-dpb DPB stores interlaced content"\
                  " as fields (default: frames)
"));
-    DEBUG_PRINT(("	--output-frame-dpb Convert output to frame mode even if"\
+    PRINT(("	--output-frame-dpb Convert output to frame mode even if"\
                  " field DPB mode used
"));
 #ifdef USE_EXTERNAL_BUFFER
-    DEBUG_PRINT(("	-A add extra external buffer randomly
"));
+    PRINT(("	-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    DEBUG_PRINT(("	-a allocate extra external buffer in output thread
"));
+    PRINT(("	-a allocate extra external buffer in output thread
"));
 #endif
 #endif
     return 0;
@@ -635,7 +648,13 @@ int main(int argc, char **argv) {
     if(strncmp(argv[i], "-N", 2) == 0) {
       max_num_pics = (u32) atoi(argv[i] + 2);
     } else if(strncmp(argv[i], "-O", 2) == 0) {
-      strcpy(out_file_name, argv[i] + 2);
+      /* -1 to accomodate for the null tern=minator */
+      if (sizeof(out_file_name) - 1 < strlen(argv[i] + 2)) {
+        PRINT(("The output file name size overflows buffer size(256)!
"));
+        return 1;
+      }  else {
+        strcpy(out_file_name, argv[i] + 2);
+      }
     } else if(strcmp(argv[i], "-X") == 0) {
       disable_output_writing = 1;
     } else if(strcmp(argv[i], "-C") == 0) {
@@ -690,11 +709,11 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
-      DEBUG_PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
+      PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
       return 1;
     }
 
@@ -704,7 +723,7 @@ int main(int argc, char **argv) {
   * fails -> exit */
   finput = fopen(argv[argc - 1], "rb");
   if(finput == NULL) {
-    DEBUG_PRINT(("UNABLE TO OPEN INPUT FILE: %s
", argv[argc - 1]));
+    PRINT(("UNABLE TO OPEN INPUT FILE: %s
", argv[argc - 1]));
     return -1;
   }
 #else
@@ -725,27 +744,25 @@ int main(int argc, char **argv) {
   /* Check that enough command line arguments given, if not -> print usage
    * information out */
   if(argc < 3) {
-    DEBUG_PRINT(("Usage: %s [-Nn] [-X] [-L] file.rcv pp.cfg
", argv[0]));
-    DEBUG_PRINT(("	-Nn forces decoding to stop after n pictures
"));
-    DEBUG_PRINT(("	-X disable output file writing
"));
-    DEBUG_PRINT(("	-Bn to use n frame buffers in decoder
"));
-    DEBUG_PRINT(("	-L enable support for long streams.
"));
-    DEBUG_PRINT(("	-I save index file
"));
-    DEBUG_PRINT(("	-E use tiled reference frame format.
"));
-    DEBUG_PRINT(("	-Q Skip decoding non-reference pictures.
"));
-    DEBUG_PRINT(("	--separate-fields-in-dpb DPB stores interlaced content"\
+    PRINT(("Usage: %s [-Nn] [-X] [-L] file.rcv pp.cfg
", argv[0]));
+    PRINT(("	-Nn forces decoding to stop after n pictures
"));
+    PRINT(("	-X disable output file writing
"));
+    PRINT(("	-Bn to use n frame buffers in decoder
"));
+    PRINT(("	-L enable support for long streams.
"));
+    PRINT(("	-I save index file
"));
+    PRINT(("	-E use tiled reference frame format.
"));
+    PRINT(("	-Q Skip decoding non-reference pictures.
"));
+    PRINT(("	--separate-fields-in-dpb DPB stores interlaced content"\
                  " as fields (default: frames)
"));
 #ifdef USE_EXTERNAL_BUFFER
-    DEBUG_PRINT(("	-A add extra external buffer randomly
"));
+    PRINT(("	-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    DEBUG_PRINT(("	-a allocate extra external buffer in output thread
"));
+    PRINT(("	-a allocate extra external buffer in output thread
"));
 #endif
 #endif
     return 0;
   }
 
-  remove("pp_out.yuv");
-
   /* read command line arguments */
   for(i = 1; i < (u32) (argc - 2); i++) {
     if(strncmp(argv[i], "-N", 2) == 0) {
@@ -789,11 +806,11 @@ int main(int argc, char **argv) {
         ds_ratio_x = argv[i][2] - '0';
         ds_ratio_y = argv[i][4] - '0';
       } else {
-        printf("Illegal parameter: %s
", argv[i]);
+        PRINT(("Illegal parameter: %s
", argv[i]));
         return 1;
       }
     } else {
-      DEBUG_PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
+      PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
       return -1;
     }
   }
@@ -801,20 +818,20 @@ int main(int argc, char **argv) {
   /* open data file */
   finput = fopen(argv[argc - 2], "rb");
   if(finput == NULL) {
-    DEBUG_PRINT(("UNABLE TO OPEN INPUT FILE: %s
", argv[argc - 2]));
+    PRINT(("UNABLE TO OPEN INPUT FILE: %s
", argv[argc - 2]));
     return -1;
   }
 #endif
 #ifdef ASIC_TRACE_SUPPORT
   tmp = openTraceFiles();
   if (!tmp) {
-    DEBUG_PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
+    PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
   }
 #endif
   if(save_index) {
     f_index = fopen("stream.cfg", "w");
     if(f_index == NULL) {
-      DEBUG_PRINT(("UNABLE TO OPEN INDEX FILE: \"stream.cfg\"
"));
+      PRINT(("UNABLE TO OPEN INDEX FILE: \"stream.cfg\"
"));
       return -1;
     }
   } else {
@@ -827,8 +844,8 @@ int main(int argc, char **argv) {
   TBSetDefaultCfg(&tb_cfg);
   f_tbcfg = fopen("tb.cfg", "r");
   if (f_tbcfg == NULL) {
-    DEBUG_PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
-    DEBUG_PRINT(("USING DEFAULT CONFIGURATION
"));
+    PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if (TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
@@ -890,7 +907,7 @@ int main(int argc, char **argv) {
 
   tmp_strm = (u8*) malloc(100);
   if (NULL == tmp_strm) {
-    DEBUG_PRINT(("MALLOC FAILED
"));
+    PRINT(("MALLOC FAILED
"));
     return -1;
   }
 
@@ -898,6 +915,7 @@ int main(int argc, char **argv) {
    * DecodeRCV checks that size is at
    * least RCV_METADATA_MAX_SIZE bytes) */
   ra = fread(tmp_strm, sizeof(u8), RCV_METADATA_MAX_SIZE, finput);
+  (void)(ra);
   rewind(finput);
 
   /* Advanced profile if startcode prefix found */
@@ -913,7 +931,7 @@ int main(int argc, char **argv) {
     * VC1DecUnpackMetaData function */
     tmp = DecodeRCV(tmp_strm, RCV_METADATA_MAX_SIZE, &meta_data);
     if (tmp != 0) {
-      DEBUG_PRINT(("DECODING RCV FAILED
"));
+      PRINT(("DECODING RCV FAILED
"));
       free(tmp_strm);
       return -1;
     }
@@ -930,7 +948,7 @@ int main(int argc, char **argv) {
     DEBUG_PRINT(("meta_data[3] %x
", *(tmp_strm+11)));
     tmp = TBRandomizeBitSwapInStream(tmp_strm+8, 4, tb_cfg.tb_params.stream_bit_swap);
     if (tmp != 0) {
-      DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       free(tmp_strm);
       return -1;
     }
@@ -947,7 +965,7 @@ int main(int argc, char **argv) {
     END_SW_PERFORMANCE
     decsw_performance();
     if (tmp != VC1DEC_OK) {
-      DEBUG_PRINT(("UNPACKING META DATA FAILED
"));
+      PRINT(("UNPACKING META DATA FAILED
"));
       free(tmp_strm);
       return -1;
     }
@@ -974,7 +992,7 @@ int main(int argc, char **argv) {
     rnd_value = 1920 + 48;
     tmp = TBRandomizeU32(&rnd_value);
     if (tmp != 0) {
-      DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       free(tmp_strm);
       return -1;
     }
@@ -986,7 +1004,7 @@ int main(int argc, char **argv) {
     rnd_value = 1920 + 48;
     tmp = TBRandomizeU32(&rnd_value);
     if (tmp != 0) {
-      DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       free(tmp_strm);
       return -1;
     }
@@ -1028,7 +1046,7 @@ int main(int argc, char **argv) {
   decsw_performance();
 
   if (ret != VC1DEC_OK) {
-    DEBUG_PRINT(("DECODER INITIALIZATION FAILED
"));
+    PRINT(("DECODER INITIALIZATION FAILED
"));
     goto end;
   }
 
@@ -1074,7 +1092,8 @@ int main(int argc, char **argv) {
 
   if (!long_stream) {
     /* check size of the input file -> length of the stream in bytes */
-    fseek(finput, 0L, SEEK_END);
+    if (fseek(finput, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     strm_len = (u32) ftell(finput);
     rewind(finput);
 
@@ -1083,7 +1102,7 @@ int main(int argc, char **argv) {
       DEBUG_PRINT(("strm_len %d
", strm_len));
       tmp = TBRandomizeU32(&strm_len);
       if (tmp != 0) {
-        DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
+        PRINT(("RANDOM STREAM ERROR FAILED
"));
         goto end;
       }
       DEBUG_PRINT(("Randomized strm_len %d
", strm_len));
@@ -1094,19 +1113,20 @@ int main(int argc, char **argv) {
 
     if(DWLMallocLinear(((decContainer_t*)dec_inst)->dwl, strm_len, &stream_mem)
         != DWL_OK ) {
-      DEBUG_PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+      PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
       goto end;
     }
 
     byte_strm_start = (u8 *) stream_mem.virtual_address;
 
     if(byte_strm_start == NULL) {
-      DEBUG_PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+      PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
       goto end;
     }
 
     /* read input stream from file to buffer and close input file */
     ra = fread(byte_strm_start, sizeof(u8), strm_len, finput);
+    (void)(ra);
     fclose(finput);
 
     /* initialize VC1DecDecode() input structure */
@@ -1130,7 +1150,7 @@ int main(int argc, char **argv) {
     if(DWLMallocLinear(((decContainer_t *) dec_inst)->dwl,
                        VC1_MAX_STREAM_SIZE,
                        &stream_mem) != DWL_OK ) {
-      DEBUG_PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+      PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
       goto end;
     }
     byte_strm_start = (u8 *) stream_mem.virtual_address;
@@ -1140,17 +1160,24 @@ int main(int argc, char **argv) {
     if (!advanced) {
       /* Read meta data and frame layer data */
       ra = fread(tmp_strm, sizeof(u8), ( 4 + 4 * rcv_v2 ) *4 + 4 + 4 * rcv_v2 + rcv_metadata_size, finput);
+      (void)(ra);
       if (ferror(finput)) {
-        DEBUG_PRINT(("STREAM READ ERROR
"));
+        PRINT(("STREAM READ ERROR
"));
         goto end;
       }
       if (feof(finput)) {
-        DEBUG_PRINT(("END OF STREAM
"));
+        PRINT(("END OF STREAM
"));
         goto end;
       }
 
       dec_input.stream_size = DecodeFrameLayerData(tmp_strm + ( 4 + 4 * rcv_v2 ) *4 + rcv_metadata_size);
-      ra = fread( (u8*)dec_input.stream, sizeof(u8), dec_input.stream_size, finput );
+      if (dec_input.stream_size > DEC_X170_MAX_STREAM) {
+        PRINT(("STREAM READ ERROR
"));
+        goto end;
+      } else {
+        ra = fread( (u8*)dec_input.stream, sizeof(u8), dec_input.stream_size, finput );
+        (void)(ra);
+      }
     } else {
       if(use_index) {
         dec_input.stream_size = fillBuffer((u8*)dec_input.stream);
@@ -1163,11 +1190,11 @@ int main(int argc, char **argv) {
     }
 
     if (ferror(finput)) {
-      DEBUG_PRINT(("STREAM READ ERROR
"));
+      PRINT(("STREAM READ ERROR
"));
       goto end;
     }
     if (feof(finput)) {
-      DEBUG_PRINT(("STREAM WILL END
"));
+      PRINT(("STREAM WILL END
"));
       /*goto end;*/
     }
   }
@@ -1214,8 +1241,9 @@ int main(int argc, char **argv) {
   /* main decoding loop */
   do {
     dec_input.pic_id = pic_id;
-    if (ret != VC1DEC_NO_DECODING_BUFFER)
-    DEBUG_PRINT(("Starting to decode picture ID %d
", pic_id));
+    if (ret != VC1DEC_NO_DECODING_BUFFER) {
+      DEBUG_PRINT(("Starting to decode picture ID %d
", pic_id));
+    }
 
     /*printf("dec_input.stream_size %d
", dec_input.stream_size);*/
 
@@ -1223,7 +1251,7 @@ int main(int argc, char **argv) {
       i32 ret;
       ret = TBRandomizeU32(&dec_input.stream_size);
       if(ret != 0) {
-        DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
+        PRINT(("RANDOM STREAM ERROR FAILED
"));
         return 0;
       }
       DEBUG_PRINT(("Randomized stream size %d
", dec_input.stream_size));
@@ -1238,12 +1266,12 @@ int main(int argc, char **argv) {
                                            dec_input.stream_size,
                                            tb_cfg.tb_params.stream_bit_swap);
           if (tmp != 0) {
-            DEBUG_PRINT(("RANDOM STREAM ERROR FAILED
"));
+            PRINT(("RANDOM STREAM ERROR FAILED
"));
             goto end;
           }
 
           corrupted_bytes = dec_input.stream_size;
-          printf("corrupted_bytes %d
", corrupted_bytes);
+          PRINT(("corrupted_bytes %d
", corrupted_bytes));
         }
       }
     }
@@ -1258,8 +1286,8 @@ int main(int argc, char **argv) {
       END_SW_PERFORMANCE;
       /*DEBUG_PRINT(("dec_output.data_left %d
", dec_output.data_left));*/
       decsw_performance();
-      DEBUG_PRINT(("VC1DecDecode returned: "));
-      vc1DecPrintReturnValue(ret);
+
+      vc1DecPrintReturnValue(ret, "VC1DecDecode returned: ");
 
 #if 1
       /* there is some data left */
@@ -1267,7 +1295,7 @@ int main(int argc, char **argv) {
       /* if advanced but long stream mode, stream is read again from file */
       /* if slice mode, test bench does not care of dec_output.data_left but also skips to next slice */
       if(dec_output.data_left && advanced && !long_stream && !slice_mode) {
-        printf("dec_output.data_left %d
", dec_output.data_left);
+        DEBUG_PRINT(("dec_output.data_left %d
", dec_output.data_left));
         corrupted_bytes -= (dec_input.stream_size - dec_output.data_left);
       } else {
         corrupted_bytes = 0;
@@ -1287,8 +1315,8 @@ int main(int argc, char **argv) {
       decsw_performance();
       VC1DecGetInfo(dec_inst, &info);
       decsw_performance();
-      DEBUG_PRINT(("RESOLUTION CHANGED
"));
-      DEBUG_PRINT(("New resolution is %dx%d
",
+      PRINT(("RESOLUTION CHANGED
"));
+      PRINT(("New resolution is %dx%d
",
                    info.coded_width, info.coded_height));
 
 #ifdef PP_PIPELINE_ENABLED
@@ -1314,7 +1342,7 @@ int main(int argc, char **argv) {
       if (pp_change_resolution( ((info.coded_width+7) & ~7),
                                 ((info.coded_height+7) & ~7),
                                 &tb_cfg) ) {
-        DEBUG_PRINT(("PP CONFIG FAILED!!!
"));
+        PRINT(("PP CONFIG FAILED!!!
"));
         goto end;
       }
 #endif
@@ -1324,9 +1352,9 @@ int main(int argc, char **argv) {
       /* Set a flag to indicate that headers are ready */
 #ifdef USE_EXTERNAL_BUFFER
       rv = VC1DecGetBufferInfo(dec_inst, &hbuf);
-      printf("VC1DecGetBufferInfo ret %d
", rv);
-      printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+      PRINT(("VC1DecGetBufferInfo ret %d
", rv));
+      PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+             (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 #endif
       hdrs_rdy = 1;
       new_headers = 1;
@@ -1362,7 +1390,8 @@ int main(int argc, char **argv) {
         } else {
           tmp = (dec_output.p_stream_curr_pos - dec_input.stream);
           stream_pos += tmp;
-          fseeko64( finput, stream_pos, SEEK_SET );
+          if (fseeko64( finput, stream_pos, SEEK_SET ) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
           dec_input.stream_size =
             fread((u8*)dec_input.stream, sizeof(u8), VC1_MAX_STREAM_SIZE, finput);
 
@@ -1371,7 +1400,8 @@ int main(int argc, char **argv) {
               GetNextDuSize((u8*)dec_input.stream,
                             dec_input.stream, dec_input.stream_size, &skipped_bytes);
             stream_pos += skipped_bytes;
-            fseeko64( finput, stream_pos, SEEK_SET );
+            if (fseeko64( finput, stream_pos, SEEK_SET ) != 0)
+              fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
             if(save_index) {
               if(dec_input.stream[0] == 0 &&
                   dec_input.stream[1] == 0 &&
@@ -1389,11 +1419,11 @@ int main(int argc, char **argv) {
           }
         }
         if (ferror(finput)) {
-          DEBUG_PRINT(("STREAM READ ERROR
"));
+          PRINT(("STREAM READ ERROR
"));
           goto end;
         }
         if (feof(finput)) {
-          DEBUG_PRINT(("STREAM WILL END
"));
+          PRINT(("STREAM WILL END
"));
           /*goto end;*/
         }
       }
@@ -1422,8 +1452,9 @@ int main(int argc, char **argv) {
         if (info.interlaced_sequence) {
           DEBUG_PRINT(("Interlaced sequence
"));
           field_output = 1;
-        } else
+        } else {
           DEBUG_PRINT(("Progressive sequence
"));
+        }
 
         DEBUG_PRINT(("Max size %dx%d
", info.max_coded_width, info.max_coded_height));
         DEBUG_PRINT(("Coded size %dx%d
", info.coded_width, info.coded_height));
@@ -1558,12 +1589,13 @@ int main(int argc, char **argv) {
                      dec_picture.coded_height, dec_picture.number_of_err_mbs,
                      dec_picture.key_picture ? "(KEYFRAME)" : ""));
 
-        if (dec_picture.interlaced && dec_picture.field_picture)
+        if (dec_picture.interlaced && dec_picture.field_picture) {
           DEBUG_PRINT(("Interlaced field %s, ", dec_picture.top_field ? "(Top)" : "(Bottom)"));
-        else if (dec_picture.interlaced && !dec_picture.field_picture)
+        } else if (dec_picture.interlaced && !dec_picture.field_picture) {
           DEBUG_PRINT(("Interlaced frame, "));
-        else
+        } else {
           DEBUG_PRINT(("Progressive, "));
+        }
 
         /* pic coding type */
         printVc1PicCodingType(dec_picture.pic_coding_type);
@@ -1598,8 +1630,7 @@ int main(int argc, char **argv) {
         decsw_performance();
 
         if (!use_peek_output) {
-          DEBUG_PRINT(("VC1DecNextPicture returned: "));
-          vc1DecPrintReturnValue(tmpret);
+          vc1DecPrintReturnValue(tmpret, "VC1DecNextPicture returned: ");
 
           if ( tmpret == VC1DEC_PIC_RDY ) {
             /* Increment display number for every displayed picture */
@@ -1610,12 +1641,13 @@ int main(int argc, char **argv) {
                          dec_picture.coded_height, dec_picture.number_of_err_mbs,
                          dec_picture.key_picture ? "(KEYFRAME)" : ""));
 
-            if (dec_picture.interlaced && dec_picture.field_picture)
+            if (dec_picture.interlaced && dec_picture.field_picture) {
               DEBUG_PRINT(("Interlaced field %s, ", dec_picture.top_field ? "(Top)" : "(Bottom)"));
-            else if (dec_picture.interlaced && !dec_picture.field_picture)
+            } else if (dec_picture.interlaced && !dec_picture.field_picture) {
               DEBUG_PRINT(("Interlaced frame, "));
-            else
+            } else {
               DEBUG_PRINT(("Progressive, "));
+            }
 
             /* pic coding type */
             printVc1PicCodingType(dec_picture.pic_coding_type);
@@ -1747,17 +1779,24 @@ int main(int argc, char **argv) {
         } else { /* LONG STREAM */
           if (!advanced) {
             ra = fread(tmp_strm, sizeof(u8),  4 + 4 * rcv_v2, finput);
+            (void)(ra);
             if (ferror(finput)) {
-              DEBUG_PRINT(("STREAM READ ERROR
"));
+              PRINT(("STREAM READ ERROR
"));
               goto end;
             }
             if (feof(finput)) {
-              DEBUG_PRINT(("END OF STREAM
"));
+              PRINT(("END OF STREAM
"));
               dec_input.stream_size = 0;
               continue;
             }
             dec_input.stream_size = DecodeFrameLayerData(tmp_strm);
-            ra = fread((u8*)dec_input.stream, sizeof(u8), dec_input.stream_size, finput);
+            if (dec_input.stream_size > DEC_X170_MAX_STREAM) {
+              PRINT(("STREAM READ ERROR
"));
+              goto end;
+            } else {
+              ra = fread((u8*)dec_input.stream, sizeof(u8), dec_input.stream_size, finput);
+              (void)(ra);
+            }
           } else {
             if(use_index) {
               if(dec_output.data_left != 0) {
@@ -1772,7 +1811,8 @@ int main(int argc, char **argv) {
             } else {
               tmp = (dec_output.p_stream_curr_pos - dec_input.stream);
               stream_pos += tmp;
-              fseeko64( finput, stream_pos, SEEK_SET );
+              if (fseeko64( finput, stream_pos, SEEK_SET ) != 0)
+                fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
               dec_input.stream_size =
                 fread((u8*)dec_input.stream, sizeof(u8), VC1_MAX_STREAM_SIZE, finput);
@@ -1795,7 +1835,8 @@ int main(int argc, char **argv) {
                   GetNextDuSize((u8*)dec_input.stream, dec_input.stream,
                                 dec_input.stream_size, &skipped_bytes);
                 stream_pos += skipped_bytes;
-                fseeko64( finput, stream_pos, SEEK_SET );
+                if (fseeko64( finput, stream_pos, SEEK_SET ) != 0)
+                  fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
                 if(save_index) {
                   if(dec_input.stream[0] == 0 &&
@@ -1816,11 +1857,11 @@ int main(int argc, char **argv) {
             }
           }
           if (ferror(finput)) {
-            DEBUG_PRINT(("STREAM READ ERROR
"));
+            PRINT(("STREAM READ ERROR
"));
             goto end;
           }
           if (feof(finput)) {
-            DEBUG_PRINT(("STREAM WILL END
"));
+            PRINT(("STREAM WILL END
"));
             /*goto end;*/
           }
         }
@@ -1872,17 +1913,24 @@ int main(int argc, char **argv) {
         } else { /* LONG STREAM */
           if (!advanced) {
             ra = fread(tmp_strm, sizeof(u8),  4 + 4 * rcv_v2, finput);
+            (void)(ra);
             if (ferror(finput)) {
-              DEBUG_PRINT(("STREAM READ ERROR
"));
+              PRINT(("STREAM READ ERROR
"));
               goto end;
             }
             if (feof(finput)) {
-              DEBUG_PRINT(("END OF STREAM
"));
+              PRINT(("END OF STREAM
"));
               dec_input.stream_size = 0;
               continue;
             }
             dec_input.stream_size = DecodeFrameLayerData(tmp_strm);
-            ra = fread((u8*)dec_input.stream, sizeof(u8), dec_input.stream_size, finput);
+            if (dec_input.stream_size > DEC_X170_MAX_STREAM) {
+              PRINT(("STREAM READ ERROR
"));
+              goto end;
+            } else {
+              ra = fread((u8*)dec_input.stream, sizeof(u8), dec_input.stream_size, finput);
+              (void)(ra);
+            }
           } else {
             if(use_index) {
               if(dec_output.data_left != 0) {
@@ -1898,7 +1946,8 @@ int main(int argc, char **argv) {
             } else {
               tmp = (dec_output.p_stream_curr_pos - dec_input.stream);
               stream_pos += tmp;
-              fseeko64( finput, stream_pos, SEEK_SET );
+              if (fseeko64( finput, stream_pos, SEEK_SET ) != 0)
+                fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
               dec_input.stream_size =
                 fread((u8*)dec_input.stream, sizeof(u8),
@@ -1908,7 +1957,8 @@ int main(int argc, char **argv) {
                   GetNextDuSize((u8*)dec_input.stream, dec_input.stream,
                                 dec_input.stream_size, &skipped_bytes);
                 stream_pos += skipped_bytes;
-                fseeko64( finput, stream_pos, SEEK_SET );
+                if (fseeko64( finput, stream_pos, SEEK_SET ) != 0)
+                  fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
                 if(save_index) {
                   if(dec_input.stream[0] == 0 &&
@@ -1929,11 +1979,11 @@ int main(int argc, char **argv) {
             }
           }
           if (ferror(finput)) {
-            DEBUG_PRINT(("STREAM READ ERROR
"));
+            PRINT(("STREAM READ ERROR
"));
             goto end;
           }
           if (feof(finput)) {
-            DEBUG_PRINT(("STREAM WILL END
"));
+            PRINT(("STREAM WILL END
"));
             /*goto end;*/
           }
         }
@@ -1948,13 +1998,13 @@ int main(int argc, char **argv) {
       break;
 
     default:
-      DEBUG_PRINT(("FATAL ERROR: %d
", ret));
+      PRINT(("FATAL ERROR: %d
", ret));
       goto end;
     }
     /* keep decoding until all data from input stream buffer consumed */
   } while(dec_input.stream_size > 0);
 
-  printf("STREAM END ENCOUNTERED
");
+  PRINT(("STREAM END ENCOUNTERED
"));
   if(save_index && advanced) {
     tmp = (dec_output.p_stream_curr_pos - dec_input.stream);
     stream_pos += tmp;
@@ -1981,21 +2031,22 @@ int main(int argc, char **argv) {
     pic_display_number++;
 
 #if !defined(VC1_EVALUATION_VERSION)
-    DEBUG_PRINT(("   BUFFERED %s ID %d SIZE %dx%d;",
+    PRINT(("   BUFFERED %s ID %d SIZE %dx%d;",
                  dec_picture.key_picture ? "(KEYFRAME)" : "", dec_picture.pic_id,
                  dec_picture.coded_width,
                  dec_picture.coded_height));
 
-    if (dec_picture.interlaced && dec_picture.field_picture)
-      DEBUG_PRINT((" Interlaced field %s, ", dec_picture.top_field ? "(Top)" : "(Bottom)"));
-    else if (dec_picture.interlaced && !dec_picture.field_picture)
-      DEBUG_PRINT((" Interlaced frame, "));
-    else
-      DEBUG_PRINT((" Progressive, "));
+    if (dec_picture.interlaced && dec_picture.field_picture) {
+      PRINT((" Interlaced field %s, ", dec_picture.top_field ? "(Top)" : "(Bottom)"));
+    } else if (dec_picture.interlaced && !dec_picture.field_picture) {
+      PRINT((" Interlaced frame, "));
+    } else {
+      PRINT((" Progressive, "));
+    }
 
     /* pic coding type */
     printVc1PicCodingType(dec_picture.pic_coding_type);
-    DEBUG_PRINT(("
"));
+    PRINT(("
"));
 #endif
 
 #ifndef PP_PIPELINE_ENABLED
@@ -2131,22 +2182,23 @@ end:
   if (NULL == foutput) {
     strm_len = 0;
   } else {
-    fseek(foutput, 0L, SEEK_END);
+    if (fseek(foutput, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     strm_len = (u32) ftell(foutput);
     fclose(foutput);
   }
 
-  DEBUG_PRINT(("Output file: %s
", out_file_name));
+  PRINT(("Output file: %s
", out_file_name));
 
-  DEBUG_PRINT(("OUTPUT_SIZE %d
", strm_len));
-  DEBUG_PRINT(("NUMBER OF WRITTEN FRAMES %d
", number_of_written_frames));
+  PRINT(("OUTPUT_SIZE %d
", strm_len));
+  PRINT(("NUMBER OF WRITTEN FRAMES %d
", number_of_written_frames));
 
   FINALIZE_SW_PERFORMANCE;
 
-  DEBUG_PRINT(("DECODING DONE
"));
+  PRINT(("DECODING DONE
"));
 
   if(num_errors || pic_decode_number == 1) {
-    DEBUG_PRINT(("ERRORS FOUND in %d out of %d PICTURES
",
+    PRINT(("ERRORS FOUND in %d out of %d PICTURES
",
                  num_errors, pic_decode_number));
     return 1;
   }
@@ -2184,7 +2236,7 @@ u32 GetNextDuSize(const u8* stream, const u8* stream_start, u32 strm_len, u32 *s
     u32 ret = 0;
     ret = TBRandomizePacketLoss(tb_cfg.tb_params.stream_packet_loss, (u8 *)&next_packet);
     if (ret != 0) {
-      printf("RANDOM STREAM ERROR FAILED
");
+      PRINT(("RANDOM STREAM ERROR FAILED
"));
       return 0;
     }
   }
@@ -2331,7 +2383,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 frame_numb
     if(strcmp(filename, "none") != 0) {
       foutput = fopen(filename, "wb");
       if(foutput == NULL) {
-        DEBUG_PRINT(("UNABLE TO OPEN OUTPUT FILE
"));
+        PRINT(("UNABLE TO OPEN OUTPUT FILE
"));
         return;
       }
     }
@@ -2428,7 +2480,7 @@ void WriteOutput(char *filename, char *filename_tiled, u8 * data, u32 frame_numb
       if(output_picture_endian == DEC_X170_BIG_ENDIAN) {
         pic_copy = (u8*) malloc(pic_size);
         if (NULL == pic_copy) {
-          DEBUG_PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
+          PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
           if(raster_scan)
             free(raster_scan);
 
@@ -2604,17 +2656,19 @@ u32 DecodeFrameLayerData(u8 *stream) {
   tmp = BIT7(tmp);
   if( rcv_v2 ) {
     time_stamp = SHOW4(p);
-    if (tmp == 1)
+    if (tmp == 1) {
       DEBUG_PRINT(("INTRA FRAME timestamp: %d size: %d
",
                    time_stamp, frame_size));
-    else
+    } else {
       DEBUG_PRINT(("INTER FRAME timestamp: %d size: %d
",
                    time_stamp, frame_size));
+    }
   } else {
-    if (tmp == 1)
+    if (tmp == 1) {
       DEBUG_PRINT(("INTRA FRAME size: %d
", frame_size));
-    else
+    } else {
       DEBUG_PRINT(("INTER FRAME size: %d
", frame_size));
+    }
   }
 
   return frame_size;
@@ -2710,95 +2764,94 @@ void FramePicture( u8 *p_in, i32 in_width, i32 in_height,
 
 }
 
-void vc1DecPrintReturnValue(VC1DecRet ret) {
+void vc1DecPrintReturnValue(VC1DecRet ret, char *str) {
   switch(ret) {
   case VC1DEC_OK:
-    DEBUG_PRINT(("VC1DEC_OK
"));
+    DEBUG_PRINT(("%s VC1DEC_OK
", str));
     break;
 
   case VC1DEC_HDRS_RDY:
-    DEBUG_PRINT(("VC1DEC_HDRS_RDY
"));
+    DEBUG_PRINT(("%s VC1DEC_HDRS_RDY
", str));
     break;
 
   case VC1DEC_PIC_RDY:
-    DEBUG_PRINT(("VC1DEC_PIC_RDY
"));
+    DEBUG_PRINT(("%s VC1DEC_PIC_RDY
", str));
     break;
 
   case VC1DEC_END_OF_SEQ:
-    DEBUG_PRINT(("VC1DEC_END_OF_SEQ
"));
+    PRINT(("%s VC1DEC_END_OF_SEQ
", str));
     break;
 
   case VC1DEC_PIC_DECODED:
-    DEBUG_PRINT(("VC1DEC_PIC_DECODED
"));
+    DEBUG_PRINT(("%s VC1DEC_PIC_DECODED
", str));
     break;
 
   case VC1DEC_PIC_CONSUMED:
-    DEBUG_PRINT(("VC1DEC_PIC_CONSUMED
"));
+    DEBUG_PRINT(("%s VC1DEC_PIC_CONSUMED
", str));
     break;
 
   case VC1DEC_RESOLUTION_CHANGED:
-    DEBUG_PRINT(("VC1DEC_RESOLUTION_CHANGED
"));
+    DEBUG_PRINT(("%s VC1DEC_RESOLUTION_CHANGED
", str));
     break;
 
   case VC1DEC_STRM_ERROR:
-    DEBUG_PRINT(("VC1DEC_STRM_ERROR
"));
+    PRINT(("%s VC1DEC_STRM_ERROR
", str));
     break;
 
   case VC1DEC_STRM_PROCESSED:
-    DEBUG_PRINT(("VC1DEC_STRM_PROCESSED
"));
+    DEBUG_PRINT(("%s VC1DEC_STRM_PROCESSED
", str));
     break;
 
   case VC1DEC_NO_DECODING_BUFFER:
-    DEBUG_PRINT(("VC1DEC_NO_DECODING_BUFFER
"));
+    DEBUG_PRINT(("%s VC1DEC_NO_DECODING_BUFFER
", str));
     break;
 
   case VC1DEC_PARAM_ERROR:
-    DEBUG_PRINT(("VC1DEC_PARAM_ERROR
"));
+    PRINT(("%s VC1DEC_PARAM_ERROR
", str));
     break;
 
   case VC1DEC_NOT_INITIALIZED:
-    DEBUG_PRINT(("VC1DEC_NOT_INITIALIZED
"));
+    PRINT(("%s VC1DEC_NOT_INITIALIZED
", str));
     break;
 
   case VC1DEC_MEMFAIL:
-    DEBUG_PRINT(("VC1DEC_MEMFAIL
"));
+    PRINT(("%s VC1DEC_MEMFAIL
", str));
     break;
 
   case VC1DEC_INITFAIL:
-    DEBUG_PRINT(("VC1DEC_INITFAIL
"));
+    PRINT(("%s VC1DEC_INITFAIL
", str));
     break;
 
   case VC1DEC_METADATA_FAIL:
-    DEBUG_PRINT(("VC1DEC_METADATA_FAIL
"));
+    PRINT(("%s VC1DEC_METADATA_FAIL
", str));
     break;
 
   case VC1DEC_HW_RESERVED:
-    DEBUG_PRINT(("VC1DEC_HW_RESERVED
"));
+    PRINT(("%s VC1DEC_HW_RESERVED
", str));
     break;
 
   case VC1DEC_HW_TIMEOUT:
-    DEBUG_PRINT(("VC1DEC_HW_TIMEOUT
"));
+    PRINT(("%s VC1DEC_HW_TIMEOUT
", str));
     break;
 
   case VC1DEC_HW_BUS_ERROR:
-    DEBUG_PRINT(("VC1DEC_HW_BUS_ERROR
"));
+    PRINT(("%s VC1DEC_HW_BUS_ERROR
", str));
     break;
 
   case VC1DEC_SYSTEM_ERROR:
-    DEBUG_PRINT(("VC1DEC_SYSTEM_ERROR
"));
+    PRINT(("%s VC1DEC_SYSTEM_ERROR
", str));
     break;
 
   case VC1DEC_DWL_ERROR:
-    DEBUG_PRINT(("VC1DEC_DWL_ERROR
"));
+    PRINT(("%s VC1DEC_DWL_ERROR
", str));
     break;
 
   case VC1DEC_NONREF_PIC_SKIPPED:
-    DEBUG_PRINT(("VC1DEC_NONREF_PIC_SKIPPED
"));
+    PRINT(("%s VC1DEC_NONREF_PIC_SKIPPED
", str));
     break;
 
   default:
-
-    DEBUG_PRINT(("unknown return value!
"));
+    PRINT(("%s unknown return value!
", str));
   }
 }
 
@@ -2810,40 +2863,40 @@ void vc1DecPrintReturnValue(VC1DecRet ret) {
 
 ------------------------------------------------------------------------------*/
 void printVc1PicCodingType(u32 *pic_type) {
-  printf("Coding type ");
+  DEBUG_PRINT(("Coding type "));
   switch (pic_type[0]) {
   case DEC_PIC_TYPE_I:
-    printf("[I:");
+    DEBUG_PRINT(("[I:"));
     break;
   case DEC_PIC_TYPE_P:
-    printf("[P:");
+    DEBUG_PRINT(("[P:"));
     break;
   case DEC_PIC_TYPE_B:
-    printf("[B:");
+    DEBUG_PRINT(("[B:"));
     break;
   case DEC_PIC_TYPE_BI:
-    printf("[BI:");
+    DEBUG_PRINT(("[BI:"));
     break;
   default:
-    printf("[Other %d:", *pic_type);
+    DEBUG_PRINT(("[Other %d:", *pic_type));
     break;
   }
 
   switch (pic_type[1]) {
   case DEC_PIC_TYPE_I:
-    printf("I]");
+    DEBUG_PRINT(("I]"));
     break;
   case DEC_PIC_TYPE_P:
-    printf("P]");
+    DEBUG_PRINT(("P]"));
     break;
   case DEC_PIC_TYPE_B:
-    printf("B]");
+    DEBUG_PRINT(("B]"));
     break;
   case DEC_PIC_TYPE_BI:
-    printf("BI]");
+    DEBUG_PRINT(("BI]"));
     break;
   default:
-    printf("Other %d]", *pic_type);
+    DEBUG_PRINT(("Other %d]", *pic_type));
     break;
   }
 }
@@ -2875,7 +2928,8 @@ u32 fillBuffer(u8 *stream) {
   off64_t pos = ftello64(finput);
   int ret;
   if(cur_index != pos) {
-    fseeko64(finput, cur_index, SEEK_SET);
+    if (fseeko64(finput, cur_index, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
 #ifndef _WIN64
   ret = fscanf(f_index, "%lu", &next_index);
@@ -2887,7 +2941,7 @@ u32 fillBuffer(u8 *stream) {
 
   /* read data */
   if (amount > DEC_X170_MAX_STREAM) {
-    printf("FILE ERROR
");
+    PRINT(("FILE ERROR
"));
     return 0;
   }
   data_len = fread(stream, 1, amount, finput);
diff --git a/decoder_sw/software/test/vp6/Makefile b/decoder_sw/software/test/vp6/Makefile
index abe9425..3baf6e6 100755
--- a/decoder_sw/software/test/vp6/Makefile
+++ b/decoder_sw/software/test/vp6/Makefile
@@ -82,6 +82,8 @@ DECLIB = libdec8190vp6.a
 
 # Enable SW performance  measurement
 #CFLAGS = -DSW_PERFORMANCE
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
 
 ifeq ($(USE_MD5SUM), y)
         MD5SUM = -DMD5SUM
diff --git a/decoder_sw/software/test/vp6/on2vp6dec.c b/decoder_sw/software/test/vp6/on2vp6dec.c
index b0eec9f..42f8e29 100755
--- a/decoder_sw/software/test/vp6/on2vp6dec.c
+++ b/decoder_sw/software/test/vp6/on2vp6dec.c
@@ -91,7 +91,20 @@ extern u32 g_hw_ver;
 u32 b_frames=0;
 void printVp6PicCodingType(u32 pic_type);
 
-#define DEBUG_PRINT(...) printf(__VA_ARGS__)
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
 
 #define MAX_BUFFERS 16
 
@@ -181,10 +194,10 @@ static void *AddBufferThread(void *arg) {
 }
 void ReleaseExtBuffers() {
   int i;
-  printf("Releasing %d external frame buffers
", external_buf_num);
+  PRINT(("Releasing %d external frame buffers
", external_buf_num));
   pthread_mutex_lock(&ext_buffer_contro);
   for(i=0; i<external_buf_num; i++) {
-    printf("Freeing buffer %p
", ext_buffers[i].virtual_address);
+    PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
     if (pp_enabled)
       DWLFreeLinear(dwl_inst, &ext_buffers[i]);
     else
@@ -568,7 +581,7 @@ void writeRawFrame(FILE * fp, unsigned char *buffer, int frame_size, int md5,
 
       pic_big_endian = (u8 *) malloc(frame_size);
       if(pic_big_endian == NULL) {
-        DEBUG_PRINT("MALLOC FAILED @ %s %d", __FILE__, __LINE__);
+        PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
         if(raster_scan)
           free(raster_scan);
         return;
@@ -597,6 +610,8 @@ void writeRawFrame(FILE * fp, unsigned char *buffer, int frame_size, int md5,
     fprintf(fp, "
");
     if(raster_scan)
       free(raster_scan);
+    if(pic_big_endian)
+      free(pic_big_endian);
     return;
   } else {
   }
@@ -629,6 +644,8 @@ void writeRawFrame(FILE * fp, unsigned char *buffer, int frame_size, int md5,
 
   if(raster_scan)
     free(raster_scan);
+  if(pic_big_endian)
+    free(pic_big_endian);
 }
 
 /*
@@ -637,8 +654,8 @@ void writeRawFrame(FILE * fp, unsigned char *buffer, int frame_size, int md5,
 */
 
 int decode_file(const options_s * opts) {
-  VP6DecInput input;
-  VP6DecOutput output;
+  VP6DecInput input = { 0 };
+  VP6DecOutput output = { 0 };
   VP6DecPicture dec_pic, tmp_pic;
   VP6DecRet ret;
   u32 tmp;
@@ -679,14 +696,14 @@ int decode_file(const options_s * opts) {
 #ifdef ASIC_TRACE_SUPPORT
   tmp = openTraceFiles();
   if (!tmp) {
-    DEBUG_PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
+    PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
   }
 #endif
 
 #ifdef USE_EXTERNAL_BUFFER
   dwl_inst = DWLInit(&dwl_init);
   if(dwl_inst == NULL) {
-    DEBUG_PRINT(("H264DecInit# ERROR: DWL Init failed
"));
+    PRINT(("H264DecInit# ERROR: DWL Init failed
"));
     goto end;
   }
 #endif
@@ -699,7 +716,7 @@ int decode_file(const options_s * opts) {
                    num_buffers,
                    tiled_output, 0, 0);
   if (ret != VP6DEC_OK) {
-    printf("DECODER INITIALIZATION FAILED
");
+    PRINT(("DECODER INITIALIZATION FAILED
"));
     goto end;
   }
 
@@ -748,7 +765,7 @@ int decode_file(const options_s * opts) {
 
   if(DWLMallocLinear(((VP6DecContainer_t *) dec_inst)->dwl,
                      STREAMBUFFER_BLOCKSIZE, &stream_mem) != DWL_OK) {
-    printf(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
+    PRINT(("UNABLE TO ALLOCATE STREAM BUFFER MEMORY
"));
     exit(-1);
   }
 
@@ -776,7 +793,7 @@ int decode_file(const options_s * opts) {
 
       ret = TBRandomizeU32(&input.data_len);
       if(ret != 0) {
-        DEBUG_PRINT("RANDOM STREAM ERROR FAILED
");
+        PRINT(("RANDOM STREAM ERROR FAILED
"));
         return 0;
       }
     }
@@ -792,7 +809,7 @@ int decode_file(const options_s * opts) {
                                        tb_cfg.tb_params.
                                        stream_bit_swap);
           if(ret != 0) {
-            DEBUG_PRINT("RANDOM STREAM ERROR FAILED
");
+            PRINT(("RANDOM STREAM ERROR FAILED
"));
             goto end;
           }
 
@@ -808,9 +825,9 @@ int decode_file(const options_s * opts) {
       if(ret == VP6DEC_HDRS_RDY) {
 #ifdef USE_EXTERNAL_BUFFER
         rv = VP6DecGetBufferInfo(dec_inst, &hbuf);
-        printf("VP6DecGetBufferInfo ret %d
", rv);
-        printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-               (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+        PRINT(("VP6DecGetBufferInfo ret %d
", rv));
+        PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+               (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 #endif
         VP6DecInfo dec_info;
 
@@ -822,7 +839,7 @@ int decode_file(const options_s * opts) {
 
         ret = VP6DecGetInfo(dec_inst, &dec_info);
         if (ret != VP6DEC_OK) {
-          DEBUG_PRINT("ERROR in getting stream info!
");
+          PRINT(("ERROR in getting stream info!
"));
           goto end;
         }
 
@@ -861,9 +878,9 @@ int decode_file(const options_s * opts) {
         mem.mem_type = DWL_MEM_TYPE_DPB;
 
         rv = VP6DecGetBufferInfo(dec_inst, &hbuf);
-        printf("VP6DecGetBufferInfo ret %d
", rv);
-        printf("buf_to_free %p, next_buf_size %d, buf_num %d
",
-               (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num);
+        PRINT(("VP6DecGetBufferInfo ret %d
", rv));
+        PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+               (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 
         if (hbuf.buf_to_free.virtual_address != NULL && res_changed) {
           add_extra_flag = 0;
@@ -884,7 +901,7 @@ int decode_file(const options_s * opts) {
               DWLMallocRefFrm(dwl_inst, hbuf.next_buf_size, &mem);
             rv = VP6DecAddBuffer(dec_inst, &mem);
 
-            printf("VP6DecAddBuffer ret %d
", rv);
+            PRINT(("VP6DecAddBuffer ret %d
", rv));
             if(rv != VP6DEC_OK && rv != VP6DEC_WAITING_FOR_BUFFER) {
               if (pp_enabled)
                 DWLFreeLinear(dwl_inst, &mem);
@@ -961,7 +978,7 @@ int decode_file(const options_s * opts) {
       }
 #endif
 
-      fprintf(stdout, "Picture %d,", current_video_frame);
+      DEBUG_PRINT(("Picture %d,", current_video_frame));
 
 #if defined(PP_PIPELINE_ENABLED) || !defined(USE_OUTPUT_RELEASE)
       /* pic coding type */
@@ -1006,7 +1023,7 @@ end:
   add_buffer_thread_run = 0;
 #endif
 
-  printf("Pictures decoded: %d
", current_video_frame);
+  PRINT(("Pictures decoded: %d
", current_video_frame));
 
 #ifdef PP_PIPELINE_ENABLED
   pp_close();
@@ -1104,8 +1121,8 @@ int main(int argc, char *argv[]) {
       exit(0);
     } else if(strcmp(argv[i], "-O") == 0) {
       options.output = optarg;
-    } else if(strcmp(argv[i], "-N") == 0) {
-      options.last_frame = atoi(optarg);
+    } else if(strncmp(argv[i], "-N", 2) == 0) {
+      options.last_frame = atoi(argv[i] + 2);
     } else if(strcmp(argv[i], "-m") == 0) {
       options.md5 = 1;
     } else if(strcmp(argv[i], "-M") == 0) {
@@ -1147,14 +1164,14 @@ int main(int argc, char *argv[]) {
 #endif
 #else
   if(argc < 3) {
-    printf("
Vp6 Decoder PP Pipelined Testbench

");
-    printf("USAGE:
%s [options] stream.vp6 pp.cfg
", argv[0]);
-    printf("-Nn to decode only first n vops of the stream
");
-    printf("-A  stream contains alpha channel
");
+    PRINT(("
Vp6 Decoder PP Pipelined Testbench

"));
+    PRINT(("USAGE:
%s [options] stream.vp6 pp.cfg
", argv[0]));
+    PRINT(("-Nn to decode only first n vops of the stream
"));
+    PRINT(("-A  stream contains alpha channel
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("--AddBuffer add extra external buffer randomly
");
+    PRINT(("--AddBuffer add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("--addbuffer add extra external buffer in output thread
");
+    PRINT(("--addbuffer add extra external buffer in output thread
"));
 #endif
 #endif
     exit(100);
@@ -1226,8 +1243,8 @@ int main(int argc, char *argv[]) {
   TBSetDefaultCfg(&tb_cfg);
   f_tbcfg = fopen("tb.cfg", "r");
   if(f_tbcfg == NULL) {
-    printf("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
");
-    printf("USING DEFAULT CONFIGURATION
");
+    PRINT(("UNABLE TO OPEN INPUT FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if(TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
@@ -1297,9 +1314,9 @@ int main(int argc, char *argv[]) {
     /* Print API version number */
     dec_api = VP6DecGetAPIVersion();
     dec_build = VP6DecGetBuild();
-    DEBUG_PRINT
-    ("
G1 VP6 Decoder API v%d.%d - SW build: %d - HW build: %x

",
-     dec_api.major, dec_api.minor, dec_build.sw_build, dec_build.hw_build);
+    PRINT
+    (("
G1 VP6 Decoder API v%d.%d - SW build: %d - HW build: %x

",
+     dec_api.major, dec_api.minor, dec_build.sw_build, dec_build.hw_build));
   }
 
   ret = decode_file(&options);
@@ -1345,13 +1362,13 @@ void HandlePpOutput(u32 vop_number, VP6DecPicture DecPicture, VP6DecInst decoder
 void printVp6PicCodingType(u32 pic_type) {
   switch (pic_type) {
   case DEC_PIC_TYPE_I:
-    printf(" DEC_PIC_TYPE_I
");
+    DEBUG_PRINT((" DEC_PIC_TYPE_I
"));
     break;
   case DEC_PIC_TYPE_P:
-    printf(" DEC_PIC_TYPE_P
");
+    DEBUG_PRINT((" DEC_PIC_TYPE_P
"));
     break;
   default:
-    printf("Other %d
", pic_type);
+    DEBUG_PRINT(("Other %d
", pic_type));
     break;
   }
 }
diff --git a/decoder_sw/software/test/vp8/Makefile b/decoder_sw/software/test/vp8/Makefile
index b672700..25814ef 100755
--- a/decoder_sw/software/test/vp8/Makefile
+++ b/decoder_sw/software/test/vp8/Makefile
@@ -50,10 +50,10 @@ ENABLE_WEBM = n
 
 SRCS = ivf.c vp8filereader.c vp8writeoutput.c vp8bufferalloc.c
 SRCS_SINGLE = dectestbench.c
-SRCS_MULTI = mcdectestbench.c
+#SRCS_MULTI = mcdectestbench.c
 OBJS = $(SRCS:.c=.o)
 OBJS_SINGLE = $(SRCS_SINGLE:.c=.o)
-OBJS_MULTI = $(SRCS_MULTI:.c=.o)
+#OBJS_MULTI = $(SRCS_MULTI:.c=.o)
 
 INCLUDE = -I../../source/inc -I../../source/vp8 -I../../source/config \
           -I../../source/dwl -I../common/swhw \
@@ -74,6 +74,8 @@ TARGET_ENV=integrator
 
 # Enable SW performance  measurement
 #CFLAGS = -DSW_PERFORMANCE
+# Enable TestBench debug info
+#CFLAGS += -D_TB_DEBUG_PRINT
 
 ifeq ($(USE_MD5SUM), y)
         MD5SUM = -DMD5SUM
diff --git a/decoder_sw/software/test/vp8/dectestbench.c b/decoder_sw/software/test/vp8/dectestbench.c
index 8ae5929..a2c527b 100755
--- a/decoder_sw/software/test/vp8/dectestbench.c
+++ b/decoder_sw/software/test/vp8/dectestbench.c
@@ -166,7 +166,20 @@ void HandlePpOutput(u32 pic_num, VP8DecInst decoder);
     Module defines
 ------------------------------------------------------------------------------*/
 
-#define DEBUG_PRINT(str) printf str
+#undef DEBUG_PRINT
+#ifdef _TB_DEBUG_PRINT
+#define DEBUG_PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
+#else
+#define DEBUG_PRINT(argv)
+#endif
+
+#define PRINT(argv) { \
+  printf argv ; \
+  fflush(stdout); \
+  }
 
 #define VP8_MAX_STREAM_SIZE  DEC_X170_MAX_STREAM>>1
 
@@ -240,7 +253,7 @@ void ReleaseExtBuffers() {
   int i;
   pthread_mutex_lock(&ext_buffer_contro);
   for(i=0; i<num_buffers; i++) {
-    DEBUG_PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
+    PRINT(("Freeing buffer %p
", ext_buffers[i].virtual_address));
     if (pp_enabled)
       DWLFreeLinear(dwl_inst, &ext_buffers[i]);
     else
@@ -515,32 +528,32 @@ int main(int argc, char**argv) {
 
 #ifndef PP_PIPELINE_ENABLED
   if (argc < 2) {
-    printf("Usage: %s [options] file.ivf
", argv[0]);
-    printf("	-Nn forces decoding to stop after n pictures
");
-    printf("	-Ooutfile write output to \"outfile\" (default out.yuv)
");
-    printf("	--md5 Output frame based md5 checksum. No YUV output!
");
-    printf("	-C display cropped image
");
-    printf("	-P write planar output.
");
-    printf("	-E use tiled reference frame format.
");
-    printf("	-G convert tiled output pictures to raster scan
");
-    printf("	-F Enable frame picture writing (filled black).
");
-    printf("	-W Set frame picture width (default 1. frame width).
");
-    printf("	-H Set frame picture height (default 1. frame height).
");
-    printf("	-Bn to use n frame buffers in decoder
");
-    printf("	-Z output pictures using VP8DecPeek() function
");
-    printf("	-ln Set luma buffer stride
");
-    printf("	-cn Set chroma buffer stride
");
-    printf("	-X user allocates picture buffers
");
-    printf("	-Xa same as above but alternate allocation order
");
-    printf("	-I use interleaved frame buffers (requires stride mode and "\
-           "user allocated buffers
");
-    printf("	-R write uncropped output (if strides used)
");
-    printf("	-xn Add n bytes of extra space after "\
-           "stream buffer for decoder
");
+    PRINT(("Usage: %s [options] file.ivf
", argv[0]));
+    PRINT(("	-Nn forces decoding to stop after n pictures
"));
+    PRINT(("	-Ooutfile write output to \"outfile\" (default out.yuv)
"));
+    PRINT(("	--md5 Output frame based md5 checksum. No YUV output!
"));
+    PRINT(("	-C display cropped image
"));
+    PRINT(("	-P write planar output.
"));
+    PRINT(("	-E use tiled reference frame format.
"));
+    PRINT(("	-G convert tiled output pictures to raster scan
"));
+    PRINT(("	-F Enable frame picture writing (filled black).
"));
+    PRINT(("	-W Set frame picture width (default 1. frame width).
"));
+    PRINT(("	-H Set frame picture height (default 1. frame height).
"));
+    PRINT(("	-Bn to use n frame buffers in decoder
"));
+    PRINT(("	-Z output pictures using VP8DecPeek() function
"));
+    PRINT(("	-ln Set luma buffer stride
"));
+    PRINT(("	-cn Set chroma buffer stride
"));
+    PRINT(("	-X user allocates picture buffers
"));
+    PRINT(("	-Xa same as above but alternate allocation order
"));
+    PRINT(("	-I use interleaved frame buffers (requires stride mode and "\
+           "user allocated buffers
"));
+    PRINT(("	-R write uncropped output (if strides used)
"));
+    PRINT(("	-xn Add n bytes of extra space after "\
+           "stream buffer for decoder
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("	-A add extra external buffer randomly
");
+    PRINT(("	-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("	-a add extra external buffer in ouput thread
");
+    PRINT(("	-a add extra external buffer in ouput thread
"));
 #endif
 #endif
 
@@ -565,9 +578,15 @@ int main(int argc, char**argv) {
       out_frame_width = (u32)atoi(argv[i] + 2);
     else if (strncmp(argv[i], "-H", 2) == 0)
       out_frame_height = (u32)atoi(argv[i] + 2);
-    else if (strncmp(argv[i], "-O", 2) == 0)
-      strcpy(out_file_name, argv[i] + 2);
-    else if(strncmp(argv[i], "-B", 2) == 0) {
+    else if (strncmp(argv[i], "-O", 2) == 0) {
+      /* -1 to accomodate for the null tern=minator */
+      if (sizeof(out_file_name) - 1 < strlen(argv[i] + 2)) {
+        PRINT(("The output file name size overflows buffer size(256)!
"));
+        return 1;
+      } else {
+        strcpy(out_file_name, argv[i] + 2);
+      }
+    } else if(strncmp(argv[i], "-B", 2) == 0) {
       num_frame_buffers = atoi(argv[i] + 2);
       if(num_frame_buffers > MAX_BUFFERS)
         num_frame_buffers = MAX_BUFFERS;
@@ -606,7 +625,7 @@ int main(int argc, char**argv) {
 #endif
 #endif
     else {
-      DEBUG_PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
+      PRINT(("UNKNOWN PARAMETER: %s
", argv[i]));
       return 1;
     }
   }
@@ -630,20 +649,20 @@ int main(int argc, char**argv) {
   }
 #else
   if (argc < 3) {
-    printf("Usage: %s [options] file.ivf
", argv[0]);
-    printf("	-Bn to use n frame buffers in decoder
");
-    printf("	-E use tiled reference frame format.
");
-    printf("	-Nn forces decoding to stop after n pictures
");
-    printf("	-X user allocates picture buffers
");
-    printf("	-Xa same as above but alternate allocation order
");
-    printf("	-I use interleaved frame buffers (requires stride mode and "\
-           "user allocated buffers
");
-    printf("	-xn Add n bytes of extra space after "\
-           "stream buffer for decoder
");
+    PRINT(("Usage: %s [options] file.ivf
", argv[0]));
+    PRINT(("	-Bn to use n frame buffers in decoder
"));
+    PRINT(("	-E use tiled reference frame format.
"));
+    PRINT(("	-Nn forces decoding to stop after n pictures
"));
+    PRINT(("	-X user allocates picture buffers
"));
+    PRINT(("	-Xa same as above but alternate allocation order
"));
+    PRINT(("	-I use interleaved frame buffers (requires stride mode and "\
+           "user allocated buffers
"));
+    PRINT(("	-xn Add n bytes of extra space after "\
+           "stream buffer for decoder
"));
 #ifdef USE_EXTERNAL_BUFFER
-    printf("	-A add extra external buffer randomly
");
+    PRINT(("	-A add extra external buffer randomly
"));
 #ifdef USE_OUTPUT_RELEASE
-    printf("	-a add extra external buffer in output thread
");
+    PRINT(("	-a add extra external buffer in output thread
"));
 #endif
 #endif
     return 0;
@@ -689,7 +708,7 @@ int main(int argc, char**argv) {
 #ifdef ASIC_TRACE_SUPPORT
   tmp = openTraceFiles();
   if (!tmp) {
-    DEBUG_PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
+    PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
   }
 #endif
 
@@ -697,8 +716,8 @@ int main(int argc, char**argv) {
   TBSetDefaultCfg(&tb_cfg);
   f_tbcfg = fopen("tb.cfg", "r");
   if (f_tbcfg == NULL) {
-    DEBUG_PRINT(("UNABLE TO OPEN TEST BENCH CONFIGURATION FILE: \"tb.cfg\"
"));
-    DEBUG_PRINT(("USING DEFAULT CONFIGURATION
"));
+    PRINT(("UNABLE TO OPEN TEST BENCH CONFIGURATION FILE: \"tb.cfg\"
"));
+    PRINT(("USING DEFAULT CONFIGURATION
"));
   } else {
     fclose(f_tbcfg);
     if (TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
@@ -717,13 +736,13 @@ int main(int argc, char**argv) {
   output_format = TBGetDecOutputFormat(&tb_cfg);
   service_merge_disable = TBGetDecServiceMergeDisable(&tb_cfg);
 
-  DEBUG_PRINT(("Decoder Clock Gating %d
", clock_gating));
-  DEBUG_PRINT(("Decoder Data Discard %d
", data_discard));
-  DEBUG_PRINT(("Decoder Latency Compensation %d
", latency_comp));
-  DEBUG_PRINT(("Decoder Output Picture Endian %d
", output_picture_endian));
-  DEBUG_PRINT(("Decoder Bus Burst Length %d
", bus_burst_length));
-  DEBUG_PRINT(("Decoder Asic Service Priority %d
", asic_service_priority));
-  DEBUG_PRINT(("Decoder Output Format %d
", output_format));
+  PRINT(("Decoder Clock Gating %d
", clock_gating));
+  PRINT(("Decoder Data Discard %d
", data_discard));
+  PRINT(("Decoder Latency Compensation %d
", latency_comp));
+  PRINT(("Decoder Output Picture Endian %d
", output_picture_endian));
+  PRINT(("Decoder Bus Burst Length %d
", bus_burst_length));
+  PRINT(("Decoder Asic Service Priority %d
", asic_service_priority));
+  PRINT(("Decoder Output Format %d
", output_format));
   seed_rnd = tb_cfg.tb_params.seed_rnd;
   stream_header_corrupt = TBGetTBStreamHeaderCorrupt(&tb_cfg);
   /* if headers are to be corrupted
@@ -759,24 +778,25 @@ int main(int argc, char**argv) {
     dec_api = VP8DecGetAPIVersion();
     dec_build = VP8DecGetBuild();
     DWLReadAsicConfig(&hw_config,DWL_CLIENT_TYPE_VP8_DEC);
-    DEBUG_PRINT((
+    PRINT((
                   "
8170 VP8 Decoder API v%d.%d - SW build: %d - HW build: %x
",
                   dec_api.major, dec_api.minor, dec_build.sw_build, dec_build.hw_build));
-    DEBUG_PRINT((
+    PRINT((
                   "HW Supports video decoding up to %d pixels,
",
                   hw_config.max_dec_pic_width));
 
-    DEBUG_PRINT((
+    PRINT((
                   "supported codecs: %s%s
",
                   hw_config.vp7_support ? "VP-7 " : "",
                   hw_config.vp8_support ? "VP-8" : ""));
 
-    if(hw_config.pp_support)
-      DEBUG_PRINT((
+    if(hw_config.pp_support) {
+      PRINT((
                     "Maximum Post-processor output size %d pixels

",
                     hw_config.max_pp_out_pic_width));
-    else
-      DEBUG_PRINT(("Post-Processor not supported

"));
+    } else {
+      PRINT(("Post-Processor not supported

"));
+    }
   }
 
   /* check format */
@@ -801,7 +821,7 @@ int main(int argc, char**argv) {
 #ifdef USE_EXTERNAL_BUFFER
   dwl_inst = DWLInit(&dwl_init);
   if(dwl_inst == NULL) {
-    DEBUG_PRINT(("H264DecInit# ERROR: DWL Init failed
"));
+    PRINT(("H264DecInit# ERROR: DWL Init failed
"));
     goto end;
   }
 #endif
@@ -938,8 +958,8 @@ int main(int argc, char**argv) {
       if (ret == VP8DEC_HDRS_RDY) {
 #ifdef USE_EXTERNAL_BUFFER
         rv = VP8DecGetBufferInfo(dec_inst, &hbuf);
-        DEBUG_PRINT(("VP8DecGetBufferInfo ret %d
", rv));
-        DEBUG_PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+        PRINT(("VP8DecGetBufferInfo ret %d
", rv));
+        PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
                      (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 #endif
         i32 mcu_in_row;
@@ -953,7 +973,7 @@ int main(int argc, char**argv) {
         /* Handle incorrect slice size for HW testing */
         if(dec_input.slice_height > (info.frame_height >> 4)) {
           dec_input.slice_height = (info.frame_height >> 4);
-          printf("FIXED Decoder Slice MB Set %d
", dec_input.slice_height);
+          PRINT(("FIXED Decoder Slice MB Set %d
", dec_input.slice_height));
         }
 #endif /* ASIC_TRACE_SUPPORT */
 
@@ -968,9 +988,9 @@ int main(int argc, char**argv) {
           } while(((dec_input.slice_height * (mcu_in_row / mcu_size_divider)) +
                    (mcu_in_row / mcu_size_divider)) <
                   VP8DEC_MAX_SLICE_SIZE);
-          printf
-          ("Force to slice mode (over 16M) ==> Decoder Slice MB Set %d
",
-           dec_input.slice_height);
+          PRINT
+          (("Force to slice mode (over 16M) ==> Decoder Slice MB Set %d
",
+           dec_input.slice_height));
           forced_slice_mode = 1;
         }
 #else
@@ -984,19 +1004,19 @@ int main(int argc, char**argv) {
           } while(((dec_input.slice_height * (mcu_in_row / mcu_size_divider)) +
                    (mcu_in_row / mcu_size_divider)) <
                   VP8DEC_MAX_SLICE_SIZE);
-          printf
-          ("Force to slice mode (over 16M) ==> Decoder Slice MB Set %d
",
-           dec_input.slice_height);
+          PRINT
+          (("Force to slice mode (over 16M) ==> Decoder Slice MB Set %d
",
+           dec_input.slice_height));
           forced_slice_mode = 1;
         }
 #endif /* ASIC_TRACE_SUPPORT */
 #endif /* PP_PIPELINE_ENABLED */
-        DEBUG_PRINT(("
Stream info:
"));
-        DEBUG_PRINT(("VP Version %d, Profile %d
", info.vp_version, info.vp_profile));
-        DEBUG_PRINT(("Frame size %dx%d
", info.frame_width, info.frame_height));
-        DEBUG_PRINT(("Coded size %dx%d
", info.coded_width, info.coded_height));
-        DEBUG_PRINT(("Scaled size %dx%d
", info.scaled_width, info.scaled_height));
-        DEBUG_PRINT(("Output format %s

", info.output_format == VP8DEC_SEMIPLANAR_YUV420
+        PRINT(("
Stream info:
"));
+        PRINT(("VP Version %d, Profile %d
", info.vp_version, info.vp_profile));
+        PRINT(("Frame size %dx%d
", info.frame_width, info.frame_height));
+        PRINT(("Coded size %dx%d
", info.coded_width, info.coded_height));
+        PRINT(("Scaled size %dx%d
", info.scaled_width, info.scaled_height));
+        PRINT(("Output format %s

", info.output_format == VP8DEC_SEMIPLANAR_YUV420
                      ? "VP8DEC_SEMIPLANAR_YUV420" : "VP8DEC_TILED_YUV420"));
 
         if (user_mem_alloc) {
@@ -1017,7 +1037,7 @@ int main(int argc, char**argv) {
               DWLFreeRefFrm(((VP8DecContainer_t *) dec_inst)->dwl, &user_alloc_chroma[i]);
           }
 
-          DEBUG_PRINT(("User allocated memory,width=%d,height=%d
",
+          PRINT(("User allocated memory,width=%d,height=%d
",
                        info.frame_width, info.frame_height));
 
           slice_height = ((VP8DecContainer_t *) dec_inst)->slice_height;
@@ -1036,10 +1056,11 @@ int main(int argc, char**argv) {
 #ifdef PP_PIPELINE_ENABLED
             rotation = pp_rotation_used();
             cropping = pp_cropping_used();
-            if (rotation || (cropping && (info.frame_width <= hw_config.max_dec_pic_width || info.frame_height < 4096)))
-              printf("User allocated output memory");
-            else
+            if (rotation || (cropping && (info.frame_width <= hw_config.max_dec_pic_width || info.frame_height < 4096))) {
+              PRINT(("User allocated output memory"));
+            } else {
               size_luma = size_chroma = 2; /* ugly hack*/
+            }
 #endif
 
             if (DWLMallocRefFrm(((VP8DecContainer_t *) dec_inst)->dwl,
@@ -1082,7 +1103,7 @@ int main(int argc, char**argv) {
               if( ((pbp.luma_stride == pbp.chroma_stride) ||
                    ((2*pbp.luma_stride) == pbp.chroma_stride)) &&
                   pbp.luma_stride >= info.frame_width*2*pbp.num_buffers) {
-                DEBUG_PRINT(("Interleave mode 1: One buffer
"));
+                PRINT(("Interleave mode 1: One buffer
"));
                 size_buffer = pbp.luma_stride * (info.frame_height+1);
                 if (DWLMallocRefFrm(((VP8DecContainer_t *) dec_inst)->dwl,
                                     size_buffer, &user_alloc_luma[0]) != DWL_OK) {
@@ -1102,7 +1123,7 @@ int main(int argc, char**argv) {
                 }
 
               } else { /* Mode 2: separate buffers for luma and chroma */
-                DEBUG_PRINT(("Interleave mode 2: Two buffers
"));
+                PRINT(("Interleave mode 2: Two buffers
"));
                 if( (pbp.luma_stride < info.frame_width*pbp.num_buffers) ||
                     (pbp.chroma_stride < info.frame_width*pbp.num_buffers)) {
                   fprintf(stderr, "CHROMA STRIDE LENGTH TOO SMALL FOR INTERLEAVED FRAME BUFFERS
");
@@ -1222,13 +1243,13 @@ int main(int argc, char**argv) {
       }
 #ifdef USE_EXTERNAL_BUFFER
       if (ret == VP8DEC_WAITING_FOR_BUFFER) {
-        DEBUG_PRINT(("Waiting for frame buffers
"));
+        PRINT(("Waiting for frame buffers
"));
         struct DWLLinearMem mem;
         mem.mem_type = DWL_MEM_TYPE_CPU;
 
         rv = VP8DecGetBufferInfo(dec_inst, &hbuf);
-        DEBUG_PRINT(("VP8DecGetBufferInfo ret %d
", rv));
-        DEBUG_PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
+        PRINT(("VP8DecGetBufferInfo ret %d
", rv));
+        PRINT(("buf_to_free %p, next_buf_size %d, buf_num %d
",
                      (void *)hbuf.buf_to_free.virtual_address, hbuf.next_buf_size, hbuf.buf_num));
 
 #if 0
@@ -1254,7 +1275,7 @@ int main(int argc, char**argv) {
             else
               DWLMallocRefFrm(dwl_inst, hbuf.next_buf_size, &mem);
             rv = VP8DecAddBuffer(dec_inst, &mem);
-            DEBUG_PRINT(("VP8DecAddBuffer ret %d
", rv));
+            PRINT(("VP8DecAddBuffer ret %d
", rv));
             if(rv != VP8DEC_OK && rv != VP8DEC_WAITING_FOR_BUFFER) {
               if (pp_enabled)
                 DWLFreeLinear(dwl_inst, &mem);
@@ -1444,9 +1465,6 @@ int main(int argc, char**argv) {
   while (!use_peek_output &&
          VP8DecNextPicture(dec_inst, &dec_picture, 1) == VP8DEC_PIC_RDY) {
 
-    END_SW_PERFORMANCE;
-    decsw_performance();
-
 #ifndef PP_PIPELINE_ENABLED
     writeRawFrame(fout,
                   (unsigned char *) dec_picture.p_output_frame,
@@ -1466,6 +1484,9 @@ int main(int argc, char**argv) {
   VP8DecEndOfStream(dec_inst, 1);
 #endif
 
+  END_SW_PERFORMANCE;
+  decsw_performance();
+
 end:
 #ifdef USE_EXTERNAL_BUFFER
   add_buffer_thread_run = 0;
@@ -1603,7 +1624,7 @@ void writeRawFrame(FILE * fp, unsigned char *buffer,
 
       pic_big_endian = (u8 *) malloc(frame_size);
       if(pic_big_endian == NULL) {
-        DEBUG_PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
+        PRINT(("MALLOC FAILED @ %s %d", __FILE__, __LINE__));
         if(raster_scan)
           free(raster_scan);
         return;
@@ -1631,6 +1652,8 @@ void writeRawFrame(FILE * fp, unsigned char *buffer,
 
       if(raster_scan)
         free(raster_scan);
+      if(pic_big_endian)
+        free(pic_big_endian);
 
       return;
     }
@@ -1707,6 +1730,8 @@ void writeRawFrame(FILE * fp, unsigned char *buffer,
 
   if(raster_scan)
     free(raster_scan);
+  if(pic_big_endian)
+    free(pic_big_endian);
 
 }
 
@@ -1793,10 +1818,12 @@ void writeSlice(FILE * fp, VP8DecPicture *dec_pic) {
   u32 i, j;
   u8 *ptr = (u8*)dec_pic->p_output_frame;
 
-  tmp_ch = (u8*)malloc(chroma_size);
   if (tmp_ch == NULL) {
-    DEBUG_PRINT(("malloc error!
"));
-    return;
+    tmp_ch = (u8*)malloc(chroma_size);
+    if (tmp_ch == NULL) {
+      PRINT(("malloc error!
"));
+      return;
+    }
   }
 
   slice_rows = dec_pic->num_slice_rows;
@@ -1896,11 +1923,12 @@ u32 FfReadFrame( reader_inst reader, const u8 *buffer, u32 max_buffer_size,
   if (stream_truncate && pic_rdy && (hdrs_rdy || stream_header_corrupt)) {
     DEBUG_PRINT(("strm_len %d
", *frame_size));
     ret = TBRandomizeU32(frame_size);
-    DEBUG_PRINT(("Randomized strm_len %d
", *frame_size));
+    PRINT(("Randomized strm_len %d
", *frame_size));
   }
   if (stream_bit_swap) {
     if (stream_header_corrupt || hdrs_rdy) {
       if (pic_rdy) {
+        (void)(ret);
         ret = TBRandomizeBitSwapInStream((u8 *)buffer,
                                          *frame_size, tb_cfg.tb_params.stream_bit_swap);
       }
diff --git a/decoder_sw/software/test/vp8/ivf.c b/decoder_sw/software/test/vp8/ivf.c
index 1ae29f3..209f50c 100755
--- a/decoder_sw/software/test/vp8/ivf.c
+++ b/decoder_sw/software/test/vp8/ivf.c
@@ -40,8 +40,12 @@
 #include <string.h>
 
 void InitIVFHeader(IVF_HEADER *ivf) {
+#if 0
   memset(ivf, 0, sizeof(IVF_HEADER));
   strncpy((char*)(ivf->signature), "DKIF", 4);
   ivf->version  = 0;
   ivf->headersize = 32;
+#else
+  return;
+#endif
 }
diff --git a/decoder_sw/software/test/vp8/mcdectestbench.c b/decoder_sw/software/test/vp8/mcdectestbench.c
deleted file mode 100755
index 3476382..0000000
--- a/decoder_sw/software/test/vp8/mcdectestbench.c
+++ /dev/null
@@ -1,749 +0,0 @@
-/*------------------------------------------------------------------------------
---       Copyright (c) 2015-2017, VeriSilicon Inc. All rights reserved        --
---         Copyright (c) 2011-2014, Google Inc. All rights reserved.          --
---         Copyright (c) 2007-2010, Hantro OY. All rights reserved.           --
---                                                                            --
--- This software is confidential and proprietary and may be used only as      --
---   expressly authorized by VeriSilicon in a written licensing agreement.    --
---                                                                            --
---         This entire notice must be reproduced on all copies                --
---                       and may not be removed.                              --
---                                                                            --
---------------------------------------------------------------------------------
--- Redistribution and use in source and binary forms, with or without         --
--- modification, are permitted provided that the following conditions are met:--
---   * Redistributions of source code must retain the above copyright notice, --
---       this list of conditions and the following disclaimer.                --
---   * Redistributions in binary form must reproduce the above copyright      --
---       notice, this list of conditions and the following disclaimer in the  --
---       documentation and/or other materials provided with the distribution. --
---   * Neither the names of Google nor the names of its contributors may be   --
---       used to endorse or promote products derived from this software       --
---       without specific prior written permission.                           --
---------------------------------------------------------------------------------
--- THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"--
--- AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE  --
--- IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE --
--- ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE  --
--- LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR        --
--- CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF       --
--- SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS   --
--- INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN    --
--- CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)    --
--- ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE --
--- POSSIBILITY OF SUCH DAMAGE.                                                --
---------------------------------------------------------------------------------
-------------------------------------------------------------------------------*/
-
-#include <assert.h>
-#include <getopt.h>
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <unistd.h>
-#include <ctype.h>
-
-#include "basetype.h"
-#include "dwl.h"
-#include "dwlthread.h"
-#include "fifo.h"
-#include "regdrv_g1.h"
-#include "tb_cfg.h"
-#include "testparams.h"
-#include "vp8bufferalloc.h"
-#include "vp8decapi.h"
-#include "vp8filereader.h"
-#include "vp8hwd_container.h"
-#include "vp8writeoutput.h"
-
-#define DEFAULT_FIFO_CAPACITY   (MAX_ASIC_CORES+1)
-#define DEFAULT_OUTPUT_FILENAME "out.yuv"
-#define VP8_MAX_STREAM_SIZE     DEC_X170_MAX_STREAM>>4
-/* Multicore decoding functionality */
-/* States to control the test bench */
-typedef enum test_state_ {
-  STATE_DOWN = 0,      /* Nothing running, no resources allocated. */
-  STATE_INITIALIZING,  /* Allocating resources in input thread. */
-  STATE_STREAMING,     /* Input reading&decoding, output handling pictures. */
-  STATE_END_OF_STREAM, /* Input waiting, outputs still pending. */
-  STATE_TEARING_DOWN,  /* Input waiting, in middle of tear-down process. */
-  STATE_OUTPUT_DOWN    /* Output thread has been torn down. */
-} test_state;
-
-/* Generic function declarations. */
-typedef i32 read_stream_func(VP8DecInput*);   /* Input reading. */
-typedef i32 write_pic_func(VP8DecPicture);    /* Output writing. */
-
-typedef struct shared_data_ {
-  FifoInst input_fifo_;    /* Handle to the fifo instance. */
-  VP8DecInst dec_inst_;     /* Decoder instance. */
-  void *dwl;                /* DWL instance. */
-  pthread_t output_thread_; /* Handle to the output thread. */
-  test_state state_;        /* State of the test bench */
-  u8 stream_buffer_refresh; /* Flag to tell whether to refresh strmbuffer. */
-  VP8DecInput dec_input_;   /* Decoder input. */
-  i32 output_status_;       /* Status value for output thread */
-  write_pic_func* write_pic_; /* Function pointer to output writing. */
-} shared_data;
-
-typedef struct decoder_cb_data_ {
-  FifoInst input_fifo_;      /* Handle to the fifo instance. */
-  struct DWLLinearMem stream_mem_; /* Information about the linear mem. */
-} decoder_cb_data;
-
-typedef i32 buffer_alloc_func(shared_data*);          /* User buffer allocation */
-typedef void buffer_free_func(shared_data*);          /* User buffer free */
-
-typedef struct decoder_utils_ {
-  read_stream_func* read_stream;
-  write_pic_func* write_pic;
-  buffer_alloc_func* alloc_buffers;
-  buffer_free_func* free_buffers;
-} decoder_utils;
-
-/* Input thread functionality. */
-static int vp8_multicore_decode(decoder_utils* decoder_utils); /* Input loop. */
-static int input_on_initializing(shared_data* shared_data);
-static int input_on_streaming(shared_data* shared_data,
-                              decoder_utils* decoder_utils);
-static int input_on_end_of_stream(shared_data* shared_data);
-static int input_on_output_down(shared_data* shared_data,
-                                decoder_utils* decoder_utils);
-static void vp8_stream_consumed_cb(u8* consumed_stream_buffer,
-                                   void* user_data); /* Callback from dec. */
-
-/* Output thread functionality. */
-static void* vp8_output_thread(void* arg); /* Output loop. */
-
-/* I/O functionality required by tests. */
-i32 alloc_user_buffers(shared_data* shared_data); /* Allocate user buffers */
-void free_user_buffers(shared_data* shared_data);
-i32 alloc_user_null(shared_data* shared_data);
-void free_user_null(shared_data* shared_data);
-i32 read_vp8_stream(VP8DecInput* input); /* Input reading. */
-i32 write_pic_null(VP8DecPicture pic); /* Output writing. */
-i32 write_pic(VP8DecPicture pic); /* Output writing. */
-
-/* Parameter helpers. */
-static void print_header(void);
-static void print_usage(char* executable);
-static void setup_default_params(test_params* params);
-static void params_resolve_overlapping(struct TBCfg* tbcfg, test_params* params);
-static int parse_params(int argc, char* argv[], test_params* params);
-static int hwconfig_override(VP8DecInst dec_inst,  struct TBCfg* tbcfg);
-
-/* Helpers to protect the state. */
-static test_state get_state(shared_data* data);
-static void set_state(shared_data* data, test_state state);
-
-/* Input reader and output writer instance. */
-reader_inst g_reader_inst;
-output_inst g_output_inst;
-useralloc_inst g_useralloc_inst;
-
-/* Hack globals to carry around data for model. */
-struct TBCfg tb_cfg;
-u32 b_frames=0;
-
-#define DEBUG_PRINT(str) printf str
-
-int main(int argc, char* argv[]) {
-  test_params params;
-  u32 tmp;
-  decoder_utils dec_utils;
-  FILE * f_tbcfg;
-
-  print_header();
-  setup_default_params(&params);
-  if (argc < 2) {
-    print_usage(argv[0]);
-    return 0;
-  }
-  if (parse_params(argc, argv, &params)) {
-    return 1;
-  }
-
-  TBSetDefaultCfg(&tb_cfg); /* Set up the struct TBCfg hack. */
-  f_tbcfg = fopen("tb.cfg", "r");
-  if (f_tbcfg == NULL) {
-    DEBUG_PRINT(("UNABLE TO OPEN TEST BENCH CONFIGURATION FILE: \"tb.cfg\"
"));
-    DEBUG_PRINT(("USING DEFAULT CONFIGURATION
"));
-  } else {
-    fclose(f_tbcfg);
-    if (TBParseConfig("tb.cfg", TBReadParam, &tb_cfg) == TB_FALSE)
-      return -1;
-    if (TBCheckCfg(&tb_cfg) != 0)
-      return -1;
-  }
-
-  params_resolve_overlapping(&tb_cfg, &params);
-
-  /* Create the reader and output. */
-  g_reader_inst = rdr_open(params.in_file_name_);
-  if (g_reader_inst == NULL)
-    return 1;
-  g_output_inst = output_open(params.out_file_name_, &params);
-  if (g_output_inst == NULL)
-    return 1;
-
-  /* Create user buffer allocator if necessary */
-  if (params.user_allocated_buffers_) {
-    g_useralloc_inst = useralloc_open(&params);
-    if (g_useralloc_inst == NULL)
-      return 1;
-  }
-
-#ifdef ASIC_TRACE_SUPPORT
-  tmp = openTraceFiles();
-  if (!tmp) {
-    DEBUG_PRINT(("UNABLE TO OPEN TRACE FILE(S)
"));
-  }
-#endif
-
-  /* Setup decoder utility functions */
-  dec_utils.read_stream = read_vp8_stream;
-  dec_utils.write_pic = write_pic;
-  if (params.user_allocated_buffers_) {
-    dec_utils.alloc_buffers = alloc_user_buffers;
-    dec_utils.free_buffers = free_user_buffers;
-  } else {
-    dec_utils.alloc_buffers = alloc_user_null;
-    dec_utils.free_buffers = free_user_null;
-  }
-  /* Run the input loop. */
-  vp8_multicore_decode(&dec_utils);
-
-  /* Close the reader and output. */
-  rdr_close(g_reader_inst);
-  output_close(g_output_inst);
-
-  if (params.user_allocated_buffers_) {
-    useralloc_close(g_useralloc_inst);
-  }
-  return 0;
-}
-
-static int vp8_multicore_decode(decoder_utils* decoder_utils) {
-  shared_data shared_data = {0};
-  set_state(&shared_data, STATE_INITIALIZING);
-  shared_data.write_pic_ = decoder_utils->write_pic;
-  /* Start the actual decoding loop. */
-  while (1) {
-    switch (get_state(&shared_data)) {
-    case STATE_INITIALIZING:
-      if(input_on_initializing(&shared_data)) {
-        /* If init fails do not continue. */
-        if (shared_data.dwl) free(shared_data.dwl);
-        return 0;
-      }
-      break;
-    case STATE_STREAMING:
-      input_on_streaming(&shared_data, decoder_utils);
-      break;
-    case STATE_END_OF_STREAM:
-      input_on_end_of_stream(&shared_data);
-      break;
-    case STATE_OUTPUT_DOWN:
-      input_on_output_down(&shared_data, decoder_utils);
-      return 0;
-    case STATE_TEARING_DOWN:
-    case STATE_DOWN:
-    default:
-      fprintf(stderr, "Input thread in invalid state.");
-      assert(0);
-      return -1;
-    }
-  }
-  fprintf(stderr, "ERROR: Something went horribly wrong with input thread.");
-  assert(0);
-  return -1;
-}
-
-static void vp8_stream_consumed_cb(u8* consumed_stream_buffer,
-                                   void* user_data) {
-  /* This function could be called in signal handler context. */
-  assert(user_data);
-  decoder_cb_data* callback_data = (decoder_cb_data*)user_data;
-  FifoObject stream_buffer = callback_data;
-  /* Recycle the input buffer to the input buffer queue. */
-  FifoPush(callback_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
-}
-
-static void* vp8_output_thread(void* arg) {
-  assert(arg);
-  do {
-    shared_data* shared_data = arg;
-    VP8DecRet rv;
-    VP8DecPicture pic;
-    switch (get_state(shared_data)) {
-    case STATE_STREAMING:
-    case STATE_END_OF_STREAM:
-      /* Function call blocks until picture is actually ready. */
-      rv = VP8DecMCNextPicture(shared_data->dec_inst_, &pic);
-      switch (rv) {
-      case VP8DEC_OK:
-      case VP8DEC_PIC_RDY:
-        shared_data->output_status_ =
-          shared_data->write_pic_(pic);
-        /* Return the picture buffer to the decoder. */
-        VP8DecMCPictureConsumed(shared_data->dec_inst_, &pic);
-        if (shared_data->output_status_) {
-          fprintf(stderr, "ERROR: output writing failed.");
-          set_state(shared_data, STATE_END_OF_STREAM);
-        }
-        break;
-      case VP8DEC_END_OF_STREAM:
-        set_state(shared_data, STATE_TEARING_DOWN);
-        break;
-      default:
-        /* If this happens, we're already screwed. */
-        fprintf(stderr,
-                "ERROR: unhandled condition for NextPicture.");
-        set_state(shared_data, STATE_OUTPUT_DOWN);
-        shared_data->output_status_ = -1;
-        break;
-      }
-      break;
-
-    case STATE_TEARING_DOWN:
-      set_state(shared_data, STATE_OUTPUT_DOWN);
-      pthread_exit(NULL);
-      break;
-
-    case STATE_INITIALIZING:
-    case STATE_OUTPUT_DOWN:
-    case STATE_DOWN:
-    default:
-      fprintf(stderr, "Output thread active in invalid state.");
-      assert(0);
-      pthread_exit(NULL);
-      break;
-    }
-  } while (1);
-
-  fprintf(stderr, "Program error in output thread.");
-  assert(0);
-  return NULL;
-}
-
-i32 alloc_user_buffers(shared_data* shared_data) {
-  return useralloc_alloc(g_useralloc_inst, shared_data->dec_inst_, shared_data->dwl);
-}
-void free_user_buffers(shared_data* shared_data) {
-  useralloc_free(g_useralloc_inst, shared_data->dec_inst_, shared_data->dwl);
-
-}
-
-i32 alloc_user_null(shared_data* shared_data) {
-  return 0;
-}
-
-void free_user_null(shared_data* shared_data) {
-  return;
-}
-
-i32 read_vp8_stream(VP8DecInput* input) {
-  return rdr_read_frame(g_reader_inst, input->stream, VP8_MAX_STREAM_SIZE,
-                        &input->data_len, 1);
-}
-
-i32 write_pic(VP8DecPicture pic) {
-  DEBUG_PRINT(("WRITING PICTURE %d
", pic.pic_id));
-
-  return output_write_pic(g_output_inst,
-                          (unsigned char *) pic.p_output_frame,
-                          (unsigned char *) pic.p_output_frame_c,
-                          pic.frame_width, pic.frame_height,
-                          pic.coded_width, pic.coded_height,
-                          0,
-                          pic.output_format,
-                          pic.luma_stride,
-                          pic.chroma_stride,
-                          pic.pic_id);
-
-}
-
-i32 write_pic_null(VP8DecPicture pic) {
-  return 0;
-}
-
-static int input_on_initializing(shared_data* shared_data) {
-  i32 i;
-  i32 num_of_stream_bufs = DEFAULT_FIFO_CAPACITY;
-  VP8DecFormat dec_format;
-  VP8DecMCConfig config;
-  VP8DecRet rv;
-
-  struct DWLInitParam dwl_init;
-  dwl_init.client_type = DWL_CLIENT_TYPE_VP8_DEC;
-
-  shared_data->dwl = (void *)DWLInit(&dwl_init);
-
-  if(shared_data->dwl == NULL) {
-    return -1;
-  }
-
-  /* Allocate initial stream buffers and put them to fifo queue */
-  if (FifoInit(DEFAULT_FIFO_CAPACITY, &shared_data->input_fifo_))
-    return -1;
-
-  if(rdr_identify_format(g_reader_inst) != BITSTREAM_VP8) {
-    return -1;
-  }
-  config.stream_consumed_callback = vp8_stream_consumed_cb;
-  /* Initialize the decoder in multicore mode. */
-  if (VP8DecMCInit(&shared_data->dec_inst_, shared_data->dwl, &config) != VP8DEC_OK) {
-    FifoRelease(shared_data->input_fifo_);
-    set_state(shared_data, STATE_TEARING_DOWN);
-    return -1;
-  }
-
-  /* Create the stream buffers and push them into the FIFO. */
-  for (i = 0; i < num_of_stream_bufs; i++) {
-    FifoObject stream_buffer;
-    struct DWLLinearMem stream_mem;
-    stream_buffer = malloc(sizeof(decoder_cb_data));
-    if (!stream_buffer) {
-      fprintf(stderr,"UNABLE TO MALLOC STREAM BUFFER
");
-      return -1;
-    }
-    stream_buffer->input_fifo_ = shared_data->input_fifo_;
-    if (DWLMallocLinear(
-          ((VP8DecContainer_t *)shared_data->dec_inst_)->dwl,
-          VP8_MAX_STREAM_SIZE,
-          &stream_buffer->stream_mem_) != DWL_OK) {
-      fprintf(stderr,"UNABLE TO ALLOCATE STREAM BUFFER MEM
");
-      set_state(shared_data, STATE_TEARING_DOWN);
-      if (stream_buffer) free(stream_buffer);
-      return -1;
-    }
-    FifoPush(shared_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
-  }
-
-  /* Internal testing feature: Override HW configuration parameters */
-  hwconfig_override(shared_data->dec_inst_, &tb_cfg);
-
-  /* Start the output handling thread. */
-  shared_data->stream_buffer_refresh = 1;
-  set_state(shared_data, STATE_STREAMING);
-  pthread_create(&shared_data->output_thread_, NULL, vp8_output_thread,
-                 shared_data);
-  return 0;
-}
-
-static int input_on_streaming(shared_data* shared_data,
-                              decoder_utils* decoder_utils) {
-  FifoObject stream_buffer = NULL;
-  VP8DecRet rv;
-  VP8DecOutput output;
-  /* If needed, refresh the input stream buffer. */
-  if (shared_data->stream_buffer_refresh) {
-    /* Fifo pop blocks until available or queue released. */
-    FifoPop(shared_data->input_fifo_, &stream_buffer, FIFO_EXCEPTION_DISABLE);
-    /* Read data to stream buffer. */
-    memset(&shared_data->dec_input_, 0, sizeof(shared_data->dec_input_));
-    shared_data->dec_input_.stream =
-      (u8*)stream_buffer->stream_mem_.virtual_address;
-    shared_data->dec_input_.stream_bus_address =
-      stream_buffer->stream_mem_.bus_address;
-    /* Trick to recycle buffer and fifo to the callback. */
-    shared_data->dec_input_.p_user_data = stream_buffer;
-    switch (decoder_utils->read_stream(&shared_data->dec_input_)) {
-    case 0:
-      shared_data->stream_buffer_refresh = 0;
-      break;
-    /* TODO(vmr): Remember to check eos and set it. */
-    default:
-      /* Return the unused buffer. */
-      FifoPush(shared_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
-      set_state(shared_data, STATE_END_OF_STREAM);
-      return 0;
-    }
-  }
-  /* Decode the contents of the input stream buffer. */
-  switch (rv = VP8DecMCDecode(shared_data->dec_inst_, &shared_data->dec_input_,
-                              &output)) {
-  case VP8DEC_HDRS_RDY:
-    if(decoder_utils->alloc_buffers(shared_data)) {
-      fprintf(stderr, "Error in custom buffer allocation
");
-      /* Return the stream buffer if allocation fails. */
-      if(stream_buffer != NULL) {
-        FifoPush(shared_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
-      }
-      set_state(shared_data, STATE_END_OF_STREAM);
-    }
-    break;
-  case VP8DEC_STRM_PROCESSED:
-  case VP8DEC_PIC_DECODED:
-  case VP8DEC_SLICE_RDY:
-  case VP8DEC_OK:
-    /* Everything is good, keep on going. */
-    shared_data->stream_buffer_refresh = 1;
-    break;
-  case VP8DEC_STREAM_NOT_SUPPORTED:
-    /* Probably encountered faulty bitstream. */
-    fprintf(stderr, "Missing headers or unsupported stream(?)
");
-    set_state(shared_data, STATE_END_OF_STREAM);
-    break;
-  case VP8DEC_MEMFAIL:
-    /* Might be low on memory or something worse, anyway we
-     * need to stop */
-    fprintf(stderr,
-            "VP8DecDecode VP8DEC_MEMFAIL. Low on memory?
");
-    set_state(shared_data, STATE_END_OF_STREAM);
-    break;
-  case VP8DEC_PARAM_ERROR:
-  case VP8DEC_NOT_INITIALIZED:
-    /* these are errors when the decoder cannot possibly call
-     * stream consumed callback and therefore we push the buffer
-     * into the empty queue here. */
-    FifoPush(shared_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
-  case VP8DEC_INITFAIL:
-  case VP8DEC_HW_RESERVED:
-  case VP8DEC_HW_TIMEOUT:
-  case VP8DEC_HW_BUS_ERROR:
-  case VP8DEC_SYSTEM_ERROR:
-  case VP8DEC_DWL_ERROR:
-  case VP8DEC_STRM_ERROR:
-    /* This is bad stuff and something in the system is
-     * fundamentally flawed. Can't do much so just stop. */
-    fprintf(stderr, "VP8DecDecode fatal failure %i
", rv);
-    set_state(shared_data, STATE_END_OF_STREAM);
-    break;
-  case VP8DEC_EVALUATION_LIMIT_EXCEEDED:
-    fprintf(stderr, "Decoder evaluation limit reached
");
-    /* Return the stream buffer. */
-    set_state(shared_data, STATE_END_OF_STREAM);
-    break;
-  case VP8DEC_PIC_RDY:
-  default:
-    fprintf(stderr, "UNKNOWN ERROR!
");
-    /* Return the stream buffer. */
-    FifoPush(shared_data->input_fifo_, stream_buffer, FIFO_EXCEPTION_DISABLE);
-    set_state(shared_data, STATE_END_OF_STREAM);
-    break;
-  }
-  return 0;
-}
-
-static int input_on_end_of_stream(shared_data* shared_data) {
-  if(VP8DecMCEndOfStream(shared_data->dec_inst_) != VP8DEC_OK) {
-    fprintf(stderr, "VP8DecMCEndOfStream returned unexpected failure
");
-  }
-
-  /* We're done, wait for the output to finish it's job. */
-  pthread_join(shared_data->output_thread_, NULL);
-  if (shared_data->output_status_) {
-    fprintf(stderr, "Output thread returned fail status (%u)
",
-            shared_data->output_status_);
-  }
-  return 0;
-}
-
-static int input_on_output_down(shared_data* shared_data,
-                                decoder_utils* decoder_utils) {
-  i32 i;
-  for (i = 0; i < DEFAULT_FIFO_CAPACITY; i++) {
-    FifoObject stream_buffer;
-    FifoPop(shared_data->input_fifo_, &stream_buffer, FIFO_EXCEPTION_DISABLE);
-    DWLFreeLinear(((VP8DecContainer_t *)shared_data->dec_inst_)->dwl,
-                  &stream_buffer->stream_mem_);
-    free(stream_buffer);
-  }
-
-  decoder_utils->free_buffers(shared_data);
-
-  /* Release the allocated resources. */
-  FifoRelease(shared_data->input_fifo_);
-  set_state(shared_data, STATE_DOWN);
-  VP8DecRelease(shared_data->dec_inst_);
-  return 0;
-}
-
-static void print_header(void) {
-  VP8DecApiVersion version = VP8DecGetAPIVersion();
-  VP8DecBuild build = VP8DecGetBuild();
-  printf("Multicore VP8 decoder
");
-  printf("API version %i.%i, ", version.major, version.minor);
-  printf("SW build %u, ", build.sw_build);
-  printf("HW build %u
", build.hw_build);
-}
-
-static void print_usage(char* executable) {
-  printf("Usage: %s [options] <file>
", executable);
-  printf("	-a (or -Xa) user allocates picture buffers, alternate allocation order. (--user-allocated-buffers-alt)
");
-  printf("	-cn Chrominance stride. (--chroma-stride)
");
-  printf("	-C display cropped image. (--display-cropped)
");
-  printf("	-D Disable output writing (--disable-write)
");
-  printf("	-E use tiled reference frame format. (--tiled-output)
");
-  printf("	-F Enable frame picture writing, filled black. (--frame-write)
");
-  printf("	-I use interleaved frame buffers (requires stride mode and "\
-         "user allocated buffers(--interleaved-buffers
");
-  printf("	-ln Luminance stride. (--luma-stride)
");
-  printf("	-Nn forces decoding to stop after n pictures. (--decode-n-pictures)
");
-  printf("	-Ooutfile write output to \"outfile\" (default out.yuv). (--output-file <outfile>)
");
-  printf("	-M write output as MD5 sum. (--md5)
");
-  printf("	-X user allocates picture buffers. (--user-allocated-buffers)
");
-}
-
-static void setup_default_params(test_params* params) {
-  memset(params, 0, sizeof(test_params));
-  params->out_file_name_ = DEFAULT_OUTPUT_FILENAME;
-}
-
-static void params_resolve_overlapping(struct TBCfg* tbcfg, test_params* params) {
-  /* Override decoder allocation with tbcfg value */
-  if (TBGetDecMemoryAllocation(&tb_cfg) &&
-      params->user_allocated_buffers_ == VP8DEC_DECODER_ALLOC) {
-    params->user_allocated_buffers_ = VP8DEC_EXTERNAL_ALLOC;
-  }
-
-  if (params->luma_stride_ || params->chroma_stride_) {
-    if (params->user_allocated_buffers_ == VP8DEC_DECODER_ALLOC) {
-      params->user_allocated_buffers_ = VP8DEC_EXTERNAL_ALLOC;
-    }
-
-    if (params->md5_) {
-      params->frame_picture_ = 1;
-    }
-  }
-  /* MD5 sum unsupported for external mem allocation */
-  if (params->interleaved_buffers_ ||
-      params->user_allocated_buffers_ != VP8DEC_DECODER_ALLOC) {
-    params->md5_ = 0;
-  }
-}
-
-static int parse_params(int argc, char* argv[], test_params* params) {
-  i32 c;
-  i32 option_index = 0;
-  static struct option long_options[] = {
-    {"user-allocated-buffers-alt", no_argument, 0, 'a'},
-    {"chroma-stride", required_argument, 0, 'c'},
-    {"display-cropped", no_argument, 0, 'C'},
-    {"disable-write", no_argument, 0, 'D'},
-    {"tiled-ouput", no_argument, 0, 'E'},
-    {"frame-write", no_argument, 0, 'F'},
-    {"interleaved-buffers", no_argument, 0, 'I'},
-    {"luma-stride", required_argument, 0, 'l'},
-    {"md5",  no_argument, 0, 'M'},
-    {"decode-n-pictures",  required_argument, 0, 'N'},
-    {"output-file",  required_argument, 0, 'O'},
-    {"user-allocated-buffers", no_argument, 0, 'X'},
-    {0, 0, 0, 0}
-  };
-
-  /* read command line arguments */
-  while ((c = getopt_long(argc, argv, "ac:CDEFIl:MN:O:X", long_options, &option_index)) != -1) {
-    switch (c) {
-
-    case 'a':
-      params->user_allocated_buffers_ = VP8DEC_EXTERNAL_ALLOC_ALT;
-      break;
-    case 'c':
-      params->chroma_stride_ = atoi(optarg);
-      break;
-    case 'C':
-      params->display_cropped_ = 1;
-      break;
-    case 'D':
-      params->disable_write_ = 1;
-      break;
-    case 'E':
-      params->tiled_ = 1;
-      break;
-    case 'F':
-      params->frame_picture_ = 1;
-      break;
-    case 'I':
-      params->interleaved_buffers_ = 1;
-      break;
-    case 'l':
-      params->luma_stride_ = atoi(optarg);
-      break;
-    case 'M':
-      params->md5_ = 1;
-      break;
-    case 'N':
-      params->num_of_decoded_pics_ = atoi(optarg);
-      break;
-    case 'O':
-      params->out_file_name_ = optarg;
-      break;
-    case 'X':
-      params->user_allocated_buffers_ = VP8DEC_EXTERNAL_ALLOC;
-      break;
-    case ':':
-      if (optopt == 'O' || optopt == 'N' || optopt == 'l' || optopt == 'c')
-        fprintf(stderr, "Option -%c requires an argument.
",
-                optopt);
-      return 1;
-    case '?':
-      if (isprint(optopt))
-        fprintf(stderr, "Unknown option `-%c'.
", optopt);
-      else
-        fprintf(stderr,
-                "Unknown option character `\x%x'.
",
-                optopt);
-      return 1;
-    default:
-      break;
-    }
-  }
-  if (optind >= argc) {
-    fprintf(stderr, "Invalid or no input file specified
");
-    return 1;
-  }
-  params->in_file_name_ = argv[optind];
-  return 0;
-}
-
-static pthread_mutex_t cs_mutex = PTHREAD_MUTEX_INITIALIZER;
-
-static test_state get_state(shared_data* data) {
-  pthread_mutex_lock(&cs_mutex);
-  test_state state = data->state_;
-  pthread_mutex_unlock(&cs_mutex);
-  return state;
-}
-
-static void set_state(shared_data* data, test_state state) {
-  pthread_mutex_lock(&cs_mutex);
-  data->state_ = state;
-  pthread_mutex_unlock(&cs_mutex);
-}
-
-static int hwconfig_override(VP8DecInst dec_inst,  struct TBCfg* tbcfg) {
-  u32 clock_gating = TBGetDecClockGating(&tb_cfg);
-  u32 data_discard = TBGetDecDataDiscard(&tb_cfg);
-  u32 latency_comp = tb_cfg.dec_params.latency_compensation;
-  u32 output_picture_endian = TBGetDecOutputPictureEndian(&tb_cfg);
-  u32 bus_burst_length = tb_cfg.dec_params.bus_burst_length;
-  u32 asic_service_priority = tb_cfg.dec_params.asic_service_priority;
-  u32 output_format = TBGetDecOutputFormat(&tb_cfg);
-  u32 service_merge_disable = TBGetDecServiceMergeDisable(&tb_cfg);
-
-  DEBUG_PRINT(("Decoder Clock Gating %d
", clock_gating));
-  DEBUG_PRINT(("Decoder Data Discard %d
", data_discard));
-  DEBUG_PRINT(("Decoder Latency Compensation %d
", latency_comp));
-  DEBUG_PRINT(("Decoder Output Picture Endian %d
", output_picture_endian));
-  DEBUG_PRINT(("Decoder Bus Burst Length %d
", bus_burst_length));
-  DEBUG_PRINT(("Decoder Asic Service Priority %d
", asic_service_priority));
-  DEBUG_PRINT(("Decoder Output Format %d
", output_format));
-
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_DEC_LATENCY,
-                 latency_comp);
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_DEC_CLK_GATE_E,
-                 clock_gating);
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_DEC_OUT_TILED_E,
-                 output_format);
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_DEC_OUT_ENDIAN,
-                 output_picture_endian);
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_DEC_MAX_BURST,
-                 bus_burst_length);
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_DEC_DATA_DISC_E,
-                 data_discard);
-  SetDecRegister(((VP8DecContainer_t *) dec_inst)->vp8_regs, HWIF_SERV_MERGE_DIS,
-                 service_merge_disable);
-  return 0;
-}
diff --git a/decoder_sw/software/test/vp8/vp8filereader.c b/decoder_sw/software/test/vp8/vp8filereader.c
index bf221b8..2ec167b 100755
--- a/decoder_sw/software/test/vp8/vp8filereader.c
+++ b/decoder_sw/software/test/vp8/vp8filereader.c
@@ -166,7 +166,8 @@ i32 rdr_read_frame(reader_inst inst, const u8 *buffer, u32 max_buffer_size,
     char signature[] = "WEBP";
     char format_[] = "VP8 ";
     u8 tmp[4];
-    fseek(fin, 8, SEEK_CUR);
+    if (fseek(fin, 8, SEEK_CUR) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     ret = fread(tmp, sizeof(u8), 4, fin);
     if (strncmp(signature, tmp, 4))
       return HANTRO_NOK;
@@ -223,11 +224,13 @@ i32 rdr_read_frame(reader_inst inst, const u8 *buffer, u32 max_buffer_size,
   if(*frame_size > max_buffer_size) {
     fprintf(stderr, "Frame size %d > buffer size %d
",
             *frame_size, max_buffer_size );
-    fseek(fin, *frame_size, SEEK_CUR);
+    if (fseek(fin, *frame_size, SEEK_CUR) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     if (ff->format_ != FF_WEBP)
       *frame_size = (u32)(-1);
     else
-      fseek(fin, pos, SEEK_SET);
+      if (fseek(fin, pos, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     return HANTRO_NOK;
   }
 
@@ -382,9 +385,11 @@ static int file_is_webm(input_ctx_t *input, FILE* infile, unsigned int* fourcc,
   nestegg_video_params params;
 
   /* Get the file size for nestegg. */
-  fseek(infile, 0, SEEK_END);
+  if (fseek(infile, 0, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   file_size = ftell(infile);
-  fseek(infile, 0, SEEK_SET);
+  if (fseek(infile, 0, SEEK_SET) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
   if(nestegg_init(&input->nestegg_ctx, io, NULL, file_size))
     goto fail;
diff --git a/decoder_sw/software/test/vp8/vp8writeoutput.c b/decoder_sw/software/test/vp8/vp8writeoutput.c
index 2f4efe1..9b3cb98 100755
--- a/decoder_sw/software/test/vp8/vp8writeoutput.c
+++ b/decoder_sw/software/test/vp8/vp8writeoutput.c
@@ -93,153 +93,6 @@ void output_close(output_inst inst) {
   free(output);
 }
 
-i32 output_write_pic(output_inst inst, unsigned char *buffer,
-                     unsigned char *buffer_ch, i32 frame_width,
-                     i32 frame_height, i32 cropped_width, i32 cropped_height, i32 planar,
-                     i32 tiled_mode, u32 luma_stride, u32 chroma_stride, u32 pic_num) {
-  output_t* output = (output_t *)inst;
-
-  int luma_size = luma_stride * frame_height;
-  int frame_size = luma_size + (chroma_stride*frame_height/2);
-  static int pic_number = 0;
-  int height_crop = 0;
-  int include_strides  = 0;
-  static struct MD5Context ctx;
-  unsigned char digest[16];
-  int i = 0;
-  unsigned char *cb,*cr;
-  int ret;
-  unsigned char *output_l = buffer;
-  unsigned char *output_ch = buffer_ch;
-  int write_planar = planar;
-  unsigned int stride_luma_local = luma_stride;
-  unsigned int stride_chroma_local = chroma_stride;
-  unsigned char *local_buffer = buffer;
-
-
-  if(output->file_ == NULL)
-    return 0;
-
-  /* TODO(mheikkinen) TILED format */
-  /* TODO(mheikkinen) DEC_X170_BIG_ENDIAN */
-  if (output->params->num_of_decoded_pics_ <= pic_num &&
-      output->params->num_of_decoded_pics_) {
-    return 1;
-  }
-
-
-  if (output->params->frame_picture_) {
-    if (output->frame_pic_ == NULL) {
-      output->frame_pic_ =
-        (u8*)malloc( frame_height * frame_width *3/2 * sizeof(u8));
-      if (output->frame_pic_ == NULL)
-        return 0;
-    }
-    FramePicture((u8*)buffer,
-                 (u8*)buffer_ch,
-                 cropped_width,
-                 cropped_height,
-                 frame_width,
-                 frame_height,
-                 output->frame_pic_, frame_width, frame_height,
-                 output->params->luma_stride_,
-                 output->params->chroma_stride_);
-    output_l = output->frame_pic_;
-    output_ch = NULL;
-    write_planar = 1;
-    stride_luma_local = stride_chroma_local = frame_width;
-    luma_size = frame_width * frame_height;
-    frame_size = luma_size * 3/2;
-    local_buffer = output->frame_pic_;
-  }
-
-  if (output->params->md5_) {
-    /* chroma should be right after luma */
-    MD5Init(&ctx);
-    MD5Update(&ctx, buffer, frame_size);
-    MD5Final(digest, &ctx);
-
-    for(i = 0; i < sizeof digest; i++) {
-      fprintf(output->file_, "%02X", digest[i]);
-    }
-    fprintf(output->file_, "
");
-
-    return 0;
-  } else {
-    if (output_ch == NULL) {
-      output_ch = output_l + luma_size;
-    }
-
-    if (!height_crop || (cropped_height == frame_height && cropped_width == frame_width)) {
-      u32 i, j;
-      u8 *buffer_tmp;
-      buffer_tmp = local_buffer;
-
-      for( i = 0 ; i < frame_height ; ++i ) {
-        fwrite( buffer_tmp, include_strides ? stride_luma_local : frame_width, 1, output->file_);
-        buffer_tmp += stride_luma_local;
-      }
-
-      if (!write_planar) {
-
-        buffer_tmp = output_ch;
-        for( i = 0 ; i < frame_height / 2 ; ++i ) {
-          fwrite( buffer_tmp, include_strides ? stride_chroma_local : frame_width, 1, output->file_);
-          buffer_tmp += stride_chroma_local;
-        }
-      } else {
-        buffer_tmp = output_ch;
-        for(i = 0; i < frame_height / 2; i++) {
-          for( j = 0 ; j < (include_strides ? stride_chroma_local / 2 : frame_width / 2); ++j) {
-            fwrite(buffer_tmp + j * 2, 1, 1, output->file_);
-          }
-          buffer_tmp += stride_chroma_local;
-        }
-        buffer_tmp = output_ch + 1;
-        for(i = 0; i < frame_height / 2; i++) {
-          for( j = 0 ; j < (include_strides ? stride_chroma_local / 2: frame_width / 2); ++j) {
-            fwrite(buffer_tmp + j * 2, 1, 1, output->file_);
-          }
-          buffer_tmp += stride_chroma_local;
-        }
-      }
-    } else {
-      u32 row;
-      for( row = 0 ; row < cropped_height ; row++) {
-        fwrite(local_buffer + row*stride_luma_local, cropped_width, 1, output->file_);
-      }
-      if (!write_planar) {
-        if(cropped_height &1)
-          cropped_height++;
-        if(cropped_width & 1)
-          cropped_width++;
-        for( row = 0 ; row < cropped_height/2 ; row++)
-          fwrite(output_ch + row*stride_chroma_local, (cropped_width*2)/2, 1, output->file_);
-      } else {
-        u32 i, tmp;
-        tmp = frame_width*cropped_height/4;
-
-        if(cropped_height &1)
-          cropped_height++;
-        if(cropped_width & 1)
-          cropped_width++;
-
-        for( row = 0 ; row < cropped_height/2 ; ++row ) {
-          for(i = 0; i < cropped_width/2; i++)
-            fwrite(output_ch + row*stride_chroma_local + i * 2, 1, 1, output->file_);
-        }
-        for( row = 0 ; row < cropped_height/2 ; ++row ) {
-          for(i = 0; i < cropped_width/2; i++)
-            fwrite(output_ch + 1 + row*stride_chroma_local + i * 2, 1, 1, output->file_);
-        }
-      }
-    }
-  }
-
-  return 0;
-
-}
-
 static void FramePicture( u8 *p_in, u8* p_ch, i32 in_width, i32 in_height,
                           i32 in_frame_width, i32 in_frame_height,
                           u8 *p_out, i32 out_width, i32 out_height,
diff --git a/decoder_sw/software/test/vp8/vp8writeoutput.h b/decoder_sw/software/test/vp8/vp8writeoutput.h
index d86ea86..f001c81 100755
--- a/decoder_sw/software/test/vp8/vp8writeoutput.h
+++ b/decoder_sw/software/test/vp8/vp8writeoutput.h
@@ -52,11 +52,6 @@ typedef void* output_inst;
 output_inst output_open(char* filename, test_params* params);
 void output_close(output_inst inst);
 
-i32 output_write_pic(output_inst inst, unsigned char *buffer,
-                     unsigned char *buffer_ch, i32 frame_width,
-                     i32 frame_height, i32 cropped_width, i32 cropped_height, i32 planar,
-                     i32 tiled_mode, u32 luma_stride, u32 chroma_stride, u32 pic_num);
-
 #ifdef __cplusplus
 }
 #endif
diff --git a/decoder_sw/software/test/vp9/dectestbench.c b/decoder_sw/software/test/vp9/dectestbench.c
index 71ff867..b868a7c 100755
--- a/decoder_sw/software/test/vp9/dectestbench.c
+++ b/decoder_sw/software/test/vp9/dectestbench.c
@@ -738,14 +738,22 @@ int main(int argc, char **argv) {
   DEBUG_PRINT(("TB Stream Packet Loss %d; odds %s
", stream_packet_loss,
                tb_cfg.tb_params.stream_packet_loss));
 
+#ifdef ASIC_TRACE_SUPPORT
   {
-    remove("regdump.txt");
-    remove("mbcontrol.hex");
-    remove("intra4x4_modes.hex");
-    remove("motion_vectors.hex");
-    remove("rlc.hex");
-    remove("picture_ctrl_dec.trc");
+    if (remove("regdump.txt") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("mbcontrol.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("intra4x4_modes.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("motion_vectors.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("rlc.hex") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (remove("picture_ctrl_dec.trc") != 0)
+      fprintf(stderr, "remove() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
+#endif
 
   if (trace_target) tb_cfg.tb_params.extra_cu_ctrl_eof = 1;
 
@@ -869,7 +877,8 @@ int main(int argc, char **argv) {
   TBInitializeRandom(seed_rnd);
 
   /* check size of the input file -> length of the stream in bytes */
-  fseek(finput, 0L, SEEK_END);
+  if (fseek(finput, 0L, SEEK_END) != 0)
+    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   strm_len = ftell(finput);
   rewind(finput);
 
@@ -976,7 +985,8 @@ int main(int argc, char **argv) {
           DEBUG_PRINT(("STREAM WILL END
"));
           stream_will_end = 1;
         } else {
-          fseek(findex, -2, SEEK_CUR);
+          if (fseek(findex, -2, SEEK_CUR) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         }
       }
 
@@ -1384,7 +1394,8 @@ end:
 
   strm_len = 0;
   if (foutput) {
-    fseek(foutput, 0L, SEEK_END);
+    if (fseek(foutput, 0L, SEEK_END) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     strm_len = (u32)ftell(foutput);
     fclose(foutput);
   }
@@ -1694,7 +1705,8 @@ u32 fill_buffer(u8 *stream) {
   u32 data_len = 0;
 
   if (cur_index != ftell(finput)) {
-    fseeko64(finput, cur_index, SEEK_SET);
+    if (fseeko64(finput, cur_index, SEEK_SET) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
   }
 
   /* read next index */
diff --git a/decoder_sw/software/test/vp9/ivf.c b/decoder_sw/software/test/vp9/ivf.c
index 8553ed6..41e5891 100755
--- a/decoder_sw/software/test/vp9/ivf.c
+++ b/decoder_sw/software/test/vp9/ivf.c
@@ -39,8 +39,12 @@
 #include <string.h>
 
 void InitIVFHeader(IVF_HEADER *ivf) {
+#if 0
   memset(ivf, 0, sizeof(IVF_HEADER));
   strncpy((char *)(ivf->signature), "DKIF", 4);
   ivf->version = 0;
   ivf->headersize = 32;
+#else
+  return;
+#endif
 }
\ No newline at end of file
diff --git a/openmax_il/source/OSAL.c b/openmax_il/source/OSAL.c
index 19c0d3c..88b0484 100755
--- a/openmax_il/source/OSAL.c
+++ b/openmax_il/source/OSAL.c
@@ -937,6 +937,7 @@ OSAL_ERRORTYPE OSAL_EventReset(OSAL_PTR hEvent)
         char c = 1;
         int ret = read(pEvent->fd[0], &c, 1);
         if (ret == -1) {
+            pthread_mutex_unlock(&pEvent->mutex);
             DBGT_CRITICAL("read(pEvent->fd[0], &c, 1) failed");
             DBGT_EPILOG("");
             return OSAL_ERROR_UNDEFINED;
@@ -974,6 +975,7 @@ OSAL_ERRORTYPE OSAL_EventSet(OSAL_PTR hEvent)
         char c = 1;
         int ret = write(pEvent->fd[1], &c, 1);
         if (ret == -1) {
+            pthread_mutex_unlock(&pEvent->mutex);
             DBGT_CRITICAL("write(pEvent->fd[1], &c, 1) failed");
             DBGT_EPILOG("");
             return OSAL_ERROR_UNDEFINED;
diff --git a/openmax_il/source/decoder/codec_avs.c b/openmax_il/source/decoder/codec_avs.c
index fdda70d..c7462ea 100755
--- a/openmax_il/source/decoder/codec_avs.c
+++ b/openmax_il/source/decoder/codec_avs.c
@@ -822,7 +822,7 @@ CODEC_STATE decoder_setframebuffer_avs(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX_
     UNUSED_PARAMETER(available_buffers);
     CODEC_AVS *this = (CODEC_AVS *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     AvsDecBufferInfo info;
     AvsDecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_h264.c b/openmax_il/source/decoder/codec_h264.c
index 30baf63..dceab6b 100755
--- a/openmax_il/source/decoder/codec_h264.c
+++ b/openmax_il/source/decoder/codec_h264.c
@@ -881,7 +881,7 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_h264(const void *DWLInstance,
                         DWLInstance,
 #endif
                         DISABLE_OUTPUT_REORDER,
-                        ERROR_HANDLING, USE_DISPLAY_SMOOTHING,
+                        DEC_EC_NONE, USE_DISPLAY_SMOOTHING,   /*use ec_none as default to aovid display freeze*/
                         dpbFlags,
                         g1Conf->bEnableAdaptiveBuffers,
                         g1Conf->nGuardSize,
@@ -944,7 +944,7 @@ CODEC_STATE decoder_setframebuffer_h264(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX
     UNUSED_PARAMETER(available_buffers);
     CODEC_H264 *this = (CODEC_H264 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     H264DecBufferInfo info;
     H264DecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_hevc.c b/openmax_il/source/decoder/codec_hevc.c
index 6ef47c2..7b3ceff 100755
--- a/openmax_il/source/decoder/codec_hevc.c
+++ b/openmax_il/source/decoder/codec_hevc.c
@@ -707,7 +707,7 @@ CODEC_STATE decoder_setframebuffer_hevc(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX
     UNUSED_PARAMETER(available_buffers);
     CODEC_HEVC *this = (CODEC_HEVC *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     struct HevcDecBufferInfo info;
     enum DecRet ret;
     const int page_size = getpagesize();
diff --git a/openmax_il/source/decoder/codec_mpeg2.c b/openmax_il/source/decoder/codec_mpeg2.c
index 87fed15..d29280c 100755
--- a/openmax_il/source/decoder/codec_mpeg2.c
+++ b/openmax_il/source/decoder/codec_mpeg2.c
@@ -847,7 +847,7 @@ CODEC_STATE decoder_setframebuffer_mpeg2(CODEC_PROTOTYPE * arg, BUFFER *buff, OM
     UNUSED_PARAMETER(available_buffers);
     CODEC_MPEG2 *this = (CODEC_MPEG2 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     Mpeg2DecBufferInfo info;
     Mpeg2DecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_mpeg4.c b/openmax_il/source/decoder/codec_mpeg4.c
index 91ca6bb..d9dbd45 100755
--- a/openmax_il/source/decoder/codec_mpeg4.c
+++ b/openmax_il/source/decoder/codec_mpeg4.c
@@ -78,8 +78,8 @@ typedef struct CODEC_MPEG4
     OMX_BOOL extraEosLoopDone;
     MPEG4_FORMAT format;
     MPEG4_CODEC_STATE state;
-    OMX_S32 custom1Width;
-    OMX_S32 custom1Height;
+    OMX_U32 custom1Width;
+    OMX_U32 custom1Height;
     OMX_BOOL dispatchOnlyFrame;
     OMX_BOOL interlaced;
     OMX_U32 out_count;
@@ -167,12 +167,30 @@ static CODEC_STATE decoder_decode_mpeg4(CODEC_PROTOTYPE * arg,
     {
         DBGT_PDEBUG("PARSE_METADATA");
         this->state = MPEG4_DECODE;
-        this->custom1Width =
-            (buf->bus_data[0]) | (buf->bus_data[1] << 8) |
-            (buf->bus_data[2] << 16) | (buf->bus_data[3] << 24);
-        this->custom1Height =
-            (buf->bus_data[4]) | (buf->bus_data[5] << 8) |
-            (buf->bus_data[6] << 16) | (buf->bus_data[7] << 24);
+        if ((OMX_U32)((buf->bus_data[0]) | (buf->bus_data[1] << 8) |
+            (buf->bus_data[2] << 16) | (buf->bus_data[3] << 24)) > 0x7fffffff)
+        {
+            *consumed = 0;
+            return CODEC_ERROR_STREAM;
+        }
+        else
+        {
+            this->custom1Width =
+                (OMX_U32)((buf->bus_data[0]) | (buf->bus_data[1] << 8) |
+                (buf->bus_data[2] << 16) | (buf->bus_data[3] << 24));
+        }
+        if ((OMX_U32)((buf->bus_data[4]) | (buf->bus_data[5] << 8) |
+            (buf->bus_data[6] << 16) | (buf->bus_data[7] << 24)) > 0x7fffffff)
+        {
+            *consumed = 0;
+            return CODEC_ERROR_STREAM;
+        }
+        else
+        {
+            this->custom1Height =
+                (OMX_U32)((buf->bus_data[4]) | (buf->bus_data[5] << 8) |
+                (buf->bus_data[6] << 16) | (buf->bus_data[7] << 24));
+        }
 
         MP4DecSetInfo(this->instance, this->custom1Width, this->custom1Height);
 #ifdef ENABLE_PP
@@ -956,7 +974,7 @@ CODEC_STATE decoder_setframebuffer_mpeg4(CODEC_PROTOTYPE * arg, BUFFER *buff, OM
     UNUSED_PARAMETER(available_buffers);
     CODEC_MPEG4 *this = (CODEC_MPEG4 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     MP4DecBufferInfo info;
     MP4DecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_rv.c b/openmax_il/source/decoder/codec_rv.c
index 80864fe..4e9f14c 100755
--- a/openmax_il/source/decoder/codec_rv.c
+++ b/openmax_il/source/decoder/codec_rv.c
@@ -822,7 +822,7 @@ CODEC_STATE decoder_setframebuffer_rv(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX_U
     UNUSED_PARAMETER(available_buffers);
     CODEC_RV *this = (CODEC_RV *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     RvDecBufferInfo info;
     RvDecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_vc1.c b/openmax_il/source/decoder/codec_vc1.c
index 4a9a277..93d5b93 100755
--- a/openmax_il/source/decoder/codec_vc1.c
+++ b/openmax_il/source/decoder/codec_vc1.c
@@ -508,6 +508,13 @@ static CODEC_STATE decoder_getinfo_vc1(CODEC_PROTOTYPE * arg, STREAM_INFO * pkg)
 
     CODEC_VC1 *this = (CODEC_VC1 *) arg;
 
+    if (this == NULL || this->instance == NULL)
+    {
+        DBGT_CRITICAL("CODEC_ERROR_UNSPECIFIED");
+        DBGT_EPILOG("");
+        return CODEC_ERROR_UNSPECIFIED;
+    }
+
     DBGT_ASSERT(this != 0);
     DBGT_ASSERT(this->instance != 0);
     DBGT_ASSERT(pkg);
@@ -648,6 +655,13 @@ static CODEC_STATE decoder_getframe_vc1(CODEC_PROTOTYPE * arg, FRAME * frame,
 
     CODEC_VC1 *this = (CODEC_VC1 *) arg;
 
+    if (this == NULL)
+    {
+        DBGT_CRITICAL("CODEC_ERROR_UNSPECIFIED");
+        DBGT_EPILOG("");
+        return CODEC_ERROR_UNSPECIFIED;
+    }
+
     DBGT_ASSERT(this != 0);
 
 #if 0
@@ -1014,6 +1028,12 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_vc1(const void *DWLInstance,
     DBGT_PROLOG("");
 
     CODEC_VC1 *this = OSAL_Malloc(sizeof(CODEC_VC1));
+    if (this == NULL)
+    {
+        DBGT_EPILOG("");
+        return NULL;
+    }
+
     VC1DecApiVersion decApi;
     VC1DecBuild decBuild;
 #ifdef ENABLE_PP
@@ -1079,7 +1099,10 @@ CODEC_PROTOTYPE *HantroHwDecOmx_decoder_create_vc1(const void *DWLInstance,
 #endif
 
     if (OSAL_EventCreate(&this->inst_create_event) != OMX_ErrorNone)
+    {
+        OSAL_Free(this);
         return NULL;
+    }
 
     DBGT_EPILOG("");
 
@@ -1117,7 +1140,7 @@ CODEC_STATE decoder_setframebuffer_vc1(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX_
     UNUSED_PARAMETER(available_buffers);
     CODEC_VC1 *this = (CODEC_VC1 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     VC1DecBufferInfo info;
     VC1DecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_vp6.c b/openmax_il/source/decoder/codec_vp6.c
index 6b9e104..97ed30c 100755
--- a/openmax_il/source/decoder/codec_vp6.c
+++ b/openmax_il/source/decoder/codec_vp6.c
@@ -782,7 +782,7 @@ CODEC_STATE decoder_setframebuffer_vp6(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX_
     UNUSED_PARAMETER(available_buffers);
     CODEC_VP6 *this = (CODEC_VP6 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     VP6DecBufferInfo info;
     VP6DecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_vp8.c b/openmax_il/source/decoder/codec_vp8.c
index 129661a..8d77728 100755
--- a/openmax_il/source/decoder/codec_vp8.c
+++ b/openmax_il/source/decoder/codec_vp8.c
@@ -852,7 +852,7 @@ CODEC_STATE decoder_setframebuffer_vp8(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX_
     UNUSED_PARAMETER(available_buffers);
     CODEC_VP8 *this = (CODEC_VP8 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     VP8DecBufferInfo info;
     VP8DecRet ret;
 
diff --git a/openmax_il/source/decoder/codec_vp9.c b/openmax_il/source/decoder/codec_vp9.c
index 3900315..a0e401e 100755
--- a/openmax_il/source/decoder/codec_vp9.c
+++ b/openmax_il/source/decoder/codec_vp9.c
@@ -140,7 +140,7 @@ static void ParseSuperframeIndex(const OMX_U8* data, size_t data_sz, OMX_U32 siz
             for (i = 0; i < frames; i++) {
                 OMX_U32 this_sz = 0;
 
-                for (j = 0; j < mag; j++) this_sz |= (*x++) << (j * 8);
+                for (j = 0; j < mag; j++) this_sz |= (OMX_U32)((*x++) << (j * 8));
                     sizes[i] = this_sz;
             }
 
@@ -786,7 +786,7 @@ CODEC_STATE decoder_setframebuffer_vp9(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX_
 #ifdef USE_EXTERNAL_BUFFER
     CODEC_VP9 *this = (CODEC_VP9 *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     struct Vp9DecBufferInfo info;
     enum DecRet ret;
     const int page_size = getpagesize();
diff --git a/openmax_il/source/decoder/codec_webp.c b/openmax_il/source/decoder/codec_webp.c
index 86fcefd..9ebabe6 100755
--- a/openmax_il/source/decoder/codec_webp.c
+++ b/openmax_il/source/decoder/codec_webp.c
@@ -811,7 +811,7 @@ CODEC_STATE decoder_setframebuffer_webp(CODEC_PROTOTYPE * arg, BUFFER *buff, OMX
     UNUSED_PARAMETER(available_buffers);
     CODEC_WEBP *this = (CODEC_WEBP *)arg;
     CODEC_STATE stat = CODEC_ERROR_UNSPECIFIED;
-    struct DWLLinearMem mem;
+    struct DWLLinearMem mem = { 0 };
     VP8DecBufferInfo info;
     VP8DecRet ret;
 
diff --git a/openmax_il/source/decoder/decoder.c b/openmax_il/source/decoder/decoder.c
index 20cce50..5d2ce26 100755
--- a/openmax_il/source/decoder/decoder.c
+++ b/openmax_il/source/decoder/decoder.c
@@ -7337,12 +7337,12 @@ static
         switch (codec)
         {
         case CODEC_OK:
-        case CODEC_NEED_MORE:
         case CODEC_ERROR_FRAME:
             break;
         case CODEC_NO_DECODING_BUFFER:
             usleep(10);
             break;
+        case CODEC_NEED_MORE:
         case CODEC_BUFFER_EMPTY:
             if(!dec->propagateDataReceived)
             {
diff --git a/openmax_il/source/decoder/test/file_reader.c b/openmax_il/source/decoder/test/file_reader.c
index a9c4f6f..5618b91 100755
--- a/openmax_il/source/decoder/test/file_reader.c
+++ b/openmax_il/source/decoder/test/file_reader.c
@@ -740,7 +740,8 @@ int read_DIVX3_file(FILE* strm, char* buffer, int bufflen, void* state, OMX_BOOL
             /* skip "00dc" from frame beginning (may signal video chunk start code) */
             for(;;)
             {
-                fseek( strm, offset, SEEK_SET );
+                if (fseek( strm, offset, SEEK_SET ) != 0)
+                    fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
                 fread( &sizeTmp, sizeof(OMX_U8), 4, strm );
                 if(feof(strm))
                 {
@@ -905,7 +906,8 @@ int read_webp_file(FILE* strm, char* buffer, int bufflen, void* state, OMX_BOOL*
     u8 tmp[4];
     u32 frameSize = 0;
     
-    fseek(strm, 8, SEEK_CUR);
+    if (fseek(strm, 8, SEEK_CUR) != 0)
+      fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     fread(tmp, sizeof(u8), 4, strm);
     
     if (strncmp(signature, (char*)tmp, 4))
@@ -1018,7 +1020,8 @@ int read_avs_file(FILE* strm, char* buffer, int bufflen, void* state, OMX_BOOL*
 
     if (buffBytes)
     {
-        fseek(strm, -buffBytes, SEEK_CUR);
+        if (fseek(strm, -buffBytes, SEEK_CUR) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     }
     if (VERBOSE_OUTPUT)
         printf("READ DECODE UNIT %d
", idx);
@@ -1191,14 +1194,17 @@ int read_rcv_file(FILE* strm, char* buffer, int bufflen, void* state, OMX_BOOL*
     {
         case 0:
         {
-            fseek(strm, 0, SEEK_END);
+            if (fseek(strm, 0, SEEK_END) != 0)
+                fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
             rcv->filesize = ftell(strm);
-            fseek(strm, 0, SEEK_SET);
+            if (fseek(strm, 0, SEEK_SET) != 0)
+                fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
             char buff[4];
             fread(buff, 1, 4, strm);
             rcv->advanced = buff[2];
             rcv->rcV1     = !(buff[3] & 0x40);
-            fseek(strm, 0, SEEK_SET);
+            if (fseek(strm, 0, SEEK_SET) != 0)
+                fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
             if (rcv->advanced)
                 break;
                 //return fread(buffer, 1, bufflen, strm);
diff --git a/openmax_il/source/decoder/test/video_decoder.c b/openmax_il/source/decoder/test/video_decoder.c
index d83dc80..60c038a 100755
--- a/openmax_il/source/decoder/test/video_decoder.c
+++ b/openmax_il/source/decoder/test/video_decoder.c
@@ -1467,7 +1467,8 @@ int decode_file(const char* input_file, const char* yuv_file,  VIDEOPROPS* props
             goto FAIL;
         }
         /* Seek back to the beginning */
-        fseek(video, 0, SEEK_SET);
+        if (fseek(video, 0, SEEK_SET) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
         if (!rm_parser_is_rm_file(ucBuf, RM2YUV_INITIAL_READ_SIZE))
         {
@@ -1527,9 +1528,11 @@ int decode_file(const char* input_file, const char* yuv_file,  VIDEOPROPS* props
             goto FAIL;
         }
         // read the whole thing into the buffer
-        fseek(mask, 0, SEEK_END);
+        if (fseek(mask, 0, SEEK_END) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         int size = ftell(mask);
-        fseek(mask, 0, SEEK_SET);
+        if (fseek(mask, 0, SEEK_SET) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
         if (size > (int)alpha_mask_buffer->nAllocLen)
         {
             DBGT_CRITICAL("Alpha mask data size greater than buffer size. Mask ignored");
@@ -1811,8 +1814,10 @@ int compare_output(const char* reference, const char* temp)
         DBGT_CRITICAL("Failed to open reference file");
         goto FAIL;
     }
-    fseek(file_tmp, 0, SEEK_END);
-    fseek(file_ref, 0, SEEK_END);
+    if (fseek(file_tmp, 0, SEEK_END) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (fseek(file_ref, 0, SEEK_END) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     int tmp_size = ftell(file_tmp);
     int ref_size = ftell(file_ref);
     int min_size = tmp_size;
@@ -1833,8 +1838,10 @@ int compare_output(const char* reference, const char* temp)
     }
     else
     {
-        fseek(file_tmp, 0, SEEK_SET);
-        fseek(file_ref, 0, SEEK_SET);
+        if (fseek(file_tmp, 0, SEEK_SET) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+        if (fseek(file_ref, 0, SEEK_SET) != 0)
+            fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
         buff_tmp = (char*)malloc(CMP_BUFF_SIZE);
         buff_ref = (char*)malloc(CMP_BUFF_SIZE);
diff --git a/openmax_il/source/encoder/encoder_h264.c b/openmax_il/source/encoder/encoder_h264.c
index 9d043aa..8577a0d 100755
--- a/openmax_il/source/encoder/encoder_h264.c
+++ b/openmax_il/source/encoder/encoder_h264.c
@@ -295,6 +295,7 @@ static CODEC_STATE encoder_encode_h264(ENCODER_PROTOTYPE* arg, FRAME* frame,
         ret = H264EncSetRateCtrl(this->instance, &rate_ctrl);
     }
 
+	(void) ret;
     DBGT_PDEBUG("rate_ctrl.qpHdr %d", rate_ctrl.qpHdr);
     DBGT_PDEBUG("rate_ctrl.bitPerSecond %d", rate_ctrl.bitPerSecond);
 
diff --git a/openmax_il/source/encoder/encoder_vp8.c b/openmax_il/source/encoder/encoder_vp8.c
index ee19f00..ce748ba 100755
--- a/openmax_il/source/encoder/encoder_vp8.c
+++ b/openmax_il/source/encoder/encoder_vp8.c
@@ -324,7 +324,7 @@ static CODEC_STATE encoder_encode_vp8(ENCODER_PROTOTYPE* arg, FRAME* frame,
         ret = VP8EncSetRateCtrl(this->instance, &rate_ctrl);
     }
 
-
+	(void) ret;
     ret = VP8EncGetCodingCtrl(this->instance, &coding_ctrl);
 
     if (ret == VP8ENC_OK)
diff --git a/openmax_il/source/encoder/test/image_encoder.c b/openmax_il/source/encoder/test/image_encoder.c
index 94b928f..204f072 100755
--- a/openmax_il/source/encoder/test/image_encoder.c
+++ b/openmax_il/source/encoder/test/image_encoder.c
@@ -587,8 +587,10 @@ void compare_output(const char* temp, const char* reference)
         printf("failed to open reference file
");
         goto FAIL;
     }
-    fseek(file_tmp, 0, SEEK_END);
-    fseek(file_ref, 0, SEEK_END);
+    if (fseek(file_tmp, 0, SEEK_END) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (fseek(file_ref, 0, SEEK_END) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     int tmp_size = ftell(file_tmp);
     int ref_size = ftell(file_ref);
     int min_size = tmp_size;
@@ -598,8 +600,10 @@ void compare_output(const char* temp, const char* reference)
         printf("file sizes do not match: temp: %d reference: %d bytes
", tmp_size, ref_size);
         printf("comparing first %d bytes
", min_size);
     }
-    fseek(file_tmp, 0, SEEK_SET);
-    fseek(file_ref, 0, SEEK_SET);
+    if (fseek(file_tmp, 0, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (fseek(file_ref, 0, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     
     buff_tmp = (char*)malloc(CMP_BUFF_SIZE);
     buff_ref = (char*)malloc(CMP_BUFF_SIZE);
diff --git a/openmax_il/source/encoder/test/video_encoder.c b/openmax_il/source/encoder/test/video_encoder.c
index 3f46ca0..e4d4875 100755
--- a/openmax_il/source/encoder/test/video_encoder.c
+++ b/openmax_il/source/encoder/test/video_encoder.c
@@ -662,8 +662,10 @@ void compare_output(const char* temp, const char* reference)
         printf("failed to open reference file
");
         goto FAIL;
     }
-    fseek(file_tmp, 0, SEEK_END);
-    fseek(file_ref, 0, SEEK_END);
+    if (fseek(file_tmp, 0, SEEK_END) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (fseek(file_ref, 0, SEEK_END) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
     int tmp_size = ftell(file_tmp);
     int ref_size = ftell(file_ref);
     int min_size = tmp_size;
@@ -673,8 +675,10 @@ void compare_output(const char* temp, const char* reference)
         printf("file sizes do not match: temp: %d reference: %d bytes
", tmp_size, ref_size);
         printf("comparing first %d bytes
", min_size);
     }
-    fseek(file_tmp, 0, SEEK_SET);
-    fseek(file_ref, 0, SEEK_SET);
+    if (fseek(file_tmp, 0, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
+    if (fseek(file_ref, 0, SEEK_SET) != 0)
+        fprintf(stderr, "fseek() failed in file %s at line # %d
", __FILE__, __LINE__-1);
 
     buff_tmp = (char*)malloc(CMP_BUFF_SIZE);
     buff_ref = (char*)malloc(CMP_BUFF_SIZE);
diff --git a/openmax_il/source/util.c b/openmax_il/source/util.c
index bc258de..1ce6ebb 100755
--- a/openmax_il/source/util.c
+++ b/openmax_il/source/util.c
@@ -34,7 +34,7 @@
 ------------------------------------------------------------------------------*/
 
 #include "util.h"
-#include "android_ext.h"
+//#include "android_ext.h"
 #include "dbgtrace.h"
 #include "vsi_vendor_ext.h"
 
