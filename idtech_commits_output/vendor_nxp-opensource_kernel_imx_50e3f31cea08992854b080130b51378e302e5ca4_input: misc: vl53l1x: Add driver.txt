50e3f31cea08 Sergii Postulga 2020-02-24

input: misc: vl53l1x: Add driver

Signed-off-by: Sergii Postulga <sergii.postulga@idtechproducts.com>
Change-Id: Ibef55e0f578316696b78ea3a5c8e4801e3d8a9c8

diff --git a/drivers/input/misc/Kconfig b/drivers/input/misc/Kconfig
index 10e49f1b1a14..6e2558b3c07d 100644
--- a/drivers/input/misc/Kconfig
+++ b/drivers/input/misc/Kconfig
@@ -886,4 +886,6 @@ config INPUT_ISL29023
 	  This driver can also be built as a module.  If so, the module
 	  will be called isl29023.
 
+source "drivers/input/misc/vl53l1x_uld/Kconfig"
+
 endif
diff --git a/drivers/input/misc/Makefile b/drivers/input/misc/Makefile
index b647d42aa312..b3f6f2993573 100644
--- a/drivers/input/misc/Makefile
+++ b/drivers/input/misc/Makefile
@@ -85,3 +85,4 @@ obj-$(CONFIG_INPUT_MPL3115)		+= mpl3115.o
 obj-$(CONFIG_SENSOR_FXLS8471)       	+= fxls8471.o fxls8471_i2c.o
 obj-$(CONFIG_INPUT_ISL29023)            += isl29023.o
 obj-$(CONFIG_SENSOR_IMX_RPMSG)		+= rpmsg_input.o
+obj-$(CONFIG_INPUT_VL53L1X_ULD)		+= vl53l1x_uld/
diff --git a/drivers/input/misc/vl53l1x_uld/Kconfig b/drivers/input/misc/vl53l1x_uld/Kconfig
new file mode 100644
index 000000000000..4a879c8f8d03
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/Kconfig
@@ -0,0 +1,8 @@
+#
+# Input misc drivers configuration
+#
+
+config INPUT_VL53L1X_ULD
+	tristate "ST VL53L1X distance sensor"
+	depends on I2C && SYSFS
+
diff --git a/drivers/input/misc/vl53l1x_uld/Makefile b/drivers/input/misc/vl53l1x_uld/Makefile
new file mode 100644
index 000000000000..7820e32b10e2
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/Makefile
@@ -0,0 +1,12 @@
+# SPDX-License-Identifier: GPL-2.0
+#
+# Makefile for the input misc drivers.
+#
+
+# Each configuration option enables a list of files.
+
+obj-$(CONFIG_INPUT_VL53L1X_ULD) += vl53l1x-i2c.o
+obj-$(CONFIG_INPUT_VL53L1X_ULD) += VL53L1X_api.o
+obj-$(CONFIG_INPUT_VL53L1X_ULD) += VL53L1X_calibration.o
+obj-$(CONFIG_INPUT_VL53L1X_ULD) += vl53l1_platform.o
+
diff --git a/drivers/input/misc/vl53l1x_uld/VL53L1X_api.c b/drivers/input/misc/vl53l1x_uld/VL53L1X_api.c
new file mode 100644
index 000000000000..6abeac7dea4e
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/VL53L1X_api.c
@@ -0,0 +1,850 @@
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+
+#include <linux/iio/iio.h>
+
+/**
+ * @file  vl53l1x_api.c
+ * @brief Functions implementation
+ */
+
+#include "VL53L1X_api.h"
+
+
+
+int VL53L1_WriteMulti(struct i2c_client *client, uint16_t index, uint8_t *pdata, uint32_t count);
+int VL53L1_ReadMulti(struct i2c_client *client, uint16_t index, uint8_t *pdata, uint32_t count);
+int VL53L1_WrByte(struct i2c_client *client, uint16_t index, uint8_t data);
+int VL53L1_WrWord(struct i2c_client *client, uint16_t index, uint16_t data);
+int VL53L1_WrDWord(struct i2c_client *client, uint16_t index, uint32_t data);
+int VL53L1_RdByte(struct i2c_client *client, uint16_t index, uint8_t *data);
+int VL53L1_RdWord(struct i2c_client *client, uint16_t index, uint16_t *data);
+int VL53L1_RdDWord(struct i2c_client *client, uint16_t index, uint32_t *data);
+// ============================================================
+
+const uint8_t VL51L1X_DEFAULT_CONFIGURATION[] = {
+0x00, /* 0x2d : set bit 2 and 5 to 1 for fast plus mode (1MHz I2C), else don't touch */
+0x00, /* 0x2e : bit 0 if I2C pulled up at 1.8V, else set bit 0 to 1 (pull up at AVDD) */
+0x00, /* 0x2f : bit 0 if GPIO pulled up at 1.8V, else set bit 0 to 1 (pull up at AVDD) */
+0x01, /* 0x30 : set bit 4 to 0 for active high interrupt and 1 for active low (bits 3:0 must be 0x1), use SetInterruptPolarity() */
+0x02, /* 0x31 : bit 1 = interrupt depending on the polarity, use CheckForDataReady() */
+0x00, /* 0x32 : not user-modifiable */
+0x02, /* 0x33 : not user-modifiable */
+0x08, /* 0x34 : not user-modifiable */
+0x00, /* 0x35 : not user-modifiable */
+0x08, /* 0x36 : not user-modifiable */
+0x10, /* 0x37 : not user-modifiable */
+0x01, /* 0x38 : not user-modifiable */
+0x01, /* 0x39 : not user-modifiable */
+0x00, /* 0x3a : not user-modifiable */
+0x00, /* 0x3b : not user-modifiable */
+0x00, /* 0x3c : not user-modifiable */
+0x00, /* 0x3d : not user-modifiable */
+0xff, /* 0x3e : not user-modifiable */
+0x00, /* 0x3f : not user-modifiable */
+0x0F, /* 0x40 : not user-modifiable */
+0x00, /* 0x41 : not user-modifiable */
+0x00, /* 0x42 : not user-modifiable */
+0x00, /* 0x43 : not user-modifiable */
+0x00, /* 0x44 : not user-modifiable */
+0x00, /* 0x45 : not user-modifiable */
+0x20, /* 0x46 : interrupt configuration 0->level low detection, 1-> level high, 2-> Out of window, 3->In window, 0x20-> New sample ready , TBC */
+0x0b, /* 0x47 : not user-modifiable */
+0x00, /* 0x48 : not user-modifiable */
+0x00, /* 0x49 : not user-modifiable */
+0x02, /* 0x4a : not user-modifiable */
+0x0a, /* 0x4b : not user-modifiable */
+0x21, /* 0x4c : not user-modifiable */
+0x00, /* 0x4d : not user-modifiable */
+0x00, /* 0x4e : not user-modifiable */
+0x05, /* 0x4f : not user-modifiable */
+0x00, /* 0x50 : not user-modifiable */
+0x00, /* 0x51 : not user-modifiable */
+0x00, /* 0x52 : not user-modifiable */
+0x00, /* 0x53 : not user-modifiable */
+0xc8, /* 0x54 : not user-modifiable */
+0x00, /* 0x55 : not user-modifiable */
+0x00, /* 0x56 : not user-modifiable */
+0x38, /* 0x57 : not user-modifiable */
+0xff, /* 0x58 : not user-modifiable */
+0x01, /* 0x59 : not user-modifiable */
+0x00, /* 0x5a : not user-modifiable */
+0x08, /* 0x5b : not user-modifiable */
+0x00, /* 0x5c : not user-modifiable */
+0x00, /* 0x5d : not user-modifiable */
+0x01, /* 0x5e : not user-modifiable */
+0xcc, /* 0x5f : not user-modifiable */
+0x0f, /* 0x60 : not user-modifiable */
+0x01, /* 0x61 : not user-modifiable */
+0xf1, /* 0x62 : not user-modifiable */
+0x0d, /* 0x63 : not user-modifiable */
+0x01, /* 0x64 : Sigma threshold MSB (mm in 14.2 format for MSB+LSB), use SetSigmaThreshold(), default value 90 mm  */
+0x68, /* 0x65 : Sigma threshold LSB */
+0x00, /* 0x66 : Min count Rate MSB (MCPS in 9.7 format for MSB+LSB), use SetSignalThreshold() */
+0x80, /* 0x67 : Min count Rate LSB */
+0x08, /* 0x68 : not user-modifiable */
+0xb8, /* 0x69 : not user-modifiable */
+0x00, /* 0x6a : not user-modifiable */
+0x00, /* 0x6b : not user-modifiable */
+0x00, /* 0x6c : Intermeasurement period MSB, 32 bits register, use SetIntermeasurementInMs() */
+0x00, /* 0x6d : Intermeasurement period */
+0x0f, /* 0x6e : Intermeasurement period */
+0x89, /* 0x6f : Intermeasurement period LSB */
+0x00, /* 0x70 : not user-modifiable */
+0x00, /* 0x71 : not user-modifiable */
+0x00, /* 0x72 : distance threshold high MSB (in mm, MSB+LSB), use SetD:tanceThreshold() */
+0x00, /* 0x73 : distance threshold high LSB */
+0x00, /* 0x74 : distance threshold low MSB ( in mm, MSB+LSB), use SetD:tanceThreshold() */
+0x00, /* 0x75 : distance threshold low LSB */
+0x00, /* 0x76 : not user-modifiable */
+0x01, /* 0x77 : not user-modifiable */
+0x0f, /* 0x78 : not user-modifiable */
+0x0d, /* 0x79 : not user-modifiable */
+0x0e, /* 0x7a : not user-modifiable */
+0x0e, /* 0x7b : not user-modifiable */
+0x00, /* 0x7c : not user-modifiable */
+0x00, /* 0x7d : not user-modifiable */
+0x02, /* 0x7e : not user-modifiable */
+0xc7, /* 0x7f : ROI center, use SetROI() */
+0xff, /* 0x80 : XY ROI (X=Width, Y=Height), use SetROI() */
+0x9B, /* 0x81 : not user-modifiable */
+0x00, /* 0x82 : not user-modifiable */
+0x00, /* 0x83 : not user-modifiable */
+0x00, /* 0x84 : not user-modifiable */
+0x01, /* 0x85 : not user-modifiable */
+0x00, /* 0x86 : clear interrupt, use ClearInterrupt() */
+0x00  /* 0x87 : start ranging, use StartRanging() or StopRanging(), If you want an automatic start after VL53L1X_init() call, put 0x40 in location 0x87 */
+};
+
+static const uint8_t status_rtn[24] = { 255, 255, 255, 5, 2, 4, 1, 7, 3, 0,
+	255, 255, 9, 13, 255, 255, 255, 255, 10, 6,
+	255, 255, 11, 12
+};
+
+
+VL53L1X_ERROR VL53L1X_SetI2CAddress(struct i2c_client *client, uint8_t new_address)
+{
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_WrByte(client, VL53L1_I2C_SLAVE__DEVICE_ADDRESS, new_address >> 1);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SensorInit(struct i2c_client *client)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t Addr = 0x00, tmp;
+
+	for (Addr = 0x2D; Addr <= 0x87; Addr++){
+		status = VL53L1_WrByte(client, Addr, VL51L1X_DEFAULT_CONFIGURATION[Addr - 0x2D]);
+	}
+	status = VL53L1X_StartRanging(client);
+	tmp  = 0;
+	while(tmp==0){
+			status = VL53L1X_CheckForDataReady(client, &tmp);
+	}
+	status = VL53L1X_ClearInterrupt(client);
+	status = VL53L1X_StopRanging(client);
+	status = VL53L1_WrByte(client, VL53L1_VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND, 0x09); /* two bounds VHV(Very High Voltage) */
+	status = VL53L1_WrByte(client, 0x0B, 0); /* start VHV from the previous temperature */
+	return status;
+}
+
+/* This function clears the interrupt to be called after a ranging data reading, to arm the interrupt for the next data ready event.
+ */
+VL53L1X_ERROR VL53L1X_ClearInterrupt(struct i2c_client *client)
+{
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_WrByte(client, SYSTEM__INTERRUPT_CLEAR, 0x01);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetInterruptPolarity(struct i2c_client *client, uint8_t NewPolarity)
+{
+	uint8_t Temp;
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_RdByte(client, GPIO_HV_MUX__CTRL, &Temp);
+	Temp = Temp & 0xEF;
+	status = VL53L1_WrByte(client, GPIO_HV_MUX__CTRL, Temp | (!(NewPolarity & 1)) << 4);
+	return status;
+}
+
+/* This function returns the current interrupt polarity, 1 = active high (default), 0 = active low.
+ */
+VL53L1X_ERROR VL53L1X_GetInterruptPolarity(struct i2c_client *client, uint8_t *pInterruptPolarity)
+{
+	uint8_t Temp;
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_RdByte(client, GPIO_HV_MUX__CTRL, &Temp);
+	Temp = Temp & 0x10;
+	*pInterruptPolarity = !(Temp>>4);
+	return status;
+}
+
+/* This function starts the ranging distance operation which is continuous. 
+   The clear interrupt has to be done after
+     each "get data" to allow the interrupt to be raised when the next data are ready. 1 = active high (default), 0 = active low.
+   If required, use SetInterruptPolarity() to change the interrupt polarity.
+ */
+VL53L1X_ERROR VL53L1X_StartRanging(struct i2c_client *client)
+{
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_WrByte(client, SYSTEM__MODE_START, 0x40);	/* Enable VL53L1X */
+	return status;
+}
+
+/* This function stops the ranging.
+ */
+VL53L1X_ERROR VL53L1X_StopRanging(struct i2c_client *client)
+{
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_WrByte(client, SYSTEM__MODE_START, 0x00);	/* Disable VL53L1X */
+	return status;
+}
+
+/* This function checks if the new ranging data are available by polling the dedicated register. 
+   Data are not ready when "isDataReady == 0". Data are ready when "isDataReady==1".
+ */
+VL53L1X_ERROR VL53L1X_CheckForDataReady(struct i2c_client *client, uint8_t *isDataReady)
+{
+	uint8_t Temp;
+	uint8_t IntPol;
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1X_GetInterruptPolarity(client, &IntPol);
+	status = VL53L1_RdByte(client, GPIO__TIO_HV_STATUS, &Temp);
+	/* Read in the register to check if a new value is available */
+	if (status == sizeof(uint8_t)){
+		if ((Temp & 1) == IntPol)
+			*isDataReady = 1;
+		else
+			*isDataReady = 0;
+	}
+	return status;
+}
+
+/* This function programs the timing budget in ms. The predefined values are 15, 20, 50, 100, 200, and 500. 
+   This function must be called after the VL53L1X_SetDistanceMode.
+ */
+VL53L1X_ERROR VL53L1X_SetTimingBudgetInMs(struct i2c_client *client, uint16_t TimingBudgetInMs)
+{
+	uint16_t DM;
+	VL53L1X_ERROR  status=0;
+
+	pr_info("%s: TimingBudgetInMs = %d +
", __func__, TimingBudgetInMs);
+	status = VL53L1X_GetDistanceMode(client, &DM);
+	if (DM == 0)
+		return 1;
+	else if (DM == 1) {	/* Short DistanceMode */
+		switch (TimingBudgetInMs) {
+		case 15: /* only available in short distance mode */
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x01D);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x0027);
+			break;
+		case 20:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x0051);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x006E);
+			break;
+		case 33:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x00D6);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x006E);
+			break;
+		case 50:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x1AE);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x01E8);
+			break;
+		case 100:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x02E1);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x0388);
+			break;
+		case 200:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x03E1);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x0496);
+			break;
+		case 500:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x0591);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x05C1);
+			break;
+		default:
+			status = 1;
+			break;
+		}
+	} else {
+		switch (TimingBudgetInMs) {
+		case 20:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x001E);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x0022);
+			break;
+		case 33:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x0060);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x006E);
+			break;
+		case 50:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x00AD);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x00C6);
+			break;
+		case 100:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x01CC);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x01EA);
+			break;
+		case 200:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x02D9);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x02F8);
+			break;
+		case 500:
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI,
+					0x048F);
+			VL53L1_WrWord(client, RANGE_CONFIG__TIMEOUT_MACROP_B_HI,
+					0x04A4);
+			break;
+		default:
+			status = 1;
+			break;
+		}
+	}
+	pr_info("%s: -
", __func__);
+	return status;
+}
+
+/* This function returns the current timing budget in ms.
+ */
+VL53L1X_ERROR VL53L1X_GetTimingBudgetInMs(struct i2c_client *client, uint16_t *pTimingBudget)
+{
+	uint16_t Temp;
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_RdWord(client, RANGE_CONFIG__TIMEOUT_MACROP_A_HI, &Temp);
+	switch (Temp) {
+		case 0x001D :
+			*pTimingBudget = 15;
+			break;
+		case 0x0051 :
+		case 0x001E :
+			*pTimingBudget = 20;
+			break;
+		case 0x00D6 :
+		case 0x0060 :
+			*pTimingBudget = 33;
+			break;
+		case 0x1AE :
+		case 0x00AD :
+			*pTimingBudget = 50;
+			break;
+		case 0x02E1 :
+		case 0x01CC :
+			*pTimingBudget = 100;
+			break;
+		case 0x03E1 :
+		case 0x02D9 :
+			*pTimingBudget = 200;
+			break;
+		case 0x0591 :
+		case 0x048F :
+			*pTimingBudget = 500;
+			break;
+		default:
+			status = 1;
+			*pTimingBudget = 0;
+	}
+	pr_info("%s: Temp = 0x%x
", __func__, Temp);
+	pr_info("%s: TimingBudget = %d
", __func__, *pTimingBudget);
+	return status;
+}
+
+/* This function programs the distance mode (1 = Short, 2 = Long). 
+   Short mode maximum distance is limited to 1.3 m but results in a better ambient immunity. 
+   Long mode can range up to 4 m in the dark with a timing budget of 200 ms.
+ */
+VL53L1X_ERROR VL53L1X_SetDistanceMode(struct i2c_client *client, uint16_t DM)
+{
+	uint16_t TB;
+	VL53L1X_ERROR status = 0;
+
+	pr_info("%s: DM = %d +
", __func__, DM);
+	status = VL53L1X_GetTimingBudgetInMs(client, &TB);
+	if (status != 0)
+		return 1;
+	switch (DM) {
+	case 1:
+		status = VL53L1_WrByte(client, PHASECAL_CONFIG__TIMEOUT_MACROP, 0x14);
+		status = VL53L1_WrByte(client, RANGE_CONFIG__VCSEL_PERIOD_A, 0x07);
+		status = VL53L1_WrByte(client, RANGE_CONFIG__VCSEL_PERIOD_B, 0x05);
+		status = VL53L1_WrByte(client, RANGE_CONFIG__VALID_PHASE_HIGH, 0x38);
+		status = VL53L1_WrWord(client, SD_CONFIG__WOI_SD0, 0x0705);
+		status = VL53L1_WrWord(client, SD_CONFIG__INITIAL_PHASE_SD0, 0x0606);
+		break;
+	case 2:
+		status = VL53L1_WrByte(client, PHASECAL_CONFIG__TIMEOUT_MACROP, 0x0A);
+		status = VL53L1_WrByte(client, RANGE_CONFIG__VCSEL_PERIOD_A, 0x0F);
+		status = VL53L1_WrByte(client, RANGE_CONFIG__VCSEL_PERIOD_B, 0x0D);
+		status = VL53L1_WrByte(client, RANGE_CONFIG__VALID_PHASE_HIGH, 0xB8);
+		status = VL53L1_WrWord(client, SD_CONFIG__WOI_SD0, 0x0F0D);
+		status = VL53L1_WrWord(client, SD_CONFIG__INITIAL_PHASE_SD0, 0x0E0E);
+		break;
+	default:
+		status = 1;
+		break;
+	}
+
+	if (status == 0)
+		status = VL53L1X_SetTimingBudgetInMs(client, TB);
+	pr_info("%s: -
", __func__);
+	return status;
+}
+
+/* This function returns the current distance mode (1 = Short, 2 = Long).
+ */
+VL53L1X_ERROR VL53L1X_GetDistanceMode(struct i2c_client *client, uint16_t *DM)
+{
+	uint8_t TempDM;
+	int status = 0;
+
+	status = VL53L1_RdByte(client,PHASECAL_CONFIG__TIMEOUT_MACROP, &TempDM);
+	if (TempDM == 0x14)
+		*DM=1;
+	if(TempDM == 0x0A)
+		*DM=2;
+	pr_info("%s: TempDM = 0x%x
", __func__, TempDM);
+	pr_info("%s: DM = 0x%x
", __func__, *DM);
+	return status;
+}
+
+/* This function programs the intermeasurement period (IMP) in ms. 
+   The IMP must be greater than or equal to the timing budget. 
+   This condition is not checked by the API, so the customer must check this condition.
+ */
+VL53L1X_ERROR VL53L1X_SetInterMeasurementInMs(struct i2c_client *client, uint32_t InterMeasMs)
+{
+	uint16_t ClockPLL;
+	VL53L1X_ERROR status = 0;
+
+	pr_info("%s: InterMeasMs = %d +
", __func__, InterMeasMs);
+	status = VL53L1_RdWord(client, VL53L1_RESULT__OSC_CALIBRATE_VAL, &ClockPLL);
+	if (status < 0) {
+		pr_err("%s: iVL53L1_RdWord fail with %d
", __func__, status);
+		return status;
+	}
+	ClockPLL = ClockPLL&0x3FF;
+	// Floating
+	VL53L1_WrDWord(client, VL53L1_SYSTEM__INTERMEASUREMENT_PERIOD,
+			(uint32_t)(ClockPLL * InterMeasMs * 1.075));
+
+	pr_info("%s: -
", __func__);
+	return status;
+
+}
+
+/* This function returns the intermeasurement period in ms.
+ */
+VL53L1X_ERROR VL53L1X_GetInterMeasurementInMs(struct i2c_client *client, uint16_t *pIM)
+{
+	uint16_t ClockPLL;
+	VL53L1X_ERROR status = 0;
+	uint32_t tmp;
+
+	status = VL53L1_RdDWord(client,VL53L1_SYSTEM__INTERMEASUREMENT_PERIOD, &tmp);
+	*pIM = (uint16_t)tmp;
+	status = VL53L1_RdWord(client, VL53L1_RESULT__OSC_CALIBRATE_VAL, &ClockPLL);
+	ClockPLL = ClockPLL&0x3FF;
+	// Floating
+	*pIM= (uint16_t)(*pIM/(ClockPLL*1.065));
+
+	pr_info("%s: IM = %d
", __func__, *pIM);
+	return status;
+}
+
+/* This function returns the Boot state of the device (1 = booted, 0 = not booted).
+ */
+VL53L1X_ERROR VL53L1X_BootState(struct i2c_client *client, uint8_t *state)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t tmp = 0;
+
+	status = VL53L1_RdByte(client,VL53L1_FIRMWARE__SYSTEM_STATUS, &tmp);
+	*state = tmp;
+	pr_info("%s: state = 0x%x
", __func__, tmp);
+	return status;
+}
+
+/* This function returns the sensor ID which must be 0xEEAC.
+ */
+VL53L1X_ERROR VL53L1X_GetSensorId(struct i2c_client *client, uint16_t *sensorId)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp = 0;
+
+	status = VL53L1_RdWord(client, VL53L1_IDENTIFICATION__MODEL_ID, &tmp);
+	*sensorId = tmp;
+	return status;
+}
+
+/* This function returns the distance measured by the sensor in mm.
+ */
+VL53L1X_ERROR VL53L1X_GetDistance(struct i2c_client *client, uint16_t *distance)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = (VL53L1_RdWord(client,
+			VL53L1_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0, &tmp));
+	if (status < 0) {
+		pr_err("%s: iVL53L1_RdWord fail with %d
", __func__, status);
+		return status;
+	}
+	*distance = tmp;
+	return status;
+}
+
+/* This function gives the returned signal per SPAD in kcps/SPAD.
+ */
+VL53L1X_ERROR VL53L1X_GetSignalPerSpad(struct i2c_client *client, uint16_t *signalRate)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t SpNb=1, signal;
+
+	status = VL53L1_RdWord(client,
+		VL53L1_RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0, &signal);
+	status = VL53L1_RdWord(client,
+		VL53L1_RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0, &SpNb);
+	// Floating
+	*signalRate = (uint16_t) (2000.0*signal/SpNb);
+
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetAmbientPerSpad(struct i2c_client *client, uint16_t *ambPerSp)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t AmbientRate, SpNb = 1;
+
+	status = VL53L1_RdWord(client, RESULT__AMBIENT_COUNT_RATE_MCPS_SD, &AmbientRate);
+	status = VL53L1_RdWord(client, VL53L1_RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0, &SpNb);
+	// Floating
+	*ambPerSp=(uint16_t) (2000.0 * AmbientRate / SpNb);
+
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetSignalRate(struct i2c_client *client, uint16_t *signal)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client,
+		VL53L1_RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0, &tmp);
+	*signal = tmp*8;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetSpadNb(struct i2c_client *client, uint16_t *spNb)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client,
+			      VL53L1_RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0, &tmp);
+	*spNb = tmp >> 8;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetAmbientRate(struct i2c_client *client, uint16_t *ambRate)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client, RESULT__AMBIENT_COUNT_RATE_MCPS_SD, &tmp);
+	*ambRate = tmp*8;
+	return status;
+}
+
+/* This function returns the ranging status error 
+   where 0 = no error, 1 = sigma failure, 2 = signal failure, 4 = sensor out-of-bounds, and 7 = wraparound).
+ */
+VL53L1X_ERROR VL53L1X_GetRangeStatus(struct i2c_client *client, uint8_t *rangeStatus)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t RgSt;
+
+	*rangeStatus = 255;
+	status = VL53L1_RdByte(client, VL53L1_RESULT__RANGE_STATUS, &RgSt);
+	RgSt = RgSt & 0x1F;
+	if (RgSt < 24)
+		*rangeStatus = status_rtn[RgSt];
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetResult(struct i2c_client *client, VL53L1X_Result_t *pResult)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t Temp[17];
+	uint8_t RgSt = 255;
+
+	status = VL53L1_ReadMulti(client, VL53L1_RESULT__RANGE_STATUS, Temp, 17);
+	RgSt = Temp[0] & 0x1F;
+	if (RgSt < 24)
+		RgSt = status_rtn[RgSt];
+	pResult->Status = RgSt;
+	pResult->Ambient = (Temp[7] << 8 | Temp[8]) * 8;
+	pResult->NumSPADs = Temp[3];
+	pResult->SigPerSPAD = (Temp[15] << 8 | Temp[16]) * 8;
+	pResult->Distance = Temp[13] << 8 | Temp[14];
+
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetOffset(struct i2c_client *client, int16_t OffsetValue)
+{
+	VL53L1X_ERROR status = 0;
+	int16_t Temp;
+
+	Temp = (OffsetValue*4);
+	VL53L1_WrWord(client, ALGO__PART_TO_PART_RANGE_OFFSET_MM,
+			(uint16_t)Temp);
+	VL53L1_WrWord(client, MM_CONFIG__INNER_OFFSET_MM, 0x0);
+	VL53L1_WrWord(client, MM_CONFIG__OUTER_OFFSET_MM, 0x0);
+	return status;
+}
+
+VL53L1X_ERROR  VL53L1X_GetOffset(struct i2c_client *client, int16_t *offset)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t Temp;
+
+	status = VL53L1_RdWord(client,ALGO__PART_TO_PART_RANGE_OFFSET_MM, &Temp);
+	Temp = Temp<<3;
+	Temp = Temp>>5;
+	*offset = (int16_t)(Temp);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetXtalk(struct i2c_client *client, uint16_t XtalkValue)
+{
+/* XTalkValue in count per second to avoid float type */
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_WrWord(client,
+			ALGO__CROSSTALK_COMPENSATION_X_PLANE_GRADIENT_KCPS,
+			0x0000);
+	status = VL53L1_WrWord(client, ALGO__CROSSTALK_COMPENSATION_Y_PLANE_GRADIENT_KCPS,
+			0x0000);
+	status = VL53L1_WrWord(client, ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS,
+			(XtalkValue<<9)/1000); /* * << 9 (7.9 format) and /1000 to convert cps to kpcs */
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetXtalk(struct i2c_client *client, uint16_t *xtalk )
+{
+	VL53L1X_ERROR status = 0;
+	uint32_t tmp;
+
+	status = VL53L1_RdDWord(client,ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS, &tmp);
+	*xtalk = (uint16_t)(tmp*1000)>>9; /* * 1000 to convert kcps to cps and >> 9 (7.9 format) */
+	return status;
+}
+
+/* This function programs the threshold detection mode. For example:
+    VL53L1X_SetDistanceThreshold(dev,100,300,0,1): below 100
+    VL53L1X_SetDistanceThreshold(dev,100,300,1,1): above 300
+    VL53L1X_SetDistanceThreshold(dev,100,300,2,1): out-of-window
+    VL53L1X_SetDistanceThreshold(dev,100,300,3,1): in window
+    Where:
+    ¡E       dev is the device address
+    ¡E       ThreshLow(in mm) is the threshold under which the device raises an interrupt if window = 0
+    ¡E       ThreshHigh(in mm) is the threshold above which the device raises an interrupt if window = 1
+    ¡E       IntOnNoTarget is the window detection mode where 0 = below, 1 = above, 2 = out, and 3 = in
+    ¡E       IntOnNoTarget = 1 (no longer used so just use 1)
+ */
+VL53L1X_ERROR VL53L1X_SetDistanceThreshold(struct i2c_client *client, uint16_t ThreshLow,
+			      uint16_t ThreshHigh, uint8_t Window,
+			      uint8_t IntOnNoTarget)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t Temp = 0;
+
+	status = VL53L1_RdByte(client, SYSTEM__INTERRUPT_CONFIG_GPIO, &Temp);
+	Temp = Temp & 0x47;
+	if (IntOnNoTarget == 0) {
+		status = VL53L1_WrByte(client, SYSTEM__INTERRUPT_CONFIG_GPIO,
+			       (Temp | (Window & 0x07)));
+	} else {
+		status = VL53L1_WrByte(client, SYSTEM__INTERRUPT_CONFIG_GPIO,
+			       ((Temp | (Window & 0x07)) | 0x40));
+	}
+	status = VL53L1_WrWord(client, SYSTEM__THRESH_HIGH, ThreshHigh);
+	status = VL53L1_WrWord(client, SYSTEM__THRESH_LOW, ThreshLow);
+	return status;
+}
+
+/* This function returns the window detection mode where 0 = below, 1 = above, 2 = out and 3 = in.
+ */
+VL53L1X_ERROR VL53L1X_GetDistanceThresholdWindow(struct i2c_client *client, uint16_t *window)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t tmp;
+	status = VL53L1_RdByte(client,SYSTEM__INTERRUPT_CONFIG_GPIO, &tmp);
+	*window = (uint16_t)(tmp & 0x7);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetDistanceThresholdLow(struct i2c_client *client, uint16_t *low)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client,SYSTEM__THRESH_LOW, &tmp);
+	*low = tmp;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetDistanceThresholdHigh(struct i2c_client *client, uint16_t *high)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client,SYSTEM__THRESH_HIGH, &tmp);
+	*high = tmp;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetROICenter(struct i2c_client *client, uint8_t ROICenter)
+{
+	VL53L1X_ERROR status = 0;
+	status = VL53L1_WrByte(client, ROI_CONFIG__USER_ROI_CENTRE_SPAD, ROICenter);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetROICenter(struct i2c_client *client, uint8_t *ROICenter)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t tmp;
+	status = VL53L1_RdByte(client, ROI_CONFIG__USER_ROI_CENTRE_SPAD, &tmp);
+	*ROICenter = tmp;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetROI(struct i2c_client *client, uint16_t X, uint16_t Y)
+{
+	uint8_t OpticalCenter;
+	VL53L1X_ERROR status = 0;
+
+	status =VL53L1_RdByte(client, VL53L1_ROI_CONFIG__MODE_ROI_CENTRE_SPAD, &OpticalCenter);
+	if (X > 16)
+		X = 16;
+	if (Y > 16)
+		Y = 16;
+	if (X > 10 || Y > 10){
+		OpticalCenter = 199;
+	}
+	status = VL53L1_WrByte(client, ROI_CONFIG__USER_ROI_CENTRE_SPAD, OpticalCenter);
+	status = VL53L1_WrByte(client, ROI_CONFIG__USER_ROI_REQUESTED_GLOBAL_XY_SIZE,
+		       (Y - 1) << 4 | (X - 1));
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetROI_XY(struct i2c_client *client, uint16_t *ROI_X, uint16_t *ROI_Y)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t tmp;
+
+	status = VL53L1_RdByte(client,ROI_CONFIG__USER_ROI_REQUESTED_GLOBAL_XY_SIZE, &tmp);
+	*ROI_X = ((uint16_t)tmp & 0x0F) + 1;
+	*ROI_Y = (((uint16_t)tmp & 0xF0) >> 4) + 1;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetSignalThreshold(struct i2c_client *client, uint16_t Signal)
+{
+	VL53L1X_ERROR status = 0;
+
+	VL53L1_WrWord(client,RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS,Signal>>3);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetSignalThreshold(struct i2c_client *client, uint16_t *signal)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client,
+				RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS, &tmp);
+	*signal = tmp <<3;
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_SetSigmaThreshold(struct i2c_client *client, uint16_t Sigma)
+{
+	VL53L1X_ERROR status = 0;
+
+	if(Sigma>(0xFFFF>>2)){
+		return 1;
+	}
+	/* 16 bits register 14.2 format */
+	status = VL53L1_WrWord(client,RANGE_CONFIG__SIGMA_THRESH,Sigma<<2);
+	return status;
+}
+
+VL53L1X_ERROR VL53L1X_GetSigmaThreshold(struct i2c_client *client, uint16_t *sigma)
+{
+	VL53L1X_ERROR status = 0;
+	uint16_t tmp;
+
+	status = VL53L1_RdWord(client,RANGE_CONFIG__SIGMA_THRESH, &tmp);
+	*sigma = tmp >> 2;
+	return status;
+
+}
+
+/* This function performs the temperature calibration.
+   If the sensor has been stopped for a long time, it is recommended to perform the temperature update prior to
+     restarting the ranging.
+   By default, the sensor can adequately handle any temperature change as long as it is running, 
+     but if the sensor is stopped for an extended period of time, a temperature compensation is advised.
+ */
+VL53L1X_ERROR VL53L1X_StartTemperatureUpdate(struct i2c_client *client)
+{
+	VL53L1X_ERROR status = 0;
+	uint8_t tmp=0;
+
+	status = VL53L1_WrByte(client,VL53L1_VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND,0x81); /* full VHV */
+	status = VL53L1_WrByte(client,0x0B,0x92);
+	status = VL53L1X_StartRanging(client);
+	while(tmp==0){
+		status = VL53L1X_CheckForDataReady(client, &tmp);
+	}
+	tmp  = 0;
+	status = VL53L1X_ClearInterrupt(client);
+	status = VL53L1X_StopRanging(client);
+	status = VL53L1_WrByte(client, VL53L1_VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND, 0x09); /* two bounds VHV */
+	status = VL53L1_WrByte(client, 0x0B, 0); /* start VHV from the previous temperature */
+	return status;
+}
diff --git a/drivers/input/misc/vl53l1x_uld/VL53L1X_api.h b/drivers/input/misc/vl53l1x_uld/VL53L1X_api.h
new file mode 100644
index 000000000000..0b00eae2bb57
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/VL53L1X_api.h
@@ -0,0 +1,198 @@
+/**
+ * @file  vl53l1x_api.h
+ * @brief Functions definition
+ */
+
+#ifndef VL53L1X_API_H_
+#define VL53L1X_API_H_
+
+typedef int8_t VL53L1X_ERROR;
+
+#define SOFT_RESET											0x0000
+#define VL53L1_I2C_SLAVE__DEVICE_ADDRESS					0x0001
+#define VL53L1_VHV_CONFIG__TIMEOUT_MACROP_LOOP_BOUND        0x0008
+#define ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS 		0x0016
+#define ALGO__CROSSTALK_COMPENSATION_X_PLANE_GRADIENT_KCPS 	0x0018
+#define ALGO__CROSSTALK_COMPENSATION_Y_PLANE_GRADIENT_KCPS 	0x001A
+#define ALGO__PART_TO_PART_RANGE_OFFSET_MM					0x001E
+#define MM_CONFIG__INNER_OFFSET_MM							0x0020
+#define MM_CONFIG__OUTER_OFFSET_MM 							0x0022
+#define GPIO_HV_MUX__CTRL									0x0030
+#define GPIO__TIO_HV_STATUS       							0x0031
+#define SYSTEM__INTERRUPT_CONFIG_GPIO 						0x0046
+#define PHASECAL_CONFIG__TIMEOUT_MACROP     				0x004B
+#define RANGE_CONFIG__TIMEOUT_MACROP_A_HI   				0x005E
+#define RANGE_CONFIG__VCSEL_PERIOD_A        				0x0060
+#define RANGE_CONFIG__VCSEL_PERIOD_B						0x0063
+#define RANGE_CONFIG__TIMEOUT_MACROP_B_HI  					0x0061
+#define RANGE_CONFIG__TIMEOUT_MACROP_B_LO  					0x0062
+#define RANGE_CONFIG__SIGMA_THRESH 							0x0064
+#define RANGE_CONFIG__MIN_COUNT_RATE_RTN_LIMIT_MCPS			0x0066
+#define RANGE_CONFIG__VALID_PHASE_HIGH      				0x0069
+#define VL53L1_SYSTEM__INTERMEASUREMENT_PERIOD				0x006C
+#define SYSTEM__THRESH_HIGH 								0x0072
+#define SYSTEM__THRESH_LOW 									0x0074
+#define SD_CONFIG__WOI_SD0                  				0x0078
+#define SD_CONFIG__INITIAL_PHASE_SD0        				0x007A
+#define ROI_CONFIG__USER_ROI_CENTRE_SPAD					0x007F
+#define ROI_CONFIG__USER_ROI_REQUESTED_GLOBAL_XY_SIZE		0x0080
+#define SYSTEM__SEQUENCE_CONFIG								0x0081
+#define VL53L1_SYSTEM__GROUPED_PARAMETER_HOLD 				0x0082
+#define SYSTEM__INTERRUPT_CLEAR       						0x0086
+#define SYSTEM__MODE_START                 					0x0087
+#define VL53L1_RESULT__RANGE_STATUS							0x0089
+#define VL53L1_RESULT__DSS_ACTUAL_EFFECTIVE_SPADS_SD0		0x008C
+#define RESULT__AMBIENT_COUNT_RATE_MCPS_SD					0x0090
+#define VL53L1_RESULT__FINAL_CROSSTALK_CORRECTED_RANGE_MM_SD0				0x0096
+#define VL53L1_RESULT__PEAK_SIGNAL_COUNT_RATE_CROSSTALK_CORRECTED_MCPS_SD0 	0x0098
+#define VL53L1_RESULT__OSC_CALIBRATE_VAL					0x00DE
+#define VL53L1_FIRMWARE__SYSTEM_STATUS                      0x00E5
+#define VL53L1_IDENTIFICATION__MODEL_ID                     0x010F
+#define VL53L1_ROI_CONFIG__MODE_ROI_CENTRE_SPAD				0x013E
+
+/**
+ *  @brief defines packed reading results type
+ */
+typedef struct {
+	uint8_t Status;		/*!< ResultStatus */
+	uint16_t Distance;	/*!< ResultDistance */
+	uint16_t Ambient;	/*!< ResultAmbient */
+	uint16_t SigPerSPAD;/*!< ResultSignalPerSPAD */
+	uint16_t NumSPADs;	/*!< ResultNumSPADs */
+} VL53L1X_Result_t;
+
+/**
+ * @brief This function loads the 135 bytes default values to initialize the sensor.
+ * @param dev Device address
+ * @return 0:success, != 0:failed
+ */
+VL53L1X_ERROR VL53L1X_SensorInit(struct i2c_client *client);
+
+/**
+ * @brief This function clears the interrupt, to be called after a ranging data reading
+ * to arm the interrupt for the next data ready event.
+ */
+VL53L1X_ERROR VL53L1X_ClearInterrupt(struct i2c_client *client);
+
+/**
+ * @brief This function starts the ranging distance operation

+ * The ranging operation is continuous. The clear interrupt has to be done after each get data to allow the interrupt to raise when the next data is ready

+ * 1=active high (default), 0=active low, use SetInterruptPolarity() to change the interrupt polarity if required.
+ */
+VL53L1X_ERROR VL53L1X_StartRanging(struct i2c_client *client);
+
+/**
+ * @brief This function stops the ranging.
+ */
+VL53L1X_ERROR VL53L1X_StopRanging(struct i2c_client *client);
+
+/**
+ * @brief This function checks if the new ranging data is available by polling the dedicated register.
+ * @param : isDataReady==0 -> not ready; isDataReady==1 -> ready
+ */
+VL53L1X_ERROR VL53L1X_CheckForDataReady(struct i2c_client *client, uint8_t *isDataReady);
+
+/**
+ * @brief This function programs the timing budget in ms.
+ * Predefined values = 15, 20, 33, 50, 100(default), 200, 500.
+ */
+VL53L1X_ERROR VL53L1X_SetTimingBudgetInMs(struct i2c_client *client, uint16_t TimingBudgetInMs);
+
+/**
+ * @brief This function programs the distance mode (1=short, 2=long(default)).
+ * Short mode max distance is limited to 1.3 m but better ambient immunity.

+ * Long mode can range up to 4 m in the dark with 200 ms timing budget.
+ */
+VL53L1X_ERROR VL53L1X_SetDistanceMode(struct i2c_client *client, uint16_t DistanceMode);
+
+/**
+ * @brief This function returns the current distance mode (1=short, 2=long).
+ */
+VL53L1X_ERROR VL53L1X_GetDistanceMode(struct i2c_client *client, uint16_t *pDistanceMode);
+
+/**
+ * @brief This function programs the Intermeasurement period in ms

+ * Intermeasurement period must be >/= timing budget. This condition is not checked by the API,
+ * the customer has the duty to check the condition. Default = 100 ms
+ */
+VL53L1X_ERROR VL53L1X_SetInterMeasurementInMs(struct i2c_client *client, uint32_t InterMeasMs);
+
+/**
+ * @brief This function returns the sensor id, sensor Id must be 0xEEAC
+ */
+VL53L1X_ERROR VL53L1X_GetSensorId(struct i2c_client *client, uint16_t *id);
+
+/**
+ * @brief This function returns the boot state of the device (1:booted, 0:not booted)
+ */
+VL53L1X_ERROR VL53L1X_BootState(struct i2c_client *client, uint8_t *state);
+
+/**
+ * @brief This function returns the distance measured by the sensor in mm
+ */
+VL53L1X_ERROR VL53L1X_GetDistance(struct i2c_client *client, uint16_t *distance);
+
+/**
+ * @brief This function returns the returned signal in kcps.
+ */
+VL53L1X_ERROR VL53L1X_GetSignalRate(struct i2c_client *client, uint16_t *signalRate);
+
+/**
+ * @brief This function returns the current number of enabled SPADs
+ */
+VL53L1X_ERROR VL53L1X_GetSpadNb(struct i2c_client *client, uint16_t *spNb);
+
+/**
+ * @brief This function returns the ranging status error 

+ * (0:no error, 1:sigma failed, 2:signal failed, ..., 7:wrap-around)
+ */
+VL53L1X_ERROR VL53L1X_GetRangeStatus(struct i2c_client *client, uint8_t *rangeStatus);
+
+/**
+ * @brief This function programs the offset correction in mm
+ * @param OffsetValue:the offset correction value to program in mm
+ */
+VL53L1X_ERROR VL53L1X_SetOffset(struct i2c_client *client, int16_t OffsetValue);
+
+/**
+ * @brief This function returns the programmed offset correction value in mm
+ */
+VL53L1X_ERROR VL53L1X_GetOffset(struct i2c_client *client, int16_t *Offset);
+
+/**
+ * @brief This function programs the xtalk correction value in cps (Count Per Second).

+ * This is the number of photons reflected back from the cover glass in cps.
+ */
+VL53L1X_ERROR VL53L1X_SetXtalk(struct i2c_client *client, uint16_t XtalkValue);
+
+/**
+ * @brief This function returns the current programmed xtalk correction value in cps
+ */
+VL53L1X_ERROR VL53L1X_GetXtalk(struct i2c_client *client, uint16_t *Xtalk);
+
+/**
+ * @brief This function programs the ROI (Region of Interest)

+ * The ROI position is centered, only the ROI size can be reprogrammed.

+ * The smallest acceptable ROI size = 4

+ * @param X:ROI Width; Y=ROI Height
+ */
+VL53L1X_ERROR VL53L1X_SetROI(struct i2c_client *client, uint16_t X, uint16_t Y);
+
+/**
+ *@brief This function returns width X and height Y
+ */
+VL53L1X_ERROR VL53L1X_GetROI_XY(struct i2c_client *client, uint16_t *ROI_X, uint16_t *ROI_Y);
+
+/**
+ *@brief This function programs the new user ROI center, please to be aware that there is no check in this function.
+ *if the ROI center vs ROI size is out of border the ranging function return error #13
+ */
+VL53L1X_ERROR VL53L1X_SetROICenter(struct i2c_client *client, uint8_t ROICenter);
+
+/**
+ *@brief This function returns the current user ROI center
+ */
+VL53L1X_ERROR VL53L1X_GetROICenter(struct i2c_client *client, uint8_t *ROICenter);
+
+
+#endif /* VL53L1X_API_H_ */
diff --git a/drivers/input/misc/vl53l1x_uld/VL53L1X_calibration.c b/drivers/input/misc/vl53l1x_uld/VL53L1X_calibration.c
new file mode 100644
index 000000000000..94e5b2bd3785
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/VL53L1X_calibration.c
@@ -0,0 +1,90 @@
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+
+#include <linux/iio/iio.h>
+
+/**
+ * @file  vl53l1x_calibration.c
+ * @brief Calibration functions implementation
+ */
+
+#include "VL53L1X_api.h"
+#include "VL53L1X_calibration.h"
+
+
+
+int VL53L1_WriteMulti(struct i2c_client *client, uint16_t index, uint8_t *pdata, uint32_t count);
+int VL53L1_ReadMulti(struct i2c_client *client, uint16_t index, uint8_t *pdata, uint32_t count);
+int VL53L1_WrByte(struct i2c_client *client, uint16_t index, uint8_t data);
+int VL53L1_WrWord(struct i2c_client *client, uint16_t index, uint16_t data);
+int VL53L1_WrDWord(struct i2c_client *client, uint16_t index, uint32_t data);
+int VL53L1_RdByte(struct i2c_client *client, uint16_t index, uint8_t *data);
+int VL53L1_RdWord(struct i2c_client *client, uint16_t index, uint16_t *data);
+int VL53L1_RdDWord(struct i2c_client *client, uint16_t index, uint32_t *data);
+// ============================================================
+
+int8_t VL53L1X_CalibrateOffset(struct i2c_client *client, uint16_t TargetDistInMm, int16_t *offset)
+{
+	uint8_t i, tmp;
+	int16_t AverageDistance = 0;
+	uint16_t distance;
+	VL53L1X_ERROR status = 0;
+
+	status = VL53L1_WrWord(client, ALGO__PART_TO_PART_RANGE_OFFSET_MM, 0x0);
+	status = VL53L1_WrWord(client, MM_CONFIG__INNER_OFFSET_MM, 0x0);
+	status = VL53L1_WrWord(client, MM_CONFIG__OUTER_OFFSET_MM, 0x0);
+	status = VL53L1X_StartRanging(client);	/* Enable VL53L1X sensor */
+	for (i = 0; i < 50; i++) {
+		tmp = 0;
+		while (tmp == 0){
+			status = VL53L1X_CheckForDataReady(client, &tmp);
+		}
+		status = VL53L1X_GetDistance(client, &distance);
+		status = VL53L1X_ClearInterrupt(client);
+		AverageDistance = AverageDistance + distance;
+	}
+	status = VL53L1X_StopRanging(client);
+	AverageDistance = AverageDistance / 50;
+	*offset = TargetDistInMm - AverageDistance;
+	status = VL53L1_WrWord(client, ALGO__PART_TO_PART_RANGE_OFFSET_MM, *offset*4);
+	return status;
+}
+
+int8_t VL53L1X_CalibrateXtalk(struct i2c_client *client, uint16_t TargetDistInMm, uint16_t *xtalk)
+{
+	uint8_t i, tmp;
+	float AverageSignalRate = 0;
+	float AverageDistance = 0;
+	float AverageSpadNb = 0;
+	uint16_t distance = 0, spadNum;
+	uint16_t sr;
+	VL53L1X_ERROR status = 0;
+	uint32_t calXtalk;
+
+	status = VL53L1_WrWord(client, 0x0016,0);	// ALGO__CROSSTALK_COMPENSATION_PLANE_OFFSET_KCPS
+	status = VL53L1X_StartRanging(client);
+	for (i = 0; i < 50; i++) {
+		tmp = 0;
+		while (tmp == 0){
+			status = VL53L1X_CheckForDataReady(client, &tmp);
+		}
+		status= VL53L1X_GetSignalRate(client, &sr);
+		status= VL53L1X_GetDistance(client, &distance);
+		status = VL53L1X_ClearInterrupt(client);
+		AverageDistance = AverageDistance + distance;
+		status = VL53L1X_GetSpadNb(client, &spadNum);
+		AverageSpadNb = AverageSpadNb + spadNum;
+		AverageSignalRate =
+		    AverageSignalRate + sr;
+	}
+	status = VL53L1X_StopRanging(client);
+	AverageDistance = AverageDistance / 50;
+	AverageSpadNb = AverageSpadNb / 50;
+	AverageSignalRate = AverageSignalRate / 50;
+	/* Calculate Xtalk value */
+	calXtalk = (uint16_t)(512*(AverageSignalRate*(1-(AverageDistance/TargetDistInMm)))/AverageSpadNb);
+	*xtalk = (uint16_t)(calXtalk*1000)>>9;
+	status = VL53L1_WrWord(client, 0x0016, calXtalk);
+	return status;
+}
diff --git a/drivers/input/misc/vl53l1x_uld/VL53L1X_calibration.h b/drivers/input/misc/vl53l1x_uld/VL53L1X_calibration.h
new file mode 100644
index 000000000000..d2e13396abff
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/VL53L1X_calibration.h
@@ -0,0 +1,33 @@
+/**
+ * @file  vl53l1x_calibration.h
+ * @brief Calibration Functions definition
+ */
+
+#ifndef VL53L1X_CALIBRATION_H_
+#define VL53L1X_CALIBRATION_H_
+
+
+/**
+ * @brief This function performs the offset calibration.

+ * The function returns the offset value found and programs the offset compensation into the device.
+ * @param TargetDistInMm target distance in mm, ST recommended 100 mm
+ * Target reflectance = grey17%
+ * @return 0:success, !=0: failed
+ * @return offset pointer contains the offset found in mm
+ */
+int8_t VL53L1X_CalibrateOffset(struct i2c_client *client, uint16_t TargetDistInMm, int16_t *offset);
+
+/**
+ * @brief This function performs the xtalk calibration.

+ * The function returns the xtalk value found and programs the xtalk compensation to the device
+ * @param TargetDistInMm target distance in mm

+ * The target distance : the distance where the sensor start to "under range"

+ * due to the influence of the photons reflected back from the cover glass becoming strong

+ * It's also called inflection point

+ * Target reflectance = grey 17%
+ * @return 0: success, !=0: failed
+ * @return xtalk pointer contains the xtalk value found in cps (number of photons in count per second)
+ */
+int8_t VL53L1X_CalibrateXtalk(struct i2c_client *client, uint16_t TargetDistInMm, uint16_t *xtalk);
+
+#endif /* VL53L1X_CALIBRATION_H_ */
diff --git a/drivers/input/misc/vl53l1x_uld/vl53l1_platform.c b/drivers/input/misc/vl53l1x_uld/vl53l1_platform.c
new file mode 100644
index 000000000000..23da72410625
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/vl53l1_platform.c
@@ -0,0 +1,317 @@
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+
+#include <linux/iio/iio.h>
+
+#define VL53L1_REG_SIZE		2
+
+static uint8_t _I2CBuffer[256];
+
+int VL53L1_WriteMulti(struct i2c_client *client, uint16_t index, uint8_t *pdata, uint32_t count)
+{
+	struct i2c_msg msg;
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = VL53L1_REG_SIZE + count;
+	msg.buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+	memcpy(&_I2CBuffer[2], pdata, count);
+
+//	pr_info("%s: addr= 0x%02X%02X
", __func__, index>>8, index&0xFF);
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 1) ? count : ret;
+}
+
+int VL53L1_ReadMulti(struct i2c_client *client, uint16_t index, uint8_t *pdata, uint32_t count)
+{
+	struct i2c_msg msg[2];
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+	memset(msg, 0 , sizeof(msg));
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = VL53L1_REG_SIZE;
+	msg[0].buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+
+	msg[1].addr = client->addr;
+	msg[1].len = count;	// len
+	msg[1].flags = I2C_M_RD;
+	msg[1].buf = (uint8_t *)pdata;
+
+//	pr_info("%s: addr= 0x%02X%02X, len= %d
", __func__, index>>8, index&0xFF, count);
+	ret = i2c_transfer(client->adapter, msg, 2);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 2) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 2) ? count : ret;
+}
+
+int VL53L1_WrByte(struct i2c_client *client, uint16_t index, uint8_t data)
+{
+	struct i2c_msg msg;
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = VL53L1_REG_SIZE + sizeof(uint8_t);
+	msg.buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+	_I2CBuffer[2] = data;
+
+//	pr_info("%s: addr= 0x%02X%02X with 0x%02X
", __func__, index>>8, index&0xFF, data);
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 1) ? sizeof(uint8_t) : ret;
+}
+
+int VL53L1_WrWord(struct i2c_client *client, uint16_t index, uint16_t data)
+{
+	struct i2c_msg msg;
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = (VL53L1_REG_SIZE + sizeof(uint16_t));
+	msg.buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+	_I2CBuffer[2] = data >> 8;			// MSB fist
+	_I2CBuffer[3] = data & 0x00FF;
+
+	//pr_info("%s: addr= 0x%02X%02X
", __func__, index>>8, index&0xFF);
+//	pr_info("%s: addr= 0x%02X%02X with 0x%04X
", __func__, index>>8, index&0xFF, data);
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 1) ? sizeof(uint16_t) : ret;
+}
+
+int VL53L1_WrDWord(struct i2c_client *client, uint16_t index, uint32_t data)
+{
+	struct i2c_msg msg;
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+
+	msg.addr = client->addr;
+	msg.flags = 0;
+	msg.len = VL53L1_REG_SIZE + sizeof(uint32_t);
+	msg.buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+	_I2CBuffer[2] = (data >> 24) & 0xFF;			// MSB fist
+	_I2CBuffer[3] = (data >> 16) & 0xFF;
+	_I2CBuffer[4] = (data >> 8)  & 0xFF;
+	_I2CBuffer[5] = (data >> 0 ) & 0xFF;
+
+//	pr_info("%s: addr= 0x%02X%02X
", __func__, index>>8, index&0xFF);
+	ret = i2c_transfer(client->adapter, &msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 1) ? sizeof(uint32_t) : ret;
+}
+
+int VL53L1_RdByte(struct i2c_client *client, uint16_t index, uint8_t *data)
+{
+	struct i2c_msg msg[1];
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+	memset(msg, 0 , sizeof(msg));
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = VL53L1_REG_SIZE;
+	msg[0].buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+
+//	pr_info("%s: addr= 0x%02X%02X
", __func__, index>>8, index&0xFF);
+	ret = i2c_transfer(client->adapter, msg, 1);
+	/* Negative error no, else the number of messages executed. */
+//	if (ret < 0 || ret != 1) 
+//	{
+//		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+//	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = I2C_M_RD;
+	msg[0].len = sizeof(uint8_t);	// one byte
+	msg[0].buf = data;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+//	else
+//		pr_info("%s: addr= 0x%02X%02X with 0x%02X
", __func__, index>>8, index&0xFF, *data);
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 1) ? sizeof(uint8_t) : ret;
+}
+
+int VL53L1_RdWord(struct i2c_client *client, uint16_t index, uint16_t *data)
+{
+	struct i2c_msg msg[1];
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+	memset(msg, 0 , sizeof(msg));
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = VL53L1_REG_SIZE;
+	msg[0].buf = _I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+
+//	pr_info("%s: addr= 0x%02X%02X
", __func__, index>>8, index&0xFF);
+	ret = i2c_transfer(client->adapter, msg, 1);
+	/* Negative error no, else the number of messages executed. */
+//	if (ret < 0 || ret != 1) 
+//	{
+//		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+//	}
+
+	msg[0].addr = client->addr;
+	msg[0].flags = I2C_M_RD;
+	msg[0].len = sizeof(uint16_t);
+	msg[0].buf = _I2CBuffer;
+
+	ret = i2c_transfer(client->adapter, msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+	else {
+		*data = ((uint16_t)_I2CBuffer[0]<<8) + (uint16_t)_I2CBuffer[1];
+//		pr_info("%s: addr= 0x%02X%02X with 0x%04X
", __func__, index>>8, index&0xFF, *data);
+	}
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 1) ? sizeof(uint8_t) : ret;
+}
+
+int VL53L1_RdDWord(struct i2c_client *client, uint16_t index, uint32_t *data)
+{
+	struct i2c_msg msg[1];
+	int ret = 0;
+
+	if (!client->adapter)
+	{
+		pr_err("%s: error, no client->adapter
", __func__);
+		return -ENODEV;
+	}
+	memset(msg, 0 , sizeof(msg));
+	msg[0].addr = client->addr;
+	msg[0].flags = 0;
+	msg[0].len = VL53L1_REG_SIZE;
+	msg[0].buf = (u8 *)_I2CBuffer;
+	_I2CBuffer[0] = index>>8;
+	_I2CBuffer[1] = index&0xFF;
+	ret = i2c_transfer(client->adapter, msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+	}
+
+	msg[0].addr = client->addr;
+	msg[0].len = sizeof(uint32_t);				// four bytes
+	msg[0].flags = I2C_M_RD;
+	msg[0].buf = _I2CBuffer;
+
+//	pr_info("%s: addr= 0x%02X%02X
", __func__, index>>8, index&0xFF);
+	ret = i2c_transfer(client->adapter, msg, 1);
+	/* Negative error no, else the number of messages executed. */
+	if (ret < 0 || ret != 1) 
+	{
+		pr_err("%s: i2c_transfer returned %d
", __func__, ret);
+		ret = -EIO;
+	}
+	else {
+		*data = ((uint32_t)_I2CBuffer[0]<<24) + ((uint32_t)_I2CBuffer[1]<<16) + ((uint32_t)_I2CBuffer[2]<<8) + (uint32_t)_I2CBuffer[3];
+//		pr_info("%s: addr= 0x%02X%02X with 0x%04X
", __func__, index>>8, index&0xFF, *data);
+	}
+
+	/* If everything went ok, return #bytes received, else error code.
+	 */
+	return (ret == 2) ? sizeof(uint32_t) : ret;
+}
+
diff --git a/drivers/input/misc/vl53l1x_uld/vl53l1x-i2c.c b/drivers/input/misc/vl53l1x_uld/vl53l1x-i2c.c
new file mode 100644
index 000000000000..37f3f724376d
--- /dev/null
+++ b/drivers/input/misc/vl53l1x_uld/vl53l1x-i2c.c
@@ -0,0 +1,1393 @@
+// SPDX-License-Identifier: GPL-2.0
+/*
+ * Support for ST VL53L0X FlightSense ToF Ranging Sensor on a i2c bus.
+ *
+ * Copyright (C) 2016 STMicroelectronics Imaging Division.
+ * Copyright (C) 2018 Song Qiang <songqiang1304521@gmail.com>
+ *
+ * Datasheet available at
+ * <https://www.st.com/resource/en/datasheet/vl53l1x.pdf>
+ *
+ * Default 7-bit i2c slave address 0x29.
+ *
+ */
+
+#include <linux/slab.h>
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/input.h>
+#include <linux/module.h>
+#include <linux/gpio.h>
+#include <linux/of.h>
+#include <linux/of_gpio.h>
+
+#define VL53L1X_POWER_CUT
+#define VL53L1X_PRX_DEV_NAME	"vl53l1x_prx"
+
+#define VL53L1X_PRX_MIN_POLL_PERIOD_MS 15
+
+#include "VL53L1X_api.h"
+#include "VL53L1X_calibration.h"
+
+/* Input events used by vl53l1x driver */
+#define INPUT_EVENT_TYPE		EV_MSC
+#define INPUT_EVENT_DISTANCE	MSC_SERIAL
+
+#define INPUT_EVENT_TIME_MSB		MSC_SCAN
+#define INPUT_EVENT_TIME_LSB		MSC_MAX
+
+/* device opmode */
+enum vl53l1x_prx_opmode {
+	VL53L1X_PRX_OPMODE_SHORT = 1,
+	VL53L1X_PRX_OPMODE_LONG,
+};
+
+/* Timing Budget */
+enum vl53l1x_prx_timing_budget {
+	VL53L1X_PRX_TIMING_BUDGET_15_MS = 15,
+	VL53L1X_PRX_TIMING_BUDGET_20_MS = 20,
+	VL53L1X_PRX_TIMING_BUDGET_33_MS = 33,
+	VL53L1X_PRX_TIMING_BUDGET_50_MS = 50,
+	VL53L1X_PRX_TIMING_BUDGET_100_MS = 100,
+	VL53L1X_PRX_TIMING_BUDGET_200_MS = 200,
+	VL53L1X_PRX_TIMING_BUDGET_500_MS = 500,
+};
+
+
+struct vl53l1x_data {
+	struct i2c_client *client;
+
+	const char *name;
+	struct mutex lock;
+	struct device *dev;
+	int hw_initialized;
+	atomic_t enabled;
+	int on_before_suspend;
+	u8 sensor_num;
+	u16 bus_type;
+
+	u32 poll_interval;
+	u32 min_interval;
+	u16 opmode;
+	u16 timing_budget;
+	u16 inter_measurement;
+	u8 roi_center;
+	u16 x_width;
+	u16 y_height;
+
+	s16 calibration_offset;
+	u16 calibration_xtalk;
+
+	struct input_dev *input_dev;
+	struct delayed_work input_work;
+	u32 schedule_num; /* Number of time work_input routine is called */
+};
+
+/* ODR table */
+struct {
+	u32 time_ms;
+	u32 tb;
+} vl53l1x_odr_table[] = {
+	{   15, 15	}, /* ODR = 66Hz */
+	{   20, 20	}, /* ODR = 50Hz */
+	{   33, 33	}, /* ODR = 33Hz */
+	{   50, 50	}, /* ODR = 20Hz */
+	{  100, 100	}, /* ODR = 10Hz */
+	{  200, 200	}, /* ODR =  5Hz */
+	{  500, 500	}, /* ODR =  2Hz */
+};
+
+static inline s64 vl53l1x_get_time_ns(void)
+{
+	struct timespec ts;
+
+	/*
+	 * calls getnstimeofday.
+	 * If hrtimers then up to ns accurate, if not microsecond.
+	 */
+	get_monotonic_boottime(&ts);
+
+	return timespec_to_ns(&ts);
+}
+
+static int vl53l1x_prx_input_init(struct vl53l1x_data *cdata,
+				    const char* description)
+{
+	int err;
+
+	cdata->input_dev = input_allocate_device();
+	if (!cdata->input_dev) {
+		dev_err(cdata->dev, "input device allocation failed
");
+		return -ENOMEM;
+	}
+
+	cdata->input_dev->name = description;
+	cdata->input_dev->id.bustype = BUS_I2C;
+	cdata->input_dev->dev.parent = cdata->dev;
+
+	input_set_drvdata(cdata->input_dev, cdata);		/* samse as dev_set_drvdata(&cdata->input_dev->dev, cdata) */
+
+	/* Set the input event characteristics of the probed sensor driver */
+	set_bit(INPUT_EVENT_TYPE, cdata->input_dev->evbit);
+	set_bit(INPUT_EVENT_TIME_MSB, cdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_TIME_LSB, cdata->input_dev->mscbit);
+	set_bit(INPUT_EVENT_DISTANCE, cdata->input_dev->mscbit);
+	input_set_abs_params(cdata->input_dev, ABS_DISTANCE, 0, 400, 0, 0);
+
+	err = input_register_device(cdata->input_dev);
+	if (err) {
+		dev_err(cdata->dev,
+			"unable to register input device %s
",
+			cdata->input_dev->name);
+		input_free_device(cdata->input_dev);
+		return err;
+	}
+
+	return 0;
+}
+
+static int vl53l1x_prx_hw_init(struct vl53l1x_data *cdata)
+{
+	int err;
+	uint16_t sensorID;
+	uint8_t sensorState=0;
+	struct i2c_client *client = cdata->client;
+
+#ifdef VL53L1X_PRX_DEBUG
+	pr_info("%s: hw init start
", VL53L1X_PRX_DEV_NAME);
+#endif
+
+	err = VL53L1X_GetSensorId(client, &sensorID);
+	if (err < 0) {
+		dev_warn(cdata->dev, "Error reading SensorID
");
+		goto error;
+	}
+
+	/* Model ID is 0xEA; Module Type is 0xCC */
+	if (sensorID != 0xEACC) {
+		dev_err(cdata->dev,
+			"device unknown (0x%04x-0x%04x)
",
+			0xEACC, sensorID);
+		err = -1; /* choose the right coded error */
+		goto error;
+	}
+
+	while(sensorState==0){
+		err = VL53L1X_BootState(client, &sensorState);
+		if (err < 0)
+			goto error;
+		pr_info("%s: sensorState = %d
", __func__, sensorState);
+		udelay(2000);
+	}
+	pr_info("%s: Chip booted
", VL53L1X_PRX_DEV_NAME);
+
+	/* This function must to be called to initialize the sensor with the default setting  */
+	err = VL53L1X_SensorInit(client);
+	if (err < 0)
+		goto error;
+
+	cdata->hw_initialized = 1;
+
+#ifdef VL53L1X_PRX_DEBUG
+	pr_info("%s: hw init done
", VL53L1X_PRX_DEV_NAME);
+#endif
+	return 0;
+
+error:
+	cdata->hw_initialized = 0;
+	dev_err(cdata->dev, "hw init error: %d
", err);
+
+	return err;
+}
+
+#ifdef VL53L1X_POWER_CUT
+static void vl53l1x_device_shutdown(struct vl53l1x_data *cdata, int enable)
+{
+	struct i2c_client *client = cdata->client;
+	struct device_node *np = client->dev.of_node;
+	int xshut_gpio;
+
+	if (!np) {
+		dev_err(&client->dev, "%s: no device tree
", __func__);
+		return;
+	}
+
+	xshut_gpio = of_get_named_gpio(np, "st,xshut-gpio", 0);
+	if (!gpio_is_valid(xshut_gpio)) {
+		dev_err(&client->dev, "%s: xshut_gpio is invalid %d
", __func__, xshut_gpio);
+		return;
+	}
+
+	if (enable)
+		gpio_direction_output(xshut_gpio, 0);	// Xshutdown pin, active low
+	else
+		gpio_direction_output(xshut_gpio, 1);
+}
+#endif
+
+static void vl53l1x_prx_device_power_off(struct vl53l1x_data *cdata)
+{
+#ifdef VL53L1X_POWER_CUT
+	vl53l1x_device_shutdown(cdata, 1);
+#else
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	/* It does not really poweroff */
+	err = VL53L1X_StopRanging(client);
+	if (err < 0)
+		dev_err(cdata->dev, "soft power off failed: %d
", err);
+#endif
+
+	if (cdata->hw_initialized)
+		cdata->hw_initialized = 0;
+}
+
+static int vl53l1x_prx_device_power_on(struct vl53l1x_data *cdata)
+{
+#ifdef VL53L1X_POWER_CUT
+	vl53l1x_device_shutdown(cdata, 0);
+#endif
+	if (!cdata->hw_initialized) {
+		int err = vl53l1x_prx_hw_init(cdata);
+		if (err < 0) {
+			vl53l1x_prx_device_power_off(cdata);
+			return err;
+		}
+	}
+
+	return 0;
+}
+
+static int vl53l1x_prx_update_opmode(struct vl53l1x_data *cdata,
+				       unsigned short opmode)
+{
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	switch (opmode) {
+	case VL53L1X_PRX_OPMODE_SHORT:
+		break;
+	case VL53L1X_PRX_OPMODE_LONG:
+		break;
+	default:
+		return -EINVAL;
+	}
+
+	err = VL53L1X_SetDistanceMode(client, opmode); /* 1=short, 2=long */
+	if (err < 0)
+		goto error;
+
+	/* Change platform data */
+	cdata->opmode = opmode;
+
+#ifdef VL53L1X_PRX_DEBUG
+	dev_info(cdata->dev, "%s opm=%d
",
+		 VL53L1X_PRX_DEV_NAME,
+		 cdata->opmode);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update opmode failed: %d
", err);
+
+	return err;
+}
+
+static int vl53l1x_prx_update_timing_budget(struct vl53l1x_data *cdata,
+				       unsigned short timing_budget)
+{
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	if (timing_budget <= 15)
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_15_MS;
+	else if (timing_budget <= 20)
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_20_MS;
+	else if (timing_budget <= 33)
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_33_MS;
+	else if (timing_budget <= 50)
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_50_MS;
+	else if (timing_budget <= 100)
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_100_MS;
+	else if (timing_budget <= 200)
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_200_MS;
+	else
+		timing_budget = VL53L1X_PRX_TIMING_BUDGET_500_MS;
+
+	err = VL53L1X_SetTimingBudgetInMs(client, timing_budget); /* in ms possible values [20, 50, 100, 200, 500] */
+	if (err < 0)
+		goto error;
+
+	/* Change platform data */
+	cdata->timing_budget = timing_budget;
+
+#ifdef VL53L1X_PRX_DEBUG
+	dev_info(cdata->dev, "%s timing_budget=%d
",
+		 VL53L1X_PRX_DEV_NAME,
+		 cdata->timing_budget);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update timing budget failed: %d
", err);
+
+	return err;
+}
+
+static int vl53l1x_prx_update_inter_measurement(struct vl53l1x_data *cdata,
+				       unsigned short inter_measurement)
+{
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	if (inter_measurement < cdata->timing_budget) {
+		pr_info("%s: The IMP must be greater than or equal to the TB, so set inter_measurement as %d ms.
", __func__, cdata->timing_budget);
+		inter_measurement = cdata->timing_budget;
+	}
+
+	err = VL53L1X_SetInterMeasurementInMs(client, inter_measurement); /* in ms, IM must be > = TB */
+	if (err < 0)
+		goto error;
+
+	/* Change platform data */
+	cdata->inter_measurement = inter_measurement;
+
+#ifdef VL53L1X_PRX_DEBUG
+	dev_info(cdata->dev, "%s inter_measurement=%d
",
+		 VL53L1X_PRX_DEV_NAME,
+		 cdata->inter_measurement);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update inter measurement failed: %d
", err);
+
+	return err;
+}
+
+static int vl53l1x_prx_update_roi_center(struct vl53l1x_data *cdata,
+				       unsigned char roi_center)
+{
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	err = VL53L1X_SetROICenter(client, roi_center);
+	if (err < 0)
+		goto error;
+
+	/* Change platform data */
+	cdata->roi_center = roi_center;
+
+#ifdef VL53L1X_PRX_DEBUG
+	dev_info(cdata->dev, "%s roi_center=%d
",
+		 VL53L1X_PRX_DEV_NAME,
+		 cdata->roi_center);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update ROI center failed: %d
", err);
+
+	return err;
+}
+
+static int vl53l1x_prx_update_roi(struct vl53l1x_data *cdata,
+				       unsigned int x_width, unsigned int y_height)
+{
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	err = VL53L1X_SetROI(client, x_width, y_height);
+	if (err < 0)
+		goto error;
+
+	/* Change platform data */
+	cdata->x_width = x_width;
+	cdata->y_height = y_height;
+
+#ifdef VL53L1X_PRX_DEBUG
+	dev_info(cdata->dev, "%s x_width=%d, y_height=%d
",
+		 VL53L1X_PRX_DEV_NAME,
+		 cdata->x_width, cdata->y_height);
+#endif
+
+	return err;
+
+error:
+	dev_err(cdata->dev, "update ROI XY failed: %d
", err);
+
+	return err;
+}
+
+static int
+vl53l1x_prx_get_distance_data(struct vl53l1x_data *cdata, int *distance)
+{
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	uint8_t dataReady;
+//	uint8_t RangeStatus;
+
+	dataReady = 0;
+	err = VL53L1X_CheckForDataReady(client, &dataReady);
+	while (dataReady == 0) {
+		err = VL53L1X_CheckForDataReady(client, &dataReady);
+//		pr_info("%s: dataReady = %d
", __func__, dataReady);
+		if (err < 0) {
+			pr_info("%s: VL53L1X_CheckForDataReady returns failure with err = %d
", __func__, err);
+			return err;
+		}
+		msleep(2);
+	}
+
+#if 0
+	err = VL53L1X_GetRangeStatus(client, &RangeStatus);
+	pr_info("%s: RangeStatus = %d
", __func__, RangeStatus);
+	if (err < 0) {
+		pr_info("%s: VL53L1X_GetRangeStatus returns failure with err = %d
", __func__, err);
+		return err;
+	}
+#endif
+
+	err = VL53L1X_GetDistance(client, (uint16_t *)distance);
+	if (err < 0) {
+		pr_info("%s: VL53L1X_GetDistance returns failure with err = %d
", __func__, err);
+		return err;
+	}
+
+	err = VL53L1X_ClearInterrupt(client);
+	if (err < 0) {
+		pr_info("%s: VL53L1X_ClearInterrupt returns failure with err = %d
", __func__, err);
+		return err;
+	}
+
+#ifdef VL53L1X_PRX_DEBUG
+	dev_info(cdata->dev, "%s read distance=%d
",
+		 VL53L1X_PRX_DEV_NAME, *distance);
+#endif
+
+	return err;
+}
+
+static void vl53l1x_prx_report_values(struct vl53l1x_data *cdata,
+					int distance, s64 timestamp)
+{
+	input_event(cdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_DISTANCE, distance);
+	input_event(cdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_MSB,
+		    timestamp >> 32);
+	input_event(cdata->input_dev, INPUT_EVENT_TYPE, INPUT_EVENT_TIME_LSB,
+		    timestamp & 0xffffffff);
+	input_sync(cdata->input_dev);
+}
+
+int vl53l1x_prx_enable(struct vl53l1x_data *cdata)
+{
+	struct i2c_client *client = cdata->client;
+
+	pr_info("%s
", __func__);
+	if (!atomic_cmpxchg(&cdata->enabled, 0, 1)) {
+		int err;
+
+		mutex_lock(&cdata->lock);
+
+		err = vl53l1x_prx_device_power_on(cdata);
+		if (err < 0) {
+			atomic_set(&cdata->enabled, 0);
+			return err;
+		}
+
+		if (cdata->poll_interval <= 15)
+			err = vl53l1x_prx_update_opmode(cdata, VL53L1X_PRX_OPMODE_SHORT); /* 1=short, 2=long */
+		else
+			err = vl53l1x_prx_update_opmode(cdata, VL53L1X_PRX_OPMODE_LONG); /* 1=short, 2=long */
+		if (err < 0) {
+			dev_err(cdata->dev, "set distance mode failed: %d
", err);
+			return err;
+		}
+		err = vl53l1x_prx_update_timing_budget(cdata, cdata->poll_interval); /* in ms possible values [20, 50, 100, 200, 500] */
+		if (err < 0) {
+			dev_err(cdata->dev, "set timing budget failed: %d
", err);
+			return err;
+		}
+		err = vl53l1x_prx_update_inter_measurement(cdata, cdata->poll_interval); /* in ms, IM must be > = TB */
+		if (err < 0) {
+			dev_err(cdata->dev, "set inter measurement failed: %d
", err);
+			return err;
+		}
+
+		err = VL53L1X_StartRanging(client);
+		if (err < 0) {
+			pr_info("%s: VL53L1X_StartRanging returns failure with err = %d
", __func__, err);
+			return err;
+		}
+		else {
+			pr_info("%s: VL53L1X_StartRanging sucessfully.
", __func__);
+		}
+
+		schedule_delayed_work(&cdata->input_work,
+				      msecs_to_jiffies(cdata->poll_interval));
+
+		mutex_unlock(&cdata->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(vl53l1x_prx_enable);
+
+int vl53l1x_prx_disable(struct vl53l1x_data *cdata)
+{
+	pr_info("%s
", __func__);
+	if (atomic_cmpxchg(&cdata->enabled, 1, 0)) {
+
+		cancel_delayed_work_sync(&cdata->input_work);
+
+		mutex_lock(&cdata->lock);
+		vl53l1x_prx_device_power_off(cdata);
+		mutex_unlock(&cdata->lock);
+	}
+
+	return 0;
+}
+EXPORT_SYMBOL(vl53l1x_prx_disable);
+
+static ssize_t attr_get_sched_num_prx(struct device *dev,
+				      struct device_attribute *attr, char *buf)
+{
+	int val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	val = cdata->schedule_num;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", val);
+}
+
+static ssize_t attr_set_sched_num_prx(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t size)
+{
+	unsigned long sched_num;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &sched_num))
+		return -EINVAL;
+
+	mutex_lock(&cdata->lock);
+	cdata->schedule_num = sched_num;
+	mutex_unlock(&cdata->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_polling_rate_prx(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	int val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	pr_info("%s
", __func__);
+	mutex_lock(&cdata->lock);
+	val = cdata->poll_interval;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", val);
+}
+
+static ssize_t attr_set_polling_rate_prx(struct device *dev,
+					 struct device_attribute *attr,
+					 const char *buf, size_t size)
+{
+	int i;
+	unsigned long interval_ms;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	pr_info("%s
", __func__);
+	if (kstrtoul(buf, 10, &interval_ms))
+		return -EINVAL;
+
+	if (!interval_ms)
+		return -EINVAL;
+
+	interval_ms = max_t(unsigned int, (unsigned int)interval_ms,
+			    cdata->min_interval);
+
+	pr_info("%s: interval_ms = %lu
", __func__, interval_ms);
+	for (i = ARRAY_SIZE(vl53l1x_odr_table) - 1; i >= 0; i--) {
+		if ((vl53l1x_odr_table[i].time_ms <= interval_ms) || (i == 0))
+			break;
+	}
+	mutex_lock(&cdata->lock);
+	cdata->poll_interval = vl53l1x_odr_table[i].tb;
+	mutex_unlock(&cdata->lock);
+
+	return size;
+}
+
+static ssize_t attr_get_opmode_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	char opmode;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	opmode = cdata->opmode;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", opmode);
+}
+
+static ssize_t attr_set_opmode_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 opmode;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid opmode */
+	switch (val) {
+	case VL53L1X_PRX_OPMODE_SHORT:
+	case VL53L1X_PRX_OPMODE_LONG:
+		opmode = val;
+		break;
+	default:
+		dev_err(cdata->dev,
+			"invalid range request: %lu, discarded
", val);
+		return -EINVAL;
+	}
+
+	pr_info("%s: opmode = %u
", __func__, opmode);
+	mutex_lock(&cdata->lock);
+	err = vl53l1x_prx_update_opmode(cdata, opmode);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "opmode set to: %u
", opmode);
+
+	return size;
+}
+
+static ssize_t attr_get_enable_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	int val = atomic_read(&cdata->enabled);
+
+	return sprintf(buf, "%d
", val);
+}
+
+static ssize_t attr_set_enable_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	unsigned long val;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	pr_info("%s: enable = %lu
", __func__, val);
+	if (val)
+		vl53l1x_prx_enable(cdata);
+	else
+		vl53l1x_prx_disable(cdata);
+
+	return size;
+}
+
+static ssize_t attr_get_timing_budget_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	u16 timing_budget;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	timing_budget = cdata->timing_budget;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", timing_budget);
+}
+
+static ssize_t attr_set_timing_budget_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 timing_budget;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid timing budget */
+	switch (val) {
+	case VL53L1X_PRX_TIMING_BUDGET_15_MS:
+	case VL53L1X_PRX_TIMING_BUDGET_20_MS:
+	case VL53L1X_PRX_TIMING_BUDGET_33_MS:
+	case VL53L1X_PRX_TIMING_BUDGET_50_MS:
+	case VL53L1X_PRX_TIMING_BUDGET_100_MS:
+	case VL53L1X_PRX_TIMING_BUDGET_200_MS:
+	case VL53L1X_PRX_TIMING_BUDGET_500_MS:
+		timing_budget = val;
+		break;
+	default:
+		dev_err(cdata->dev,
+			"invalid timing budget request: %lu, discarded
", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = vl53l1x_prx_update_timing_budget(cdata, timing_budget); /* in ms possible values [20, 50, 100, 200, 500] */
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "timing_budget set to: %u ms
", timing_budget);
+
+	return size;
+}
+
+static ssize_t attr_get_inter_measurement_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	u16 inter_measurement;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	mutex_lock(&cdata->lock);
+	inter_measurement = cdata->inter_measurement;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", inter_measurement);
+}
+
+static ssize_t attr_set_inter_measurement_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 inter_measurement;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid inter measurement */
+	if (val >= cdata->timing_budget) {
+		inter_measurement = val;
+	}
+	else {
+		dev_err(cdata->dev,
+			"invalid inter measurement request: %lu, discarded
", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = vl53l1x_prx_update_inter_measurement(cdata, inter_measurement); /* in ms, IM must be > = TB */
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "inter_measurement set to: %u ms
", inter_measurement);
+
+	return size;
+}
+
+static ssize_t attr_get_roi_center_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	u8 roi_center;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	mutex_lock(&cdata->lock);
+//	roi_center = cdata->roi_center;
+	err = VL53L1X_GetROICenter(client, &roi_center);
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", roi_center);
+}
+
+static ssize_t attr_set_roi_center_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u8 roi_center;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid ROI center */
+	if (val < 256) {
+		roi_center = (u8)val;
+	}
+	else {
+		dev_err(cdata->dev,
+			"invalid ROI center request: %lu, discarded
", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = vl53l1x_prx_update_roi_center(cdata, roi_center);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "roi_center set to: %u
", roi_center);
+
+	return size;
+}
+
+static ssize_t attr_get_roi_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	u16 x_width, y_height;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	mutex_lock(&cdata->lock);
+//	roi_center = cdata->roi_center;
+	err = VL53L1X_GetROI_XY(client, &x_width, &y_height);
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d,%d
", x_width, y_height);
+}
+
+static ssize_t attr_set_roi_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 x_width, y_height;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	char *delim = ",";		// Comma
+	char *running;
+	char *pch;
+	char strdupa[64];
+
+	strncpy(strdupa, buf, size);
+	running = strdupa;
+	pch = strsep(&running, delim);		// use strsep instead of strtok in kernel
+	val = simple_strtol(pch, NULL, 10);	// P3:base
+        x_width = (u16)val;
+	if (running == NULL) {
+		dev_err(cdata->dev,
+			"no ROI height, discarded
");
+		return -EINVAL;
+	}
+	else if (running != NULL) {
+		pch = strsep(&running, delim);
+		val = simple_strtol(pch, NULL, 10);	// P3:base
+		y_height = (u16)val;
+	}
+
+	if (running != NULL) {
+		dev_err(cdata->dev,
+			"too many ROI values, extra discarded
");
+	}
+
+	/* Check if argument is valid ROI width/height */
+	if ((x_width > 16) || (x_width < 4) ||
+	    (y_height > 16) || (y_height < 4)) {
+		dev_err(cdata->dev,
+			"invalid ROI width/height request: %u/%u, discarded
", x_width, x_width);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = vl53l1x_prx_update_roi(cdata, x_width, y_height);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "ROI XY set to: %u/%u
", x_width, y_height);
+
+	return size;
+}
+
+static ssize_t attr_get_distance_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	int err;
+	int distance = 0;
+
+	mutex_lock(&cdata->lock);
+	err = vl53l1x_prx_get_distance_data(cdata, &distance);
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", distance);
+}
+
+/* calibration related */
+static ssize_t attr_get_offset_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	s16 offset;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	mutex_lock(&cdata->lock);
+	err = VL53L1X_GetOffset(client, &offset);
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", offset);
+}
+
+static ssize_t attr_set_offset_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	s16 offset;
+	long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	struct i2c_client *client = cdata->client;
+
+	if (kstrtol(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid offset */
+	offset = (s16)val;
+
+	mutex_lock(&cdata->lock);
+	err = VL53L1X_SetOffset(client, offset);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "offset set to: %d
", offset);
+
+	return size;
+}
+
+static ssize_t attr_get_xtalk_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	u16 xtalk;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	int err;
+	struct i2c_client *client = cdata->client;
+
+	mutex_lock(&cdata->lock);
+	err = VL53L1X_GetXtalk(client, &xtalk);
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", xtalk);
+}
+
+static ssize_t attr_set_xtalk_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 xtalk;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	struct i2c_client *client = cdata->client;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid xtalk */
+	xtalk = (u16)val;
+
+	mutex_lock(&cdata->lock);
+	err = VL53L1X_SetXtalk(client, xtalk);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "xtalk set to: %d
", xtalk);
+
+	return size;
+}
+
+static ssize_t attr_get_cal_off_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	s16 offset;
+
+	mutex_lock(&cdata->lock);
+	offset = cdata->calibration_offset;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", offset);
+}
+
+static ssize_t attr_set_cal_off_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 target_distance;
+	s16 offset;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	struct i2c_client *client = cdata->client;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid calibration distance */
+	if (val == 140) {
+		target_distance = (u16)val;
+	}
+	else {
+		dev_err(cdata->dev,
+			"invalid offset calibration distance request: %lu, discarded
", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = VL53L1X_CalibrateOffset(client, target_distance, &offset);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	cdata->calibration_offset = offset;
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "calibration offset done with offset: %d
", offset);
+
+	return size;
+}
+
+static ssize_t attr_get_calibration_xtalk_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   char *buf)
+{
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	u16 xtalk;
+
+	mutex_lock(&cdata->lock);
+	xtalk = cdata->calibration_xtalk;
+	mutex_unlock(&cdata->lock);
+
+	return sprintf(buf, "%d
", xtalk);
+}
+
+static ssize_t attr_set_calibration_xtalk_prx(struct device *dev,
+				   struct device_attribute *attr,
+				   const char *buf, size_t size)
+{
+	int err;
+	u16 target_distance;
+	u16 xtalk;
+	unsigned long val;
+	struct vl53l1x_data *cdata = dev_get_drvdata(dev);
+	struct i2c_client *client = cdata->client;
+
+	if (kstrtoul(buf, 10, &val))
+		return -EINVAL;
+
+	/* Check if argument is valid calibration distance */
+	if (val < 300) {
+		target_distance = (u16)val;
+	}
+	else {
+		dev_err(cdata->dev,
+			"invalid xtalk calibration distance request: %lu, discarded
", val);
+		return -EINVAL;
+	}
+
+	mutex_lock(&cdata->lock);
+	err = VL53L1X_CalibrateXtalk(client, target_distance, &xtalk);
+	if (err < 0) {
+		mutex_unlock(&cdata->lock);
+		return err;
+	}
+	cdata->calibration_xtalk = xtalk;
+	mutex_unlock(&cdata->lock);
+
+	dev_info(cdata->dev, "calibration xtalk done with xtalk: %u
", xtalk);
+
+	return size;
+}
+
+static struct device_attribute attributes[] = {
+	__ATTR(pollrate_ms,   0664, attr_get_polling_rate_prx,     attr_set_polling_rate_prx),
+	__ATTR(opmode,        0664, attr_get_opmode_prx,           attr_set_opmode_prx),
+	__ATTR(enable_device, 0664, attr_get_enable_prx,           attr_set_enable_prx),
+	__ATTR(timing_budget, 0664, attr_get_timing_budget_prx,    attr_set_timing_budget_prx),
+	__ATTR(imp,           0664, attr_get_inter_measurement_prx, attr_set_inter_measurement_prx),
+	__ATTR(roi_center,    0664, attr_get_roi_center_prx,       attr_set_roi_center_prx),
+	__ATTR(roi,           0664, attr_get_roi_prx,              attr_set_roi_prx),
+	__ATTR(dist,          0444, attr_get_distance_prx,         NULL),
+
+	/* calibration related */ /* ToDo: to be verified */
+	__ATTR(offset,        0664, attr_get_offset_prx,           attr_set_offset_prx),
+	__ATTR(xtalk,         0664, attr_get_xtalk_prx,            attr_set_xtalk_prx),
+	__ATTR(cal_off,       0664, attr_get_cal_off_prx,          attr_set_cal_off_prx),
+	__ATTR(cal_xtalk,     0664, attr_get_calibration_xtalk_prx, attr_set_calibration_xtalk_prx),
+
+	__ATTR(schedule_num,  0664, attr_get_sched_num_prx,        attr_set_sched_num_prx),
+};
+
+static int create_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		if (device_create_file(dev, attributes + i))
+			goto error;
+	return 0;
+
+error:
+	for (; i >= 0; i--)
+		device_remove_file(dev, attributes + i);
+
+	dev_err(dev, "%s:Unable to create interface
", __func__);
+
+	return -1;
+}
+
+static int remove_sysfs_interfaces(struct device *dev)
+{
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(attributes); i++)
+		device_remove_file(dev, attributes + i);
+
+	return 0;
+}
+
+static void vl53l1x_prx_input_work_func(struct work_struct *work)
+{
+	struct vl53l1x_data *cdata;
+	int err;
+	int distance = 0;
+
+	cdata = container_of((struct delayed_work *)work,
+			     struct vl53l1x_data, input_work);
+
+	mutex_lock(&cdata->lock);
+	cdata->schedule_num++;
+	err = vl53l1x_prx_get_distance_data(cdata, &distance);
+	if (err < 0)
+		dev_err(cdata->dev, "get_distance_data failed
");
+	else {
+		distance /= 10;
+		vl53l1x_prx_report_values(cdata, distance, vl53l1x_get_time_ns());
+//		pr_info("%s: distance = %d
", __func__, distance);
+	}
+
+	schedule_delayed_work(&cdata->input_work, msecs_to_jiffies(
+			      cdata->poll_interval));
+	mutex_unlock(&cdata->lock);
+}
+
+static void vl53l1x_prx_input_cleanup(struct vl53l1x_data *cdata)
+{
+	input_unregister_device(cdata->input_dev);
+	input_free_device(cdata->input_dev);
+}
+
+int vl53l1x_prx_probe(struct vl53l1x_data *cdata)
+{
+	int err;
+#if 0 //test
+	uint16_t distance;
+#endif
+
+	mutex_lock(&cdata->lock);
+	cdata->poll_interval = 100;
+	cdata->min_interval = VL53L1X_PRX_MIN_POLL_PERIOD_MS;
+
+	err = vl53l1x_prx_device_power_on(cdata);
+	if (err < 0) {
+		dev_err(cdata->dev, "power on failed: %d
", err);
+		goto  err_power_off;
+	}
+
+	atomic_set(&cdata->enabled, 1);
+
+	/* Set parameters */
+	/* Optional functions to be used to change the main ranging parameters according the application requirements to get the best ranging performances */
+	err = vl53l1x_prx_update_opmode(cdata, VL53L1X_PRX_OPMODE_LONG); /* 1=short, 2=long */
+	if (err < 0) {
+		dev_err(cdata->dev, "set distance mode failed: %d
", err);
+		goto  err_power_off;
+	}
+
+	err = vl53l1x_prx_update_timing_budget(cdata, VL53L1X_PRX_TIMING_BUDGET_100_MS); /* in ms possible values [20, 50, 100, 200, 500] */
+	if (err < 0) {
+		dev_err(cdata->dev, "set timing budget failed: %d
", err);
+		goto  err_power_off;
+	}
+	err = vl53l1x_prx_update_inter_measurement(cdata, 100); /* in ms, IM must be > = TB */
+	if (err < 0) {
+		dev_err(cdata->dev, "set inter measurement failed: %d
", err);
+		goto  err_power_off;
+	}
+	
+
+	err = vl53l1x_prx_input_init(cdata, VL53L1X_PRX_DEV_NAME);
+	if (err < 0) {
+		dev_err(cdata->dev, "input init failed
");
+		goto err_power_off;
+	}
+	INIT_DELAYED_WORK(&cdata->input_work, vl53l1x_prx_input_work_func);
+
+
+	err = create_sysfs_interfaces(cdata->dev);
+	if (err < 0) {
+		dev_err(cdata->dev,
+		   "device VL53L1X_PRX_DEV_NAME sysfs register failed
");
+		goto err_input_cleanup;
+	}
+
+
+	vl53l1x_prx_device_power_off(cdata);
+#if 0
+	err = VL53L1X_GetDistance(client, (uint16_t *)&distance);
+	pr_info("%s: distance = %d
", __func__, distance);
+#endif
+
+	/* As default, do not report information */
+	atomic_set(&cdata->enabled, 0);
+
+	dev_info(cdata->dev, "%s: probed
", VL53L1X_PRX_DEV_NAME);
+
+	mutex_unlock(&cdata->lock);
+
+	return 0;
+
+err_input_cleanup:
+	vl53l1x_prx_input_cleanup(cdata);
+err_power_off:
+	vl53l1x_prx_device_power_off(cdata);
+	mutex_unlock(&cdata->lock);
+	pr_err("%s: Driver Init failed
", VL53L1X_PRX_DEV_NAME);
+
+	return err;
+}
+
+void vl53l1x_prx_remove(struct vl53l1x_data *cdata)
+{
+	vl53l1x_prx_disable(cdata);
+	vl53l1x_prx_input_cleanup(cdata);
+	remove_sysfs_interfaces(cdata->dev);
+}
+
+static int vl53l1x_probe(struct i2c_client *client, const struct i2c_device_id *id)
+{
+	int err;
+	struct vl53l1x_data *cdata;
+
+	/* Alloc Common data structure */
+	cdata = kzalloc(sizeof(struct vl53l1x_data), GFP_KERNEL);
+	if (!cdata) {
+		dev_err(&client->dev, "failed to allocate module data
");
+		return -ENOMEM;
+	}
+
+	cdata->sensor_num = 1;
+	cdata->dev = &client->dev;
+	cdata->name = client->name;
+	cdata->bus_type = BUS_I2C;
+
+	cdata->client = client;
+
+	i2c_set_clientdata(client, cdata);
+
+	mutex_init(&cdata->lock);
+
+	err = vl53l1x_prx_probe(cdata);
+	if (err < 0) {
+		kfree(cdata);
+
+		return err;
+	}
+
+	return 0;
+}
+
+int vl53l1x_remove(struct i2c_client *client)
+{
+	struct vl53l1x_data *cdata = i2c_get_clientdata(client);
+
+	dev_info(cdata->dev, "driver removing
");
+
+	vl53l1x_prx_remove(cdata);
+	kfree(cdata);
+
+	return 0;
+}
+
+static const struct of_device_id st_vl53l1x_dt_match[] = {
+	{ .compatible = "st,vl53l1x", },
+	{ }
+};
+MODULE_DEVICE_TABLE(of, st_vl53l1x_dt_match);
+
+static const struct i2c_device_id vl53l1x_prx_i2c_id[] = {
+	{ "vl53l1x_prx", 0 },
+	{ },
+};
+MODULE_DEVICE_TABLE(i2c, lsm303agr_acc_i2c_id);
+
+static struct i2c_driver vl53l1x_driver = {
+	.driver = {
+		.owner = THIS_MODULE,
+		.name = "vl53l1x-i2c",
+#ifdef CONFIG_OF
+		.of_match_table = st_vl53l1x_dt_match,
+#endif /* CONFIG_OF */
+	},
+	.probe = vl53l1x_probe,
+	.remove = vl53l1x_remove,
+	.id_table = vl53l1x_prx_i2c_id,
+};
+module_i2c_driver(vl53l1x_driver);
+
+
+
+MODULE_AUTHOR("Song Qiang <songqiang1304521@gmail.com>");
+MODULE_DESCRIPTION("ST vl53l1x ToF ranging sensor driver");
+MODULE_LICENSE("GPL v2");
\ No newline at end of file
