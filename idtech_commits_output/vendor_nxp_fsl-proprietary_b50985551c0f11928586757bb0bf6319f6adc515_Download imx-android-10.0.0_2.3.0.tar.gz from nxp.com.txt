b509855 jenkins 2020-07-17

Download imx-android-10.0.0_2.3.0.tar.gz from nxp.com

Change-Id: I75791da93d21dbe297e2b0e98868acd807c91e29

diff --git a/dynamic_partiton_tools/LICENSE b/dynamic_partiton_tools/LICENSE
new file mode 100644
index 0000000..d645695
--- /dev/null
+++ b/dynamic_partiton_tools/LICENSE
@@ -0,0 +1,202 @@
+
+                                 Apache License
+                           Version 2.0, January 2004
+                        http://www.apache.org/licenses/
+
+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION
+
+   1. Definitions.
+
+      "License" shall mean the terms and conditions for use, reproduction,
+      and distribution as defined by Sections 1 through 9 of this document.
+
+      "Licensor" shall mean the copyright owner or entity authorized by
+      the copyright owner that is granting the License.
+
+      "Legal Entity" shall mean the union of the acting entity and all
+      other entities that control, are controlled by, or are under common
+      control with that entity. For the purposes of this definition,
+      "control" means (i) the power, direct or indirect, to cause the
+      direction or management of such entity, whether by contract or
+      otherwise, or (ii) ownership of fifty percent (50%) or more of the
+      outstanding shares, or (iii) beneficial ownership of such entity.
+
+      "You" (or "Your") shall mean an individual or Legal Entity
+      exercising permissions granted by this License.
+
+      "Source" form shall mean the preferred form for making modifications,
+      including but not limited to software source code, documentation
+      source, and configuration files.
+
+      "Object" form shall mean any form resulting from mechanical
+      transformation or translation of a Source form, including but
+      not limited to compiled object code, generated documentation,
+      and conversions to other media types.
+
+      "Work" shall mean the work of authorship, whether in Source or
+      Object form, made available under the License, as indicated by a
+      copyright notice that is included in or attached to the work
+      (an example is provided in the Appendix below).
+
+      "Derivative Works" shall mean any work, whether in Source or Object
+      form, that is based on (or derived from) the Work and for which the
+      editorial revisions, annotations, elaborations, or other modifications
+      represent, as a whole, an original work of authorship. For the purposes
+      of this License, Derivative Works shall not include works that remain
+      separable from, or merely link (or bind by name) to the interfaces of,
+      the Work and Derivative Works thereof.
+
+      "Contribution" shall mean any work of authorship, including
+      the original version of the Work and any modifications or additions
+      to that Work or Derivative Works thereof, that is intentionally
+      submitted to Licensor for inclusion in the Work by the copyright owner
+      or by an individual or Legal Entity authorized to submit on behalf of
+      the copyright owner. For the purposes of this definition, "submitted"
+      means any form of electronic, verbal, or written communication sent
+      to the Licensor or its representatives, including but not limited to
+      communication on electronic mailing lists, source code control systems,
+      and issue tracking systems that are managed by, or on behalf of, the
+      Licensor for the purpose of discussing and improving the Work, but
+      excluding communication that is conspicuously marked or otherwise
+      designated in writing by the copyright owner as "Not a Contribution."
+
+      "Contributor" shall mean Licensor and any individual or Legal Entity
+      on behalf of whom a Contribution has been received by Licensor and
+      subsequently incorporated within the Work.
+
+   2. Grant of Copyright License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      copyright license to reproduce, prepare Derivative Works of,
+      publicly display, publicly perform, sublicense, and distribute the
+      Work and such Derivative Works in Source or Object form.
+
+   3. Grant of Patent License. Subject to the terms and conditions of
+      this License, each Contributor hereby grants to You a perpetual,
+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
+      (except as stated in this section) patent license to make, have made,
+      use, offer to sell, sell, import, and otherwise transfer the Work,
+      where such license applies only to those patent claims licensable
+      by such Contributor that are necessarily infringed by their
+      Contribution(s) alone or by combination of their Contribution(s)
+      with the Work to which such Contribution(s) was submitted. If You
+      institute patent litigation against any entity (including a
+      cross-claim or counterclaim in a lawsuit) alleging that the Work
+      or a Contribution incorporated within the Work constitutes direct
+      or contributory patent infringement, then any patent licenses
+      granted to You under this License for that Work shall terminate
+      as of the date such litigation is filed.
+
+   4. Redistribution. You may reproduce and distribute copies of the
+      Work or Derivative Works thereof in any medium, with or without
+      modifications, and in Source or Object form, provided that You
+      meet the following conditions:
+
+      (a) You must give any other recipients of the Work or
+          Derivative Works a copy of this License; and
+
+      (b) You must cause any modified files to carry prominent notices
+          stating that You changed the files; and
+
+      (c) You must retain, in the Source form of any Derivative Works
+          that You distribute, all copyright, patent, trademark, and
+          attribution notices from the Source form of the Work,
+          excluding those notices that do not pertain to any part of
+          the Derivative Works; and
+
+      (d) If the Work includes a "NOTICE" text file as part of its
+          distribution, then any Derivative Works that You distribute must
+          include a readable copy of the attribution notices contained
+          within such NOTICE file, excluding those notices that do not
+          pertain to any part of the Derivative Works, in at least one
+          of the following places: within a NOTICE text file distributed
+          as part of the Derivative Works; within the Source form or
+          documentation, if provided along with the Derivative Works; or,
+          within a display generated by the Derivative Works, if and
+          wherever such third-party notices normally appear. The contents
+          of the NOTICE file are for informational purposes only and
+          do not modify the License. You may add Your own attribution
+          notices within Derivative Works that You distribute, alongside
+          or as an addendum to the NOTICE text from the Work, provided
+          that such additional attribution notices cannot be construed
+          as modifying the License.
+
+      You may add Your own copyright statement to Your modifications and
+      may provide additional or different license terms and conditions
+      for use, reproduction, or distribution of Your modifications, or
+      for any such Derivative Works as a whole, provided Your use,
+      reproduction, and distribution of the Work otherwise complies with
+      the conditions stated in this License.
+
+   5. Submission of Contributions. Unless You explicitly state otherwise,
+      any Contribution intentionally submitted for inclusion in the Work
+      by You to the Licensor shall be under the terms and conditions of
+      this License, without any additional terms or conditions.
+      Notwithstanding the above, nothing herein shall supersede or modify
+      the terms of any separate license agreement you may have executed
+      with Licensor regarding such Contributions.
+
+   6. Trademarks. This License does not grant permission to use the trade
+      names, trademarks, service marks, or product names of the Licensor,
+      except as required for reasonable and customary use in describing the
+      origin of the Work and reproducing the content of the NOTICE file.
+
+   7. Disclaimer of Warranty. Unless required by applicable law or
+      agreed to in writing, Licensor provides the Work (and each
+      Contributor provides its Contributions) on an "AS IS" BASIS,
+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
+      implied, including, without limitation, any warranties or conditions
+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
+      PARTICULAR PURPOSE. You are solely responsible for determining the
+      appropriateness of using or redistributing the Work and assume any
+      risks associated with Your exercise of permissions under this License.
+
+   8. Limitation of Liability. In no event and under no legal theory,
+      whether in tort (including negligence), contract, or otherwise,
+      unless required by applicable law (such as deliberate and grossly
+      negligent acts) or agreed to in writing, shall any Contributor be
+      liable to You for damages, including any direct, indirect, special,
+      incidental, or consequential damages of any character arising as a
+      result of this License or out of the use or inability to use the
+      Work (including but not limited to damages for loss of goodwill,
+      work stoppage, computer failure or malfunction, or any and all
+      other commercial damages or losses), even if such Contributor
+      has been advised of the possibility of such damages.
+
+   9. Accepting Warranty or Additional Liability. While redistributing
+      the Work or Derivative Works thereof, You may choose to offer,
+      and charge a fee for, acceptance of support, warranty, indemnity,
+      or other liability obligations and/or rights consistent with this
+      License. However, in accepting such obligations, You may act only
+      on Your own behalf and on Your sole responsibility, not on behalf
+      of any other Contributor, and only if You agree to indemnify,
+      defend, and hold each Contributor harmless for any liability
+      incurred by, or claims asserted against, such Contributor by reason
+      of your accepting any such warranty or additional liability.
+
+   END OF TERMS AND CONDITIONS
+
+   APPENDIX: How to apply the Apache License to your work.
+
+      To apply the Apache License to your work, attach the following
+      boilerplate notice, with the fields enclosed by brackets "[]"
+      replaced with your own identifying information. (Don't include
+      the brackets!)  The text should be enclosed in the appropriate
+      comment syntax for the file format. We also recommend that a
+      file or class name and description of purpose be included on the
+      same "printed page" as the copyright notice for easier
+      identification within third-party archives.
+
+   Copyright [yyyy] [name of copyright owner]
+
+   Licensed under the Apache License, Version 2.0 (the "License");
+   you may not use this file except in compliance with the License.
+   You may obtain a copy of the License at
+
+       http://www.apache.org/licenses/LICENSE-2.0
+
+   Unless required by applicable law or agreed to in writing, software
+   distributed under the License is distributed on an "AS IS" BASIS,
+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+   See the License for the specific language governing permissions and
+   limitations under the License.
diff --git a/fsl-dpu/lib/libg2d-dpu.so b/fsl-dpu/lib/libg2d-dpu.so
index d019dc9..5630f72 100755
Binary files a/fsl-dpu/lib/libg2d-dpu.so and b/fsl-dpu/lib/libg2d-dpu.so differ
diff --git a/fsl-dpu/lib64/libg2d-dpu.so b/fsl-dpu/lib64/libg2d-dpu.so
index 0399f5b..494b73f 100755
Binary files a/fsl-dpu/lib64/libg2d-dpu.so and b/fsl-dpu/lib64/libg2d-dpu.so differ
diff --git a/gpu-viv/lib/egl/libEGL_VIVANTE.so b/gpu-viv/lib/egl/libEGL_VIVANTE.so
index f20ec32..06eace7 100644
Binary files a/gpu-viv/lib/egl/libEGL_VIVANTE.so and b/gpu-viv/lib/egl/libEGL_VIVANTE.so differ
diff --git a/gpu-viv/lib/egl/libGLESv1_CM_VIVANTE.so b/gpu-viv/lib/egl/libGLESv1_CM_VIVANTE.so
index e072d65..2a37557 100644
Binary files a/gpu-viv/lib/egl/libGLESv1_CM_VIVANTE.so and b/gpu-viv/lib/egl/libGLESv1_CM_VIVANTE.so differ
diff --git a/gpu-viv/lib/egl/libGLESv2_VIVANTE.so b/gpu-viv/lib/egl/libGLESv2_VIVANTE.so
index 0d3dd44..a598a23 100644
Binary files a/gpu-viv/lib/egl/libGLESv2_VIVANTE.so and b/gpu-viv/lib/egl/libGLESv2_VIVANTE.so differ
diff --git a/gpu-viv/lib/hw/gralloc_viv.imx.so b/gpu-viv/lib/hw/gralloc_viv.imx.so
index 954d301..541d8b5 100644
Binary files a/gpu-viv/lib/hw/gralloc_viv.imx.so and b/gpu-viv/lib/hw/gralloc_viv.imx.so differ
diff --git a/gpu-viv/lib/hw/hwcomposer_viv.imx.so b/gpu-viv/lib/hw/hwcomposer_viv.imx.so
index bfd6e49..286c767 100644
Binary files a/gpu-viv/lib/hw/hwcomposer_viv.imx.so and b/gpu-viv/lib/hw/hwcomposer_viv.imx.so differ
diff --git a/gpu-viv/lib/libCLC.so b/gpu-viv/lib/libCLC.so
index 464bc54..599b304 100644
Binary files a/gpu-viv/lib/libCLC.so and b/gpu-viv/lib/libCLC.so differ
diff --git a/gpu-viv/lib/libGAL.so b/gpu-viv/lib/libGAL.so
index e290331..f7748d3 100644
Binary files a/gpu-viv/lib/libGAL.so and b/gpu-viv/lib/libGAL.so differ
diff --git a/gpu-viv/lib/libGLSLC.so b/gpu-viv/lib/libGLSLC.so
index 91e0b58..d43bff9 100644
Binary files a/gpu-viv/lib/libGLSLC.so and b/gpu-viv/lib/libGLSLC.so differ
diff --git a/gpu-viv/lib/libNNGPUBinary-evis.so b/gpu-viv/lib/libNNGPUBinary-evis.so
index 7d9f2a5..55c2894 100755
Binary files a/gpu-viv/lib/libNNGPUBinary-evis.so and b/gpu-viv/lib/libNNGPUBinary-evis.so differ
diff --git a/gpu-viv/lib/libNNGPUBinary-evis2.so b/gpu-viv/lib/libNNGPUBinary-evis2.so
index d37d6a5..608e906 100755
Binary files a/gpu-viv/lib/libNNGPUBinary-evis2.so and b/gpu-viv/lib/libNNGPUBinary-evis2.so differ
diff --git a/gpu-viv/lib/libNNGPUBinary-lite.so b/gpu-viv/lib/libNNGPUBinary-lite.so
index c566b71..ff587db 100755
Binary files a/gpu-viv/lib/libNNGPUBinary-lite.so and b/gpu-viv/lib/libNNGPUBinary-lite.so differ
diff --git a/gpu-viv/lib/libNNGPUBinary-ulite.so b/gpu-viv/lib/libNNGPUBinary-ulite.so
index 41cd6fa..561cdcd 100755
Binary files a/gpu-viv/lib/libNNGPUBinary-ulite.so and b/gpu-viv/lib/libNNGPUBinary-ulite.so differ
diff --git a/gpu-viv/lib/libNNVXCBinary-evis.so b/gpu-viv/lib/libNNVXCBinary-evis.so
index e06d7f2..74211c0 100755
Binary files a/gpu-viv/lib/libNNVXCBinary-evis.so and b/gpu-viv/lib/libNNVXCBinary-evis.so differ
diff --git a/gpu-viv/lib/libNNVXCBinary-evis2.so b/gpu-viv/lib/libNNVXCBinary-evis2.so
index 5ffddf8..4360e65 100755
Binary files a/gpu-viv/lib/libNNVXCBinary-evis2.so and b/gpu-viv/lib/libNNVXCBinary-evis2.so differ
diff --git a/gpu-viv/lib/libOpenCL.so b/gpu-viv/lib/libOpenCL.so
index db5d176..557dc77 100644
Binary files a/gpu-viv/lib/libOpenCL.so and b/gpu-viv/lib/libOpenCL.so differ
diff --git a/gpu-viv/lib/libOpenVX.so b/gpu-viv/lib/libOpenVX.so
index f69957a..75b1a98 100755
Binary files a/gpu-viv/lib/libOpenVX.so and b/gpu-viv/lib/libOpenVX.so differ
diff --git a/gpu-viv/lib/libOpenVXU.so b/gpu-viv/lib/libOpenVXU.so
index d3c440a..f0fbc91 100755
Binary files a/gpu-viv/lib/libOpenVXU.so and b/gpu-viv/lib/libOpenVXU.so differ
diff --git a/gpu-viv/lib/libOvx12VXCBinary-evis.so b/gpu-viv/lib/libOvx12VXCBinary-evis.so
index 8a0a948..7f08868 100755
Binary files a/gpu-viv/lib/libOvx12VXCBinary-evis.so and b/gpu-viv/lib/libOvx12VXCBinary-evis.so differ
diff --git a/gpu-viv/lib/libOvx12VXCBinary-evis2.so b/gpu-viv/lib/libOvx12VXCBinary-evis2.so
index 2c0262d..058a469 100755
Binary files a/gpu-viv/lib/libOvx12VXCBinary-evis2.so and b/gpu-viv/lib/libOvx12VXCBinary-evis2.so differ
diff --git a/gpu-viv/lib/libSPIRV_viv.so b/gpu-viv/lib/libSPIRV_viv.so
index 5421789..2fd3ff3 100644
Binary files a/gpu-viv/lib/libSPIRV_viv.so and b/gpu-viv/lib/libSPIRV_viv.so differ
diff --git a/gpu-viv/lib/libVSC.so b/gpu-viv/lib/libVSC.so
index 245bd3f..31bd7cb 100644
Binary files a/gpu-viv/lib/libVSC.so and b/gpu-viv/lib/libVSC.so differ
diff --git a/gpu-viv/lib/libg2d-viv.so b/gpu-viv/lib/libg2d-viv.so
index a154579..b8a15a5 100644
Binary files a/gpu-viv/lib/libg2d-viv.so and b/gpu-viv/lib/libg2d-viv.so differ
diff --git a/gpu-viv/lib/libgpuhelper.so b/gpu-viv/lib/libgpuhelper.so
index ce8513d..39ca56c 100644
Binary files a/gpu-viv/lib/libgpuhelper.so and b/gpu-viv/lib/libgpuhelper.so differ
diff --git a/gpu-viv/lib/libvulkan_VIVANTE.so b/gpu-viv/lib/libvulkan_VIVANTE.so
index fd915bd..9192fde 100644
Binary files a/gpu-viv/lib/libvulkan_VIVANTE.so and b/gpu-viv/lib/libvulkan_VIVANTE.so differ
diff --git a/gpu-viv/lib64/egl/libEGL_VIVANTE.so b/gpu-viv/lib64/egl/libEGL_VIVANTE.so
index 4ce0d9d..f87c0a6 100644
Binary files a/gpu-viv/lib64/egl/libEGL_VIVANTE.so and b/gpu-viv/lib64/egl/libEGL_VIVANTE.so differ
diff --git a/gpu-viv/lib64/egl/libGLESv1_CM_VIVANTE.so b/gpu-viv/lib64/egl/libGLESv1_CM_VIVANTE.so
index d1a3312..98b93c5 100644
Binary files a/gpu-viv/lib64/egl/libGLESv1_CM_VIVANTE.so and b/gpu-viv/lib64/egl/libGLESv1_CM_VIVANTE.so differ
diff --git a/gpu-viv/lib64/egl/libGLESv2_VIVANTE.so b/gpu-viv/lib64/egl/libGLESv2_VIVANTE.so
index bafa874..d6c7c80 100644
Binary files a/gpu-viv/lib64/egl/libGLESv2_VIVANTE.so and b/gpu-viv/lib64/egl/libGLESv2_VIVANTE.so differ
diff --git a/gpu-viv/lib64/hw/gralloc_viv.imx.so b/gpu-viv/lib64/hw/gralloc_viv.imx.so
index c0a9b5e..0e6a8c9 100644
Binary files a/gpu-viv/lib64/hw/gralloc_viv.imx.so and b/gpu-viv/lib64/hw/gralloc_viv.imx.so differ
diff --git a/gpu-viv/lib64/hw/hwcomposer_viv.imx.so b/gpu-viv/lib64/hw/hwcomposer_viv.imx.so
index c1e2b66..fb5b781 100644
Binary files a/gpu-viv/lib64/hw/hwcomposer_viv.imx.so and b/gpu-viv/lib64/hw/hwcomposer_viv.imx.so differ
diff --git a/gpu-viv/lib64/libCLC.so b/gpu-viv/lib64/libCLC.so
index a8929c9..de67701 100644
Binary files a/gpu-viv/lib64/libCLC.so and b/gpu-viv/lib64/libCLC.so differ
diff --git a/gpu-viv/lib64/libGAL.so b/gpu-viv/lib64/libGAL.so
index 079ed18..f2faf99 100644
Binary files a/gpu-viv/lib64/libGAL.so and b/gpu-viv/lib64/libGAL.so differ
diff --git a/gpu-viv/lib64/libGLSLC.so b/gpu-viv/lib64/libGLSLC.so
index bcd69b5..8a7d8d7 100644
Binary files a/gpu-viv/lib64/libGLSLC.so and b/gpu-viv/lib64/libGLSLC.so differ
diff --git a/gpu-viv/lib64/libNNGPUBinary-evis.so b/gpu-viv/lib64/libNNGPUBinary-evis.so
index 797f014..bd05c41 100755
Binary files a/gpu-viv/lib64/libNNGPUBinary-evis.so and b/gpu-viv/lib64/libNNGPUBinary-evis.so differ
diff --git a/gpu-viv/lib64/libNNGPUBinary-evis2.so b/gpu-viv/lib64/libNNGPUBinary-evis2.so
index ad385da..caac296 100755
Binary files a/gpu-viv/lib64/libNNGPUBinary-evis2.so and b/gpu-viv/lib64/libNNGPUBinary-evis2.so differ
diff --git a/gpu-viv/lib64/libNNGPUBinary-lite.so b/gpu-viv/lib64/libNNGPUBinary-lite.so
index 6808938..1d91b5c 100755
Binary files a/gpu-viv/lib64/libNNGPUBinary-lite.so and b/gpu-viv/lib64/libNNGPUBinary-lite.so differ
diff --git a/gpu-viv/lib64/libNNGPUBinary-ulite.so b/gpu-viv/lib64/libNNGPUBinary-ulite.so
index 981689b..293b41e 100755
Binary files a/gpu-viv/lib64/libNNGPUBinary-ulite.so and b/gpu-viv/lib64/libNNGPUBinary-ulite.so differ
diff --git a/gpu-viv/lib64/libNNVXCBinary-evis.so b/gpu-viv/lib64/libNNVXCBinary-evis.so
index c1132da..5f22111 100755
Binary files a/gpu-viv/lib64/libNNVXCBinary-evis.so and b/gpu-viv/lib64/libNNVXCBinary-evis.so differ
diff --git a/gpu-viv/lib64/libNNVXCBinary-evis2.so b/gpu-viv/lib64/libNNVXCBinary-evis2.so
index 7fb1f7f..d0ad848 100755
Binary files a/gpu-viv/lib64/libNNVXCBinary-evis2.so and b/gpu-viv/lib64/libNNVXCBinary-evis2.so differ
diff --git a/gpu-viv/lib64/libOpenCL.so b/gpu-viv/lib64/libOpenCL.so
index cfdc890..9e0dbe9 100644
Binary files a/gpu-viv/lib64/libOpenCL.so and b/gpu-viv/lib64/libOpenCL.so differ
diff --git a/gpu-viv/lib64/libOpenVX.so b/gpu-viv/lib64/libOpenVX.so
index f976730..356c408 100755
Binary files a/gpu-viv/lib64/libOpenVX.so and b/gpu-viv/lib64/libOpenVX.so differ
diff --git a/gpu-viv/lib64/libOpenVXU.so b/gpu-viv/lib64/libOpenVXU.so
index 4254133..060d5ea 100755
Binary files a/gpu-viv/lib64/libOpenVXU.so and b/gpu-viv/lib64/libOpenVXU.so differ
diff --git a/gpu-viv/lib64/libOvx12VXCBinary-evis.so b/gpu-viv/lib64/libOvx12VXCBinary-evis.so
index 34873e3..a1a6e0d 100755
Binary files a/gpu-viv/lib64/libOvx12VXCBinary-evis.so and b/gpu-viv/lib64/libOvx12VXCBinary-evis.so differ
diff --git a/gpu-viv/lib64/libOvx12VXCBinary-evis2.so b/gpu-viv/lib64/libOvx12VXCBinary-evis2.so
index 0a137fc..0790ec1 100755
Binary files a/gpu-viv/lib64/libOvx12VXCBinary-evis2.so and b/gpu-viv/lib64/libOvx12VXCBinary-evis2.so differ
diff --git a/gpu-viv/lib64/libSPIRV_viv.so b/gpu-viv/lib64/libSPIRV_viv.so
index da27eb1..558d763 100644
Binary files a/gpu-viv/lib64/libSPIRV_viv.so and b/gpu-viv/lib64/libSPIRV_viv.so differ
diff --git a/gpu-viv/lib64/libVSC.so b/gpu-viv/lib64/libVSC.so
index 969bf53..d2ba394 100644
Binary files a/gpu-viv/lib64/libVSC.so and b/gpu-viv/lib64/libVSC.so differ
diff --git a/gpu-viv/lib64/libg2d-viv.so b/gpu-viv/lib64/libg2d-viv.so
index 367b113..71f15c6 100644
Binary files a/gpu-viv/lib64/libg2d-viv.so and b/gpu-viv/lib64/libg2d-viv.so differ
diff --git a/gpu-viv/lib64/libgpuhelper.so b/gpu-viv/lib64/libgpuhelper.so
index 180cae5..9c7743e 100644
Binary files a/gpu-viv/lib64/libgpuhelper.so and b/gpu-viv/lib64/libgpuhelper.so differ
diff --git a/gpu-viv/lib64/libvulkan_VIVANTE.so b/gpu-viv/lib64/libvulkan_VIVANTE.so
index a51a617..d37bcc2 100644
Binary files a/gpu-viv/lib64/libvulkan_VIVANTE.so and b/gpu-viv/lib64/libvulkan_VIVANTE.so differ
diff --git a/include/VX/vx_khr_compatible.h b/include/VX/vx_khr_compatible.h
new file mode 100644
index 0000000..5a6c6d4
--- /dev/null
+++ b/include/VX/vx_khr_compatible.h
@@ -0,0 +1,18 @@
+#ifndef __VX_KHR_COMPATIBLE_H__
+#define __VX_KHR_COMPATIBLE_H__
+/*
+ VX_DECONVOLUTION_WEIGHT_LAYOUT_COMPATIBLE_KHRONOS is used to distingush deconvolution weight layout
+ [value]
+ 0: weight_layout is whnc
+ 1: weight_layout is whcn
+*/
+#define VX_DECONVOLUTION_WEIGHT_LAYOUT_COMPATIBLE_KHRONOS 1
+/*
+ VX_CONVERT_POLICY_WRAP_ENABLE is used to differentiate two overflow_policys(VX_CONVERT_POLICY_WRAP and VX_CONVERT_POLICY_SAT)
+ [value]
+ 0: both overflow_policys considered as VX_CONVERT_POLICY_SAT
+ 1: overflow_policy is determined by arguments.
+*/
+#define VX_CONVERT_POLICY_WRAP_ENABLE 1
+
+#endif /* __VX_KHR_COMPATIBLE_H__ */
\ No newline at end of file
diff --git a/include/VX/vx_khr_nn.h b/include/VX/vx_khr_nn.h
index a0da580..0f2b9e4 100644
--- a/include/VX/vx_khr_nn.h
+++ b/include/VX/vx_khr_nn.h
@@ -70,6 +70,9 @@ enum vx_graph_attribute_internal_type_e
  */
 #define VX_WRAP_USER_MEMORY_SIZE_ALIGNMENT (0x40)
 
+/*! rief OpenVX Version Compatibility set*/
+#define VX_KHR_COMPATIBILITY (0x1)
+
 /*==============================================================================
 CONVOLUTIONAL_NETWORK structs and enums
 =============================================================================*/
diff --git a/include/g2dExt.h b/include/g2dExt.h
index 78baec8..d9e0a55 100644
--- a/include/g2dExt.h
+++ b/include/g2dExt.h
@@ -59,6 +59,7 @@ enum g2d_tiling
     G2D_AMPHION_TILED       = 0x8,
     G2D_AMPHION_INTERLACED  = 0x10,
     G2D_TILED_STATUS        = 0x20,
+    G2D_AMPHION_TILED_10BIT = 0x40,
 };
 
 struct g2d_surfaceEx
diff --git a/mcu-sdk/7ulp/imx7ulp_m4_demo.img b/mcu-sdk/7ulp/imx7ulp_m4_demo.img
index 9d5419b..7cd8558 100755
Binary files a/mcu-sdk/7ulp/imx7ulp_m4_demo.img and b/mcu-sdk/7ulp/imx7ulp_m4_demo.img differ
diff --git a/mcu-sdk/imx8mm/imx8mm_mcu_demo.img b/mcu-sdk/imx8mm/imx8mm_mcu_demo.img
old mode 100755
new mode 100644
index baf51a1..776d9a4
Binary files a/mcu-sdk/imx8mm/imx8mm_mcu_demo.img and b/mcu-sdk/imx8mm/imx8mm_mcu_demo.img differ
diff --git a/mcu-sdk/imx8mp/imx8mp_mcu_demo.img b/mcu-sdk/imx8mp/imx8mp_mcu_demo.img
new file mode 100644
index 0000000..850d214
Binary files /dev/null and b/mcu-sdk/imx8mp/imx8mp_mcu_demo.img differ
diff --git a/mcu-sdk/imx8q/imx8qm_m4_0_default.bin b/mcu-sdk/imx8q/imx8qm_m4_0_default.bin
index 125cea7..19362a7 100755
Binary files a/mcu-sdk/imx8q/imx8qm_m4_0_default.bin and b/mcu-sdk/imx8q/imx8qm_m4_0_default.bin differ
diff --git a/mcu-sdk/imx8q/imx8qm_m4_1_default.bin b/mcu-sdk/imx8q/imx8qm_m4_1_default.bin
index d523bdd..f83e315 100755
Binary files a/mcu-sdk/imx8q/imx8qm_m4_1_default.bin and b/mcu-sdk/imx8q/imx8qm_m4_1_default.bin differ
diff --git a/mcu-sdk/imx8q/imx8qx_m4_default.bin b/mcu-sdk/imx8q/imx8qx_m4_default.bin
index 5735513..61b3f68 100755
Binary files a/mcu-sdk/imx8q/imx8qx_m4_default.bin and b/mcu-sdk/imx8q/imx8qx_m4_default.bin differ
diff --git a/media-profile/imx8mm/media_codecs_c2.xml b/media-profile/imx8mm/media_codecs_c2.xml
index 9290270..d30cce4 100644
--- a/media-profile/imx8mm/media_codecs_c2.xml
+++ b/media-profile/imx8mm/media_codecs_c2.xml
@@ -66,7 +66,7 @@
             <Limit name="performance-point-1280x720" value="240" />
             <Feature name="adaptive-playback" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imx8mn/media_codecs_c2.xml b/media-profile/imx8mn/media_codecs_c2.xml
index f003553..48a5aab 100644
--- a/media-profile/imx8mn/media_codecs_c2.xml
+++ b/media-profile/imx8mn/media_codecs_c2.xml
@@ -18,7 +18,7 @@
 
 <Included>
     <Decoders>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imx8mp/media_codecs_c2.xml b/media-profile/imx8mp/media_codecs_c2.xml
index ce1fb5d..36dca97 100644
--- a/media-profile/imx8mp/media_codecs_c2.xml
+++ b/media-profile/imx8mp/media_codecs_c2.xml
@@ -18,6 +18,7 @@
 
 <Included>
     <Include href="media_codecs_c2_dsp_aacp.xml" />
+    <Include href="media_codecs_c2_dsp_wma.xml" />
     <Include href="media_codecs_c2_dsp.xml" />
     <Decoders>
        <MediaCodec name="c2.imx.avc.decoder" type="video/avc" >
@@ -68,7 +69,7 @@
             <Limit name="performance-point-1280x720" value="240" />
             <Feature name="adaptive-playback" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imx8mp/media_codecs_performance_c2.xml b/media-profile/imx8mp/media_codecs_performance_c2.xml
index 7f4a2f5..2417675 100644
--- a/media-profile/imx8mp/media_codecs_performance_c2.xml
+++ b/media-profile/imx8mp/media_codecs_performance_c2.xml
@@ -47,7 +47,7 @@
         <MediaCodec name="c2.android.vp8.encoder" type="video/x-vnd.on2.vp8" update="true">
             <Limit name="measured-frame-rate-320x180" range="127-128" />
             <Limit name="measured-frame-rate-640x360" range="41-41" />
-            <Limit name="measured-frame-rate-1280x720" range="30-31" />
+            <Limit name="measured-frame-rate-1280x720" range="13-13" />
             <Limit name="measured-frame-rate-1920x1080" range="14-14" />
         </MediaCodec>
     </Encoders>
diff --git a/media-profile/imx8mq/media_codecs_c2.xml b/media-profile/imx8mq/media_codecs_c2.xml
index 3a139e9..5e5b2f2 100644
--- a/media-profile/imx8mq/media_codecs_c2.xml
+++ b/media-profile/imx8mq/media_codecs_c2.xml
@@ -118,7 +118,7 @@
             <Limit name="performance-point-1920x1080" value="60" />
             <Limit name="performance-point-1280x720" value="100" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imx8q/media_codecs_8qm.xml b/media-profile/imx8q/media_codecs_8qm.xml
index 9712a01..7ae2e7b 100644
--- a/media-profile/imx8q/media_codecs_8qm.xml
+++ b/media-profile/imx8q/media_codecs_8qm.xml
@@ -18,10 +18,11 @@
 
 <Included>
     <Include href="media_codecs_c2_dsp_aacp.xml" />
+    <Include href="media_codecs_c2_dsp_wma.xml" />
     <Include href="media_codecs_c2_dsp.xml" />
     <Decoders>
        <MediaCodec name="c2.imx.avc.decoder" type="video/avc" >
-            <Limit name="size" min="64x64" max="4096x2160" />
+            <Limit name="size" min="64x64" max="4096x2560" />
             <Limit name="alignment" value="2x2" />
             <Limit name="block-size" value="16x16" />
             <Limit name="blocks-per-second" min="1" max="1036800" />
@@ -34,7 +35,7 @@
             <Feature name="adaptive-playback" />
         </MediaCodec>
         <MediaCodec name="c2.imx.hevc.decoder" type="video/hevc" >
-            <Limit name="size" min="144x144" max="4096x2160" />
+            <Limit name="size" min="144x144" max="4096x2560" />
             <Limit name="alignment" value="2x2" />
             <Limit name="block-size" value="16x16" />
             <Limit name="blocks-per-second" min="1" max="2073600" />
@@ -122,7 +123,7 @@
             <Limit name="performance-point-1920x1080" value="60" />
             <Limit name="performance-point-1280x720" value="100" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imx8q/media_codecs_8qxp.xml b/media-profile/imx8q/media_codecs_8qxp.xml
index 6207902..9331b19 100644
--- a/media-profile/imx8q/media_codecs_8qxp.xml
+++ b/media-profile/imx8q/media_codecs_8qxp.xml
@@ -18,10 +18,11 @@
 
 <Included>
     <Include href="media_codecs_c2_dsp_aacp.xml" />
+    <Include href="media_codecs_c2_dsp_wma.xml" />
     <Include href="media_codecs_c2_dsp.xml" />
     <Decoders>
        <MediaCodec name="c2.imx.avc.decoder" type="video/avc" >
-            <Limit name="size" min="64x64" max="4096x2160" />
+            <Limit name="size" min="64x64" max="4096x2560" />
             <Limit name="alignment" value="2x2" />
             <Limit name="block-size" value="16x16" />
             <Limit name="blocks-per-second" min="1" max="1036800" />
@@ -34,7 +35,7 @@
             <Feature name="adaptive-playback" />
         </MediaCodec>
         <MediaCodec name="c2.imx.hevc.decoder" type="video/hevc" >
-            <Limit name="size" min="144x144" max="4096x2160" />
+            <Limit name="size" min="144x144" max="4096x2560" />
             <Limit name="alignment" value="2x2" />
             <Limit name="block-size" value="16x16" />
             <Limit name="blocks-per-second" min="1" max="2073600" />
@@ -122,7 +123,7 @@
             <Limit name="performance-point-1920x1080" value="60" />
             <Limit name="performance-point-1280x720" value="100" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imx8q/media_codecs_c2.xml b/media-profile/imx8q/media_codecs_c2.xml
index 94ef414..5ff70cc 100644
--- a/media-profile/imx8q/media_codecs_c2.xml
+++ b/media-profile/imx8q/media_codecs_c2.xml
@@ -122,7 +122,7 @@
             <Limit name="performance-point-1920x1080" value="60" />
             <Limit name="performance-point-1280x720" value="100" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/imxaiy8mq/media_codecs_c2.xml b/media-profile/imxaiy8mq/media_codecs_c2.xml
index 1bdbac8..a2e4719 100644
--- a/media-profile/imxaiy8mq/media_codecs_c2.xml
+++ b/media-profile/imxaiy8mq/media_codecs_c2.xml
@@ -31,7 +31,7 @@
             <Limit name="performance-point-1280x720" value="240" />
             <Feature name="adaptive-playback" />
         </MediaCodec>
-        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/aac-fsl" >
+        <MediaCodec name="c2.imx.aac.decoder.sw" type="audio/mp4a-latm" >
             <Limit name="channel-count" max="6" />
             <Limit name="sample-rate" ranges="7350,8000,11025,12000,16000,22050,24000,32000,44100,48000,96000" />
             <Limit name="bitrate" range="8000-256000" />
diff --git a/media-profile/media-profile.mk b/media-profile/media-profile.mk
index 23baec9..6e3af22 100755
--- a/media-profile/media-profile.mk
+++ b/media-profile/media-profile.mk
@@ -169,9 +169,14 @@ endif
 
 HAVE_WMV9 = $(shell test -f $(FSL_RESTRICTED_CODEC_PATH)/fsl-restricted-codec/fsl_ms_codec/media_codecs_c2_wmv9.xml && echo yes)
 ifeq ($(HAVE_WMV9), yes)
-ifneq ($(findstring $(BOARD_SOC_TYPE),  IMX8MQ IMX8Q),)
+ifneq ($(findstring $(BOARD_SOC_TYPE),  IMX8Q IMX8MQ),)
 include $(CLEAR_VARS)
 LOCAL_SRC_FILES = ../../../../$(FSL_RESTRICTED_CODEC_PATH)/fsl-restricted-codec/fsl_ms_codec/media_codecs_c2_wmv9.xml
+
+ifneq ($(findstring $(BOARD_SOC_TYPE),  IMX8MQ),)
+LOCAL_SRC_FILES := ../../../../$(FSL_RESTRICTED_CODEC_PATH)/fsl-restricted-codec/fsl_ms_codec/media_codecs_c2_wmv9_hantro.xml
+endif
+
 LOCAL_MODULE := media_codecs_c2_wmv9.xml
 LOCAL_MODULE_CLASS := ETC
 LOCAL_VENDOR_MODULE := true
@@ -213,6 +218,16 @@ LOCAL_VENDOR_MODULE := true
 include $(BUILD_PREBUILT)
 endif
 
+HAVE_DSP_WMA = $(shell test -f $(FSL_RESTRICTED_CODEC_PATH)/fsl-restricted-codec/imx_dsp_wma_dec/media_codecs_c2_dsp_wma.xml && echo yes)
+ifeq ($(HAVE_DSP_WMA), yes)
+include $(CLEAR_VARS)
+LOCAL_SRC_FILES = ../../../../$(FSL_RESTRICTED_CODEC_PATH)/fsl-restricted-codec/imx_dsp_wma_dec/media_codecs_c2_dsp_wma.xml
+LOCAL_MODULE := media_codecs_c2_dsp_wma.xml
+LOCAL_MODULE_CLASS := ETC
+LOCAL_VENDOR_MODULE := true
+include $(BUILD_PREBUILT)
+endif
+
 HAVE_DSP = $(shell test -f $(FSL_RESTRICTED_CODEC_PATH)/fsl-restricted-codec/imx_dsp_codec/media_codecs_c2_dsp.xml && echo yes)
 ifeq ($(HAVE_DSP), yes)
 include $(CLEAR_VARS)
diff --git a/patches/libcore/0001-MA-16651-add-support-for-rmvb-adts.patch b/patches/libcore/0001-MA-16651-add-support-for-rmvb-adts.patch
new file mode 100644
index 0000000..f0f3b18
--- /dev/null
+++ b/patches/libcore/0001-MA-16651-add-support-for-rmvb-adts.patch
@@ -0,0 +1,29 @@
+From 472b486707723afa8041352c6702ba8e13104935 Mon Sep 17 00:00:00 2001
+From: Xu Mao <mao.xu@nxp.com>
+Date: Tue, 10 Mar 2020 21:19:33 +0000
+Subject: [PATCH] MA-16651 add support for rmvb, adts
+
+Signed-off-by: Xu Mao <mao.xu@nxp.com>
+Change-Id: If1e7e296764d309eb26def05e9a49cfc601cbe12
+Reviewed-on: http://androidsource.ap.freescale.net/project/11651
+Reviewed-by: guoyin.chen <guoyin.chen@nxp.com>
+Reviewed-by: xiahong bao <xiahong.bao@nxp.com>
+---
+ luni/src/main/java/libcore/net/android.mime.types | 4 ++++
+ 1 file changed, 4 insertions(+)
+
+diff --git a/luni/src/main/java/libcore/net/android.mime.types b/luni/src/main/java/libcore/net/android.mime.types
+index 6332489a41..fb2826f3da 100644
+--- a/luni/src/main/java/libcore/net/android.mime.types
++++ b/luni/src/main/java/libcore/net/android.mime.types
+@@ -97,3 +97,7 @@ video/mpeg mpeg!
+ video/quicktime mov!
+ video/vnd.youtube.yt yt
+ video/x-matroska mkv!
++
++# NXP added
++audio/aac adts
++audio/x-pn-realaudio rmvb
+-- 
+2.17.1
+
diff --git a/test/bin/gmem_info b/test/bin/gmem_info
index 9975c1d..79b6ef5 100755
Binary files a/test/bin/gmem_info and b/test/bin/gmem_info differ
diff --git a/test/gmem.go b/test/gmem.go
index b1b513e..dacb4a3 100755
--- a/test/gmem.go
+++ b/test/gmem.go
@@ -39,8 +39,7 @@ func gmemDefaults(ctx android.LoadHookContext) {
         }
     }
     p := &props{}
-    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("PREBUILT_FSL_IMX_GPU") &&
-       ctx.Config().VendorConfig("IMXPLUGIN").String("BOARD_PLATFORM")=="imx6" {
+    if ctx.Config().VendorConfig("IMXPLUGIN").Bool("PREBUILT_FSL_IMX_GPU") {
         p.Target.Android.Enabled = proptools.BoolPtr(true)
     } else {
         p.Target.Android.Enabled = proptools.BoolPtr(false)
diff --git a/uboot-firmware/imx8q/board-imx8qm.c b/uboot-firmware/imx8q/board-imx8qm.c
index 6422f17..8dfbbff 100755
--- a/uboot-firmware/imx8q/board-imx8qm.c
+++ b/uboot-firmware/imx8q/board-imx8qm.c
@@ -2,7 +2,7 @@
 ** ###################################################################
 **
 **     Copyright (c) 2016 Freescale Semiconductor, Inc.
-**     Copyright 2017-2019 NXP
+**     Copyright 2017-2020 NXP
 **
 **     Redistribution and use in source and binary forms, with or without modification,
 **     are permitted provided that the following conditions are met:
@@ -39,7 +39,7 @@
  *
  * File containing the implementation of the MX8QM MEK board.
  *
- * @addtogroup MX8QM_MEK_BRD (BRD) MX8QM MEK Board
+ * @addtogroup MX8QM_MEK_BRD BRD: MX8QM MEK Board
  *
  * Module for MX8QM MEK board access.
  *
@@ -60,13 +60,14 @@
 #include "drivers/lpi2c/fsl_lpi2c.h"
 #include "drivers/pmic/fsl_pmic.h"
 #include "drivers/pmic/pf8100/fsl_pf8100.h"
-#include "drivers/gpio/fsl_gpio.h"
+#include "drivers/rgpio/fsl_rgpio.h"
 #include "drivers/snvs/fsl_snvs.h"
 #include "drivers/wdog32/fsl_wdog32.h"
 #include "drivers/lpuart/fsl_lpuart.h"
 #include "drivers/drc/fsl_drc_cbt.h"
 #include "drivers/drc/fsl_drc_derate.h"
 #include "drivers/drc/fsl_drc_rdbi_deskew.h"
+#include "drivers/drc/fsl_drc_dram_vref.h"
 #include "drivers/systick/fsl_systick.h"
 #include "pads.h"
 #include "drivers/pad/fsl_pad.h"
@@ -215,8 +216,8 @@ const uint32_t board_ddr_derate_period_ms = 1000U;
 /*--------------------------------------------------------------------------*/
 void board_init(boot_phase_t phase)
 {
-    gpio_pin_config_t config;
-    config.pinDirection = kGPIO_DigitalOutput;
+    rgpio_pin_config_t config;
+    config.pinDirection = kRGPIO_DigitalOutput;
 
     ss_print(3, "board_init(%d)
", phase);
 
@@ -233,7 +234,7 @@ void board_init(boot_phase_t phase)
         config.outputLogic  = 0U;
         FGPIO_PinInit(FGPIOA, 1U, &config);
         SYSTICK_CycleDelay(SC_SYSTICK_NSEC_TO_TICKS(30U) + 1U);
-        FGPIO_WritePinOutput(FGPIOA, 1U, 1U);  
+        FGPIO_PinWrite(FGPIOA, 1U, 1U);
 
         /* SCU_LED on SC_GPIO_02 */
         config.outputLogic  = 1U;
@@ -252,7 +253,7 @@ void board_init(boot_phase_t phase)
     else if (phase == BOOT_PHASE_TEST_INIT)
     {
         /* Configure board for SCFW tests - only called in a unit test
-         * image. Called just before SC tests are run. 
+         * image. Called just before SC tests are run.
          */
 
         /* Configure ADMA UART pads. Needed for test_dma.
@@ -296,7 +297,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
         /* Power up UART */
         pm_force_resource_power_mode_v(SC_R_SC_UART,
             SC_PM_PW_MODE_ON);
-    
+
         /* Check if debug disabled */
         if (SCFW_DBG_READY == 0U)
         {
@@ -334,7 +335,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
 
             if (banner == SC_FALSE)
             {
-                debug_print(1, 
+                debug_print(1,
                     "
Hello from SCU (Build %u, Commit %08x, %s %s)

",
                     SCFW_BUILD, SCFW_COMMIT, SCFW_DATE, SCFW_TIME);
                 banner = SC_TRUE;
@@ -361,7 +362,7 @@ void board_disable_debug_uart(void)
             /* Disable use of UART */
             SCFW_DBG_READY = 0U;
 
-            // UART deinit to flush TX buffers 
+            // UART deinit to flush TX buffers
             LPUART_Deinit(LPUART_DEBUG);
 
             /* Turn off UART */
@@ -440,6 +441,9 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
         case BOARD_PARM_DC1_PLL1_SSC:
             rtn = BOARD_PARM_RTN_NOT_USED;
             break;
+        case BOARD_PARM_KS1_WDOG_WAKE:
+            rtn = BOARD_PARM_KS1_WDOG_WAKE_ENABLE;
+            break;
         default :
             ; /* Intentional empty default */
             break;
@@ -454,21 +458,26 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
 sc_bool_t board_rsrc_avail(sc_rsrc_t rsrc)
 {
     sc_bool_t rtn = SC_TRUE;
-    
-    /* Return SC_FALSE here if a resource isn't available due to board 
+
+    /* Return SC_FALSE here if a resource isn't available due to board
        connections (typically lack of power). Examples incluse DRC_0/1
        and ADC. */
+
+    /* The value here may be overridden by SoC fuses or emulation config */
+    
+    /* Note return values are usually static. Can be made dynamic by storing
+       return in a global variable and setting using board_set_control() */
+
     #if defined(BD_DDR_RET_NUM_DRC) && (BD_DDR_RET_NUM_DRC == 1U)
         if(rsrc == SC_R_DRC_1)
         {
             rtn = SC_FALSE;
         }
     #endif
-
-    /* The value here may be overridden by SoC fuses or emulation config */
-
-    /* Note return values are usually static. Can be made dynamic by storing
-       return in a global variable and setting using board_set_control() */
+    if(rsrc == SC_R_PMIC_2)
+    {
+        rtn = SC_FALSE;
+    }
 
     return rtn;
 }
@@ -481,13 +490,13 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
     /*
      * Variables for DDR retention
      */
-    #ifdef BD_DDR_RET
+    #if defined(BD_DDR_RET) & !defined(SKIP_DDR)
         /* Storage for DRC registers */
         static ddrc board_ddr_ret_drc_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DRC PHY registers */
         static ddr_phy board_ddr_ret_drc_phy_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DDR regions */
         static uint32_t board_ddr_ret_buf1[BD_DDR_RET_REGION1_SIZE];
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -505,9 +514,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         #ifdef BD_DDR_RET_REGION6_SIZE
         static uint32_t board_ddr_ret_buf6[BD_DDR_RET_REGION6_SIZE];
         #endif
-        
+
         /* DDR region descriptors */
-        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] = 
+        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] =
         {
             { BD_DDR_RET_REGION1_ADDR, BD_DDR_RET_REGION1_SIZE, board_ddr_ret_buf1 },
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -528,13 +537,20 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         };
 
         /* DDR retention descriptor passed to SCFW */
-        static soc_ddr_ret_info_t board_ddr_ret_info = 
-        { 
-          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst, 
+        static soc_ddr_ret_info_t board_ddr_ret_info =
+        {
+          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst,
           BD_DDR_RET_NUM_REGION, board_ddr_ret_region
         };
     #endif
 
+    #if defined(BD_LPDDR4_INC_DQS2DQ) && defined(BOARD_DQS2DQ_SYNC)
+        static soc_dqs2dq_sync_info_t board_dqs2dq_sync_info =
+        {
+            BOARD_DQS2DQ_ISI_RSRC, BOARD_DQS2DQ_ISI_REG, BOARD_DQS2DQ_SYNC_TIME
+        };
+    #endif
+
     board_print(3, "board_init_ddr(%d)
", early);
 
     #ifdef SKIP_DDR
@@ -556,21 +572,25 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
 
         #ifdef DEBUG_BOARD
             uint32_t rate = 0U;
+            sc_err_t rate_err = SC_ERR_FAIL;
             if (rm_is_resource_avail(SC_R_DRC_0))
             {
-                (void) pm_get_clock_rate(SC_PT, SC_R_DRC_0, SC_PM_CLK_MISC0,
-                    &rate);
+                rate_err = pm_get_clock_rate(SC_PT, SC_R_DRC_0,
+                    SC_PM_CLK_SLV_BUS, &rate);
             }
             else if (rm_is_resource_avail(SC_R_DRC_1))
             {
-                (void) pm_get_clock_rate(SC_PT, SC_R_DRC_1, SC_PM_CLK_MISC0,
-                    &rate);
+                rate_err = pm_get_clock_rate(SC_PT, SC_R_DRC_1,
+                    SC_PM_CLK_SLV_BUS, &rate);
             }
             else
             {
                 ; /* Intentional empty else */
             }
-            board_print(1, "DDR frequency = %u
", rate * 2U);
+            if (rate_err == SC_ERR_NONE)
+            {
+                board_print(1, "DDR frequency = %u
", rate * 2U);
+            }
         #endif
 
         if (err == SC_ERR_NONE)
@@ -580,6 +600,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
             #endif
 
             #ifdef BD_LPDDR4_INC_DQS2DQ
+            #ifdef BOARD_DQS2DQ_SYNC
+                soc_ddr_dqs2dq_config(&board_dqs2dq_sync_info);
+            #endif
                 if (board_ddr_period_ms != 0U)
                 {
                     soc_ddr_dqs2dq_init();
@@ -680,6 +703,24 @@ sc_err_t  board_ddr_config(bool rom_caller, board_ddr_action_t action)
             }
             break;
     #endif
+        case BOARD_DDR0_VREF:
+            #if defined(MONITOR) || defined(EXPORT_MONITOR)
+                // Launch VREF training
+                DRAM_VREF_training_hw(0);
+            #else
+                // Run vref training
+                DRAM_VREF_training_sw(0);
+            #endif
+            break;
+        case BOARD_DDR1_VREF:
+            #if defined(MONITOR) || defined(EXPORT_MONITOR)
+                // Launch VREF training
+                DRAM_VREF_training_hw(1);
+            #else
+                // Run vref training
+                DRAM_VREF_training_sw(1);
+            #endif
+            break;
         default:
             #include "dcd/dcd.h"
             break;
@@ -691,10 +732,11 @@ sc_err_t  board_ddr_config(bool rom_caller, board_ddr_action_t action)
 /*--------------------------------------------------------------------------*/
 /* Configure the system (inc. additional resource partitions)               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
+void board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
+
     /* This function configures the system. It usually partitions
        resources according to the system design. It must be modified by
        customers. Partitions should then be specified using the mkimage
@@ -704,17 +746,27 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 
     sc_bool_t alt_config = SC_FALSE;
     sc_bool_t no_ap = SC_FALSE;
-    
+
     /* Get boot parameters. See the Boot Flags section for defintition
        of these flags.*/
-    (void) boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
+    boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
         NULL, NULL, &no_ap);
 
     board_print(3, "board_system_config(%d, %d)
", early, alt_config);
 
+#ifndef EMUL
+    sc_rm_mr_t mr_temp;
+
+    /* Board has 6GB memory so fragment upper region and retain 4GB */
+    BRD_ERR(rm_memreg_frag(pt_boot, &mr_temp, 0x980000000ULL,
+        0xFFFFFFFFFULL));
+    BRD_ERR(rm_memreg_free(pt_boot, mr_temp));
+#endif
+
     /* Configure initial resource allocation (note additional allocation
        and assignments can be made by the SCFW clients at run-time */
-    if (alt_config != SC_FALSE)
+    if ((alt_config != SC_FALSE) 
+        && (rm_is_resource_avail(SC_R_M4_0_PID0) != SC_FALSE))
     {
         sc_rm_pt_t pt_m4_0;
         sc_rm_pt_t pt_m4_1;
@@ -731,11 +783,11 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_FALSE));
         BRD_ERR(rm_set_pad_movable(pt_boot, SC_P_ALL, SC_P_ALL,
             SC_FALSE));
-        
+
         /* Allocate M4_0 partition */
         BRD_ERR(rm_partition_alloc(pt_boot, &pt_m4_0, SC_FALSE, SC_TRUE,
             SC_FALSE, SC_TRUE, SC_FALSE));
-        
+
         /* Mark all M4_0 subsystem resources as movable */
         BRD_ERR(rm_set_subsys_rsrc_movable(pt_boot, SC_R_M4_0_PID0,
             SC_TRUE));
@@ -755,6 +807,8 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_R_MU_8B, SC_TRUE));
         BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_GPT_4,
             SC_R_GPT_4, SC_TRUE));
+        BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_SECO_MU_4,
+            SC_R_SECO_MU_4, SC_TRUE));
 
         /* Move everything flagged as movable */
         BRD_ERR(rm_move_all(pt_boot, pt_boot, pt_m4_0, SC_TRUE, SC_TRUE));
@@ -868,7 +922,7 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_RM_PERM_FULL));
 
         /* Protect some resources */
-        /* M4 PID1-4 can be used to allow M4 to map to other SID */      
+        /* M4 PID1-4 can be used to allow M4 to map to other SID */
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID1));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID2));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID3));
@@ -882,12 +936,6 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             rm_dump(pt_boot);
         #endif
     }
-    else
-    {
-        err = SC_ERR_UNAVAILABLE;
-    }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -901,7 +949,7 @@ sc_bool_t board_early_cpu(sc_rsrc_t cpu)
     {
         rtn = SC_TRUE;
     }
-    
+
     return rtn;
 }
 
@@ -923,6 +971,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
     /* Check for PMIC */
     if (pmic_ver.device_id != 0U)
     {
+        sc_err_t err = SC_ERR_NONE;
+
         /* Flip switch */
         if (to_mode > SC_PM_PW_MODE_OFF)
         {
@@ -930,8 +980,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
-                    SW_RUN_PWM | SW_STBY_PWM);
+                BRD_ERR(PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
+                    SW_RUN_PWM | SW_STBY_PWM));
                 idx++;
             }
             SystemTimeDelay(PMIC_MAX_RAMP);
@@ -942,8 +992,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
-                    SW_RUN_OFF);
+                BRD_ERR(PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
+                    SW_RUN_OFF));
                 idx++;
             }
         }
@@ -976,8 +1026,8 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
 
         while (idx < num_regs)
         {
-            (void) PMIC_SET_VOLTAGE(pmic_id[idx], pmic_reg[idx], new_volt,
-                REG_RUN_MODE);
+            BRD_ERR(PMIC_SET_VOLTAGE(pmic_id[idx], pmic_reg[idx], new_volt,
+                REG_RUN_MODE));
             idx++;
         }
         if ((old_volt != 0U) && (new_volt > old_volt))
@@ -992,73 +1042,105 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
     return err;
 }
 
+/*--------------------------------------------------------------------------*/
+/* Set board power supplies when enter/exit low-power mode                  */
+/*--------------------------------------------------------------------------*/
+void board_lpm(sc_pm_power_mode_t mode)
+{
+    static uint32_t vdd_memc_mode = 0U;
+
+    if (mode == SC_PM_PW_MODE_STBY)
+    {
+        /*
+         * System standby (KS1) entry allows VDD_MEMC to be gated off.
+         * Save current mode and switch off supply.
+         */
+        if (PMIC_GET_MODE(PMIC_1_ADDR, PF8100_SW5, &vdd_memc_mode)
+            == SC_ERR_NONE)
+        {
+            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, SW_STBY_OFF
+                | SW_RUN_OFF);
+        }
+    }
+    else if (mode == SC_PM_PW_MODE_ON)
+    {
+        /*
+         * System standby (KS1) exit should switch on VDD_MEMC.  Restore
+         * previous mode saved during KS1 entry.
+         */
+        if (vdd_memc_mode != 0U)
+        {
+            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, vdd_memc_mode);
+        }
+    }
+    else
+    {
+        ; /* Intentional empty else */
+    }
+}
+
 /*--------------------------------------------------------------------------*/
 /* Reset a board resource                                                   */
 /*--------------------------------------------------------------------------*/
-void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx)
+void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx, sc_rm_pt_t pt)
 {
 }
 
 /*--------------------------------------------------------------------------*/
 /* Transition external board-level supply for board component               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
+void board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
     sc_pm_power_mode_t from_mode, sc_pm_power_mode_t to_mode)
 {
-    sc_err_t err = SC_ERR_NONE;
-    
-    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx, 
+    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx,
         rnames[rsrc_idx], from_mode, to_mode);
 
     /* Init PMIC */
     pmic_init();
 
-    /* Check if PMIC available */
-    ASRT_ERR(pmic_ver.device_id != 0U, SC_ERR_NOTFOUND);
-
     /* Process resource */
-    if (err == SC_ERR_NONE)
+    if (pmic_ver.device_id != 0U)
     {
+        sc_err_t err = SC_ERR_NONE;
+
         switch (idx)
         {
             case BRD_R_BOARD_R2 : /* EMVSIM */
                 if (to_mode > SC_PM_PW_MODE_OFF)
                 {
-                    (void) PMIC_SET_VOLTAGE(PMIC_1_ADDR, PF8100_LDO1,
-                        3300, REG_RUN_MODE);
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
-                        RUN_EN_STBY_EN);
+                    BRD_ERR(PMIC_SET_VOLTAGE(PMIC_1_ADDR, PF8100_LDO1,
+                        3000, REG_RUN_MODE));
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
+                        RUN_EN_STBY_EN));
                 }
                 else
                 {
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
-                        RUN_OFF_STBY_OFF);
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
+                        RUN_OFF_STBY_OFF));
                 }
                 break;
             case BRD_R_BOARD_R3 : /* USDHC2 on Base Board */
                 if (to_mode > SC_PM_PW_MODE_OFF)
                 {
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
-                        RUN_EN_STBY_EN | VSELECT_EN);
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
+                        RUN_EN_STBY_EN | VSELECT_EN));
                 }
                 else
                 {
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
-                        RUN_OFF_STBY_OFF);
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
+                        RUN_OFF_STBY_OFF));
                 }
                 break;
-            case BRD_R_BOARD_R7 : 
+            case BRD_R_BOARD_R7 :
                 /* Example for testing (use SC_R_BOARD_R7) */
                 board_print(3, "SC_R_BOARD_R7 from %u to %u
",
                     from_mode, to_mode);
                 break;
             default :
-                err = SC_ERR_PARM;
+                ; /* Intentional empty default */
                 break;
         }
     }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -1067,42 +1149,19 @@ sc_err_t board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
 sc_err_t board_power(sc_pm_power_mode_t mode)
 {
     sc_err_t err = SC_ERR_NONE;
-    static uint32_t vdd_memc_mode = 0U;
 
     if (mode == SC_PM_PW_MODE_OFF)
     {
         /* Request power off */
         SNVS_PowerOff();
         err = snvs_err;
-        
+
         /* Loop forever */
         while(err == SC_ERR_NONE)
         {
             ; /* Intentional empty while */
         }
     }
-    else if (mode == SC_PM_PW_MODE_STBY)
-    {
-        /* 
-         * System standby (KS1) entry allows VDD_MEMC to be gated off.  Save
-         * current mode and switch off supply.
-         */
-        if (PMIC_GET_MODE(PMIC_1_ADDR, PF8100_SW5, &vdd_memc_mode) == SC_ERR_NONE)
-        {
-            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, SW_STBY_OFF | SW_RUN_OFF);
-        }
-    }
-    else if (mode == SC_PM_PW_MODE_ON)
-    {
-        /* 
-         * System standby (KS1) exit should switch on VDD_MEMC.  Restore previous
-         * mode saved during KS1 entry.
-         */
-        if (vdd_memc_mode != 0U)
-        {
-            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, vdd_memc_mode);
-        }
-    }
     else
     {
         err = SC_ERR_PARM;
@@ -1132,7 +1191,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
 
     #ifdef DEBUG
         /* Dump out caller of reset request */
-        always_print("Board reset (%u, caller = 0x%08X)
", reason, 
+        always_print("Board reset (%u, caller = 0x%08X)
", reason,
             __builtin_return_address(0));
     #endif
     #ifdef ALT_DEBUG_UART
@@ -1143,7 +1202,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
     /* Request a warm reset */
     soc_set_reset_info(reason, pt);
     NVIC_SystemReset();
-    
+
     return SC_ERR_UNAVAILABLE;
 }
 
@@ -1155,19 +1214,19 @@ void board_cpu_reset(sc_rsrc_t resource, board_cpu_rst_ev_t reset_event,
 {
     /* Note:  Production code should decide the response for each type
      *        of reset event.  Options include allowing the SCFW to
-     *        reset the CPU or forcing a full system reset.  Additionally, 
-     *        the number of reset attempts can be tracked to determine the 
+     *        reset the CPU or forcing a full system reset.  Additionally,
+     *        the number of reset attempts can be tracked to determine the
      *        reset response.
      */
-    
+
     /* Check for M4 reset event */
     if ((resource == SC_R_M4_0_PID0) || (resource == SC_R_M4_1_PID0))
     {
-        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource, 
+        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource,
             reset_event);
 
         /* Treat lockups or parity/ECC reset events as board faults */
-        if ((reset_event == BOARD_CPU_RESET_LOCKUP) || 
+        if ((reset_event == BOARD_CPU_RESET_LOCKUP) ||
             (reset_event == BOARD_CPU_RESET_MEM_ERR))
         {
             board_fault(SC_FALSE, BOARD_BFAULT_CPU, pt);
@@ -1218,10 +1277,11 @@ board_reboot_to_t board_reboot_timeout(sc_rm_pt_t pt)
 /*--------------------------------------------------------------------------*/
 void board_panic(sc_dsc_t dsc)
 {
+    /* See Porting Guide for more info on panic alarms */
     #ifdef DEBUG
         error_print("Panic temp (dsc=%d)
", dsc);
     #endif
-    
+
     (void) board_reset(SC_PM_RESET_TYPE_BOARD, SC_PM_RESET_REASON_TEMP,
         SC_PT);
 }
@@ -1241,6 +1301,8 @@ void board_fault(sc_bool_t restarted, sc_bfault_t reason,
         WDOG32_SetTimeoutValue(WDOG_SC, 0xFFFF);
         WDOG32_Disable(WDOG_SC);
 
+        board_print(1, "board fault(%u, %u, %u)
", restarted, reason, pt);
+
         /* Stop so developer can see WDOG occurred */
         HALT;
     #else
@@ -1281,7 +1343,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_set_control(%s, %u, %u)
", rnames[rsrc_idx], ctrl, val);
 
@@ -1299,7 +1361,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
             case SC_R_PMIC_0 :
                 if (ctrl == SC_C_TEMP_HI)
                 {
-                    temp_alarm0 = 
+                    temp_alarm0 =
                         SET_PMIC_TEMP_ALARM(PMIC_0_ADDR, val);
                 }
                 else
@@ -1310,7 +1372,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
             case SC_R_PMIC_1 :
                 if (ctrl == SC_C_TEMP_HI)
                 {
-                    temp_alarm1 = 
+                    temp_alarm1 =
                         SET_PMIC_TEMP_ALARM(PMIC_1_ADDR, val);
                 }
                 else
@@ -1346,7 +1408,7 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t *val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_get_control(%s, %u)
", rnames[rsrc_idx], ctrl);
 
@@ -1370,6 +1432,12 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
                 {
                     *val = temp_alarm0;
                 }
+                else if (ctrl == SC_C_ID)
+                {
+                    pmic_version_t v = GET_PMIC_VERSION(PMIC_0_ADDR);
+
+                    *val = (U32(v.device_id) << 8U) | U32(v.si_rev);
+                }
                 else
                 {
                     err = SC_ERR_PARM;
@@ -1384,6 +1452,12 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
                 {
                     *val = temp_alarm1;
                 }
+                else if (ctrl == SC_C_ID)
+                {
+                    pmic_version_t v = GET_PMIC_VERSION(PMIC_1_ADDR);
+
+                    *val = (U32(v.device_id) << 8U) | U32(v.si_rev);
+                }
                 else
                 {
                     err = SC_ERR_PARM;
@@ -1466,7 +1540,7 @@ static void pmic_init(void)
                 SC_PM_PW_MODE_ON);
             (void) pm_set_clock_rate(SC_PT, SC_R_SC_I2C,
                 SC_PM_CLK_PER, &rate);
-            (void) pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
+            pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
                 SC_TRUE);
 
             /* Initialize the pads used to communicate with the PMIC */
@@ -1511,25 +1585,29 @@ static void pmic_init(void)
             err |= pmic_match_otp(PMIC_0_ADDR, pmic_ver);
             err |= pmic_match_otp(PMIC_1_ADDR, pmic_ver);
 
+            /* Enable WDI detection in Standby */
+            err |= pf8100_pmic_wdog_enable(PMIC_0_ADDR, SC_FALSE, SC_FALSE, SC_TRUE);
+            err |= pf8100_pmic_wdog_enable(PMIC_1_ADDR, SC_FALSE, SC_FALSE, SC_TRUE);
+
             if (err != SC_ERR_NONE)
             {
                 /* Loop so WDOG will expire */
                 HALT;
             }
 
-            (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1, SW_RUN_PWM
-                | SW_STBY_PWM);
-            (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2, SW_RUN_PWM
-                | SW_STBY_PWM);
-            (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW7, SW_RUN_PWM
-                | SW_STBY_PWM);
-            
+            BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1, SW_RUN_PWM
+                | SW_STBY_PWM));
+            BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2, SW_RUN_PWM
+                | SW_STBY_PWM));
+            BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW7, SW_RUN_PWM
+                | SW_STBY_PWM));
+
             /* Configure STBY voltage for SW1 (VDD_MAIN) */
             if (board_parameter(BOARD_PARM_KS1_RETENTION)
                 == BOARD_PARM_KS1_RETENTION_ENABLE)
             {
-                (void) PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, 800,
-                    REG_STBY_MODE);
+                BRD_ERR(PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, 800,
+                    REG_STBY_MODE));
             }
 
             /* Enable PMIC IRQ at NVIC level */
@@ -1606,7 +1684,7 @@ static sc_err_t pmic_ignore_current_limit(uint8_t address)
 /*--------------------------------------------------------------------------*/
 static sc_err_t pmic_update_timing(uint8_t address)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
     uint8_t val = 0xED;
 
     /*
@@ -1619,7 +1697,6 @@ static sc_err_t pmic_update_timing(uint8_t address)
      */
     if (address == PMIC_0_ADDR)
     {
-        err = SC_ERR_NONE;
         err |= PMIC_REGISTER_ACCESS(address, 0x8D, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x77, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x7F, SC_TRUE, &val);
@@ -1628,7 +1705,6 @@ static sc_err_t pmic_update_timing(uint8_t address)
     }
     else if (address == PMIC_1_ADDR)
     {
-        err = SC_ERR_NONE;
         err |= PMIC_REGISTER_ACCESS(address, 0x8D, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x6F, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x77, SC_TRUE, &val);
@@ -1638,18 +1714,18 @@ static sc_err_t pmic_update_timing(uint8_t address)
     }
     else
     {
-        ; /* Intentional empty else */
+        err = SC_ERR_PARM;
     }
 
     return err;
 }
 
 /*--------------------------------------------------------------------------*/
-/* Check correct version of OTP for PF8100                                          */
+/* Check correct version of OTP for PF8100                                  */
 /*--------------------------------------------------------------------------*/
 static sc_err_t pmic_match_otp(uint8_t address, pmic_version_t ver)
 {
-    uint8_t reg_value = 0;
+    uint8_t reg_value = 0U;
     uint16_t prog_id, match;
     sc_err_t err = SC_ERR_NONE;
 
@@ -1664,12 +1740,12 @@ static sc_err_t pmic_match_otp(uint8_t address, pmic_version_t ver)
 
     /* Read Prog ID */
     err |= PMIC_REGISTER_ACCESS(address, 0x2, SC_FALSE, &reg_value);
-    prog_id = ((reg_value << 4U) & 0x0F00U);
+    prog_id = (((uint16_t)reg_value << 4U) & 0x0F00U);
     err |= PMIC_REGISTER_ACCESS(address, 0x3, SC_FALSE, &reg_value);
     prog_id |= reg_value;
 
     /* test against calibration fusing */
-    if (OTP_PROG_FUSE_VERSION_1_7V_CAL != 0)
+    if (OTP_PROG_FUSE_VERSION_1_7V_CAL != 0U)
     {
         if (ver.si_rev >= PF8100_C1_SI_REV)
         {
@@ -1762,7 +1838,7 @@ void board_tick(uint16_t msec)
 sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
     uint32_t *parm2, uint32_t *parm3)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
 
     /* For test_misc */
     if (*parm1 == 0xFFFFFFFEU)
@@ -1770,8 +1846,10 @@ sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
         *parm1 = *parm2 + *parm3;
         *parm2 = mu;
         *parm3 = caller_pt;
-
-        err = SC_ERR_NONE;
+    }
+    else
+    {
+        err = SC_ERR_PARM;
     }
 
     return err;
diff --git a/uboot-firmware/imx8q/board-imx8qxp.c b/uboot-firmware/imx8q/board-imx8qxp.c
index 3654ef5..ecf1994 100755
--- a/uboot-firmware/imx8q/board-imx8qxp.c
+++ b/uboot-firmware/imx8q/board-imx8qxp.c
@@ -2,7 +2,7 @@
 ** ###################################################################
 **
 **     Copyright (c) 2016 Freescale Semiconductor, Inc.
-**     Copyright 2017-2019 NXP
+**     Copyright 2017-2020 NXP
 **
 **     Redistribution and use in source and binary forms, with or without modification,
 **     are permitted provided that the following conditions are met:
@@ -39,7 +39,7 @@
  *
  * File containing the implementation of the MX8QX MEK board.
  *
- * @addtogroup MX8QX_MEK_BRD (BRD) MX8QX MEK Board
+ * @addtogroup MX8QX_MEK_BRD BRD: MX8QX MEK Board
  *
  * Module for MX8QX MEK board access.
  *
@@ -60,14 +60,15 @@
 #include "drivers/lpi2c/fsl_lpi2c.h"
 #include "drivers/pmic/fsl_pmic.h"
 #include "drivers/pmic/pf8100/fsl_pf8100.h"
-#include "drivers/gpio/fsl_gpio.h"
-#include "drivers/igpio/fsl_igpio.h"
+#include "drivers/rgpio/fsl_rgpio.h"
+#include "drivers/igpio/fsl_gpio.h"
 #include "drivers/snvs/fsl_snvs.h"
 #include "drivers/wdog32/fsl_wdog32.h"
 #include "drivers/lpuart/fsl_lpuart.h"
 #include "drivers/drc/fsl_drc_cbt.h"
 #include "drivers/drc/fsl_drc_derate.h"
 #include "drivers/drc/fsl_drc_rdbi_deskew.h"
+#include "drivers/drc/fsl_drc_dram_vref.h"
 #include "pads.h"
 #include "drivers/pad/fsl_pad.h"
 #include "dcd/dcd_retention.h"
@@ -141,9 +142,11 @@
 /* Local Functions */
 
 static void pmic_init(void);
+#ifndef EMUL
 static sc_err_t pmic_ignore_current_limit(uint8_t address,
     pmic_version_t ver);
 static sc_err_t pmic_update_timing(uint8_t address);
+#endif
 static void board_get_pmic_info(sc_sub_t ss, uint32_t *pmic_reg,
     uint8_t *num_regs);
 
@@ -225,8 +228,8 @@ void board_init(boot_phase_t phase)
     }
     else if (phase == BOOT_PHASE_EARLY_INIT)
     {
-        igpio_pin_config_t config;
-        config.direction = kIGPIO_DigitalOutput;
+        gpio_pin_config_t config;
+        config.direction = kGPIO_DigitalOutput;
 
         /* Power on GPIO */
         pm_force_resource_power_mode_v(SC_R_GPIO_1, SC_PM_PW_MODE_ON);
@@ -237,9 +240,9 @@ void board_init(boot_phase_t phase)
 
         /* Toggle base board reset, >= 30nS */
         config.outputLogic  = 0U;
-        IGPIO_PinInit(GPIO1, 1U, &config);
+        GPIO_PinInit(GPIO1, 1U, &config);
         SYSTICK_CycleDelay(SC_SYSTICK_NSEC_TO_TICKS(30U) + 1U);
-        IGPIO_WritePinOutput(GPIO1, 1U, 1U);  
+        GPIO_WritePinOutput(GPIO1, 1U, 1U);
 
         /* Latch output */
         pad_force_mux(SC_P_SPI2_SDO, 4, SC_PAD_CONFIG_NORMAL,
@@ -251,7 +254,7 @@ void board_init(boot_phase_t phase)
     else if (phase == BOOT_PHASE_TEST_INIT)
     {
         /* Configure board for SCFW tests - only called in a unit test
-         * image. Called just before SC tests are run. 
+         * image. Called just before SC tests are run.
          */
 
         /* Configure ADMA UART pads. Needed for test_dma.
@@ -295,7 +298,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
         /* Power up UART */
         pm_force_resource_power_mode_v(SC_R_SC_UART,
             SC_PM_PW_MODE_ON);
-    
+
         /* Check if debug disabled */
         if (SCFW_DBG_READY == 0U)
         {
@@ -333,7 +336,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
 
             if (banner == SC_FALSE)
             {
-                debug_print(1, 
+                debug_print(1,
                     "
Hello from SCU (Build %u, Commit %08x, %s %s)

",
                     SCFW_BUILD, SCFW_COMMIT, SCFW_DATE, SCFW_TIME);
                 banner = SC_TRUE;
@@ -360,7 +363,7 @@ void board_disable_debug_uart(void)
             /* Disable use of UART */
             SCFW_DBG_READY = 0U;
 
-            // UART deinit to flush TX buffers 
+            // UART deinit to flush TX buffers
             LPUART_Deinit(LPUART_DEBUG);
 
             /* Turn off UART */
@@ -437,6 +440,9 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
         case BOARD_PARM_DC0_PLL1_SSC:
             rtn = BOARD_PARM_RTN_NOT_USED;
             break;
+        case BOARD_PARM_KS1_WDOG_WAKE:
+            rtn = BOARD_PARM_KS1_WDOG_WAKE_ENABLE;
+            break;
         default :
             ; /* Intentional empty default */
             break;
@@ -450,7 +456,9 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
 /*--------------------------------------------------------------------------*/
 sc_bool_t board_rsrc_avail(sc_rsrc_t rsrc)
 {
-    /* Return SC_FALSE here if a resource isn't available due to board 
+    sc_bool_t rtn = SC_TRUE;
+
+    /* Return SC_FALSE here if a resource isn't available due to board
        connections (typically lack of power). Examples incluse DRC_0/1
        and ADC. */
 
@@ -459,7 +467,16 @@ sc_bool_t board_rsrc_avail(sc_rsrc_t rsrc)
     /* Note return values are usually static. Can be made dynamic by storing
        return in a global variable and setting using board_set_control() */
 
-    return SC_TRUE;
+    if(rsrc == SC_R_PMIC_1)
+    {
+        rtn = SC_FALSE;
+    }
+    if(rsrc == SC_R_PMIC_2)
+    {
+        rtn = SC_FALSE;
+    }
+
+    return rtn;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -470,13 +487,13 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
     /*
      * Variables for DDR retention
      */
-    #ifdef BD_DDR_RET
+    #if defined(BD_DDR_RET) & !defined(SKIP_DDR)
         /* Storage for DRC registers */
         static ddrc board_ddr_ret_drc_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DRC PHY registers */
         static ddr_phy board_ddr_ret_drc_phy_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DDR regions */
         static uint32_t board_ddr_ret_buf1[BD_DDR_RET_REGION1_SIZE];
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -485,9 +502,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         #ifdef BD_DDR_RET_REGION3_SIZE
         static uint32_t board_ddr_ret_buf3[BD_DDR_RET_REGION3_SIZE];
         #endif
-        
+
         /* DDR region descriptors */
-        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] = 
+        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] =
         {
             { BD_DDR_RET_REGION1_ADDR, BD_DDR_RET_REGION1_SIZE, board_ddr_ret_buf1 },
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -499,13 +516,20 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         };
 
         /* DDR retention descriptor passed to SCFW */
-        static soc_ddr_ret_info_t board_ddr_ret_info = 
-        { 
-          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst, 
+        static soc_ddr_ret_info_t board_ddr_ret_info =
+        {
+          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst,
           BD_DDR_RET_NUM_REGION, board_ddr_ret_region
         };
     #endif
 
+    #if defined(BD_LPDDR4_INC_DQS2DQ) && defined(BOARD_DQS2DQ_SYNC)
+        static soc_dqs2dq_sync_info_t board_dqs2dq_sync_info =
+        {
+            BOARD_DQS2DQ_ISI_RSRC, BOARD_DQS2DQ_ISI_REG, BOARD_DQS2DQ_SYNC_TIME
+        };
+    #endif
+
     board_print(3, "board_init_ddr(%d)
", early);
 
     #ifdef SKIP_DDR
@@ -527,12 +551,16 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
 
         #ifdef DEBUG_BOARD
             uint32_t rate = 0U;
+            sc_err_t rate_err = SC_ERR_FAIL;
             if (rm_is_resource_avail(SC_R_DRC_0))
             {
-                (void) pm_get_clock_rate(SC_PT, SC_R_DRC_0, SC_PM_CLK_MISC0,
-                    &rate);
+                rate_err = pm_get_clock_rate(SC_PT, SC_R_DRC_0,
+                    SC_PM_CLK_SLV_BUS, &rate);
+            }
+            if (rate_err == SC_ERR_NONE)
+            {
+                board_print(1, "DDR frequency = %u
", rate * 2U);
             }
-            board_print(1, "DDR frequency = %u
", rate * 2U);
         #endif
 
         if (err == SC_ERR_NONE)
@@ -542,6 +570,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
             #endif
 
             #ifdef BD_LPDDR4_INC_DQS2DQ
+            #ifdef BOARD_DQS2DQ_SYNC
+                soc_ddr_dqs2dq_config(&board_dqs2dq_sync_info);
+            #endif
                 if (board_ddr_period_ms != 0U)
                 {
                     soc_ddr_dqs2dq_init();
@@ -650,6 +681,15 @@ sc_err_t  board_ddr_config(bool rom_caller, board_ddr_action_t action)
             }
             break;
     #endif
+        case BOARD_DDR0_VREF:
+            #if defined(MONITOR) || defined(EXPORT_MONITOR)
+                // Launch VREF training
+                DRAM_VREF_training_hw(0);
+            #else
+                // Run vref training
+                DRAM_VREF_training_sw(0);
+            #endif
+            break;
         default:
             #include "dcd/dcd.h"
             break;
@@ -661,10 +701,10 @@ sc_err_t  board_ddr_config(bool rom_caller, board_ddr_action_t action)
 /*--------------------------------------------------------------------------*/
 /* Configure the system (inc. additional resource partitions)               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
+void board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     /* This function configures the system. It usually partitions
        resources according to the system design. It must be modified by
        customers. Partitions should then be specified using the mkimage
@@ -674,17 +714,27 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 
     sc_bool_t alt_config = SC_FALSE;
     sc_bool_t no_ap = SC_FALSE;
-    
+
     /* Get boot parameters. See the Boot Flags section for defintition
        of these flags.*/
-    (void) boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
+    boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
         NULL, NULL, &no_ap);
 
     board_print(3, "board_system_config(%d, %d)
", early, alt_config);
 
+#ifndef EMUL
+    sc_rm_mr_t mr_temp;
+
+    /* Board has 3GB memory so fragment upper region and retain 1GB */
+    BRD_ERR(rm_memreg_frag(pt_boot, &mr_temp, 0x8C0000000ULL,
+        0xFFFFFFFFFULL));
+    BRD_ERR(rm_memreg_free(pt_boot, mr_temp));
+#endif
+
     /* Configure initial resource allocation (note additional allocation
        and assignments can be made by the SCFW clients at run-time */
-    if (alt_config != SC_FALSE)
+    if ((alt_config != SC_FALSE) 
+        && (rm_is_resource_avail(SC_R_M4_0_PID0) != SC_FALSE))
     {
         sc_rm_pt_t pt_m4_0;
         sc_rm_mr_t mr_m4_0;
@@ -703,11 +753,11 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_FALSE));
         BRD_ERR(rm_set_pad_movable(pt_boot, SC_P_ALL, SC_P_ALL,
             SC_FALSE));
-        
+
         /* Allocate M4_0 partition */
         BRD_ERR(rm_partition_alloc(pt_boot, &pt_m4_0, SC_FALSE, SC_TRUE,
             SC_FALSE, SC_TRUE, SC_FALSE));
-        
+
         /* Mark all M4_0 subsystem resources as movable */
         BRD_ERR(rm_set_subsys_rsrc_movable(pt_boot, SC_R_M4_0_PID0,
             SC_TRUE));
@@ -731,6 +781,8 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_R_I2C_1, SC_TRUE));
         BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_FSPI_0,
             SC_R_FSPI_0, SC_TRUE));
+        BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_SECO_MU_4,
+            SC_R_SECO_MU_4, SC_TRUE));
 
         /* Move some pads not in the M4_0 subsystem */
         BRD_ERR(rm_set_pad_movable(pt_boot, SC_P_FLEXCAN0_RX,
@@ -792,7 +844,7 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_RM_PERM_FULL));
 
         /* Protect some resources */
-        /* M4 PID1-4 can be used to allow M4 to map to other SID */      
+        /* M4 PID1-4 can be used to allow M4 to map to other SID */
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID1));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID2));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID3));
@@ -802,12 +854,6 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             rm_dump(pt_boot);
         #endif
     }
-    else
-    {
-        err = SC_ERR_UNAVAILABLE;
-    }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -821,7 +867,7 @@ sc_bool_t board_early_cpu(sc_rsrc_t cpu)
     {
         rtn = SC_TRUE;
     }
-    
+
     return rtn;
 }
 
@@ -842,6 +888,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
     /* Check for PMIC */
     if (pmic_ver.device_id != 0U)
     {
+        sc_err_t err = SC_ERR_NONE;
+
         /* Flip switch */
         if (to_mode > SC_PM_PW_MODE_OFF)
         {
@@ -849,8 +897,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
-                    SW_RUN_PWM | SW_STBY_PWM);
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
+                    SW_RUN_PWM | SW_STBY_PWM));
                 idx++;
             }
             SystemTimeDelay(PMIC_MAX_RAMP);
@@ -861,14 +909,21 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
-                    SW_RUN_OFF);
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
+                    SW_RUN_OFF));
                 idx++;
             }
         }
     }
 }
 
+/*--------------------------------------------------------------------------*/
+/* Set board power supplies when enter/exit low-power mode                  */
+/*--------------------------------------------------------------------------*/
+void board_lpm(sc_pm_power_mode_t mode)
+{
+}
+
 /*--------------------------------------------------------------------------*/
 /* Set the voltage for the given SS.                                        */
 /*--------------------------------------------------------------------------*/
@@ -894,8 +949,8 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
 
         while (idx < num_regs)
         {
-            (void) PMIC_SET_VOLTAGE(PMIC_0_ADDR, pmic_reg,
-                new_volt, REG_RUN_MODE);
+            BRD_ERR(PMIC_SET_VOLTAGE(PMIC_0_ADDR, pmic_reg,
+                new_volt, REG_RUN_MODE));
             idx++;
         }
         if ((old_volt != 0U) && (new_volt > old_volt))
@@ -913,44 +968,37 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
 /*--------------------------------------------------------------------------*/
 /* Reset a board resource                                                   */
 /*--------------------------------------------------------------------------*/
-void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx)
+void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx, sc_rm_pt_t pt)
 {
 }
 
 /*--------------------------------------------------------------------------*/
 /* Transition external board-level supply for board component               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
+void board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
     sc_pm_power_mode_t from_mode, sc_pm_power_mode_t to_mode)
 {
-    sc_err_t err = SC_ERR_NONE;
-    
-    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx, 
+    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx,
         rnames[rsrc_idx], from_mode, to_mode);
 
     /* Init PMIC */
     pmic_init();
 
-    /* Check if PMIC available */
-    ASRT_ERR(pmic_ver.device_id != 0U, SC_ERR_NOTFOUND);
-
     /* Process resource */
-    if (err == SC_ERR_NONE)
+    if (pmic_ver.device_id != 0U)
     {
         switch (idx)
         {
-            case BRD_R_BOARD_R7 : 
+            case BRD_R_BOARD_R7 :
                 /* Example for testing (use SC_R_BOARD_R7) */
                 board_print(3, "SC_R_BOARD_R7 from %u to %u
",
                     from_mode, to_mode);
                 break;
             default :
-                err = SC_ERR_PARM;
+                ; /* Intentional empty default */
                 break;
         }
     }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -965,7 +1013,7 @@ sc_err_t board_power(sc_pm_power_mode_t mode)
         /* Request power off */
         SNVS_PowerOff();
         err = snvs_err;
-        
+
         /* Loop forever */
         while(err == SC_ERR_NONE)
         {
@@ -1001,7 +1049,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
 
     #ifdef DEBUG
         /* Dump out caller of reset request */
-        always_print("Board reset (%u, caller = 0x%08X)
", reason, 
+        always_print("Board reset (%u, caller = 0x%08X)
", reason,
             __builtin_return_address(0));
     #endif
     #ifdef ALT_DEBUG_UART
@@ -1012,7 +1060,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
     /* Request a warm reset */
     soc_set_reset_info(reason, pt);
     NVIC_SystemReset();
-    
+
     return SC_ERR_UNAVAILABLE;
 }
 
@@ -1024,19 +1072,19 @@ void board_cpu_reset(sc_rsrc_t resource, board_cpu_rst_ev_t reset_event,
 {
     /* Note:  Production code should decide the response for each type
      *        of reset event.  Options include allowing the SCFW to
-     *        reset the CPU or forcing a full system reset.  Additionally, 
-     *        the number of reset attempts can be tracked to determine the 
+     *        reset the CPU or forcing a full system reset.  Additionally,
+     *        the number of reset attempts can be tracked to determine the
      *        reset response.
      */
-    
+
     /* Check for M4 reset event */
     if (resource == SC_R_M4_0_PID0)
     {
-        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource, 
+        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource,
             reset_event);
 
         /* Treat lockups or parity/ECC reset events as board faults */
-        if ((reset_event == BOARD_CPU_RESET_LOCKUP) || 
+        if ((reset_event == BOARD_CPU_RESET_LOCKUP) ||
             (reset_event == BOARD_CPU_RESET_MEM_ERR))
         {
             board_fault(SC_FALSE, BOARD_BFAULT_CPU, pt);
@@ -1087,10 +1135,11 @@ board_reboot_to_t board_reboot_timeout(sc_rm_pt_t pt)
 /*--------------------------------------------------------------------------*/
 void board_panic(sc_dsc_t dsc)
 {
+    /* See Porting Guide for more info on panic alarms */
     #ifdef DEBUG
         error_print("Panic temp (dsc=%d)
", dsc);
     #endif
-    
+
     (void) board_reset(SC_PM_RESET_TYPE_BOARD, SC_PM_RESET_REASON_TEMP,
         SC_PT);
 }
@@ -1110,6 +1159,8 @@ void board_fault(sc_bool_t restarted, sc_bfault_t reason,
         WDOG32_SetTimeoutValue(WDOG_SC, 0xFFFF);
         WDOG32_Disable(WDOG_SC);
 
+        board_print(1, "board fault(%u, %u, %u)
", restarted, reason, pt);
+
         /* Stop so developer can see WDOG occurred */
         HALT;
     #else
@@ -1150,7 +1201,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_set_control(%s, %u, %u)
", rnames[rsrc_idx], ctrl, val);
 
@@ -1168,7 +1219,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
             case SC_R_PMIC_0 :
                 if (ctrl == SC_C_TEMP_HI)
                 {
-                    temp_alarm = 
+                    temp_alarm =
                         SET_PMIC_TEMP_ALARM(PMIC_0_ADDR, val);
                 }
                 else
@@ -1204,7 +1255,7 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t *val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_get_control(%s, %u)
", rnames[rsrc_idx], ctrl);
 
@@ -1228,6 +1279,12 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
                 {
                     *val = temp_alarm;
                 }
+                else if (ctrl == SC_C_ID)
+                {
+                    pmic_version_t v = GET_PMIC_VERSION(PMIC_0_ADDR);
+
+                    *val = (U32(v.device_id) << 8U) | U32(v.si_rev);
+                }
                 else
                 {
                     err = SC_ERR_PARM;
@@ -1304,7 +1361,7 @@ static void pmic_init(void)
                 SC_PM_PW_MODE_ON);
             (void) pm_set_clock_rate(SC_PT, SC_R_SC_I2C,
                 SC_PM_CLK_PER, &rate);
-            (void) pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
+            pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
                 SC_TRUE);
 
             /* Initialize the pads used to communicate with the PMIC */
@@ -1345,23 +1402,26 @@ static void pmic_init(void)
             if(pmic_ver.si_rev == PF8100_A0_REV)
             {
                 /* Set Regulation modes for MAIN and 1.8V rails */
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1,
-                    SW_RUN_PWM | SW_STBY_PWM);
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2,
-                    SW_RUN_PWM | SW_STBY_PWM);
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW6,
-                    SW_RUN_PWM | SW_STBY_PWM);
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1,
+                    SW_RUN_PWM | SW_STBY_PWM));
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2,
+                    SW_RUN_PWM | SW_STBY_PWM));
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW6,
+                    SW_RUN_PWM | SW_STBY_PWM));
             }
 
             /* Adjust startup timing */
             err |= pmic_update_timing(PMIC_0_ADDR);
 
+            /* Enable WDI detection in Standby */
+            err |= pf8100_pmic_wdog_enable(PMIC_0_ADDR, SC_FALSE, SC_FALSE, SC_TRUE);
+
             if (err != SC_ERR_NONE)
             {
                 /* Loop so WDOG will expire */
                 HALT;
             }
-            
+
             /* Configure STBY voltage for SW1 (VDD_MAIN) */
             if (board_parameter(BOARD_PARM_KS1_RETENTION)
                 == BOARD_PARM_KS1_RETENTION_ENABLE)
@@ -1373,8 +1433,8 @@ static void pmic_init(void)
                     ks1_volt = 700U;
                 }
 
-                (void) PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, ks1_volt,
-                    REG_STBY_MODE);
+                BRD_ERR(PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, ks1_volt,
+                    REG_STBY_MODE));
             }
 
             /* Enable PMIC IRQ at NVIC level */
@@ -1385,6 +1445,7 @@ static void pmic_init(void)
     #endif
 }
 
+#ifndef EMUL
 /*--------------------------------------------------------------------------*/
 /* Bypass current limit for PF8100                                          */
 /*--------------------------------------------------------------------------*/
@@ -1455,7 +1516,7 @@ static sc_err_t pmic_ignore_current_limit(uint8_t address,
 /*--------------------------------------------------------------------------*/
 static sc_err_t pmic_update_timing(uint8_t address)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
     uint8_t val = 0xED;
 
     /*
@@ -1465,7 +1526,6 @@ static sc_err_t pmic_update_timing(uint8_t address)
      */
     if (address == PMIC_0_ADDR)
     {
-        err = SC_ERR_NONE;
         err |= PMIC_REGISTER_ACCESS(address, 0x6F, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x77, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x7F, SC_TRUE, &val);
@@ -1473,10 +1533,16 @@ static sc_err_t pmic_update_timing(uint8_t address)
         val = 0x29;
         err |= PMIC_REGISTER_ACCESS(address, 0x3C, SC_TRUE, &val);
     }
+    else
+    {
+        err = SC_ERR_PARM;
+    }
 
     return err;
 }
 
+#endif
+
 /*--------------------------------------------------------------------------*/
 /* Get the pmic ids and switchers connected to SS.                          */
 /*--------------------------------------------------------------------------*/
@@ -1515,7 +1581,7 @@ void board_tick(uint16_t msec)
 sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
     uint32_t *parm2, uint32_t *parm3)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
 
     /* For test_misc */
     if (*parm1 == 0xFFFFFFFEU)
@@ -1523,8 +1589,10 @@ sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
         *parm1 = *parm2 + *parm3;
         *parm2 = mu;
         *parm3 = caller_pt;
-
-        err = SC_ERR_NONE;
+    }
+    else
+    {
+        err = SC_ERR_PARM;
     }
 
     return err;
diff --git a/uboot-firmware/imx8q/imx8dx_dcd_lpddr4_16bit_1.2GHz.cfg b/uboot-firmware/imx8q/imx8dx_dcd_lpddr4_16bit_1.2GHz.cfg
new file mode 100755
index 0000000..8ed9715
--- /dev/null
+++ b/uboot-firmware/imx8q/imx8dx_dcd_lpddr4_16bit_1.2GHz.cfg
@@ -0,0 +1,378 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE BD_DDR_RET      /* Add/remove DDR retention */
+
+DEFINE BD_DDR_RET_NUM_DRC 1 /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION 2 /* DDR regions to save/restore */
+
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE BD_DDR_RET_REGION1_ADDR 0x80000000
+DEFINE BD_DDR_RET_REGION1_SIZE 32
+DEFINE BD_DDR_RET_REGION2_ADDR 0x80002020
+DEFINE BD_DDR_RET_REGION2_SIZE 8
+
+
+
+/*
+ * Device Configuration Data (DCD) Version 14
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1200MHz DDR, DRC 600MHz operation */
+DATA 4  0xff190000  0x00000CC8  /* DRC0 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+ return SC_ERR_NONE;
+}
+
+#endif
+
+//-------------------------------------------
+// Reset controller core domain (required to configure it)
+//--------------------------------------------
+DATA 4 0x41C80208 0x1
+DATA 4 0x41C80040 0xb
+DATA 4 0x41C80204 0x1
+
+//-------------------------------------------
+// Configure controller registers
+//--------------------------------------------
+/* DRAM controller configuration begin */
+DATA 4  DDRC_MSTR_0    0x81081020 // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_0    0x00000203 // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_0    0x0124F800 // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_0 0x0021F000
+DATA 4  DDRC_RFSHTMG_0 0x004900A8 // tREFI, tRFC
+DATA 4  DDRC_INIT0_0   0x40030495 // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_0   0x00770000 // dram_rstn = 200us
+DATA 4  DDRC_INIT3_0   0x00440024 // MR1, MR2
+DATA 4  DDRC_INIT4_0   0x00F100C0 // MR3, MR13
+DATA 4 DDRC_RANKCTL_0   0x0000066F // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4 DDRC_DRAMTMG0_0  0x1618141A // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4 DDRC_DRAMTMG1_0  0x00050526 // tXP, rd2pre, tRC
+DATA 4 DDRC_DRAMTMG2_0  0x060E1514 // WL, RL, rd2wr, wr2rd
+DATA 4 DDRC_DRAMTMG3_0  0x00909000 // tmrw, tmrd, tmod
+DATA 4 DDRC_DRAMTMG4_0  0x0B04060B // trcd, tccd, trrd, trp
+DATA 4 DDRC_DRAMTMG5_0  0x02030909 // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4 DDRC_DRAMTMG6_0  0x02020006 // tckdpde, tckdpdx, tckcsx
+DATA 4 DDRC_DRAMTMG7_0  0x00000301 // tckpde, tckpdx
+DATA 4 DDRC_DRAMTMG12_0 0x00020510 // tCMDCKE, tCKEHCMD
+DATA 4 DDRC_DRAMTMG13_0 0x0B100002 // tODTLoff, tCCDMW, tPPD
+DATA 4 DDRC_DRAMTMG14_0 0x000000AD // txsr
+DATA 4 DDRC_ZQCTL0_0    0x02580012 // tZQCAL, tZQLAT
+DATA 4 DDRC_ZQCTL1_0    0x01E0493E // tZQReset, tzq_short_interval
+DATA 4 DDRC_DFITMG0_0   0x0499820A // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4 DDRC_DFITMG1_0   0x00070303 // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4 DDRC_DFITMG2_0   0x00001708 // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4 DDRC_DFIMISC_0   0x00000005 // dfi_data_cs_polarity
+DATA 4 DDRC_DFIUPD0_0   0x00400003 // Disable the automatic dfi_ctrlupd_req generation
+DATA 4 DDRC_DFIUPD1_0   0x008000A0 // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4 DDRC_DFIUPD2_0   0x80000000 // dfi_phyupd_en
+DATA 4 DDRC_ADDRMAP0_0  0x0000001F // addrmap_cs_bit0
+DATA 4 DDRC_ADDRMAP3_0  0x1F000000 // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4 DDRC_ADDRMAP4_0  0x00001F1F // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4 DDRC_ADDRMAP1_0  0x00070707 // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4 DDRC_ADDRMAP5_0  0x06060606 // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4 DDRC_ADDRMAP6_0  0x06060606 // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4 DDRC_DBICTL_0    0x00000007 // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4 DDRC_ODTMAP_0    0x00000000 // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4 DDRC_PCTRL_0_0   0x00000001 // Enable port 0
+
+//Performance optimizations
+DATA 4 DDRC_PWRCTL_0 0x0000010A
+DATA 4 DDRC_PWRTMG_0 0x00402010
+DATA 4 DDRC_HWLPCTL_0 0x003F0001
+
+DATA 4 DDRC_SCHED_0 0x7F001F05 // 30ns delay upon read store empty if write pending, CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4 DDRC_DFILPCFG0_0 0x0700B100
+
+//-------------------------------------------
+// Release reset of controller core domain
+//--------------------------------------------
+DATA 4 0x41c80208 0x1
+DATA 4  0x41c80040 0xf
+DATA 4  0x41c80204 0x1
+
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Following are uncommented (to disable) or commented (to enable) particular byte lanes
+DATA 4 DDR_PHY_DX2GCR1_0 0x55556000 // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4 DDR_PHY_DX3GCR1_0 0x55556000 // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX4GCR1_0 0x55556000 // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR3_0  0x0029A4A4  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR3_0  0x0029A4A4  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR3_0  0x0029A4A4  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR4_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR4_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR4_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR5_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR5_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR5_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+
+// Set-up DRAM Configuration Register
+DATA 4 DDR_PHY_DCR_0 0x0000040D // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4 DDR_PHY_PGCR8_0     0x00010002
+DATA 4 DDR_PHY_DX0DQMAP0_0 0x00061032 // DQ bit 0/1/2/3/4 remapping
+DATA 4 DDR_PHY_DX0DQMAP1_0 0x00004578 // DQ bit 5/6/7 and DM remapping
+DATA 4 DDR_PHY_DX1DQMAP0_0 0x00071032 // DQ bit 0/1/2/3/4 remapping
+DATA 4 DDR_PHY_DX1DQMAP1_0 0x00004685 // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00000000  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00000000  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00000000  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00000000  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX4DQMAP0_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_DX4DQMAP1_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4 DDR_PHY_CATR0_0     0x00141000 // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4 DDR_PHY_CATR1_0     0x0103AAAA // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_0 0x000A0040 // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4 DDR_PHY_PGCR0_0 0x07001E00 // Set ADCP=1 (Address Copy) if 32-bit, else 0 if 16-bit data bus
+DATA 4 DDR_PHY_PGCR2_0 0x00F0A193 // Set tREFPRD
+DATA 4 DDR_PHY_PGCR3_0 0x050A1080 // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4 DDR_PHY_PTR0_0 0x4B025810 // tPLLPD, tPLLGS, tPHYRST
+DATA 4 DDR_PHY_PTR1_0 0x3A981518 // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4 DDR_PHY_PLLCR0_0       0x801C0000
+DATA 4 DDR_PHY_DX8SLbPLLCR0_0 0x801C0000
+SET_BIT 4 DDR_PHY_DX8SL1PLLCR0_0 0x20000000 // uncommented to disable byte lanes 2 and 3 PLL when configured for 16-bit data bus
+SET_BIT 4 DDR_PHY_DX8SL2PLLCR0_0 0x20000000 // uncommented to disable byte lanes 4 and 5 PLL when configured for 16-bit data bus
+
+// Set-up Impedance Control Register
+DATA 4 DDR_PHY_ZQCR_0 0x008B2C58 // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_0 0x0001BBBB // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_0 0x0001B9BB // Impedance control for DQ bus
+
+//-------------------------------------------
+// Launch PLL init
+//--------------------------------------------
+DATA 4  DDR_PHY_PIR_0 0x10
+DATA 4  DDR_PHY_PIR_0 0x11
+
+// Wait end of PLL init (Wait for bit 0 of PGSR0 to be '1')
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+
+//-------------------------------------------
+// Switch to boot frequency and launch DCAL+ZCAL
+//--------------------------------------------
+DATA 4  DDR_PHY_PLLCR0_0 0xA01C0000 // Put PLL in power down state
+DATA 4 DDR_PHY_DX8SLbPLLCR0_0 0xA01C0000
+// Switch to boot frequency
+DATA 4 0x41C80208 0x1 // Gate functional clock to avoid glitches
+DATA 4  0x41C80504 0x00800000 // Set bypass mode in DSC GPR control register
+DATA 4  0x41C80204 0x1 // Ungate functional clock
+// Set PLL timings for boot frequency
+DATA 4 DDR_PHY_PTR0_0 0x026012C1
+DATA 4 DDR_PHY_PTR1_0 0x01D500A9
+// Launch DCAL+ZCAL
+DATA 4  DDR_PHY_PIR_0 0x22
+DATA 4  DDR_PHY_PIR_0 0x23
+
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4 DDR_PHY_MR1_0 0x44 // Set BL, WR-PRE, nWR, RPST
+DATA 4 DDR_PHY_MR2_0 0x24 // Set RL/WL
+DATA 4 DDR_PHY_MR3_0 0xF1 // Set drive strength
+
+DATA 4 DDR_PHY_MR11_0 0x54 // Set CA and DQ ODT
+DATA 4 DDR_PHY_MR13_0 0xC0
+DATA 4 DDR_PHY_MR22_0 0x15 // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4 DDR_PHY_MR12_0 0x48
+DATA 4 DDR_PHY_MR14_0 0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4 DDR_PHY_DTPR0_0 0x0C331A09 // tRRD, tRAS, tRP, tRTP
+DATA 4 DDR_PHY_DTPR1_0 0x28300411 // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4 DDR_PHY_DTPR2_0 0x0069615A // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4 DDR_PHY_DTPR3_0 0x01800501 // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4 DDR_PHY_DTPR4_0 0x01502B0C // tRFC, tWLO, tXP
+DATA 4 DDR_PHY_DTPR5_0 0x194C160D // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4 DDR_PHY_PTR2_0 0x000A3DEF // tWLDLYS
+DATA 4 DDR_PHY_PTR3_0 0x000124F8 // tDINIT0
+DATA 4 DDR_PHY_PTR4_0 0x0000004B // tDINIT1
+DATA 4 DDR_PHY_PTR5_0 0x00001D4C // tDINIT2
+DATA 4 DDR_PHY_PTR6_0 0x00B00026 // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4 DDR_PHY_RANKIDR_0 0x00000001 // Select rank 1 to write
+DATA 4 DDR_PHY_ODTCR_0 0x00000000 // ODT of rank1 disabled
+DATA 4 DDR_PHY_RANKIDR_0 0x00000000 // Select rank 0 to write
+DATA 4 DDR_PHY_ODTCR_0 0x00000000 // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4 DDR_PHY_ACIOCR0_0 0x30070801 // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4 DDR_PHY_ACIOCR5_0 0x09000000 // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4 DDR_PHY_ACIOCR1_0 0x44000000
+// Set-up VREF Training Control Registers
+DATA 4 DDR_PHY_VTCR0_0 0xF0032008 // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4 DDR_PHY_VTCR1_0 0x07F0018F // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4 DDR_PHY_PGCR5_0 0x4
+DATA 4 DDR_PHY_PGCR6_0 0x00033200 // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4 DDR_PHY_DX0GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4 DDR_PHY_DX1GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+// DATA 4 DDR_PHY_DX2GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+// DATA 4 DDR_PHY_DX3GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4 DDR_PHY_DX0GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4 DDR_PHY_DX1GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// DATA 4 DDR_PHY_DX2GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// DATA 4 DDR_PHY_DX3GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH=0xA
+DATA 4 DDR_PHY_DX8SLbDXCTL2_0 0x001C1600
+
+//Enable PHY PLL to go into power down on DFI low power request
+DATA 4 DDR_PHY_PGCR4_0 0x001900B1
+
+// Set-up DATX8 IO Control Register
+DATA 4 DDR_PHY_DX8SLbIOCR_0 0x79000000 // I/O mode = LPDDR4
+
+//-------------------------------------------
+// Wait end of PHY initialization then launch DRAM initialization
+//-------------------------------------------
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0 0x180
+DATA 4  DDR_PHY_PIR_0 0x181
+
+//-------------------------------------------
+// Wait end of DRAM initialization then launch second DRAM initialization
+// This is required due to errata e10945:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+//-------------------------------------------
+// DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4  DDR_PHY_PTR3_0 0x0000004B
+// Launch DRAM initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0 0x100
+DATA 4  DDR_PHY_PIR_0 0x101
+
+//-------------------------------------------
+// Wait end of second DRAM initialization
+//-------------------------------------------
+CHECK_BITS_SET 4 DDR_PHY_PGSR0_0 0x1
+
+//-------------------------------------------
+// Run CBT (Command Bus Training)
+//-------------------------------------------
+//Call run_cbt(initial DDR_PHY_PTR0 value, initial DDR_PHY_PTR1 value, total_num_drc) here
+run_cbt(0x4B025810, 0x3A981518, 1);
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4  DDR_PHY_DQSDR0_0 0x00000001 // Disable drift
+SET_BIT 4  DDR_PHY_PGCR6_0 0x00000001 // Disable VT compensation
+CHECK_BITS_SET 4  DDR_PHY_PGSR1_0 0x40000000 // Disable VT compensation
+SET_BIT 4  DDR_PHY_PGCR1_0 0x00020040 // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_0 0x00010100 //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_0 0x700003FF // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_0 0x00003FFF // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4  DDR_PHY_DTCR0_0 0x000031C7 // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_0 0x00010236 // Set RANKEN
+
+// Launch Write leveling
+DATA 4  DDR_PHY_PIR_0 0x200
+DATA 4  DDR_PHY_PIR_0 0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4 DDR_PHY_PGSR0_0 0x1
+CHECK_BITS_CLR 4 DDR_PHY_PGSR0_0 0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947
+DATA 4  DDR_PHY_DX8SLbDQSCTL_0 0x012240F7
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_0 0x400
+DATA 4  DDR_PHY_PIR_0 0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0 0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4  DDR_PHY_DX8SLbDQSCTL_0 0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4 DDR_PHY_PIR_0 0x0010F800
+DATA 4 DDR_PHY_PIR_0 0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4 DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4 DDR_PHY_PGSR0_0  0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4 DDR_PHY_PGCR1_0 0x00020040 // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4 DDR_PHY_DX0GCR3_0 0x08000000
+CLR_BIT 4 DDR_PHY_DX1GCR3_0 0x08000000
+CLR_BIT 4 DDR_PHY_DX2GCR3_0 0x08000000
+CLR_BIT 4 DDR_PHY_DX3GCR3_0 0x08000000
+// Enable DQS drift detection PHY0
+DATA 4  DDR_PHY_DQSDR0_0 0x20188005
+DATA 4  DDR_PHY_DQSDR1_0 0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_0 0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41c80504 0x400
+
+// Enable VT compensation
+CLR_BIT 4 DDR_PHY_PGCR6_0 0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4 DDRC_STAT_0 0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
+
diff --git a/uboot-firmware/imx8q/imx8qm_dcd_1.6GHz.cfg b/uboot-firmware/imx8q/imx8qm_dcd_1.6GHz.cfg
new file mode 100755
index 0000000..d354b71
--- /dev/null
+++ b/uboot-firmware/imx8q/imx8qm_dcd_1.6GHz.cfg
@@ -0,0 +1,595 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET    /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC     2  /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION  6  /* DDR regions to save/restore */
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80008040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80010000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+DEFINE  BD_DDR_RET_REGION4_ADDR  0x80001000
+DEFINE  BD_DDR_RET_REGION4_SIZE  64
+DEFINE  BD_DDR_RET_REGION5_ADDR  0x80009040
+DEFINE  BD_DDR_RET_REGION5_SIZE  16
+DEFINE  BD_DDR_RET_REGION6_ADDR  0x80011000
+DEFINE  BD_DDR_RET_REGION6_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 18
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1600MHz DDR, DRC 800MHz operation */
+DATA 4  0xff148000  0x00000885  /* DRC0 bringup */
+DATA 4  0xff1a0000  0x00000885  /* DRC1 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+//-------------------------------------------
+// Reset controller core domain (required to configure it)
+//--------------------------------------------
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4  0x41a40040  0xB
+DATA 4  0x41d00040  0xB
+DATA 4  0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+
+//-------------------------------------------
+// Configure controller registers
+//--------------------------------------------
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0186A000  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0   0x0021F000
+DATA 4   DDRC_RFSHTMG_0   0x006100E0  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0     0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0     0x009E0000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0     0x0054002D  // MR1, MR2
+DATA 4   DDRC_INIT4_0     0x00F100C0  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_0     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+
+/* DRAM 1 controller initialization */
+DATA 4  DDRC_MSTR_1       0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_1   0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_1  0x0186A000  // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_1   0x0021F000
+DATA 4  DDRC_RFSHTMG_1    0x006100E0  // tREFI, tRFC
+DATA 4  DDRC_INIT0_1      0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_1      0x009E0000  // dram_rstn = 200us
+DATA 4  DDRC_INIT3_1      0x0054002D  // MR1, MR2
+DATA 4  DDRC_INIT4_1      0x00F100C0  // MR3, MR13
+DATA 4  DDRC_RANKCTL_1    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_1   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_1   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_1   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_1   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_1   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_1   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_1   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_1   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_1  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_1  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_1  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_1     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_1     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_1    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_1    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_1    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_1    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_1    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_1    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_1    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_1   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_1   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_1   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_1   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_1   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_1   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_1     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_1     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_1    0x00000001  // Enable port 0
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0   0x0000010A
+DATA 4  DDRC_PWRCTL_1   0x0000010A
+DATA 4  DDRC_PWRTMG_0   0x00402010
+DATA 4  DDRC_PWRTMG_1   0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x06FF0001
+DATA 4  DDRC_HWLPCTL_1  0x06FF0001
+
+DATA 4 DDRC_SCHED_0 0x00001F05  // CAM (32 entries)
+DATA 4 DDRC_SCHED_1 0x00001F05  // CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+DATA 4  DDRC_DFILPCFG0_1  0x0700B100
+
+//-------------------------------------------
+// Release reset of controller core domain
+//--------------------------------------------
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4   0x41a40040  0xF
+DATA 4  0x41d00040  0xF
+DATA 4   0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+
+//-------------------------------------------
+// Configure PHY registers for PHY initialization
+//--------------------------------------------
+/* DRAM 0 controller configuration begin */
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0040  // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_0  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x801C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x801C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001B9BB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+
+/* DRAM 1 controller configuration begin */
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_1  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_1  0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_1  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_1  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_1  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_1  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_1  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_1  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_1  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_1  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_1  0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_1  0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_1  0x000A0040  // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4  DDR_PHY_PGCR0_1  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_1  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_1  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_1  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_1  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_1  0x801C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0x801C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_1  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_1  0x0001B9BB  // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_1  0x0001B9BB  // Impedance control for DQ bus
+
+//-------------------------------------------
+// Launch PLL init
+//--------------------------------------------
+DATA 4   DDR_PHY_PIR_0  0x10
+DATA 4   DDR_PHY_PIR_0  0x11
+DATA 4  DDR_PHY_PIR_1  0x10
+DATA 4  DDR_PHY_PIR_1  0x11
+
+// Wait end of PLL init (Wait for bit 0 of PGSR0 to be '1')
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+//-------------------------------------------
+// Switch to boot frequency and launch DCAL+ZCAL
+//--------------------------------------------
+/* DRAM 0 */
+DATA 4   DDR_PHY_PLLCR0_0  0xA01C0000  // Put PLL in power down state
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0xA01C0000
+// Switch to boot frequency
+DATA 4  0x41a40208  0x1  // Gate functional clock to avoid glitches
+DATA 4   0x41a40504  0x00800000  // Set bypass mode in DSC GPR control register
+DATA 4   0x41a40204  0x1  // Ungate functional clock
+// Set PLL timings for boot frequency
+DATA 4  DDR_PHY_PTR0_0  0x03201901
+DATA 4  DDR_PHY_PTR1_0  0x027100E1
+// Launch DCAL+ZCAL
+DATA 4   DDR_PHY_PIR_0  0x22
+DATA 4   DDR_PHY_PIR_0  0x23
+
+/* DRAM 1 */
+DATA 4  DDR_PHY_PLLCR0_1  0xA01C0000  // Put PLL in power down state
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0xA01C0000
+// Switch to boot frequency
+DATA 4  0x41d00208  0x1
+DATA 4  0x41d00504  0x00800000
+DATA 4  0x41d00204  0x1
+// Set PLL timings for boot frequency
+DATA 4  DDR_PHY_PTR0_1  0x03201901
+DATA 4  DDR_PHY_PTR1_1  0x027100E1
+// Launch DCAL+ZCAL
+DATA 4  DDR_PHY_PIR_1  0x22
+DATA 4  DDR_PHY_PIR_1  0x23
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+/* DRAM 0 */
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR13_0  0xC0
+DATA 4  DDR_PHY_MR22_0  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF  // tWLDLYS
+DATA 4  DDR_PHY_PTR3_0  0x000186A0  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000064  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x00002710  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x00B00032  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070801  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+
+/* DRAM 1 */
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_1  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_1  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_1  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_1  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR13_1  0xC0
+DATA 4  DDR_PHY_MR22_1  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_1  0x48
+DATA 4  DDR_PHY_MR14_1  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_1  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_1  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_1  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_1  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_1  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_1  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_1  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_1  0x000186A0  // tDINIT0
+DATA 4  DDR_PHY_PTR4_1  0x00000064  // tDINIT1
+DATA 4  DDR_PHY_PTR5_1  0x00002710  // tDINIT2
+DATA 4  DDR_PHY_PTR6_1  0x00B00032  // tDINIT4, tDINIT3 (1us)
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_1  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_1  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_1  0x30070801  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_1  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_1  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_1  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_1  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_1  0x4
+DATA 4  DDR_PHY_PGCR6_1  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_1  0x001C1600
+DATA 4  DDR_PHY_PGCR4_1  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_1  0x79000000  // I/O mode = LPDDR4
+
+//-------------------------------------------
+// Wait end of PHY initialization then launch DRAM initialization
+//-------------------------------------------
+/* DRAM 0 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Launch DRAM initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+
+/* DRAM 1 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+// Launch DRAM initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x180
+DATA 4  DDR_PHY_PIR_1  0x181
+
+//-------------------------------------------
+// Wait end of DRAM initialization then launch second DRAM initialization
+// This is required due to errata e10945:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+//-------------------------------------------
+
+/* DRAM 0 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4   DDR_PHY_PTR3_0  0x00000064
+// Launch DRAM initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+
+/* DRAM 1 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4  DDR_PHY_PTR3_1  0x00000064
+// Launch DRAM initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x100
+DATA 4  DDR_PHY_PIR_1  0x101
+
+//-------------------------------------------
+// Wait end of second DRAM initialization
+//-------------------------------------------
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// DRAM 1 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+//-------------------------------------------
+// Run CBT (Command Bus Training)
+//-------------------------------------------
+//Call run_cbt(initial DDR_PHY_PTR0 value, initial DDR_PHY_PTR1 value, total_num_drc) here
+run_cbt(0x64032010, 0x4E201C20, 2);
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+CLR_BIT 4   DDR_PHY_DQSDR0_1  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_1  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_1  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_1  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_1  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_1  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_1  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4  DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+DATA 4  DDR_PHY_DTCR0_1  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_1  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+DATA 4  DDR_PHY_PIR_1  0x200
+DATA 4  DDR_PHY_PIR_1  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240B3
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00200000
+// Set DQS/DQSn glitch suppression resistor for training PHY1 to satisfy errata e10947
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x012240B3
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_1  0x400
+DATA 4  DDR_PHY_PIR_1  0x401
+
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+
+// Wait Read DQS training to complete PHY1
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x01224000
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_1  0x0010F800
+DATA 4  DDR_PHY_PIR_1  0x0010F801
+
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+RDBI_bit_deskew(1);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+DRAM_VREF_training_hw(1);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+DRAM_VREF_training_sw(1);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+DATA 4 DDR_PHY_DX8SLbDDLCTL_1 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+CLR_BIT 4  DDR_PHY_PGCR1_1  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+//DQS Drift Registers PHY1
+CLR_BIT 4  DDR_PHY_DX0GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_1  0x08000000
+// Enable DQS drift detection PHY1
+DATA 4  DDR_PHY_DQSDR0_1  0x20188005
+DATA 4  DDR_PHY_DQSDR1_1  0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_1  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41A40504  0x400
+DATA 4  0x41D00504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+CLR_BIT 4  DDR_PHY_PGCR6_1  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+CHECK_BITS_SET 4  DDRC_STAT_1  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q/imx8qm_dcd_1.6GHz_nocbt.cfg b/uboot-firmware/imx8q/imx8qm_dcd_1.6GHz_nocbt.cfg
new file mode 100755
index 0000000..053d0f0
--- /dev/null
+++ b/uboot-firmware/imx8q/imx8qm_dcd_1.6GHz_nocbt.cfg
@@ -0,0 +1,518 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET    /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC     2  /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION  6  /* DDR regions to save/restore */
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80008040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80010000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+DEFINE  BD_DDR_RET_REGION4_ADDR  0x80001000
+DEFINE  BD_DDR_RET_REGION4_SIZE  64
+DEFINE  BD_DDR_RET_REGION5_ADDR  0x80009040
+DEFINE  BD_DDR_RET_REGION5_SIZE  16
+DEFINE  BD_DDR_RET_REGION6_ADDR  0x80011000
+DEFINE  BD_DDR_RET_REGION6_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 18
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1600MHz DDR, DRC 800MHz operation */
+DATA 4  0xff148000  0x00000885  /* DRC0 bringup */
+DATA 4  0xff1a0000  0x00000885  /* DRC1 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4  0x41a40040  0xB
+DATA 4  0x41d00040  0xB
+DATA 4  0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0186A000  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0   0x0021F000
+DATA 4   DDRC_RFSHTMG_0   0x006100E0  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0     0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0     0x009E0000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0     0x0054002D  // MR1, MR2
+DATA 4   DDRC_INIT4_0     0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_0     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_0  0x00808000
+
+/* DRAM 1 controller initialization */
+DATA 4  DDRC_MSTR_1       0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_1   0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_1  0x0186A000  // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_1   0x0021F000
+DATA 4  DDRC_RFSHTMG_1    0x006100E0  // tREFI, tRFC
+DATA 4  DDRC_INIT0_1      0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_1      0x009E0000  // dram_rstn = 200us
+DATA 4  DDRC_INIT3_1      0x0054002D  // MR1, MR2
+DATA 4  DDRC_INIT4_1      0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_1    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_1   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_1   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_1   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_1   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_1   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_1   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_1   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_1   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_1  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_1  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_1  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_1     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_1     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_1    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_1    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_1    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_1    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_1    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_1    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_1    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_1   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_1   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_1   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_1   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_1   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_1   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_1     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_1     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_1    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_1  0x00808000
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0   0x0000010A
+DATA 4  DDRC_PWRCTL_1   0x0000010A
+DATA 4  DDRC_PWRTMG_0   0x00402010
+DATA 4  DDRC_PWRTMG_1   0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x06FF0001
+DATA 4  DDRC_HWLPCTL_1  0x06FF0001
+
+DATA 4 DDRC_SCHED_0 0x00001F05  // CAM (32 entries)
+DATA 4 DDRC_SCHED_1 0x00001F05  // CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+DATA 4  DDRC_DFILPCFG0_1  0x0700B100
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4   0x41a40040  0xF
+DATA 4  0x41d00040  0xF
+DATA 4   0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_0  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x001C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x001C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001B9BB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4   DDR_PHY_PIR_0  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0  0x33
+//-------------------------------------------
+// Configure registers for PHY initialization
+//-------------------------------=------------
+// Set-up DRAM 1 PHY Configuration Register
+DATA 4  DDR_PHY_DCR_1  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_1  0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_1  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_1  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_1  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_1  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_1  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_1  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_1  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_1  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_1  0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_1  0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_1  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_1  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_1  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_1  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_1  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_1  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_1  0x001C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0x001C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_1  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_1  0x0001B9BB  // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_1  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4  DDR_PHY_PIR_1  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x33
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_0  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_0  0x0030D400  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000C80  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x0004E200  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x03300640  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_1  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_1  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_1  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_1  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_1  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_1  0x48
+DATA 4  DDR_PHY_MR14_1  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_1  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_1  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_1  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_1  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_1  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_1  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_1  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_1  0x0030D400  // tDINIT0
+DATA 4  DDR_PHY_PTR4_1  0x00000C80  // tDINIT1
+DATA 4  DDR_PHY_PTR5_1  0x0004E200  // tDINIT2
+DATA 4  DDR_PHY_PTR6_1  0x03300640  // tDINIT4, tDINIT3 (1us)
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_1  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_1  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_1  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_1  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_1  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_1  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_1  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_1  0x4
+DATA 4  DDR_PHY_PGCR6_1  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_1  0x001C1600
+DATA 4  DDR_PHY_PGCR4_1  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_1  0x79000000  // I/O mode = LPDDR4
+
+// Wait PHY initialization end then launch DRAM initialization
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+// Launch DRAM 1 initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x180
+DATA 4  DDR_PHY_PIR_1  0x181
+
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// DRAM 1 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch a second time DRAM initialization due to errata e10945:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+DATA 4  DDR_PHY_PIR_1  0x100
+DATA 4  DDR_PHY_PIR_1  0x101
+
+// Wait (second time) DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+// Wait (second time) DRAM 1 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+CLR_BIT 4   DDR_PHY_DQSDR0_1  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_1  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_1  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_1  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_1  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_1  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_1  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4  DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+DATA 4  DDR_PHY_DTCR0_1  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_1  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+DATA 4  DDR_PHY_PIR_1  0x200
+DATA 4  DDR_PHY_PIR_1  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240B3
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Set DQS/DQSn glitch suppression resistor for training PHY1 to satisfy errata e10947
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x012240B3
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_1  0x400
+DATA 4  DDR_PHY_PIR_1  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+// Wait Read DQS training to complete PHY1
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+DATA 4  DDR_PHY_PIR_1  0x0010F800
+DATA 4  DDR_PHY_PIR_1  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+RDBI_bit_deskew(1);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+DRAM_VREF_training_hw(1);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+DRAM_VREF_training_sw(1);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+DATA 4 DDR_PHY_DX8SLbDDLCTL_1 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+CLR_BIT 4  DDR_PHY_PGCR1_1  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+//DQS Drift Registers PHY1
+CLR_BIT 4  DDR_PHY_DX0GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_1  0x08000000
+// Enable DQS drift detection PHY1
+DATA 4  DDR_PHY_DQSDR0_1  0x20188005
+DATA 4  DDR_PHY_DQSDR1_1  0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_1  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41A40504  0x400
+DATA 4  0x41D00504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+CLR_BIT 4  DDR_PHY_PGCR6_1  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+CHECK_BITS_SET 4  DDRC_STAT_1  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q/imx8qm_dcd_800MHz.cfg b/uboot-firmware/imx8q/imx8qm_dcd_800MHz.cfg
new file mode 100755
index 0000000..848cc69
--- /dev/null
+++ b/uboot-firmware/imx8q/imx8qm_dcd_800MHz.cfg
@@ -0,0 +1,518 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET    /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC     2  /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION  6  /* DDR regions to save/restore */
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80008040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80010000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+DEFINE  BD_DDR_RET_REGION4_ADDR  0x80001000
+DEFINE  BD_DDR_RET_REGION4_SIZE  64
+DEFINE  BD_DDR_RET_REGION5_ADDR  0x80009040
+DEFINE  BD_DDR_RET_REGION5_SIZE  16
+DEFINE  BD_DDR_RET_REGION6_ADDR  0x80011000
+DEFINE  BD_DDR_RET_REGION6_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 17
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 800MHz DDR, DRC 400MHz operation */
+DATA 4  0xff148000  0x00000C85  /* DRC0 bringup */
+DATA 4  0xff1a0000  0x00000C85  /* DRC1 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+else
+{
+/* Change to div4 output */
+DATA 4 0x41A43800 0x4C000000
+DATA 4 0x41D03800 0x4C000000
+}
+#endif
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4  0x41a40040  0xB
+DATA 4  0x41d00040  0xB
+DATA 4  0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000111  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x00C35000  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0   0x0021F000
+DATA 4   DDRC_RFSHTMG_0   0x00300070  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0     0x4002030F  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0     0x00500000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0     0x00240012  // MR1, MR2
+DATA 4   DDRC_INIT4_0     0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x10100D11  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x0003041A  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x0408100F  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00606000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x08040408  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02030606  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020004  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020310  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x00000073  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x0190000C  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x014030D4  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x048D8206  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00000B04  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_0     0x00002211  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_0  0x00808000
+
+/* DRAM 1 controller initialization */
+DATA 4  DDRC_MSTR_1       0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_1   0x00000111  // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_1  0x00C35000  // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_1   0x0021F000
+DATA 4  DDRC_RFSHTMG_1    0x00300070  // tREFI, tRFC
+DATA 4  DDRC_INIT0_1      0x4002030F  // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_1      0x00500000  // dram_rstn = 200us
+DATA 4  DDRC_INIT3_1      0x00240012  // MR1, MR2
+DATA 4  DDRC_INIT4_1      0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_1    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_1   0x10100D11  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_1   0x0003041A  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_1   0x0408100F  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_1   0x00606000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_1   0x08040408  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_1   0x02030606  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_1   0x02020004  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_1   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_1  0x00020310  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_1  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_1  0x00000073  // txsr
+DATA 4  DDRC_ZQCTL0_1     0x0190000C  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_1     0x014030D4  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_1    0x048D8206  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_1    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_1    0x00000B04  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_1    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_1    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_1    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_1    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_1   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_1   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_1   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_1   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_1   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_1   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_1     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_1     0x00002211  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_1    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_1  0x00808000
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0   0x0000010A
+DATA 4  DDRC_PWRCTL_1   0x0000010A
+DATA 4  DDRC_PWRTMG_0   0x00402010
+DATA 4  DDRC_PWRTMG_1   0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x06FF0001
+DATA 4  DDRC_HWLPCTL_1  0x06FF0001
+
+DATA 4 DDRC_SCHED_0 0x00001F05  // CAM (32 entries)
+DATA 4 DDRC_SCHED_1 0x00001F05  // CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+DATA 4  DDRC_DFILPCFG0_1  0x0700B100
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4   0x41a40040  0xF
+DATA 4  0x41d00040  0xF
+DATA 4   0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_0  0x00F06AAC  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x32019010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x27100E10  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x011C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x011C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008A2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001B9BB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4   DDR_PHY_PIR_0  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0  0x33
+//-------------------------------------------
+// Configure registers for PHY initialization
+//-------------------------------=------------
+// Set-up DRAM 1 PHY Configuration Register
+DATA 4  DDR_PHY_DCR_1  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_1  0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_1  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_1  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_1  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_1  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_1  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_1  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_1  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_1  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_1  0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_1  0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_1  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_1  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_1  0x00F06AAC  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_1  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_1  0x32019010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_1  0x27100E10  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_1  0x011C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0x011C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_1  0x008A2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_1  0x0001B9BB  // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_1  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4  DDR_PHY_PIR_1  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x33
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x24  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x12  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_0  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x08221108  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x2820040C  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x006640E6  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800301  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x00E02B09  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x11330F09  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_0  0x00186A00  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000640  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x00027100  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x01B00320  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F0016F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_1  0x24  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_1  0x12  // Set RL/WL
+DATA 4  DDR_PHY_MR3_1  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_1  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_1  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_1  0x48
+DATA 4  DDR_PHY_MR14_1  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_1  0x08221108  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_1  0x2820040C  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_1  0x006640E6  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_1  0x01800301  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_1  0x00E02B09  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_1  0x11330F09  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_1  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_1  0x00186A00  // tDINIT0
+DATA 4  DDR_PHY_PTR4_1  0x00000640  // tDINIT1
+DATA 4  DDR_PHY_PTR5_1  0x00027100  // tDINIT2
+DATA 4  DDR_PHY_PTR6_1  0x01B00320  // tDINIT4, tDINIT3 (1us)
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_1  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_1  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_1  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_1  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_1  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_1  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_1  0x07F0016F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_1  0x4
+DATA 4  DDR_PHY_PGCR6_1  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_1  0x001C1600
+DATA 4  DDR_PHY_PGCR4_1  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_1  0x79000000  // I/O mode = LPDDR4
+
+// Wait PHY initialization end then launch DRAM initialization
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+// Launch DRAM 1 initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x180
+DATA 4  DDR_PHY_PIR_1  0x181
+
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// DRAM 1 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch a second time DRAM initialization due to following Synopsys PHY bug:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+DATA 4  DDR_PHY_PIR_1  0x100
+DATA 4  DDR_PHY_PIR_1  0x101
+
+// Wait (second time) DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+// Wait (second time) DRAM 1 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+CLR_BIT 4   DDR_PHY_DQSDR0_1  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_1  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_1  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_1  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_1  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_1  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_1  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for PHY bug (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+// (FYI avoiding refresh during training leads to Denali error (CUMULATIVE_REFRESH_POSTPONE_EXCEEDS_MAX_ALLOWED).
+DATA 4   DDR_PHY_DTCR0_0  0x000071C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4   DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+DATA 4  DDR_PHY_DTCR0_1  0x000071C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_1  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+DATA 4  DDR_PHY_PIR_1  0x200
+DATA 4  DDR_PHY_PIR_1  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240F7
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Set DQS/DQSn glitch suppression resistor for training PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x012240F7
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_1  0x400
+DATA 4  DDR_PHY_PIR_1  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+// Wait Read DQS training to complete PHY1
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+DATA 4  DDR_PHY_PIR_1  0x0010F800
+DATA 4  DDR_PHY_PIR_1  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1   0x7FF40000
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+DRAM_VREF_training_hw(1);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+DRAM_VREF_training_sw(1);
+#endif
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+CLR_BIT 4  DDR_PHY_PGCR1_1  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+//DQS Drift Registers PHY1
+CLR_BIT 4  DDR_PHY_DX0GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_1  0x08000000
+// Enable DQS drift detection PHY1
+DATA 4  DDR_PHY_DQSDR0_1  0x20188005
+DATA 4  DDR_PHY_DQSDR1_1  0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_1  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41A40504  0x400
+DATA 4  0x41D00504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+CLR_BIT 4  DDR_PHY_PGCR6_1  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+CHECK_BITS_SET 4  DDRC_STAT_1  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q/imx8qx_dcd_1.2GHz.cfg b/uboot-firmware/imx8q/imx8qx_dcd_1.2GHz.cfg
new file mode 100755
index 0000000..73a7d37
--- /dev/null
+++ b/uboot-firmware/imx8q/imx8qx_dcd_1.2GHz.cfg
@@ -0,0 +1,376 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET        /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC  1  /* Number for DRCs to retain */
+DEFINE   BD_DDR_RET_NUM_REGION  3  /* DDR regions to save/restore */
+
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80004040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80008000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 14
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1200MHz DDR, DRC 600MHz operation */
+DATA 4   0xff190000   0x00000CC8   /* DRC0 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+//-------------------------------------------
+// Reset controller core domain (required to configure it)
+//--------------------------------------------
+DATA 4  0x41C80208  0x1
+DATA 4  0x41C80040  0xb
+DATA 4  0x41C80204  0x1
+
+//-------------------------------------------
+// Configure controller registers
+//--------------------------------------------
+/* DRAM controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000203  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0124F800  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0  0x0021F000
+DATA 4   DDRC_RFSHTMG_0  0x004900A8  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0    0x40030495  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0    0x00770000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0    0x00440024  // MR1, MR2
+DATA 4   DDRC_INIT4_0    0x00F100C0  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1618141A  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00050526  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x060E1514  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00909000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0B04060B  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02030909  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020006  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020510  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000AD  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x02580012  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x01E0493E  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x0499820A  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001708  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4	DDRC_ODTMAP_0     0x00000000	// rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0  0x0000010A
+DATA 4  DDRC_PWRTMG_0  0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x003F0001
+
+DATA 4 DDRC_SCHED_0 0x7F001F05  // 30ns delay upon read store empty if write pending, CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+
+//-------------------------------------------
+// Release reset of controller core domain
+//--------------------------------------------
+DATA 4  0x41c80208  0x1
+DATA 4   0x41c80040  0xf
+DATA 4   0x41c80204  0x1
+
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Following are uncommented (to disable) or commented (to enable) particular byte lanes
+// DATA 4  DDR_PHY_DX2GCR1_0  0x55556000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR1_0  0x55556000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR1_0  0x55556000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR3_0  0x0029A4A4  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR3_0  0x0029A4A4  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR3_0  0x0029A4A4  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR4_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR4_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR4_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR5_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR5_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR5_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x0003000A
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00061032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00004578  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00071032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00004685  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00016578  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00004203  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00015867  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00004320  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX4DQMAP0_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_DX4DQMAP1_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0103AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0040  // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy) if 32-bit, else 0 if 16-bit data bus
+DATA 4  DDR_PHY_PGCR2_0  0x00F0A193  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x4B025810  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x3A981518  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x801C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x801C0000
+// SET_BIT 4  DDR_PHY_DX8SL1PLLCR0_0  0x20000000  // uncommented to disable byte lanes 2 and 3 PLL when configured for 16-bit data bus
+// SET_BIT 4  DDR_PHY_DX8SL2PLLCR0_0  0x20000000  // uncommented to disable byte lanes 4 and 5 PLL when configured for 16-bit data bus
+
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008B2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001BBBB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+
+//-------------------------------------------
+// Launch PLL init
+//--------------------------------------------
+DATA 4   DDR_PHY_PIR_0  0x10
+DATA 4   DDR_PHY_PIR_0  0x11
+
+// Wait end of PLL init (Wait for bit 0 of PGSR0 to be '1')
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+
+//-------------------------------------------
+// Switch to boot frequency and launch DCAL+ZCAL
+//--------------------------------------------
+DATA 4   DDR_PHY_PLLCR0_0  0xA01C0000  // Put PLL in power down state
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0xA01C0000
+// Switch to boot frequency
+DATA 4  0x41C80208  0x1  // Gate functional clock to avoid glitches
+DATA 4   0x41C80504  0x00800000  // Set bypass mode in DSC GPR control register
+DATA 4   0x41C80204  0x1  // Ungate functional clock
+// Set PLL timings for boot frequency
+DATA 4  DDR_PHY_PTR0_0  0x026012C1
+DATA 4  DDR_PHY_PTR1_0  0x01D500A9
+// Launch DCAL+ZCAL
+DATA 4   DDR_PHY_PIR_0  0x22
+DATA 4   DDR_PHY_PIR_0  0x23
+
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x44  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x24  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA and DQ ODT
+DATA 4  DDR_PHY_MR13_0  0xC0
+DATA 4  DDR_PHY_MR22_0  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x0C331A09  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28300411  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x0069615A  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800501  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01502B0C  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x194C160D  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF  // tWLDLYS
+DATA 4  DDR_PHY_PTR3_0  0x000124F8  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x0000004B  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x00001D4C  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x00B00026  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070801  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F0018F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH=0xA
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+
+//Enable PHY PLL to go into power down on DFI low power request
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+
+//-------------------------------------------
+// Wait end of PHY initialization then launch DRAM initialization
+//-------------------------------------------
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+
+//-------------------------------------------
+// Wait end of DRAM initialization then launch second DRAM initialization
+// This is required due to errata e10945:			
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+//-------------------------------------------
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4   DDR_PHY_PTR3_0  0x0000004B
+// Launch DRAM initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+
+//-------------------------------------------
+// Wait end of second DRAM initialization
+//-------------------------------------------
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+
+//-------------------------------------------
+// Run CBT (Command Bus Training)
+//-------------------------------------------
+//Call run_cbt(initial DDR_PHY_PTR0 value, initial DDR_PHY_PTR1 value, total_num_drc) here
+run_cbt(0x4B025810, 0x3A981518, 1);
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys			
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4   DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4   DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947			
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240F7
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4   0x41c80504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q/imx8qx_dcd_1.2GHz_nocbt.cfg b/uboot-firmware/imx8q/imx8qx_dcd_1.2GHz_nocbt.cfg
new file mode 100755
index 0000000..145e460
--- /dev/null
+++ b/uboot-firmware/imx8q/imx8qx_dcd_1.2GHz_nocbt.cfg
@@ -0,0 +1,334 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET        /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC  1  /* Number for DRCs to retain */
+DEFINE   BD_DDR_RET_NUM_REGION  3  /* DDR regions to save/restore */
+
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80004040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80008000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 14
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1200MHz DDR, DRC 600MHz operation */
+DATA 4   0xff190000   0x00000CC8   /* DRC0 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+DATA 4  0x41C80208  0x1
+DATA 4  0x41C80040  0xb
+DATA 4  0x41C80204  0x1
+
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000203  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0124F800  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0  0x0021F000  // REFRESH_BURST = 7
+DATA 4   DDRC_RFSHTMG_0  0x004900A8  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0    0x40030495  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0    0x00770000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0    0x00440024  // MR1, MR2
+DATA 4   DDRC_INIT4_0    0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1618141A  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00050526  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x060E1514  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00909000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0B04060B  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02030909  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020006  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020510  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000AD  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x02580012  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x01E0493E  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x0499820A  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001708  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4	DDRC_ODTMAP_0   	0x00000000	// rank[3:0]_wr_odt, rank[3:0]_wr_odt		
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+DATA 4  DDRC_HWLPCTL_0  0x003F0001  // Enable Hardware idle period
+
+DATA 4 DDRC_SCHED_0 0x7F001F05  // 30ns delay upon read store empty if write pending, CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100  // dfi_lp_en_sr, dfi_lp_wakeup_sr config
+
+DATA 4  DDRC_DFITMG0_SHADOW_0  0x00808000
+
+DATA 4  DDRC_PWRCTL_0  0x0000010A
+DATA 4  DDRC_PWRTMG_0  0x00402010
+
+DATA 4  0x41c80208  0x1
+DATA 4   0x41c80040  0xf
+DATA 4   0x41c80204  0x1
+
+//-------------------------------------------
+// Configure registers for PHY initialization
+// Timings are computed for 1200MHz DRAM operation
+//--------------------------------------------
+// Following are uncommented (to disable) or commented (to enable) particular byte lanes
+// DATA 4  DDR_PHY_DX2GCR1_0  0x55556000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR1_0  0x55556000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR1_0  0x55556000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR3_0  0x0029A4A4  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR3_0  0x0029A4A4  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR3_0  0x0029A4A4  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR4_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR4_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR4_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR5_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR5_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR5_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x0003000A
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00061032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00004578  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00071032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00004685  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00016578  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00004203  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00015867  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00004320  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX4DQMAP0_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_DX4DQMAP1_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0103AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+// PGCR1,4,5,6,7 are untouched
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy) if 32-bit, else 0 if 16-bit data bus
+DATA 4  DDR_PHY_PGCR2_0  0x00F0A193  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x4B025810  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x3A981518  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x001C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x001C0000
+// SET_BIT 4  DDR_PHY_DX8SL1PLLCR0_0  0x20000000  // uncommented to disable byte lanes 2 and 3 PLL when configured for 16-bit data bus
+// SET_BIT 4  DDR_PHY_DX8SL2PLLCR0_0  0x20000000  // uncommented to disable byte lanes 4 and 5 PLL when configured for 16-bit data bus
+
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008B2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001BBBB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4   DDR_PHY_PIR_0  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0  0x33
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x44  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x24  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA and DQ ODT
+DATA 4  DDR_PHY_MR22_0  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x0C331A09  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28300411  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x0069615A  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800501  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01502B0C  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x194C160D  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF  // tWLDLYS
+DATA 4  DDR_PHY_PTR3_0  0x00249F00  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000960  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x0003A980  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x027004B0  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F0018F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH=0xA
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+
+//Enable PHY PLL to go into power down on DFI low power request
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+
+// Wait PHY initialization end then launch DRAM initialization
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x7FF40000  // Check that no error occured
+
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x7FF40000
+
+// Launch a second time DRAM initialization due to errata e10945:					
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+
+// Wait (second time) DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x7FF40000
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys					
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4   DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4   DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947					
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240F7
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+#endif
+
+DATA 4	DDR_PHY_DX8SLbDDLCTL_0	0x00100002			
+					
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+
+DATA 4   0x41c80504  0x400
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q/mx8dx-scfw-tcm.bin b/uboot-firmware/imx8q/mx8dx-scfw-tcm.bin
new file mode 100755
index 0000000..8d48031
Binary files /dev/null and b/uboot-firmware/imx8q/mx8dx-scfw-tcm.bin differ
diff --git a/uboot-firmware/imx8q/mx8qm-scfw-tcm.bin b/uboot-firmware/imx8q/mx8qm-scfw-tcm.bin
index 40d2f4b..49dcaa6 100755
Binary files a/uboot-firmware/imx8q/mx8qm-scfw-tcm.bin and b/uboot-firmware/imx8q/mx8qm-scfw-tcm.bin differ
diff --git a/uboot-firmware/imx8q/mx8qx-scfw-tcm.bin b/uboot-firmware/imx8q/mx8qx-scfw-tcm.bin
index 5e61487..14eb01b 100755
Binary files a/uboot-firmware/imx8q/mx8qx-scfw-tcm.bin and b/uboot-firmware/imx8q/mx8qx-scfw-tcm.bin differ
diff --git a/uboot-firmware/imx8q_car/board-imx8qm.c b/uboot-firmware/imx8q_car/board-imx8qm.c
index e65e3a6..72938f0 100755
--- a/uboot-firmware/imx8q_car/board-imx8qm.c
+++ b/uboot-firmware/imx8q_car/board-imx8qm.c
@@ -2,7 +2,7 @@
 ** ###################################################################
 **
 **     Copyright (c) 2016 Freescale Semiconductor, Inc.
-**     Copyright 2017-2019 NXP
+**     Copyright 2017-2020 NXP
 **
 **     Redistribution and use in source and binary forms, with or without modification,
 **     are permitted provided that the following conditions are met:
@@ -39,7 +39,7 @@
  *
  * File containing the implementation of the MX8QM MEK board.
  *
- * @addtogroup MX8QM_MEK_BRD (BRD) MX8QM MEK Board
+ * @addtogroup MX8QM_MEK_BRD BRD: MX8QM MEK Board
  *
  * Module for MX8QM MEK board access.
  *
@@ -60,13 +60,14 @@
 #include "drivers/lpi2c/fsl_lpi2c.h"
 #include "drivers/pmic/fsl_pmic.h"
 #include "drivers/pmic/pf8100/fsl_pf8100.h"
-#include "drivers/gpio/fsl_gpio.h"
+#include "drivers/rgpio/fsl_rgpio.h"
 #include "drivers/snvs/fsl_snvs.h"
 #include "drivers/wdog32/fsl_wdog32.h"
 #include "drivers/lpuart/fsl_lpuart.h"
 #include "drivers/drc/fsl_drc_cbt.h"
 #include "drivers/drc/fsl_drc_derate.h"
 #include "drivers/drc/fsl_drc_rdbi_deskew.h"
+#include "drivers/drc/fsl_drc_dram_vref.h"
 #include "drivers/systick/fsl_systick.h"
 #include "pads.h"
 #include "drivers/pad/fsl_pad.h"
@@ -159,7 +160,6 @@ static uint32_t temp_alarm1;
 
 static sc_rm_pt_t g_pt_boot;
 static sc_rm_pt_t g_pt_m4_1;
-static bool separate_m4_pt = false;
 /*!
  * This constant contains info to map resources to the board.
  * DO NOT CHANGE - must match object code.
@@ -221,8 +221,8 @@ const uint32_t board_ddr_derate_period_ms = 1000U;
 /*--------------------------------------------------------------------------*/
 void board_init(boot_phase_t phase)
 {
-    gpio_pin_config_t config;
-    config.pinDirection = kGPIO_DigitalOutput;
+    rgpio_pin_config_t config;
+    config.pinDirection = kRGPIO_DigitalOutput;
 
     ss_print(3, "board_init(%d)
", phase);
 
@@ -239,7 +239,7 @@ void board_init(boot_phase_t phase)
         config.outputLogic  = 0U;
         FGPIO_PinInit(FGPIOA, 1U, &config);
         SYSTICK_CycleDelay(SC_SYSTICK_NSEC_TO_TICKS(30U) + 1U);
-        FGPIO_WritePinOutput(FGPIOA, 1U, 1U);  
+        FGPIO_PinWrite(FGPIOA, 1U, 1U);
 
         /* SCU_LED on SC_GPIO_02 */
         config.outputLogic  = 1U;
@@ -258,7 +258,7 @@ void board_init(boot_phase_t phase)
     else if (phase == BOOT_PHASE_TEST_INIT)
     {
         /* Configure board for SCFW tests - only called in a unit test
-         * image. Called just before SC tests are run. 
+         * image. Called just before SC tests are run.
          */
 
         /* Configure ADMA UART pads. Needed for test_dma.
@@ -302,7 +302,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
         /* Power up UART */
         pm_force_resource_power_mode_v(SC_R_SC_UART,
             SC_PM_PW_MODE_ON);
-    
+
         /* Check if debug disabled */
         if (SCFW_DBG_READY == 0U)
         {
@@ -340,7 +340,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
 
             if (banner == SC_FALSE)
             {
-                debug_print(1, 
+                debug_print(1,
                     "
Hello from SCU (Build %u, Commit %08x, %s %s)

",
                     SCFW_BUILD, SCFW_COMMIT, SCFW_DATE, SCFW_TIME);
                 banner = SC_TRUE;
@@ -367,7 +367,7 @@ void board_disable_debug_uart(void)
             /* Disable use of UART */
             SCFW_DBG_READY = 0U;
 
-            // UART deinit to flush TX buffers 
+            // UART deinit to flush TX buffers
             LPUART_Deinit(LPUART_DEBUG);
 
             /* Turn off UART */
@@ -446,6 +446,9 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
         case BOARD_PARM_DC1_PLL1_SSC:
             rtn = BOARD_PARM_RTN_NOT_USED;
             break;
+        case BOARD_PARM_KS1_WDOG_WAKE:
+            rtn = BOARD_PARM_KS1_WDOG_WAKE_ENABLE;
+            break;
         default :
             ; /* Intentional empty default */
             break;
@@ -460,21 +463,26 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
 sc_bool_t board_rsrc_avail(sc_rsrc_t rsrc)
 {
     sc_bool_t rtn = SC_TRUE;
-    
-    /* Return SC_FALSE here if a resource isn't available due to board 
+
+    /* Return SC_FALSE here if a resource isn't available due to board
        connections (typically lack of power). Examples incluse DRC_0/1
        and ADC. */
+
+    /* The value here may be overridden by SoC fuses or emulation config */
+    
+    /* Note return values are usually static. Can be made dynamic by storing
+       return in a global variable and setting using board_set_control() */
+
     #if defined(BD_DDR_RET_NUM_DRC) && (BD_DDR_RET_NUM_DRC == 1U)
         if(rsrc == SC_R_DRC_1)
         {
             rtn = SC_FALSE;
         }
     #endif
-
-    /* The value here may be overridden by SoC fuses or emulation config */
-
-    /* Note return values are usually static. Can be made dynamic by storing
-       return in a global variable and setting using board_set_control() */
+    if(rsrc == SC_R_PMIC_2)
+    {
+        rtn = SC_FALSE;
+    }
 
     return rtn;
 }
@@ -487,13 +495,13 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
     /*
      * Variables for DDR retention
      */
-    #ifdef BD_DDR_RET
+    #if defined(BD_DDR_RET) & !defined(SKIP_DDR)
         /* Storage for DRC registers */
         static ddrc board_ddr_ret_drc_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DRC PHY registers */
         static ddr_phy board_ddr_ret_drc_phy_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DDR regions */
         static uint32_t board_ddr_ret_buf1[BD_DDR_RET_REGION1_SIZE];
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -511,9 +519,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         #ifdef BD_DDR_RET_REGION6_SIZE
         static uint32_t board_ddr_ret_buf6[BD_DDR_RET_REGION6_SIZE];
         #endif
-        
+
         /* DDR region descriptors */
-        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] = 
+        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] =
         {
             { BD_DDR_RET_REGION1_ADDR, BD_DDR_RET_REGION1_SIZE, board_ddr_ret_buf1 },
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -534,13 +542,20 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         };
 
         /* DDR retention descriptor passed to SCFW */
-        static soc_ddr_ret_info_t board_ddr_ret_info = 
-        { 
-          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst, 
+        static soc_ddr_ret_info_t board_ddr_ret_info =
+        {
+          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst,
           BD_DDR_RET_NUM_REGION, board_ddr_ret_region
         };
     #endif
 
+    #if defined(BD_LPDDR4_INC_DQS2DQ) && defined(BOARD_DQS2DQ_SYNC)
+        static soc_dqs2dq_sync_info_t board_dqs2dq_sync_info =
+        {
+            BOARD_DQS2DQ_ISI_RSRC, BOARD_DQS2DQ_ISI_REG, BOARD_DQS2DQ_SYNC_TIME
+        };
+    #endif
+
     board_print(3, "board_init_ddr(%d)
", early);
 
     #ifdef SKIP_DDR
@@ -562,21 +577,25 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
 
         #ifdef DEBUG_BOARD
             uint32_t rate = 0U;
+            sc_err_t rate_err = SC_ERR_FAIL;
             if (rm_is_resource_avail(SC_R_DRC_0))
             {
-                (void) pm_get_clock_rate(SC_PT, SC_R_DRC_0, SC_PM_CLK_MISC0,
-                    &rate);
+                rate_err = pm_get_clock_rate(SC_PT, SC_R_DRC_0,
+                    SC_PM_CLK_SLV_BUS, &rate);
             }
             else if (rm_is_resource_avail(SC_R_DRC_1))
             {
-                (void) pm_get_clock_rate(SC_PT, SC_R_DRC_1, SC_PM_CLK_MISC0,
-                    &rate);
+                rate_err = pm_get_clock_rate(SC_PT, SC_R_DRC_1,
+                    SC_PM_CLK_SLV_BUS, &rate);
             }
             else
             {
                 ; /* Intentional empty else */
             }
-            board_print(1, "DDR frequency = %u
", rate * 2U);
+            if (rate_err == SC_ERR_NONE)
+            {
+                board_print(1, "DDR frequency = %u
", rate * 2U);
+            }
         #endif
 
         if (err == SC_ERR_NONE)
@@ -586,6 +605,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
             #endif
 
             #ifdef BD_LPDDR4_INC_DQS2DQ
+            #ifdef BOARD_DQS2DQ_SYNC
+                soc_ddr_dqs2dq_config(&board_dqs2dq_sync_info);
+            #endif
                 if (board_ddr_period_ms != 0U)
                 {
                     soc_ddr_dqs2dq_init();
@@ -686,6 +708,24 @@ sc_err_t  board_ddr_config(bool rom_caller, board_ddr_action_t action)
             }
             break;
     #endif
+        case BOARD_DDR0_VREF:
+            #if defined(MONITOR) || defined(EXPORT_MONITOR)
+                // Launch VREF training
+                DRAM_VREF_training_hw(0);
+            #else
+                // Run vref training
+                DRAM_VREF_training_sw(0);
+            #endif
+            break;
+        case BOARD_DDR1_VREF:
+            #if defined(MONITOR) || defined(EXPORT_MONITOR)
+                // Launch VREF training
+                DRAM_VREF_training_hw(1);
+            #else
+                // Run vref training
+                DRAM_VREF_training_sw(1);
+            #endif
+            break;
         default:
             #include "dcd/dcd.h"
             break;
@@ -758,10 +798,11 @@ sc_err_t board_assign_resources(sc_rm_pt_t pt_src)
 /*--------------------------------------------------------------------------*/
 /* Configure the system (inc. additional resource partitions)               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
+void board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
+
     /* This function configures the system. It usually partitions
        resources according to the system design. It must be modified by
        customers. Partitions should then be specified using the mkimage
@@ -771,18 +812,28 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 
     sc_bool_t alt_config = SC_FALSE;
     sc_bool_t no_ap = SC_FALSE;
-    
+
     /* Get boot parameters. See the Boot Flags section for defintition
        of these flags.*/
-    (void) boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
+    boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
         NULL, NULL, &no_ap);
 
     board_print(3, "board_system_config(%d, %d)
", early, alt_config);
 
     g_pt_boot = pt_boot;
+#ifndef EMUL
+    sc_rm_mr_t mr_temp;
+
+    /* Board has 6GB memory so fragment upper region and retain 4GB */
+    BRD_ERR(rm_memreg_frag(pt_boot, &mr_temp, 0x980000000ULL,
+        0xFFFFFFFFFULL));
+    BRD_ERR(rm_memreg_free(pt_boot, mr_temp));
+#endif
+
     /* Configure initial resource allocation (note additional allocation
        and assignments can be made by the SCFW clients at run-time */
-    if (alt_config != SC_FALSE)
+    if ((alt_config != SC_FALSE) 
+        && (rm_is_resource_avail(SC_R_M4_0_PID0) != SC_FALSE))
     {
         sc_rm_pt_t pt_m4_0;
         sc_rm_pt_t pt_m4_1;
@@ -790,8 +841,6 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
         sc_rm_pt_t pt_sh;
         sc_rm_mr_t mr_sh;
 
-        separate_m4_pt = true;
-
         #ifdef BOARD_RM_DUMP
             rm_dump(pt_boot);
         #endif
@@ -801,11 +850,11 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_FALSE));
         BRD_ERR(rm_set_pad_movable(pt_boot, SC_P_ALL, SC_P_ALL,
             SC_FALSE));
-        
+
         /* Allocate M4_0 partition */
         BRD_ERR(rm_partition_alloc(pt_boot, &pt_m4_0, SC_FALSE, SC_TRUE,
             SC_FALSE, SC_TRUE, SC_FALSE));
-        
+
         /* Mark all M4_0 subsystem resources as movable */
         BRD_ERR(rm_set_subsys_rsrc_movable(pt_boot, SC_R_M4_0_PID0,
             SC_TRUE));
@@ -825,6 +874,8 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_R_MU_8B, SC_TRUE));
         BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_GPT_4,
             SC_R_GPT_4, SC_TRUE));
+        BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_SECO_MU_4,
+            SC_R_SECO_MU_4, SC_TRUE));
 
         /* Move everything flagged as movable */
         BRD_ERR(rm_move_all(pt_boot, pt_boot, pt_m4_0, SC_TRUE, SC_TRUE));
@@ -954,7 +1005,7 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_RM_PERM_FULL));
 
         /* Protect some resources */
-        /* M4 PID1-4 can be used to allow M4 to map to other SID */      
+        /* M4 PID1-4 can be used to allow M4 to map to other SID */
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID1));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID2));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID3));
@@ -968,12 +1019,6 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             rm_dump(pt_boot);
         #endif
     }
-    else
-    {
-        err = SC_ERR_UNAVAILABLE;
-    }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -987,7 +1032,7 @@ sc_bool_t board_early_cpu(sc_rsrc_t cpu)
     {
         rtn = SC_TRUE;
     }
-    
+
     return rtn;
 }
 
@@ -1009,6 +1054,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
     /* Check for PMIC */
     if (pmic_ver.device_id != 0U)
     {
+        sc_err_t err = SC_ERR_NONE;
+
         /* Flip switch */
         if (to_mode > SC_PM_PW_MODE_OFF)
         {
@@ -1016,8 +1063,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
-                    SW_RUN_PWM | SW_STBY_PWM);
+                BRD_ERR(PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
+                    SW_RUN_PWM | SW_STBY_PWM));
                 idx++;
             }
             SystemTimeDelay(PMIC_MAX_RAMP);
@@ -1028,8 +1075,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
-                    SW_RUN_OFF);
+                BRD_ERR(PMIC_SET_MODE(pmic_id[idx], pmic_reg[idx],
+                    SW_RUN_OFF));
                 idx++;
             }
         }
@@ -1062,8 +1109,8 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
 
         while (idx < num_regs)
         {
-            (void) PMIC_SET_VOLTAGE(pmic_id[idx], pmic_reg[idx], new_volt,
-                REG_RUN_MODE);
+            BRD_ERR(PMIC_SET_VOLTAGE(pmic_id[idx], pmic_reg[idx], new_volt,
+                REG_RUN_MODE));
             idx++;
         }
         if ((old_volt != 0U) && (new_volt > old_volt))
@@ -1078,73 +1125,105 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
     return err;
 }
 
+/*--------------------------------------------------------------------------*/
+/* Set board power supplies when enter/exit low-power mode                  */
+/*--------------------------------------------------------------------------*/
+void board_lpm(sc_pm_power_mode_t mode)
+{
+    static uint32_t vdd_memc_mode = 0U;
+
+    if (mode == SC_PM_PW_MODE_STBY)
+    {
+        /*
+         * System standby (KS1) entry allows VDD_MEMC to be gated off.
+         * Save current mode and switch off supply.
+         */
+        if (PMIC_GET_MODE(PMIC_1_ADDR, PF8100_SW5, &vdd_memc_mode)
+            == SC_ERR_NONE)
+        {
+            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, SW_STBY_OFF
+                | SW_RUN_OFF);
+        }
+    }
+    else if (mode == SC_PM_PW_MODE_ON)
+    {
+        /*
+         * System standby (KS1) exit should switch on VDD_MEMC.  Restore
+         * previous mode saved during KS1 entry.
+         */
+        if (vdd_memc_mode != 0U)
+        {
+            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, vdd_memc_mode);
+        }
+    }
+    else
+    {
+        ; /* Intentional empty else */
+    }
+}
+
 /*--------------------------------------------------------------------------*/
 /* Reset a board resource                                                   */
 /*--------------------------------------------------------------------------*/
-void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx)
+void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx, sc_rm_pt_t pt)
 {
 }
 
 /*--------------------------------------------------------------------------*/
 /* Transition external board-level supply for board component               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
+void board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
     sc_pm_power_mode_t from_mode, sc_pm_power_mode_t to_mode)
 {
-    sc_err_t err = SC_ERR_NONE;
-    
-    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx, 
+    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx,
         rnames[rsrc_idx], from_mode, to_mode);
 
     /* Init PMIC */
     pmic_init();
 
-    /* Check if PMIC available */
-    ASRT_ERR(pmic_ver.device_id != 0U, SC_ERR_NOTFOUND);
-
     /* Process resource */
-    if (err == SC_ERR_NONE)
+    if (pmic_ver.device_id != 0U)
     {
+        sc_err_t err = SC_ERR_NONE;
+
         switch (idx)
         {
             case BRD_R_BOARD_R2 : /* EMVSIM */
                 if (to_mode > SC_PM_PW_MODE_OFF)
                 {
-                    (void) PMIC_SET_VOLTAGE(PMIC_1_ADDR, PF8100_LDO1,
-                        3300, REG_RUN_MODE);
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
-                        RUN_EN_STBY_EN);
+                    BRD_ERR(PMIC_SET_VOLTAGE(PMIC_1_ADDR, PF8100_LDO1,
+                        3000, REG_RUN_MODE));
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
+                        RUN_EN_STBY_EN));
                 }
                 else
                 {
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
-                        RUN_OFF_STBY_OFF);
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO1,
+                        RUN_OFF_STBY_OFF));
                 }
                 break;
             case BRD_R_BOARD_R3 : /* USDHC2 on Base Board */
                 if (to_mode > SC_PM_PW_MODE_OFF)
                 {
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
-                        RUN_EN_STBY_EN | VSELECT_EN);
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
+                        RUN_EN_STBY_EN | VSELECT_EN));
                 }
                 else
                 {
-                    (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
-                        RUN_OFF_STBY_OFF);
+                    BRD_ERR(PMIC_SET_MODE(PMIC_1_ADDR, PF8100_LDO2,
+                        RUN_OFF_STBY_OFF));
                 }
                 break;
-            case BRD_R_BOARD_R7 : 
+            case BRD_R_BOARD_R7 :
                 /* Example for testing (use SC_R_BOARD_R7) */
                 board_print(3, "SC_R_BOARD_R7 from %u to %u
",
                     from_mode, to_mode);
                 break;
             default :
-                err = SC_ERR_PARM;
+                ; /* Intentional empty default */
                 break;
         }
     }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -1153,42 +1232,19 @@ sc_err_t board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
 sc_err_t board_power(sc_pm_power_mode_t mode)
 {
     sc_err_t err = SC_ERR_NONE;
-    static uint32_t vdd_memc_mode = 0U;
 
     if (mode == SC_PM_PW_MODE_OFF)
     {
         /* Request power off */
         SNVS_PowerOff();
         err = snvs_err;
-        
+
         /* Loop forever */
         while(err == SC_ERR_NONE)
         {
             ; /* Intentional empty while */
         }
     }
-    else if (mode == SC_PM_PW_MODE_STBY)
-    {
-        /* 
-         * System standby (KS1) entry allows VDD_MEMC to be gated off.  Save
-         * current mode and switch off supply.
-         */
-        if (PMIC_GET_MODE(PMIC_1_ADDR, PF8100_SW5, &vdd_memc_mode) == SC_ERR_NONE)
-        {
-            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, SW_STBY_OFF | SW_RUN_OFF);
-        }
-    }
-    else if (mode == SC_PM_PW_MODE_ON)
-    {
-        /* 
-         * System standby (KS1) exit should switch on VDD_MEMC.  Restore previous
-         * mode saved during KS1 entry.
-         */
-        if (vdd_memc_mode != 0U)
-        {
-            (void) PMIC_SET_MODE(PMIC_1_ADDR, PF8100_SW5, vdd_memc_mode);
-        }
-    }
     else
     {
         err = SC_ERR_PARM;
@@ -1218,7 +1274,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
 
     #ifdef DEBUG
         /* Dump out caller of reset request */
-        always_print("Board reset (%u, caller = 0x%08X)
", reason, 
+        always_print("Board reset (%u, caller = 0x%08X)
", reason,
             __builtin_return_address(0));
     #endif
     #ifdef ALT_DEBUG_UART
@@ -1229,7 +1285,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
     /* Request a warm reset */
     soc_set_reset_info(reason, pt);
     NVIC_SystemReset();
-    
+
     return SC_ERR_UNAVAILABLE;
 }
 
@@ -1241,19 +1297,19 @@ void board_cpu_reset(sc_rsrc_t resource, board_cpu_rst_ev_t reset_event,
 {
     /* Note:  Production code should decide the response for each type
      *        of reset event.  Options include allowing the SCFW to
-     *        reset the CPU or forcing a full system reset.  Additionally, 
-     *        the number of reset attempts can be tracked to determine the 
+     *        reset the CPU or forcing a full system reset.  Additionally,
+     *        the number of reset attempts can be tracked to determine the
      *        reset response.
      */
-    
+
     /* Check for M4 reset event */
     if ((resource == SC_R_M4_0_PID0) || (resource == SC_R_M4_1_PID0))
     {
-        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource, 
+        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource,
             reset_event);
 
         /* Treat lockups or parity/ECC reset events as board faults */
-        if ((reset_event == BOARD_CPU_RESET_LOCKUP) || 
+        if ((reset_event == BOARD_CPU_RESET_LOCKUP) ||
             (reset_event == BOARD_CPU_RESET_MEM_ERR))
         {
             board_fault(SC_FALSE, BOARD_BFAULT_CPU, pt);
@@ -1276,22 +1332,26 @@ void board_reboot_part(sc_rm_pt_t pt, sc_pm_reset_type_t *type,
      * rebooted.
      */
 
+    *mask = 0UL;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Trap partition reboot continue                                           */
+/*--------------------------------------------------------------------------*/
+void board_reboot_part_cont(sc_rm_pt_t pt, sc_rsrc_t *boot_cpu,
+    sc_rsrc_t *boot_mu, sc_rsrc_t *boot_dev, sc_faddr_t *boot_addr)
+{
+    /* Code can modify boot parameters on a reboot. Called after partition
+     * is powered off but before it is powered back on and started.
+     */
     sc_rm_pt_t p;
 
-    board_print(1, "partition %d reboot
", pt);
-    if ((pt == g_pt_boot) && separate_m4_pt)/* only assign resources when pt_boot reboot*/
+    if (pt == g_pt_boot)/* only assign resources when pt_boot reboot*/
     {
         /* get the owner partition of SC_R_DC_1, it's shared resource*/
         rm_get_resource_owner(pt, SC_R_DC_1, &p);
         if (p != g_pt_m4_1)
         {
-            /* Power off all peripherals, set 'base_reboot' to 'SC_TRUE' so resources
-             * will be reset.
-             */
-            base_reboot = SC_TRUE;
-            (void) pm_set_resource_power_mode(p, SC_R_ALL,
-                SC_PM_PW_MODE_OFF);
-            base_reboot = SC_FALSE;
             /* Reassign some resource to M4 partition */
             board_assign_resources(p);
         }
@@ -1299,19 +1359,6 @@ void board_reboot_part(sc_rm_pt_t pt, sc_pm_reset_type_t *type,
         MU_Type *base = (MU_Type *)LSIO_MU12A_BASE;/* MU_12A */
         (void) MU_TriggerInterrupts(base, MU_CR_GIRn(SC_RPC_MU_GIR_SVC));
     }
-
-    *mask = 0UL;
-}
-
-/*--------------------------------------------------------------------------*/
-/* Trap partition reboot continue                                           */
-/*--------------------------------------------------------------------------*/
-void board_reboot_part_cont(sc_rm_pt_t pt, sc_rsrc_t *boot_cpu,
-    sc_rsrc_t *boot_mu, sc_rsrc_t *boot_dev, sc_faddr_t *boot_addr)
-{
-    /* Code can modify boot parameters on a reboot. Called after partition
-     * is powered off but before it is powered back on and started.
-     */
 }
 
 /*--------------------------------------------------------------------------*/
@@ -1329,10 +1376,11 @@ board_reboot_to_t board_reboot_timeout(sc_rm_pt_t pt)
 /*--------------------------------------------------------------------------*/
 void board_panic(sc_dsc_t dsc)
 {
+    /* See Porting Guide for more info on panic alarms */
     #ifdef DEBUG
         error_print("Panic temp (dsc=%d)
", dsc);
     #endif
-    
+
     (void) board_reset(SC_PM_RESET_TYPE_BOARD, SC_PM_RESET_REASON_TEMP,
         SC_PT);
 }
@@ -1352,6 +1400,8 @@ void board_fault(sc_bool_t restarted, sc_bfault_t reason,
         WDOG32_SetTimeoutValue(WDOG_SC, 0xFFFF);
         WDOG32_Disable(WDOG_SC);
 
+        board_print(1, "board fault(%u, %u, %u)
", restarted, reason, pt);
+
         /* Stop so developer can see WDOG occurred */
         HALT;
     #else
@@ -1392,7 +1442,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_set_control(%s, %u, %u)
", rnames[rsrc_idx], ctrl, val);
 
@@ -1410,7 +1460,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
             case SC_R_PMIC_0 :
                 if (ctrl == SC_C_TEMP_HI)
                 {
-                    temp_alarm0 = 
+                    temp_alarm0 =
                         SET_PMIC_TEMP_ALARM(PMIC_0_ADDR, val);
                 }
                 else
@@ -1421,7 +1471,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
             case SC_R_PMIC_1 :
                 if (ctrl == SC_C_TEMP_HI)
                 {
-                    temp_alarm1 = 
+                    temp_alarm1 =
                         SET_PMIC_TEMP_ALARM(PMIC_1_ADDR, val);
                 }
                 else
@@ -1457,7 +1507,7 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t *val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_get_control(%s, %u)
", rnames[rsrc_idx], ctrl);
 
@@ -1481,6 +1531,12 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
                 {
                     *val = temp_alarm0;
                 }
+                else if (ctrl == SC_C_ID)
+                {
+                    pmic_version_t v = GET_PMIC_VERSION(PMIC_0_ADDR);
+
+                    *val = (U32(v.device_id) << 8U) | U32(v.si_rev);
+                }
                 else
                 {
                     err = SC_ERR_PARM;
@@ -1495,6 +1551,12 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
                 {
                     *val = temp_alarm1;
                 }
+                else if (ctrl == SC_C_ID)
+                {
+                    pmic_version_t v = GET_PMIC_VERSION(PMIC_1_ADDR);
+
+                    *val = (U32(v.device_id) << 8U) | U32(v.si_rev);
+                }
                 else
                 {
                     err = SC_ERR_PARM;
@@ -1577,7 +1639,7 @@ static void pmic_init(void)
                 SC_PM_PW_MODE_ON);
             (void) pm_set_clock_rate(SC_PT, SC_R_SC_I2C,
                 SC_PM_CLK_PER, &rate);
-            (void) pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
+            pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
                 SC_TRUE);
 
             /* Initialize the pads used to communicate with the PMIC */
@@ -1622,25 +1684,29 @@ static void pmic_init(void)
             err |= pmic_match_otp(PMIC_0_ADDR, pmic_ver);
             err |= pmic_match_otp(PMIC_1_ADDR, pmic_ver);
 
+            /* Enable WDI detection in Standby */
+            err |= pf8100_pmic_wdog_enable(PMIC_0_ADDR, SC_FALSE, SC_FALSE, SC_TRUE);
+            err |= pf8100_pmic_wdog_enable(PMIC_1_ADDR, SC_FALSE, SC_FALSE, SC_TRUE);
+
             if (err != SC_ERR_NONE)
             {
                 /* Loop so WDOG will expire */
                 HALT;
             }
 
-            (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1, SW_RUN_PWM
-                | SW_STBY_PWM);
-            (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2, SW_RUN_PWM
-                | SW_STBY_PWM);
-            (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW7, SW_RUN_PWM
-                | SW_STBY_PWM);
-            
+            BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1, SW_RUN_PWM
+                | SW_STBY_PWM));
+            BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2, SW_RUN_PWM
+                | SW_STBY_PWM));
+            BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW7, SW_RUN_PWM
+                | SW_STBY_PWM));
+
             /* Configure STBY voltage for SW1 (VDD_MAIN) */
             if (board_parameter(BOARD_PARM_KS1_RETENTION)
                 == BOARD_PARM_KS1_RETENTION_ENABLE)
             {
-                (void) PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, 800,
-                    REG_STBY_MODE);
+                BRD_ERR(PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, 800,
+                    REG_STBY_MODE));
             }
 
             /* Enable PMIC IRQ at NVIC level */
@@ -1717,7 +1783,7 @@ static sc_err_t pmic_ignore_current_limit(uint8_t address)
 /*--------------------------------------------------------------------------*/
 static sc_err_t pmic_update_timing(uint8_t address)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
     uint8_t val = 0xED;
 
     /*
@@ -1730,7 +1796,6 @@ static sc_err_t pmic_update_timing(uint8_t address)
      */
     if (address == PMIC_0_ADDR)
     {
-        err = SC_ERR_NONE;
         err |= PMIC_REGISTER_ACCESS(address, 0x8D, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x77, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x7F, SC_TRUE, &val);
@@ -1739,7 +1804,6 @@ static sc_err_t pmic_update_timing(uint8_t address)
     }
     else if (address == PMIC_1_ADDR)
     {
-        err = SC_ERR_NONE;
         err |= PMIC_REGISTER_ACCESS(address, 0x8D, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x6F, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x77, SC_TRUE, &val);
@@ -1749,18 +1813,18 @@ static sc_err_t pmic_update_timing(uint8_t address)
     }
     else
     {
-        ; /* Intentional empty else */
+        err = SC_ERR_PARM;
     }
 
     return err;
 }
 
 /*--------------------------------------------------------------------------*/
-/* Check correct version of OTP for PF8100                                          */
+/* Check correct version of OTP for PF8100                                  */
 /*--------------------------------------------------------------------------*/
 static sc_err_t pmic_match_otp(uint8_t address, pmic_version_t ver)
 {
-    uint8_t reg_value = 0;
+    uint8_t reg_value = 0U;
     uint16_t prog_id, match;
     sc_err_t err = SC_ERR_NONE;
 
@@ -1775,12 +1839,12 @@ static sc_err_t pmic_match_otp(uint8_t address, pmic_version_t ver)
 
     /* Read Prog ID */
     err |= PMIC_REGISTER_ACCESS(address, 0x2, SC_FALSE, &reg_value);
-    prog_id = ((reg_value << 4U) & 0x0F00U);
+    prog_id = (((uint16_t)reg_value << 4U) & 0x0F00U);
     err |= PMIC_REGISTER_ACCESS(address, 0x3, SC_FALSE, &reg_value);
     prog_id |= reg_value;
 
     /* test against calibration fusing */
-    if (OTP_PROG_FUSE_VERSION_1_7V_CAL != 0)
+    if (OTP_PROG_FUSE_VERSION_1_7V_CAL != 0U)
     {
         if (ver.si_rev >= PF8100_C1_SI_REV)
         {
@@ -1873,7 +1937,7 @@ void board_tick(uint16_t msec)
 sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
     uint32_t *parm2, uint32_t *parm3)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
 
     /* For test_misc */
     if (*parm1 == 0xFFFFFFFEU)
@@ -1881,13 +1945,14 @@ sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
         *parm1 = *parm2 + *parm3;
         *parm2 = mu;
         *parm3 = caller_pt;
-
-        err = SC_ERR_NONE;
     } else if (*parm1 == 0x1U) {
-	/* XEN will use this param to let scfw trigger interrupt to M41 */
-	MU_Type *base = (MU_Type *)LSIO_MU12A_BASE;/* MU_12A */
-	(void) MU_TriggerInterrupts(base, MU_CR_GIRn(SC_RPC_MU_GIR_SVC));
-	err = SC_ERR_NONE;
+        /* XEN will use this param to let scfw trigger interrupt to M41 */
+        MU_Type *base = (MU_Type *)LSIO_MU12A_BASE;/* MU_12A */
+        (void) MU_TriggerInterrupts(base, MU_CR_GIRn(SC_RPC_MU_GIR_SVC));
+    }
+    else
+    {
+        err = SC_ERR_PARM;
     }
 
     return err;
diff --git a/uboot-firmware/imx8q_car/board-imx8qxp.c b/uboot-firmware/imx8q_car/board-imx8qxp.c
index b746409..5c3db50 100755
--- a/uboot-firmware/imx8q_car/board-imx8qxp.c
+++ b/uboot-firmware/imx8q_car/board-imx8qxp.c
@@ -2,7 +2,7 @@
 ** ###################################################################
 **
 **     Copyright (c) 2016 Freescale Semiconductor, Inc.
-**     Copyright 2017-2019 NXP
+**     Copyright 2017-2020 NXP
 **
 **     Redistribution and use in source and binary forms, with or without modification,
 **     are permitted provided that the following conditions are met:
@@ -39,7 +39,7 @@
  *
  * File containing the implementation of the MX8QX MEK board.
  *
- * @addtogroup MX8QX_MEK_BRD (BRD) MX8QX MEK Board
+ * @addtogroup MX8QX_MEK_BRD BRD: MX8QX MEK Board
  *
  * Module for MX8QX MEK board access.
  *
@@ -60,14 +60,15 @@
 #include "drivers/lpi2c/fsl_lpi2c.h"
 #include "drivers/pmic/fsl_pmic.h"
 #include "drivers/pmic/pf8100/fsl_pf8100.h"
-#include "drivers/gpio/fsl_gpio.h"
-#include "drivers/igpio/fsl_igpio.h"
+#include "drivers/rgpio/fsl_rgpio.h"
+#include "drivers/igpio/fsl_gpio.h"
 #include "drivers/snvs/fsl_snvs.h"
 #include "drivers/wdog32/fsl_wdog32.h"
 #include "drivers/lpuart/fsl_lpuart.h"
 #include "drivers/drc/fsl_drc_cbt.h"
 #include "drivers/drc/fsl_drc_derate.h"
 #include "drivers/drc/fsl_drc_rdbi_deskew.h"
+#include "drivers/drc/fsl_drc_dram_vref.h"
 #include "pads.h"
 #include "drivers/pad/fsl_pad.h"
 #include "dcd/dcd_retention.h"
@@ -144,9 +145,11 @@
 /* Local Functions */
 
 static void pmic_init(void);
+#ifndef EMUL
 static sc_err_t pmic_ignore_current_limit(uint8_t address,
     pmic_version_t ver);
 static sc_err_t pmic_update_timing(uint8_t address);
+#endif
 static void board_get_pmic_info(sc_sub_t ss, uint32_t *pmic_reg,
     uint8_t *num_regs);
 
@@ -157,7 +160,6 @@ static uint32_t temp_alarm;
 static sc_rm_pt_t g_pt_boot;
 static sc_rm_pt_t g_pt_m4_0;
 
-static bool separate_m4_pt = false;
 /*!
  * This constant contains info to map resources to the board.
  * DO NOT CHANGE - must match object code.
@@ -231,8 +233,8 @@ void board_init(boot_phase_t phase)
     }
     else if (phase == BOOT_PHASE_EARLY_INIT)
     {
-        igpio_pin_config_t config;
-        config.direction = kIGPIO_DigitalOutput;
+        gpio_pin_config_t config;
+        config.direction = kGPIO_DigitalOutput;
 
         /* Power on GPIO */
         pm_force_resource_power_mode_v(SC_R_GPIO_1, SC_PM_PW_MODE_ON);
@@ -243,9 +245,9 @@ void board_init(boot_phase_t phase)
 
         /* Toggle base board reset, >= 30nS */
         config.outputLogic  = 0U;
-        IGPIO_PinInit(GPIO1, 1U, &config);
+        GPIO_PinInit(GPIO1, 1U, &config);
         SYSTICK_CycleDelay(SC_SYSTICK_NSEC_TO_TICKS(30U) + 1U);
-        IGPIO_WritePinOutput(GPIO1, 1U, 1U);  
+        GPIO_WritePinOutput(GPIO1, 1U, 1U);
 
         /* Latch output */
         pad_force_mux(SC_P_SPI2_SDO, 4, SC_PAD_CONFIG_NORMAL,
@@ -257,7 +259,7 @@ void board_init(boot_phase_t phase)
     else if (phase == BOOT_PHASE_TEST_INIT)
     {
         /* Configure board for SCFW tests - only called in a unit test
-         * image. Called just before SC tests are run. 
+         * image. Called just before SC tests are run.
          */
 
         /* Configure ADMA UART pads. Needed for test_dma.
@@ -301,7 +303,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
         /* Power up UART */
         pm_force_resource_power_mode_v(SC_R_SC_UART,
             SC_PM_PW_MODE_ON);
-    
+
         /* Check if debug disabled */
         if (SCFW_DBG_READY == 0U)
         {
@@ -339,7 +341,7 @@ void board_config_debug_uart(sc_bool_t early_phase)
 
             if (banner == SC_FALSE)
             {
-                debug_print(1, 
+                debug_print(1,
                     "
Hello from SCU (Build %u, Commit %08x, %s %s)

",
                     SCFW_BUILD, SCFW_COMMIT, SCFW_DATE, SCFW_TIME);
                 banner = SC_TRUE;
@@ -366,7 +368,7 @@ void board_disable_debug_uart(void)
             /* Disable use of UART */
             SCFW_DBG_READY = 0U;
 
-            // UART deinit to flush TX buffers 
+            // UART deinit to flush TX buffers
             LPUART_Deinit(LPUART_DEBUG);
 
             /* Turn off UART */
@@ -443,6 +445,9 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
         case BOARD_PARM_DC0_PLL1_SSC:
             rtn = BOARD_PARM_RTN_NOT_USED;
             break;
+        case BOARD_PARM_KS1_WDOG_WAKE:
+            rtn = BOARD_PARM_KS1_WDOG_WAKE_ENABLE;
+            break;
         default :
             ; /* Intentional empty default */
             break;
@@ -456,7 +461,9 @@ board_parm_rtn_t board_parameter(board_parm_t parm)
 /*--------------------------------------------------------------------------*/
 sc_bool_t board_rsrc_avail(sc_rsrc_t rsrc)
 {
-    /* Return SC_FALSE here if a resource isn't available due to board 
+    sc_bool_t rtn = SC_TRUE;
+
+    /* Return SC_FALSE here if a resource isn't available due to board
        connections (typically lack of power). Examples incluse DRC_0/1
        and ADC. */
 
@@ -465,7 +472,16 @@ sc_bool_t board_rsrc_avail(sc_rsrc_t rsrc)
     /* Note return values are usually static. Can be made dynamic by storing
        return in a global variable and setting using board_set_control() */
 
-    return SC_TRUE;
+    if(rsrc == SC_R_PMIC_1)
+    {
+        rtn = SC_FALSE;
+    }
+    if(rsrc == SC_R_PMIC_2)
+    {
+        rtn = SC_FALSE;
+    }
+
+    return rtn;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -476,13 +492,13 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
     /*
      * Variables for DDR retention
      */
-    #ifdef BD_DDR_RET
+    #if defined(BD_DDR_RET) & !defined(SKIP_DDR)
         /* Storage for DRC registers */
         static ddrc board_ddr_ret_drc_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DRC PHY registers */
         static ddr_phy board_ddr_ret_drc_phy_inst[BD_DDR_RET_NUM_DRC];
-        
+
         /* Storage for DDR regions */
         static uint32_t board_ddr_ret_buf1[BD_DDR_RET_REGION1_SIZE];
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -491,9 +507,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         #ifdef BD_DDR_RET_REGION3_SIZE
         static uint32_t board_ddr_ret_buf3[BD_DDR_RET_REGION3_SIZE];
         #endif
-        
+
         /* DDR region descriptors */
-        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] = 
+        static const soc_ddr_ret_region_t board_ddr_ret_region[BD_DDR_RET_NUM_REGION] =
         {
             { BD_DDR_RET_REGION1_ADDR, BD_DDR_RET_REGION1_SIZE, board_ddr_ret_buf1 },
         #ifdef BD_DDR_RET_REGION2_SIZE
@@ -505,13 +521,20 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
         };
 
         /* DDR retention descriptor passed to SCFW */
-        static soc_ddr_ret_info_t board_ddr_ret_info = 
-        { 
-          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst, 
+        static soc_ddr_ret_info_t board_ddr_ret_info =
+        {
+          BD_DDR_RET_NUM_DRC, board_ddr_ret_drc_inst, board_ddr_ret_drc_phy_inst,
           BD_DDR_RET_NUM_REGION, board_ddr_ret_region
         };
     #endif
 
+    #if defined(BD_LPDDR4_INC_DQS2DQ) && defined(BOARD_DQS2DQ_SYNC)
+        static soc_dqs2dq_sync_info_t board_dqs2dq_sync_info =
+        {
+            BOARD_DQS2DQ_ISI_RSRC, BOARD_DQS2DQ_ISI_REG, BOARD_DQS2DQ_SYNC_TIME
+        };
+    #endif
+
     board_print(3, "board_init_ddr(%d)
", early);
 
     #ifdef SKIP_DDR
@@ -533,12 +556,16 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
 
         #ifdef DEBUG_BOARD
             uint32_t rate = 0U;
+            sc_err_t rate_err = SC_ERR_FAIL;
             if (rm_is_resource_avail(SC_R_DRC_0))
             {
-                (void) pm_get_clock_rate(SC_PT, SC_R_DRC_0, SC_PM_CLK_MISC0,
-                    &rate);
+                rate_err = pm_get_clock_rate(SC_PT, SC_R_DRC_0,
+                    SC_PM_CLK_SLV_BUS, &rate);
+            }
+            if (rate_err == SC_ERR_NONE)
+            {
+                board_print(1, "DDR frequency = %u
", rate * 2U);
             }
-            board_print(1, "DDR frequency = %u
", rate * 2U);
         #endif
 
         if (err == SC_ERR_NONE)
@@ -548,6 +575,9 @@ sc_err_t board_init_ddr(sc_bool_t early, sc_bool_t ddr_initialized)
             #endif
 
             #ifdef BD_LPDDR4_INC_DQS2DQ
+            #ifdef BOARD_DQS2DQ_SYNC
+                soc_ddr_dqs2dq_config(&board_dqs2dq_sync_info);
+            #endif
                 if (board_ddr_period_ms != 0U)
                 {
                     soc_ddr_dqs2dq_init();
@@ -656,6 +686,15 @@ sc_err_t  board_ddr_config(bool rom_caller, board_ddr_action_t action)
             }
             break;
     #endif
+        case BOARD_DDR0_VREF:
+            #if defined(MONITOR) || defined(EXPORT_MONITOR)
+                // Launch VREF training
+                DRAM_VREF_training_hw(0);
+            #else
+                // Run vref training
+                DRAM_VREF_training_sw(0);
+            #endif
+            break;
         default:
             #include "dcd/dcd.h"
             break;
@@ -719,10 +758,10 @@ sc_err_t board_assign_resources(sc_rm_pt_t pt_src)
 /*--------------------------------------------------------------------------*/
 /* Configure the system (inc. additional resource partitions)               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
+void board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     /* This function configures the system. It usually partitions
        resources according to the system design. It must be modified by
        customers. Partitions should then be specified using the mkimage
@@ -732,26 +771,34 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
 
     sc_bool_t alt_config = SC_FALSE;
     sc_bool_t no_ap = SC_FALSE;
-    
+
     /* Get boot parameters. See the Boot Flags section for defintition
        of these flags.*/
-    (void) boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
+    boot_get_data(NULL, NULL, NULL, NULL, NULL, NULL, &alt_config,
         NULL, NULL, &no_ap);
 
     board_print(3, "board_system_config(%d, %d)
", early, alt_config);
 
     g_pt_boot = pt_boot;
+#ifndef EMUL
+    sc_rm_mr_t mr_temp;
+
+    /* Board has 3GB memory so fragment upper region and retain 1GB */
+    BRD_ERR(rm_memreg_frag(pt_boot, &mr_temp, 0x8C0000000ULL,
+        0xFFFFFFFFFULL));
+    BRD_ERR(rm_memreg_free(pt_boot, mr_temp));
+#endif
+
     /* Configure initial resource allocation (note additional allocation
        and assignments can be made by the SCFW clients at run-time */
-    if (alt_config != SC_FALSE)
+    if ((alt_config != SC_FALSE) 
+        && (rm_is_resource_avail(SC_R_M4_0_PID0) != SC_FALSE))
     {
         sc_rm_pt_t pt_m4_0;
         sc_rm_mr_t mr_m4_0;
         sc_rm_pt_t pt_sh;
         sc_rm_mr_t mr_sh;
 
-        separate_m4_pt = true;
-
         #ifdef BOARD_RM_DUMP
             rm_dump(pt_boot);
         #endif
@@ -764,12 +811,12 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_FALSE));
         BRD_ERR(rm_set_pad_movable(pt_boot, SC_P_ALL, SC_P_ALL,
             SC_FALSE));
-        
+
         /* Allocate M4_0 partition */
         BRD_ERR(rm_partition_alloc(pt_boot, &pt_m4_0, SC_FALSE, SC_TRUE,
             SC_FALSE, SC_TRUE, SC_FALSE));
-	g_pt_m4_0 = pt_m4_0;
-        
+        g_pt_m4_0 = pt_m4_0;
+
         /* Mark all M4_0 subsystem resources as movable */
         BRD_ERR(rm_set_subsys_rsrc_movable(pt_boot, SC_R_M4_0_PID0,
             SC_TRUE));
@@ -795,6 +842,8 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_R_I2C_1, SC_TRUE));
         BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_FSPI_0,
             SC_R_FSPI_0, SC_TRUE));
+        BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_SECO_MU_4,
+            SC_R_SECO_MU_4, SC_TRUE));
         BRD_ERR(rm_set_resource_movable(pt_boot, SC_R_M4_0_INTMUX,
             SC_R_M4_0_INTMUX, SC_TRUE));
 
@@ -863,7 +912,7 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             SC_RM_PERM_FULL));
 
         /* Protect some resources */
-        /* M4 PID1-4 can be used to allow M4 to map to other SID */      
+        /* M4 PID1-4 can be used to allow M4 to map to other SID */
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID1));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID2));
         BRD_ERR(rm_assign_resource(pt_m4_0, pt_sh, SC_R_M4_0_PID3));
@@ -873,12 +922,6 @@ sc_err_t board_system_config(sc_bool_t early, sc_rm_pt_t pt_boot)
             rm_dump(pt_boot);
         #endif
     }
-    else
-    {
-        err = SC_ERR_UNAVAILABLE;
-    }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -892,7 +935,7 @@ sc_bool_t board_early_cpu(sc_rsrc_t cpu)
     {
         rtn = SC_TRUE;
     }
-    
+
     return rtn;
 }
 
@@ -913,6 +956,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
     /* Check for PMIC */
     if (pmic_ver.device_id != 0U)
     {
+        sc_err_t err = SC_ERR_NONE;
+
         /* Flip switch */
         if (to_mode > SC_PM_PW_MODE_OFF)
         {
@@ -920,8 +965,8 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
-                    SW_RUN_PWM | SW_STBY_PWM);
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
+                    SW_RUN_PWM | SW_STBY_PWM));
                 idx++;
             }
             SystemTimeDelay(PMIC_MAX_RAMP);
@@ -932,14 +977,21 @@ void board_set_power_mode(sc_sub_t ss, uint8_t pd,
 
             while (idx < num_regs)
             {
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
-                    SW_RUN_OFF);
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, pmic_reg,
+                    SW_RUN_OFF));
                 idx++;
             }
         }
     }
 }
 
+/*--------------------------------------------------------------------------*/
+/* Set board power supplies when enter/exit low-power mode                  */
+/*--------------------------------------------------------------------------*/
+void board_lpm(sc_pm_power_mode_t mode)
+{
+}
+
 /*--------------------------------------------------------------------------*/
 /* Set the voltage for the given SS.                                        */
 /*--------------------------------------------------------------------------*/
@@ -965,8 +1017,8 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
 
         while (idx < num_regs)
         {
-            (void) PMIC_SET_VOLTAGE(PMIC_0_ADDR, pmic_reg,
-                new_volt, REG_RUN_MODE);
+            BRD_ERR(PMIC_SET_VOLTAGE(PMIC_0_ADDR, pmic_reg,
+                new_volt, REG_RUN_MODE));
             idx++;
         }
         if ((old_volt != 0U) && (new_volt > old_volt))
@@ -984,44 +1036,37 @@ sc_err_t board_set_voltage(sc_sub_t ss, uint32_t new_volt, uint32_t old_volt)
 /*--------------------------------------------------------------------------*/
 /* Reset a board resource                                                   */
 /*--------------------------------------------------------------------------*/
-void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx)
+void board_rsrc_reset(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx, sc_rm_pt_t pt)
 {
 }
 
 /*--------------------------------------------------------------------------*/
 /* Transition external board-level supply for board component               */
 /*--------------------------------------------------------------------------*/
-sc_err_t board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
+void board_trans_resource_power(sc_rm_idx_t idx, sc_rm_idx_t rsrc_idx,
     sc_pm_power_mode_t from_mode, sc_pm_power_mode_t to_mode)
 {
-    sc_err_t err = SC_ERR_NONE;
-    
-    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx, 
+    board_print(3, "board_trans_resource_power(%d, %s, %u, %u)
", idx,
         rnames[rsrc_idx], from_mode, to_mode);
 
     /* Init PMIC */
     pmic_init();
 
-    /* Check if PMIC available */
-    ASRT_ERR(pmic_ver.device_id != 0U, SC_ERR_NOTFOUND);
-
     /* Process resource */
-    if (err == SC_ERR_NONE)
+    if (pmic_ver.device_id != 0U)
     {
         switch (idx)
         {
-            case BRD_R_BOARD_R7 : 
+            case BRD_R_BOARD_R7 :
                 /* Example for testing (use SC_R_BOARD_R7) */
                 board_print(3, "SC_R_BOARD_R7 from %u to %u
",
                     from_mode, to_mode);
                 break;
             default :
-                err = SC_ERR_PARM;
+                ; /* Intentional empty default */
                 break;
         }
     }
-
-    return err;
 }
 
 /*--------------------------------------------------------------------------*/
@@ -1036,7 +1081,7 @@ sc_err_t board_power(sc_pm_power_mode_t mode)
         /* Request power off */
         SNVS_PowerOff();
         err = snvs_err;
-        
+
         /* Loop forever */
         while(err == SC_ERR_NONE)
         {
@@ -1072,7 +1117,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
 
     #ifdef DEBUG
         /* Dump out caller of reset request */
-        always_print("Board reset (%u, caller = 0x%08X)
", reason, 
+        always_print("Board reset (%u, caller = 0x%08X)
", reason,
             __builtin_return_address(0));
     #endif
     #ifdef ALT_DEBUG_UART
@@ -1083,7 +1128,7 @@ sc_err_t board_reset(sc_pm_reset_type_t type, sc_pm_reset_reason_t reason,
     /* Request a warm reset */
     soc_set_reset_info(reason, pt);
     NVIC_SystemReset();
-    
+
     return SC_ERR_UNAVAILABLE;
 }
 
@@ -1095,19 +1140,19 @@ void board_cpu_reset(sc_rsrc_t resource, board_cpu_rst_ev_t reset_event,
 {
     /* Note:  Production code should decide the response for each type
      *        of reset event.  Options include allowing the SCFW to
-     *        reset the CPU or forcing a full system reset.  Additionally, 
-     *        the number of reset attempts can be tracked to determine the 
+     *        reset the CPU or forcing a full system reset.  Additionally,
+     *        the number of reset attempts can be tracked to determine the
      *        reset response.
      */
-    
+
     /* Check for M4 reset event */
     if (resource == SC_R_M4_0_PID0)
     {
-        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource, 
+        always_print("CM4 reset event (rsrc = %d, event = %d)
", resource,
             reset_event);
 
         /* Treat lockups or parity/ECC reset events as board faults */
-        if ((reset_event == BOARD_CPU_RESET_LOCKUP) || 
+        if ((reset_event == BOARD_CPU_RESET_LOCKUP) ||
             (reset_event == BOARD_CPU_RESET_MEM_ERR))
         {
             board_fault(SC_FALSE, BOARD_BFAULT_CPU, pt);
@@ -1130,22 +1175,26 @@ void board_reboot_part(sc_rm_pt_t pt, sc_pm_reset_type_t *type,
      * rebooted.
      */
 
+    *mask = 0UL;
+}
+
+/*--------------------------------------------------------------------------*/
+/* Trap partition reboot continue                                           */
+/*--------------------------------------------------------------------------*/
+void board_reboot_part_cont(sc_rm_pt_t pt, sc_rsrc_t *boot_cpu,
+    sc_rsrc_t *boot_mu, sc_rsrc_t *boot_dev, sc_faddr_t *boot_addr)
+{
+    /* Code can modify boot parameters on a reboot. Called after partition
+     * is powered off but before it is powered back on and started.
+     */
     sc_rm_pt_t p;
 
-    board_print(1, "partition %d reboot
", pt);
-    if ((pt == g_pt_boot) && separate_m4_pt)
+    if (pt == g_pt_boot)
     {
         /* get the owner partition of SC_R_DC_0, it's shared resource*/
         rm_get_resource_owner(pt, SC_R_DC_0, &p);
         if (p != g_pt_m4_0)
         {
-            /* Power off all peripherals, set 'base_reboot' to 'SC_TRUE' so resources
-             * will be reset.
-             */
-            base_reboot = SC_TRUE;
-            (void) pm_set_resource_power_mode(p, SC_R_ALL,
-                SC_PM_PW_MODE_OFF);
-            base_reboot = SC_FALSE;
             /* Reassign some resource to M4 partition */
             board_assign_resources(p);
         }
@@ -1154,18 +1203,6 @@ void board_reboot_part(sc_rm_pt_t pt, sc_pm_reset_type_t *type,
         (void) MU_TriggerInterrupts(base, MU_CR_GIRn(SC_RPC_MU_GIR_SVC));
     }
 
-    *mask = 0UL;
-}
-
-/*--------------------------------------------------------------------------*/
-/* Trap partition reboot continue                                           */
-/*--------------------------------------------------------------------------*/
-void board_reboot_part_cont(sc_rm_pt_t pt, sc_rsrc_t *boot_cpu,
-    sc_rsrc_t *boot_mu, sc_rsrc_t *boot_dev, sc_faddr_t *boot_addr)
-{
-    /* Code can modify boot parameters on a reboot. Called after partition
-     * is powered off but before it is powered back on and started.
-     */
 }
 
 /*--------------------------------------------------------------------------*/
@@ -1183,10 +1220,11 @@ board_reboot_to_t board_reboot_timeout(sc_rm_pt_t pt)
 /*--------------------------------------------------------------------------*/
 void board_panic(sc_dsc_t dsc)
 {
+    /* See Porting Guide for more info on panic alarms */
     #ifdef DEBUG
         error_print("Panic temp (dsc=%d)
", dsc);
     #endif
-    
+
     (void) board_reset(SC_PM_RESET_TYPE_BOARD, SC_PM_RESET_REASON_TEMP,
         SC_PT);
 }
@@ -1206,6 +1244,8 @@ void board_fault(sc_bool_t restarted, sc_bfault_t reason,
         WDOG32_SetTimeoutValue(WDOG_SC, 0xFFFF);
         WDOG32_Disable(WDOG_SC);
 
+        board_print(1, "board fault(%u, %u, %u)
", restarted, reason, pt);
+
         /* Stop so developer can see WDOG occurred */
         HALT;
     #else
@@ -1246,7 +1286,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_set_control(%s, %u, %u)
", rnames[rsrc_idx], ctrl, val);
 
@@ -1264,7 +1304,7 @@ sc_err_t board_set_control(sc_rsrc_t resource, sc_rm_idx_t idx,
             case SC_R_PMIC_0 :
                 if (ctrl == SC_C_TEMP_HI)
                 {
-                    temp_alarm = 
+                    temp_alarm =
                         SET_PMIC_TEMP_ALARM(PMIC_0_ADDR, val);
                 }
                 else
@@ -1300,7 +1340,7 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
     sc_rm_idx_t rsrc_idx, uint32_t ctrl, uint32_t *val)
 {
     sc_err_t err = SC_ERR_NONE;
-    
+
     board_print(3,
         "board_get_control(%s, %u)
", rnames[rsrc_idx], ctrl);
 
@@ -1324,6 +1364,12 @@ sc_err_t board_get_control(sc_rsrc_t resource, sc_rm_idx_t idx,
                 {
                     *val = temp_alarm;
                 }
+                else if (ctrl == SC_C_ID)
+                {
+                    pmic_version_t v = GET_PMIC_VERSION(PMIC_0_ADDR);
+
+                    *val = (U32(v.device_id) << 8U) | U32(v.si_rev);
+                }
                 else
                 {
                     err = SC_ERR_PARM;
@@ -1400,7 +1446,7 @@ static void pmic_init(void)
                 SC_PM_PW_MODE_ON);
             (void) pm_set_clock_rate(SC_PT, SC_R_SC_I2C,
                 SC_PM_CLK_PER, &rate);
-            (void) pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
+            pm_force_clock_enable(SC_R_SC_I2C, SC_PM_CLK_PER,
                 SC_TRUE);
 
             /* Initialize the pads used to communicate with the PMIC */
@@ -1441,23 +1487,26 @@ static void pmic_init(void)
             if(pmic_ver.si_rev == PF8100_A0_REV)
             {
                 /* Set Regulation modes for MAIN and 1.8V rails */
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1,
-                    SW_RUN_PWM | SW_STBY_PWM);
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2,
-                    SW_RUN_PWM | SW_STBY_PWM);
-                (void) PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW6,
-                    SW_RUN_PWM | SW_STBY_PWM);
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW1,
+                    SW_RUN_PWM | SW_STBY_PWM));
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW2,
+                    SW_RUN_PWM | SW_STBY_PWM));
+                BRD_ERR(PMIC_SET_MODE(PMIC_0_ADDR, PF8100_SW6,
+                    SW_RUN_PWM | SW_STBY_PWM));
             }
 
             /* Adjust startup timing */
             err |= pmic_update_timing(PMIC_0_ADDR);
 
+            /* Enable WDI detection in Standby */
+            err |= pf8100_pmic_wdog_enable(PMIC_0_ADDR, SC_FALSE, SC_FALSE, SC_TRUE);
+
             if (err != SC_ERR_NONE)
             {
                 /* Loop so WDOG will expire */
                 HALT;
             }
-            
+
             /* Configure STBY voltage for SW1 (VDD_MAIN) */
             if (board_parameter(BOARD_PARM_KS1_RETENTION)
                 == BOARD_PARM_KS1_RETENTION_ENABLE)
@@ -1469,8 +1518,8 @@ static void pmic_init(void)
                     ks1_volt = 700U;
                 }
 
-                (void) PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, ks1_volt,
-                    REG_STBY_MODE);
+                BRD_ERR(PMIC_SET_VOLTAGE(PMIC_0_ADDR, PF8100_SW1, ks1_volt,
+                    REG_STBY_MODE));
             }
 
             /* Enable PMIC IRQ at NVIC level */
@@ -1481,6 +1530,7 @@ static void pmic_init(void)
     #endif
 }
 
+#ifndef EMUL
 /*--------------------------------------------------------------------------*/
 /* Bypass current limit for PF8100                                          */
 /*--------------------------------------------------------------------------*/
@@ -1551,7 +1601,7 @@ static sc_err_t pmic_ignore_current_limit(uint8_t address,
 /*--------------------------------------------------------------------------*/
 static sc_err_t pmic_update_timing(uint8_t address)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
     uint8_t val = 0xED;
 
     /*
@@ -1561,7 +1611,6 @@ static sc_err_t pmic_update_timing(uint8_t address)
      */
     if (address == PMIC_0_ADDR)
     {
-        err = SC_ERR_NONE;
         err |= PMIC_REGISTER_ACCESS(address, 0x6F, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x77, SC_TRUE, &val);
         err |= PMIC_REGISTER_ACCESS(address, 0x7F, SC_TRUE, &val);
@@ -1569,10 +1618,16 @@ static sc_err_t pmic_update_timing(uint8_t address)
         val = 0x29;
         err |= PMIC_REGISTER_ACCESS(address, 0x3C, SC_TRUE, &val);
     }
+    else
+    {
+        err = SC_ERR_PARM;
+    }
 
     return err;
 }
 
+#endif
+
 /*--------------------------------------------------------------------------*/
 /* Get the pmic ids and switchers connected to SS.                          */
 /*--------------------------------------------------------------------------*/
@@ -1611,7 +1666,7 @@ void board_tick(uint16_t msec)
 sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
     uint32_t *parm2, uint32_t *parm3)
 {
-    sc_err_t err = SC_ERR_PARM;
+    sc_err_t err = SC_ERR_NONE;
 
     /* For test_misc */
     if (*parm1 == 0xFFFFFFFEU)
@@ -1619,8 +1674,10 @@ sc_err_t board_ioctl(sc_rm_pt_t caller_pt, sc_rsrc_t mu, uint32_t *parm1,
         *parm1 = *parm2 + *parm3;
         *parm2 = mu;
         *parm3 = caller_pt;
-
-        err = SC_ERR_NONE;
+    }
+    else
+    {
+        err = SC_ERR_PARM;
     }
 
     return err;
diff --git a/uboot-firmware/imx8q_car/imx8dx_dcd_lpddr4_16bit_1.2GHz.cfg b/uboot-firmware/imx8q_car/imx8dx_dcd_lpddr4_16bit_1.2GHz.cfg
new file mode 100755
index 0000000..8ed9715
--- /dev/null
+++ b/uboot-firmware/imx8q_car/imx8dx_dcd_lpddr4_16bit_1.2GHz.cfg
@@ -0,0 +1,378 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE BD_DDR_RET      /* Add/remove DDR retention */
+
+DEFINE BD_DDR_RET_NUM_DRC 1 /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION 2 /* DDR regions to save/restore */
+
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE BD_DDR_RET_REGION1_ADDR 0x80000000
+DEFINE BD_DDR_RET_REGION1_SIZE 32
+DEFINE BD_DDR_RET_REGION2_ADDR 0x80002020
+DEFINE BD_DDR_RET_REGION2_SIZE 8
+
+
+
+/*
+ * Device Configuration Data (DCD) Version 14
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1200MHz DDR, DRC 600MHz operation */
+DATA 4  0xff190000  0x00000CC8  /* DRC0 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+ return SC_ERR_NONE;
+}
+
+#endif
+
+//-------------------------------------------
+// Reset controller core domain (required to configure it)
+//--------------------------------------------
+DATA 4 0x41C80208 0x1
+DATA 4 0x41C80040 0xb
+DATA 4 0x41C80204 0x1
+
+//-------------------------------------------
+// Configure controller registers
+//--------------------------------------------
+/* DRAM controller configuration begin */
+DATA 4  DDRC_MSTR_0    0x81081020 // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_0    0x00000203 // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_0    0x0124F800 // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_0 0x0021F000
+DATA 4  DDRC_RFSHTMG_0 0x004900A8 // tREFI, tRFC
+DATA 4  DDRC_INIT0_0   0x40030495 // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_0   0x00770000 // dram_rstn = 200us
+DATA 4  DDRC_INIT3_0   0x00440024 // MR1, MR2
+DATA 4  DDRC_INIT4_0   0x00F100C0 // MR3, MR13
+DATA 4 DDRC_RANKCTL_0   0x0000066F // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4 DDRC_DRAMTMG0_0  0x1618141A // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4 DDRC_DRAMTMG1_0  0x00050526 // tXP, rd2pre, tRC
+DATA 4 DDRC_DRAMTMG2_0  0x060E1514 // WL, RL, rd2wr, wr2rd
+DATA 4 DDRC_DRAMTMG3_0  0x00909000 // tmrw, tmrd, tmod
+DATA 4 DDRC_DRAMTMG4_0  0x0B04060B // trcd, tccd, trrd, trp
+DATA 4 DDRC_DRAMTMG5_0  0x02030909 // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4 DDRC_DRAMTMG6_0  0x02020006 // tckdpde, tckdpdx, tckcsx
+DATA 4 DDRC_DRAMTMG7_0  0x00000301 // tckpde, tckpdx
+DATA 4 DDRC_DRAMTMG12_0 0x00020510 // tCMDCKE, tCKEHCMD
+DATA 4 DDRC_DRAMTMG13_0 0x0B100002 // tODTLoff, tCCDMW, tPPD
+DATA 4 DDRC_DRAMTMG14_0 0x000000AD // txsr
+DATA 4 DDRC_ZQCTL0_0    0x02580012 // tZQCAL, tZQLAT
+DATA 4 DDRC_ZQCTL1_0    0x01E0493E // tZQReset, tzq_short_interval
+DATA 4 DDRC_DFITMG0_0   0x0499820A // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4 DDRC_DFITMG1_0   0x00070303 // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4 DDRC_DFITMG2_0   0x00001708 // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4 DDRC_DFIMISC_0   0x00000005 // dfi_data_cs_polarity
+DATA 4 DDRC_DFIUPD0_0   0x00400003 // Disable the automatic dfi_ctrlupd_req generation
+DATA 4 DDRC_DFIUPD1_0   0x008000A0 // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4 DDRC_DFIUPD2_0   0x80000000 // dfi_phyupd_en
+DATA 4 DDRC_ADDRMAP0_0  0x0000001F // addrmap_cs_bit0
+DATA 4 DDRC_ADDRMAP3_0  0x1F000000 // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4 DDRC_ADDRMAP4_0  0x00001F1F // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4 DDRC_ADDRMAP1_0  0x00070707 // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4 DDRC_ADDRMAP5_0  0x06060606 // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4 DDRC_ADDRMAP6_0  0x06060606 // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4 DDRC_DBICTL_0    0x00000007 // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4 DDRC_ODTMAP_0    0x00000000 // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4 DDRC_PCTRL_0_0   0x00000001 // Enable port 0
+
+//Performance optimizations
+DATA 4 DDRC_PWRCTL_0 0x0000010A
+DATA 4 DDRC_PWRTMG_0 0x00402010
+DATA 4 DDRC_HWLPCTL_0 0x003F0001
+
+DATA 4 DDRC_SCHED_0 0x7F001F05 // 30ns delay upon read store empty if write pending, CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4 DDRC_DFILPCFG0_0 0x0700B100
+
+//-------------------------------------------
+// Release reset of controller core domain
+//--------------------------------------------
+DATA 4 0x41c80208 0x1
+DATA 4  0x41c80040 0xf
+DATA 4  0x41c80204 0x1
+
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Following are uncommented (to disable) or commented (to enable) particular byte lanes
+DATA 4 DDR_PHY_DX2GCR1_0 0x55556000 // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4 DDR_PHY_DX3GCR1_0 0x55556000 // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX4GCR1_0 0x55556000 // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR3_0  0x0029A4A4  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR3_0  0x0029A4A4  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR3_0  0x0029A4A4  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR4_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR4_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR4_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+DATA 4  DDR_PHY_DX2GCR5_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+DATA 4  DDR_PHY_DX3GCR5_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR5_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+
+// Set-up DRAM Configuration Register
+DATA 4 DDR_PHY_DCR_0 0x0000040D // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4 DDR_PHY_PGCR8_0     0x00010002
+DATA 4 DDR_PHY_DX0DQMAP0_0 0x00061032 // DQ bit 0/1/2/3/4 remapping
+DATA 4 DDR_PHY_DX0DQMAP1_0 0x00004578 // DQ bit 5/6/7 and DM remapping
+DATA 4 DDR_PHY_DX1DQMAP0_0 0x00071032 // DQ bit 0/1/2/3/4 remapping
+DATA 4 DDR_PHY_DX1DQMAP1_0 0x00004685 // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00000000  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00000000  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00000000  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00000000  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX4DQMAP0_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_DX4DQMAP1_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4 DDR_PHY_CATR0_0     0x00141000 // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4 DDR_PHY_CATR1_0     0x0103AAAA // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_0 0x000A0040 // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4 DDR_PHY_PGCR0_0 0x07001E00 // Set ADCP=1 (Address Copy) if 32-bit, else 0 if 16-bit data bus
+DATA 4 DDR_PHY_PGCR2_0 0x00F0A193 // Set tREFPRD
+DATA 4 DDR_PHY_PGCR3_0 0x050A1080 // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4 DDR_PHY_PTR0_0 0x4B025810 // tPLLPD, tPLLGS, tPHYRST
+DATA 4 DDR_PHY_PTR1_0 0x3A981518 // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4 DDR_PHY_PLLCR0_0       0x801C0000
+DATA 4 DDR_PHY_DX8SLbPLLCR0_0 0x801C0000
+SET_BIT 4 DDR_PHY_DX8SL1PLLCR0_0 0x20000000 // uncommented to disable byte lanes 2 and 3 PLL when configured for 16-bit data bus
+SET_BIT 4 DDR_PHY_DX8SL2PLLCR0_0 0x20000000 // uncommented to disable byte lanes 4 and 5 PLL when configured for 16-bit data bus
+
+// Set-up Impedance Control Register
+DATA 4 DDR_PHY_ZQCR_0 0x008B2C58 // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_0 0x0001BBBB // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_0 0x0001B9BB // Impedance control for DQ bus
+
+//-------------------------------------------
+// Launch PLL init
+//--------------------------------------------
+DATA 4  DDR_PHY_PIR_0 0x10
+DATA 4  DDR_PHY_PIR_0 0x11
+
+// Wait end of PLL init (Wait for bit 0 of PGSR0 to be '1')
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+
+//-------------------------------------------
+// Switch to boot frequency and launch DCAL+ZCAL
+//--------------------------------------------
+DATA 4  DDR_PHY_PLLCR0_0 0xA01C0000 // Put PLL in power down state
+DATA 4 DDR_PHY_DX8SLbPLLCR0_0 0xA01C0000
+// Switch to boot frequency
+DATA 4 0x41C80208 0x1 // Gate functional clock to avoid glitches
+DATA 4  0x41C80504 0x00800000 // Set bypass mode in DSC GPR control register
+DATA 4  0x41C80204 0x1 // Ungate functional clock
+// Set PLL timings for boot frequency
+DATA 4 DDR_PHY_PTR0_0 0x026012C1
+DATA 4 DDR_PHY_PTR1_0 0x01D500A9
+// Launch DCAL+ZCAL
+DATA 4  DDR_PHY_PIR_0 0x22
+DATA 4  DDR_PHY_PIR_0 0x23
+
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4 DDR_PHY_MR1_0 0x44 // Set BL, WR-PRE, nWR, RPST
+DATA 4 DDR_PHY_MR2_0 0x24 // Set RL/WL
+DATA 4 DDR_PHY_MR3_0 0xF1 // Set drive strength
+
+DATA 4 DDR_PHY_MR11_0 0x54 // Set CA and DQ ODT
+DATA 4 DDR_PHY_MR13_0 0xC0
+DATA 4 DDR_PHY_MR22_0 0x15 // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4 DDR_PHY_MR12_0 0x48
+DATA 4 DDR_PHY_MR14_0 0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4 DDR_PHY_DTPR0_0 0x0C331A09 // tRRD, tRAS, tRP, tRTP
+DATA 4 DDR_PHY_DTPR1_0 0x28300411 // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4 DDR_PHY_DTPR2_0 0x0069615A // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4 DDR_PHY_DTPR3_0 0x01800501 // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4 DDR_PHY_DTPR4_0 0x01502B0C // tRFC, tWLO, tXP
+DATA 4 DDR_PHY_DTPR5_0 0x194C160D // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4 DDR_PHY_PTR2_0 0x000A3DEF // tWLDLYS
+DATA 4 DDR_PHY_PTR3_0 0x000124F8 // tDINIT0
+DATA 4 DDR_PHY_PTR4_0 0x0000004B // tDINIT1
+DATA 4 DDR_PHY_PTR5_0 0x00001D4C // tDINIT2
+DATA 4 DDR_PHY_PTR6_0 0x00B00026 // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4 DDR_PHY_RANKIDR_0 0x00000001 // Select rank 1 to write
+DATA 4 DDR_PHY_ODTCR_0 0x00000000 // ODT of rank1 disabled
+DATA 4 DDR_PHY_RANKIDR_0 0x00000000 // Select rank 0 to write
+DATA 4 DDR_PHY_ODTCR_0 0x00000000 // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4 DDR_PHY_ACIOCR0_0 0x30070801 // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4 DDR_PHY_ACIOCR5_0 0x09000000 // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4 DDR_PHY_ACIOCR1_0 0x44000000
+// Set-up VREF Training Control Registers
+DATA 4 DDR_PHY_VTCR0_0 0xF0032008 // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4 DDR_PHY_VTCR1_0 0x07F0018F // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4 DDR_PHY_PGCR5_0 0x4
+DATA 4 DDR_PHY_PGCR6_0 0x00033200 // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4 DDR_PHY_DX0GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4 DDR_PHY_DX1GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+// DATA 4 DDR_PHY_DX2GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+// DATA 4 DDR_PHY_DX3GCR5_0 0x09092020 // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4 DDR_PHY_DX0GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4 DDR_PHY_DX1GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// DATA 4 DDR_PHY_DX2GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// DATA 4 DDR_PHY_DX3GCR4_0 0x0E00BF3C // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH=0xA
+DATA 4 DDR_PHY_DX8SLbDXCTL2_0 0x001C1600
+
+//Enable PHY PLL to go into power down on DFI low power request
+DATA 4 DDR_PHY_PGCR4_0 0x001900B1
+
+// Set-up DATX8 IO Control Register
+DATA 4 DDR_PHY_DX8SLbIOCR_0 0x79000000 // I/O mode = LPDDR4
+
+//-------------------------------------------
+// Wait end of PHY initialization then launch DRAM initialization
+//-------------------------------------------
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0 0x180
+DATA 4  DDR_PHY_PIR_0 0x181
+
+//-------------------------------------------
+// Wait end of DRAM initialization then launch second DRAM initialization
+// This is required due to errata e10945:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+//-------------------------------------------
+// DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4  DDR_PHY_PTR3_0 0x0000004B
+// Launch DRAM initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0 0x100
+DATA 4  DDR_PHY_PIR_0 0x101
+
+//-------------------------------------------
+// Wait end of second DRAM initialization
+//-------------------------------------------
+CHECK_BITS_SET 4 DDR_PHY_PGSR0_0 0x1
+
+//-------------------------------------------
+// Run CBT (Command Bus Training)
+//-------------------------------------------
+//Call run_cbt(initial DDR_PHY_PTR0 value, initial DDR_PHY_PTR1 value, total_num_drc) here
+run_cbt(0x4B025810, 0x3A981518, 1);
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4  DDR_PHY_DQSDR0_0 0x00000001 // Disable drift
+SET_BIT 4  DDR_PHY_PGCR6_0 0x00000001 // Disable VT compensation
+CHECK_BITS_SET 4  DDR_PHY_PGSR1_0 0x40000000 // Disable VT compensation
+SET_BIT 4  DDR_PHY_PGCR1_0 0x00020040 // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_0 0x00010100 //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_0 0x700003FF // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_0 0x00003FFF // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4  DDR_PHY_DTCR0_0 0x000031C7 // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_0 0x00010236 // Set RANKEN
+
+// Launch Write leveling
+DATA 4  DDR_PHY_PIR_0 0x200
+DATA 4  DDR_PHY_PIR_0 0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4 DDR_PHY_PGSR0_0 0x1
+CHECK_BITS_CLR 4 DDR_PHY_PGSR0_0 0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947
+DATA 4  DDR_PHY_DX8SLbDQSCTL_0 0x012240F7
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_0 0x400
+DATA 4  DDR_PHY_PIR_0 0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0 0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0 0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4  DDR_PHY_DX8SLbDQSCTL_0 0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4 DDR_PHY_PIR_0 0x0010F800
+DATA 4 DDR_PHY_PIR_0 0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4 DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4 DDR_PHY_PGSR0_0  0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4 DDR_PHY_PGCR1_0 0x00020040 // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4 DDR_PHY_DX0GCR3_0 0x08000000
+CLR_BIT 4 DDR_PHY_DX1GCR3_0 0x08000000
+CLR_BIT 4 DDR_PHY_DX2GCR3_0 0x08000000
+CLR_BIT 4 DDR_PHY_DX3GCR3_0 0x08000000
+// Enable DQS drift detection PHY0
+DATA 4  DDR_PHY_DQSDR0_0 0x20188005
+DATA 4  DDR_PHY_DQSDR1_0 0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_0 0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41c80504 0x400
+
+// Enable VT compensation
+CLR_BIT 4 DDR_PHY_PGCR6_0 0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4 DDRC_STAT_0 0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
+
diff --git a/uboot-firmware/imx8q_car/imx8qm_dcd_1.6GHz.cfg b/uboot-firmware/imx8q_car/imx8qm_dcd_1.6GHz.cfg
new file mode 100755
index 0000000..d354b71
--- /dev/null
+++ b/uboot-firmware/imx8q_car/imx8qm_dcd_1.6GHz.cfg
@@ -0,0 +1,595 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET    /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC     2  /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION  6  /* DDR regions to save/restore */
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80008040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80010000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+DEFINE  BD_DDR_RET_REGION4_ADDR  0x80001000
+DEFINE  BD_DDR_RET_REGION4_SIZE  64
+DEFINE  BD_DDR_RET_REGION5_ADDR  0x80009040
+DEFINE  BD_DDR_RET_REGION5_SIZE  16
+DEFINE  BD_DDR_RET_REGION6_ADDR  0x80011000
+DEFINE  BD_DDR_RET_REGION6_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 18
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1600MHz DDR, DRC 800MHz operation */
+DATA 4  0xff148000  0x00000885  /* DRC0 bringup */
+DATA 4  0xff1a0000  0x00000885  /* DRC1 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+//-------------------------------------------
+// Reset controller core domain (required to configure it)
+//--------------------------------------------
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4  0x41a40040  0xB
+DATA 4  0x41d00040  0xB
+DATA 4  0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+
+//-------------------------------------------
+// Configure controller registers
+//--------------------------------------------
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0186A000  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0   0x0021F000
+DATA 4   DDRC_RFSHTMG_0   0x006100E0  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0     0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0     0x009E0000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0     0x0054002D  // MR1, MR2
+DATA 4   DDRC_INIT4_0     0x00F100C0  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_0     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+
+/* DRAM 1 controller initialization */
+DATA 4  DDRC_MSTR_1       0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_1   0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_1  0x0186A000  // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_1   0x0021F000
+DATA 4  DDRC_RFSHTMG_1    0x006100E0  // tREFI, tRFC
+DATA 4  DDRC_INIT0_1      0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_1      0x009E0000  // dram_rstn = 200us
+DATA 4  DDRC_INIT3_1      0x0054002D  // MR1, MR2
+DATA 4  DDRC_INIT4_1      0x00F100C0  // MR3, MR13
+DATA 4  DDRC_RANKCTL_1    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_1   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_1   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_1   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_1   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_1   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_1   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_1   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_1   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_1  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_1  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_1  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_1     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_1     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_1    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_1    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_1    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_1    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_1    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_1    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_1    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_1   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_1   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_1   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_1   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_1   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_1   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_1     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_1     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_1    0x00000001  // Enable port 0
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0   0x0000010A
+DATA 4  DDRC_PWRCTL_1   0x0000010A
+DATA 4  DDRC_PWRTMG_0   0x00402010
+DATA 4  DDRC_PWRTMG_1   0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x06FF0001
+DATA 4  DDRC_HWLPCTL_1  0x06FF0001
+
+DATA 4 DDRC_SCHED_0 0x00001F05  // CAM (32 entries)
+DATA 4 DDRC_SCHED_1 0x00001F05  // CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+DATA 4  DDRC_DFILPCFG0_1  0x0700B100
+
+//-------------------------------------------
+// Release reset of controller core domain
+//--------------------------------------------
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4   0x41a40040  0xF
+DATA 4  0x41d00040  0xF
+DATA 4   0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+
+//-------------------------------------------
+// Configure PHY registers for PHY initialization
+//--------------------------------------------
+/* DRAM 0 controller configuration begin */
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0040  // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_0  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x801C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x801C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001B9BB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+
+/* DRAM 1 controller configuration begin */
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_1  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_1  0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_1  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_1  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_1  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_1  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_1  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_1  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_1  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_1  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_1  0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_1  0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_1  0x000A0040  // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4  DDR_PHY_PGCR0_1  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_1  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_1  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_1  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_1  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_1  0x801C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0x801C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_1  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_1  0x0001B9BB  // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_1  0x0001B9BB  // Impedance control for DQ bus
+
+//-------------------------------------------
+// Launch PLL init
+//--------------------------------------------
+DATA 4   DDR_PHY_PIR_0  0x10
+DATA 4   DDR_PHY_PIR_0  0x11
+DATA 4  DDR_PHY_PIR_1  0x10
+DATA 4  DDR_PHY_PIR_1  0x11
+
+// Wait end of PLL init (Wait for bit 0 of PGSR0 to be '1')
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+//-------------------------------------------
+// Switch to boot frequency and launch DCAL+ZCAL
+//--------------------------------------------
+/* DRAM 0 */
+DATA 4   DDR_PHY_PLLCR0_0  0xA01C0000  // Put PLL in power down state
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0xA01C0000
+// Switch to boot frequency
+DATA 4  0x41a40208  0x1  // Gate functional clock to avoid glitches
+DATA 4   0x41a40504  0x00800000  // Set bypass mode in DSC GPR control register
+DATA 4   0x41a40204  0x1  // Ungate functional clock
+// Set PLL timings for boot frequency
+DATA 4  DDR_PHY_PTR0_0  0x03201901
+DATA 4  DDR_PHY_PTR1_0  0x027100E1
+// Launch DCAL+ZCAL
+DATA 4   DDR_PHY_PIR_0  0x22
+DATA 4   DDR_PHY_PIR_0  0x23
+
+/* DRAM 1 */
+DATA 4  DDR_PHY_PLLCR0_1  0xA01C0000  // Put PLL in power down state
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0xA01C0000
+// Switch to boot frequency
+DATA 4  0x41d00208  0x1
+DATA 4  0x41d00504  0x00800000
+DATA 4  0x41d00204  0x1
+// Set PLL timings for boot frequency
+DATA 4  DDR_PHY_PTR0_1  0x03201901
+DATA 4  DDR_PHY_PTR1_1  0x027100E1
+// Launch DCAL+ZCAL
+DATA 4  DDR_PHY_PIR_1  0x22
+DATA 4  DDR_PHY_PIR_1  0x23
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+/* DRAM 0 */
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR13_0  0xC0
+DATA 4  DDR_PHY_MR22_0  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF  // tWLDLYS
+DATA 4  DDR_PHY_PTR3_0  0x000186A0  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000064  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x00002710  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x00B00032  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070801  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+
+/* DRAM 1 */
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_1  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_1  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_1  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_1  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR13_1  0xC0
+DATA 4  DDR_PHY_MR22_1  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_1  0x48
+DATA 4  DDR_PHY_MR14_1  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_1  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_1  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_1  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_1  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_1  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_1  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_1  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_1  0x000186A0  // tDINIT0
+DATA 4  DDR_PHY_PTR4_1  0x00000064  // tDINIT1
+DATA 4  DDR_PHY_PTR5_1  0x00002710  // tDINIT2
+DATA 4  DDR_PHY_PTR6_1  0x00B00032  // tDINIT4, tDINIT3 (1us)
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_1  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_1  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_1  0x30070801  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_1  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_1  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_1  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_1  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_1  0x4
+DATA 4  DDR_PHY_PGCR6_1  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_1  0x001C1600
+DATA 4  DDR_PHY_PGCR4_1  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_1  0x79000000  // I/O mode = LPDDR4
+
+//-------------------------------------------
+// Wait end of PHY initialization then launch DRAM initialization
+//-------------------------------------------
+/* DRAM 0 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Launch DRAM initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+
+/* DRAM 1 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+// Launch DRAM initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x180
+DATA 4  DDR_PHY_PIR_1  0x181
+
+//-------------------------------------------
+// Wait end of DRAM initialization then launch second DRAM initialization
+// This is required due to errata e10945:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+//-------------------------------------------
+
+/* DRAM 0 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4   DDR_PHY_PTR3_0  0x00000064
+// Launch DRAM initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+
+/* DRAM 1 */
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4  DDR_PHY_PTR3_1  0x00000064
+// Launch DRAM initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x100
+DATA 4  DDR_PHY_PIR_1  0x101
+
+//-------------------------------------------
+// Wait end of second DRAM initialization
+//-------------------------------------------
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// DRAM 1 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+//-------------------------------------------
+// Run CBT (Command Bus Training)
+//-------------------------------------------
+//Call run_cbt(initial DDR_PHY_PTR0 value, initial DDR_PHY_PTR1 value, total_num_drc) here
+run_cbt(0x64032010, 0x4E201C20, 2);
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+CLR_BIT 4   DDR_PHY_DQSDR0_1  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_1  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_1  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_1  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_1  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_1  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_1  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4  DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+DATA 4  DDR_PHY_DTCR0_1  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_1  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+DATA 4  DDR_PHY_PIR_1  0x200
+DATA 4  DDR_PHY_PIR_1  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240B3
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00200000
+// Set DQS/DQSn glitch suppression resistor for training PHY1 to satisfy errata e10947
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x012240B3
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_1  0x400
+DATA 4  DDR_PHY_PIR_1  0x401
+
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+
+// Wait Read DQS training to complete PHY1
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x01224000
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_1  0x0010F800
+DATA 4  DDR_PHY_PIR_1  0x0010F801
+
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+RDBI_bit_deskew(1);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+DRAM_VREF_training_hw(1);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+DRAM_VREF_training_sw(1);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+DATA 4 DDR_PHY_DX8SLbDDLCTL_1 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+CLR_BIT 4  DDR_PHY_PGCR1_1  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+//DQS Drift Registers PHY1
+CLR_BIT 4  DDR_PHY_DX0GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_1  0x08000000
+// Enable DQS drift detection PHY1
+DATA 4  DDR_PHY_DQSDR0_1  0x20188005
+DATA 4  DDR_PHY_DQSDR1_1  0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_1  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41A40504  0x400
+DATA 4  0x41D00504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+CLR_BIT 4  DDR_PHY_PGCR6_1  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+CHECK_BITS_SET 4  DDRC_STAT_1  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q_car/imx8qm_dcd_1.6GHz_nocbt.cfg b/uboot-firmware/imx8q_car/imx8qm_dcd_1.6GHz_nocbt.cfg
new file mode 100755
index 0000000..053d0f0
--- /dev/null
+++ b/uboot-firmware/imx8q_car/imx8qm_dcd_1.6GHz_nocbt.cfg
@@ -0,0 +1,518 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET    /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC     2  /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION  6  /* DDR regions to save/restore */
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80008040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80010000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+DEFINE  BD_DDR_RET_REGION4_ADDR  0x80001000
+DEFINE  BD_DDR_RET_REGION4_SIZE  64
+DEFINE  BD_DDR_RET_REGION5_ADDR  0x80009040
+DEFINE  BD_DDR_RET_REGION5_SIZE  16
+DEFINE  BD_DDR_RET_REGION6_ADDR  0x80011000
+DEFINE  BD_DDR_RET_REGION6_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 18
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1600MHz DDR, DRC 800MHz operation */
+DATA 4  0xff148000  0x00000885  /* DRC0 bringup */
+DATA 4  0xff1a0000  0x00000885  /* DRC1 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4  0x41a40040  0xB
+DATA 4  0x41d00040  0xB
+DATA 4  0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0186A000  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0   0x0021F000
+DATA 4   DDRC_RFSHTMG_0   0x006100E0  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0     0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0     0x009E0000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0     0x0054002D  // MR1, MR2
+DATA 4   DDRC_INIT4_0     0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_0     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_0  0x00808000
+
+/* DRAM 1 controller initialization */
+DATA 4  DDRC_MSTR_1       0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_1   0x00000213  // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_1  0x0186A000  // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_1   0x0021F000
+DATA 4  DDRC_RFSHTMG_1    0x006100E0  // tREFI, tRFC
+DATA 4  DDRC_INIT0_1      0x4003061C  // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_1      0x009E0000  // dram_rstn = 200us
+DATA 4  DDRC_INIT3_1      0x0054002D  // MR1, MR2
+DATA 4  DDRC_INIT4_1      0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_1    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_1   0x1A201B22  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_1   0x00060633  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_1   0x07101617  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_1   0x00C0C000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_1   0x0F04080F  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_1   0x02040C0C  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_1   0x02020007  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_1   0x00000401  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_1  0x00020610  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_1  0x0C100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_1  0x000000E6  // txsr
+DATA 4  DDRC_ZQCTL0_1     0x03200018  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_1     0x028061A8  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_1    0x049E820C  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_1    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_1    0x00001C0A  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_1    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_1    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_1    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_1    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_1   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_1   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_1   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_1   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_1   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_1   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_1     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_1     0x00000000  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_1    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_1  0x00808000
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0   0x0000010A
+DATA 4  DDRC_PWRCTL_1   0x0000010A
+DATA 4  DDRC_PWRTMG_0   0x00402010
+DATA 4  DDRC_PWRTMG_1   0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x06FF0001
+DATA 4  DDRC_HWLPCTL_1  0x06FF0001
+
+DATA 4 DDRC_SCHED_0 0x00001F05  // CAM (32 entries)
+DATA 4 DDRC_SCHED_1 0x00001F05  // CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+DATA 4  DDRC_DFILPCFG0_1  0x0700B100
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4   0x41a40040  0xF
+DATA 4  0x41d00040  0xF
+DATA 4   0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_0  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x001C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x001C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001B9BB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4   DDR_PHY_PIR_0  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0  0x33
+//-------------------------------------------
+// Configure registers for PHY initialization
+//-------------------------------=------------
+// Set-up DRAM 1 PHY Configuration Register
+DATA 4  DDR_PHY_DCR_1  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_1  0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_1  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_1  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_1  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_1  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_1  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_1  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_1  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_1  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_1  0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_1  0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_1  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_1  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_1  0x00F0D879  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_1  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_1  0x64032010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_1  0x4E201C20  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_1  0x001C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0x001C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_1  0x008C2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_1  0x0001B9BB  // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_1  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4  DDR_PHY_PIR_1  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x33
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_0  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_0  0x0030D400  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000C80  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x0004E200  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x03300640  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_1  0x54  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_1  0x2D  // Set RL/WL
+DATA 4  DDR_PHY_MR3_1  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_1  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_1  0x16  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_1  0x48
+DATA 4  DDR_PHY_MR14_1  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_1  0x1044220C  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_1  0x28400417  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_1  0x006CA1CC  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_1  0x01800602  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_1  0x01C02B0F  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_1  0x21651D11  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_1  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_1  0x0030D400  // tDINIT0
+DATA 4  DDR_PHY_PTR4_1  0x00000C80  // tDINIT1
+DATA 4  DDR_PHY_PTR5_1  0x0004E200  // tDINIT2
+DATA 4  DDR_PHY_PTR6_1  0x03300640  // tDINIT4, tDINIT3 (1us)
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_1  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_1  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_1  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_1  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_1  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_1  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_1  0x07F001AF  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_1  0x4
+DATA 4  DDR_PHY_PGCR6_1  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_1  0x001C1600
+DATA 4  DDR_PHY_PGCR4_1  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_1  0x79000000  // I/O mode = LPDDR4
+
+// Wait PHY initialization end then launch DRAM initialization
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+// Launch DRAM 1 initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x180
+DATA 4  DDR_PHY_PIR_1  0x181
+
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// DRAM 1 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch a second time DRAM initialization due to errata e10945:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+DATA 4  DDR_PHY_PIR_1  0x100
+DATA 4  DDR_PHY_PIR_1  0x101
+
+// Wait (second time) DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+// Wait (second time) DRAM 1 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+CLR_BIT 4   DDR_PHY_DQSDR0_1  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_1  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_1  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_1  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_1  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_1  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_1  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4  DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+DATA 4  DDR_PHY_DTCR0_1  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_1  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+DATA 4  DDR_PHY_PIR_1  0x200
+DATA 4  DDR_PHY_PIR_1  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240B3
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Set DQS/DQSn glitch suppression resistor for training PHY1 to satisfy errata e10947
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x012240B3
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_1  0x400
+DATA 4  DDR_PHY_PIR_1  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+// Wait Read DQS training to complete PHY1
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+DATA 4  DDR_PHY_PIR_1  0x0010F800
+DATA 4  DDR_PHY_PIR_1  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+RDBI_bit_deskew(1);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+DRAM_VREF_training_hw(1);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+DRAM_VREF_training_sw(1);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+DATA 4 DDR_PHY_DX8SLbDDLCTL_1 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+CLR_BIT 4  DDR_PHY_PGCR1_1  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+//DQS Drift Registers PHY1
+CLR_BIT 4  DDR_PHY_DX0GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_1  0x08000000
+// Enable DQS drift detection PHY1
+DATA 4  DDR_PHY_DQSDR0_1  0x20188005
+DATA 4  DDR_PHY_DQSDR1_1  0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_1  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41A40504  0x400
+DATA 4  0x41D00504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+CLR_BIT 4  DDR_PHY_PGCR6_1  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+CHECK_BITS_SET 4  DDRC_STAT_1  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q_car/imx8qm_dcd_800MHz.cfg b/uboot-firmware/imx8q_car/imx8qm_dcd_800MHz.cfg
new file mode 100755
index 0000000..848cc69
--- /dev/null
+++ b/uboot-firmware/imx8q_car/imx8qm_dcd_800MHz.cfg
@@ -0,0 +1,518 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET    /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC     2  /* Number for DRCs to retain */
+DEFINE  BD_DDR_RET_NUM_REGION  6  /* DDR regions to save/restore */
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80008040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80010000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+DEFINE  BD_DDR_RET_REGION4_ADDR  0x80001000
+DEFINE  BD_DDR_RET_REGION4_SIZE  64
+DEFINE  BD_DDR_RET_REGION5_ADDR  0x80009040
+DEFINE  BD_DDR_RET_REGION5_SIZE  16
+DEFINE  BD_DDR_RET_REGION6_ADDR  0x80011000
+DEFINE  BD_DDR_RET_REGION6_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 17
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 800MHz DDR, DRC 400MHz operation */
+DATA 4  0xff148000  0x00000C85  /* DRC0 bringup */
+DATA 4  0xff1a0000  0x00000C85  /* DRC1 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+else
+{
+/* Change to div4 output */
+DATA 4 0x41A43800 0x4C000000
+DATA 4 0x41D03800 0x4C000000
+}
+#endif
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4  0x41a40040  0xB
+DATA 4  0x41d00040  0xB
+DATA 4  0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000111  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x00C35000  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0   0x0021F000
+DATA 4   DDRC_RFSHTMG_0   0x00300070  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0     0x4002030F  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0     0x00500000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0     0x00240012  // MR1, MR2
+DATA 4   DDRC_INIT4_0     0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x10100D11  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x0003041A  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x0408100F  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00606000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x08040408  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02030606  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020004  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020310  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x00000073  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x0190000C  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x014030D4  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x048D8206  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00000B04  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_0     0x00002211  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_0  0x00808000
+
+/* DRAM 1 controller initialization */
+DATA 4  DDRC_MSTR_1       0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4  DDRC_DERATEEN_1   0x00000111  // derate enable, derate values, byte to read MRR data
+DATA 4  DDRC_DERATEINT_1  0x00C35000  // derate MR4 interval read
+DATA 4  DDRC_RFSHCTL0_1   0x0021F000
+DATA 4  DDRC_RFSHTMG_1    0x00300070  // tREFI, tRFC
+DATA 4  DDRC_INIT0_1      0x4002030F  // pre_cke = 2ms, post_cke = 2us
+DATA 4  DDRC_INIT1_1      0x00500000  // dram_rstn = 200us
+DATA 4  DDRC_INIT3_1      0x00240012  // MR1, MR2
+DATA 4  DDRC_INIT4_1      0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_1    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_1   0x10100D11  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_1   0x0003041A  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_1   0x0408100F  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_1   0x00606000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_1   0x08040408  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_1   0x02030606  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_1   0x02020004  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_1   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_1  0x00020310  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_1  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_1  0x00000073  // txsr
+DATA 4  DDRC_ZQCTL0_1     0x0190000C  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_1     0x014030D4  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_1    0x048D8206  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_1    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_1    0x00000B04  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_1    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_1    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_1    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_1    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_1   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_1   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_1   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_1   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_1   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_1   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_1     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4  DDRC_ODTMAP_1     0x00002211  // rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_1    0x00000001  // Enable port 0
+DATA 4  DDRC_DFITMG0_SHADOW_1  0x00808000
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0   0x0000010A
+DATA 4  DDRC_PWRCTL_1   0x0000010A
+DATA 4  DDRC_PWRTMG_0   0x00402010
+DATA 4  DDRC_PWRTMG_1   0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x06FF0001
+DATA 4  DDRC_HWLPCTL_1  0x06FF0001
+
+DATA 4 DDRC_SCHED_0 0x00001F05  // CAM (32 entries)
+DATA 4 DDRC_SCHED_1 0x00001F05  // CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+DATA 4  DDRC_DFILPCFG0_1  0x0700B100
+
+DATA 4  0x41a40208  0x1
+DATA 4  0x41d00208  0x1
+DATA 4   0x41a40040  0xF
+DATA 4  0x41d00040  0xF
+DATA 4   0x41a40204  0x1
+DATA 4  0x41d00204  0x1
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_0  0x00F06AAC  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x32019010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x27100E10  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x011C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x011C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008A2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001B9BB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4   DDR_PHY_PIR_0  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0  0x33
+//-------------------------------------------
+// Configure registers for PHY initialization
+//-------------------------------=------------
+// Set-up DRAM 1 PHY Configuration Register
+DATA 4  DDR_PHY_DCR_1  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_1  0x000F0009
+DATA 4  DDR_PHY_DX0DQMAP0_1  0x00003465  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_1  0x00008271  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_1  0x00075632  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_1  0x00008104  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_1  0x00064732  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_1  0x00008015  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_1  0x00012574  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_1  0x00008360  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_CATR0_1  0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_1  0x0013AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4  DDR_PHY_PGCR1_1  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_1  0x87001E00  // Set ADCP=1 (Address Copy)
+DATA 4  DDR_PHY_PGCR2_1  0x00F06AAC  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_1  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_1  0x32019010  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_1  0x27100E10  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_1  0x011C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_1  0x011C0000
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_1  0x008A2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4  DDR_PHY_ZQ0PR0_1  0x0001B9BB  // Impedance control for CA bus
+DATA 4  DDR_PHY_ZQ1PR0_1  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4  DDR_PHY_PIR_1  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x33
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x24  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x12  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_0  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x08221108  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x2820040C  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x006640E6  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800301  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x00E02B09  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x11330F09  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_0  0x00186A00  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000640  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x00027100  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x01B00320  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F0016F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_1  0x24  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_1  0x12  // Set RL/WL
+DATA 4  DDR_PHY_MR3_1  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_1  0x54  // Set CA ODT and DQ ODT
+DATA 4  DDR_PHY_MR22_1  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_1  0x48
+DATA 4  DDR_PHY_MR14_1  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_1  0x08221108  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_1  0x2820040C  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_1  0x006640E6  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_1  0x01800301  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_1  0x00E02B09  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_1  0x11330F09  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_1  0x000A3DEF
+DATA 4  DDR_PHY_PTR3_1  0x00186A00  // tDINIT0
+DATA 4  DDR_PHY_PTR4_1  0x00000640  // tDINIT1
+DATA 4  DDR_PHY_PTR5_1  0x00027100  // tDINIT2
+DATA 4  DDR_PHY_PTR6_1  0x01B00320  // tDINIT4, tDINIT3 (1us)
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_1  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_1  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_1  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_1  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_1  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_1  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_1  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_1  0x07F0016F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_1  0x4
+DATA 4  DDR_PHY_PGCR6_1  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_1  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_1  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH
+DATA 4  DDR_PHY_DX8SLbDXCTL2_1  0x001C1600
+DATA 4  DDR_PHY_PGCR4_1  0x001900B1
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_1  0x79000000  // I/O mode = LPDDR4
+
+// Wait PHY initialization end then launch DRAM initialization
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+// Launch DRAM 1 initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_1  0x180
+DATA 4  DDR_PHY_PIR_1  0x181
+
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// DRAM 1 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_1  0x1
+
+// Launch a second time DRAM initialization due to following Synopsys PHY bug:
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+DATA 4  DDR_PHY_PIR_1  0x100
+DATA 4  DDR_PHY_PIR_1  0x101
+
+// Wait (second time) DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+// Wait (second time) DRAM 1 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+CLR_BIT 4   DDR_PHY_DQSDR0_1  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_1  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_1  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_1  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4  DDR_PHY_BISTAR1_1  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4  DDR_PHY_BISTAR2_1  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4  DDR_PHY_BISTAR4_1  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for PHY bug (Synopsys
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+// (FYI avoiding refresh during training leads to Denali error (CUMULATIVE_REFRESH_POSTPONE_EXCEEDS_MAX_ALLOWED).
+DATA 4   DDR_PHY_DTCR0_0  0x000071C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4   DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+DATA 4  DDR_PHY_DTCR0_1  0x000071C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4  DDR_PHY_DTCR1_1  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+DATA 4  DDR_PHY_PIR_1  0x200
+DATA 4  DDR_PHY_PIR_1  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240F7
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Set DQS/DQSn glitch suppression resistor for training PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x012240F7
+// Launch Read DQS training
+DATA 4  DDR_PHY_PIR_1  0x400
+DATA 4  DDR_PHY_PIR_1  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+// Wait Read DQS training to complete PHY1
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY1
+DATA 4  DDR_PHY_DX8SLbDQSCTL_1  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+DATA 4  DDR_PHY_PIR_1  0x0010F800
+DATA 4  DDR_PHY_PIR_1  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_1   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_1   0x7FF40000
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+DRAM_VREF_training_hw(1);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+DRAM_VREF_training_sw(1);
+#endif
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+CLR_BIT 4  DDR_PHY_PGCR1_1  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+//DQS Drift Registers PHY1
+CLR_BIT 4  DDR_PHY_DX0GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_1  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_1  0x08000000
+// Enable DQS drift detection PHY1
+DATA 4  DDR_PHY_DQSDR0_1  0x20188005
+DATA 4  DDR_PHY_DQSDR1_1  0xA8AA0000
+DATA 4  DDR_PHY_DQSDR2_1  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4  0x41A40504  0x400
+DATA 4  0x41D00504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+CLR_BIT 4  DDR_PHY_PGCR6_1  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+CHECK_BITS_SET 4  DDRC_STAT_1  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q_car/imx8qx_dcd_1.2GHz.cfg b/uboot-firmware/imx8q_car/imx8qx_dcd_1.2GHz.cfg
new file mode 100755
index 0000000..73a7d37
--- /dev/null
+++ b/uboot-firmware/imx8q_car/imx8qx_dcd_1.2GHz.cfg
@@ -0,0 +1,376 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET        /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC  1  /* Number for DRCs to retain */
+DEFINE   BD_DDR_RET_NUM_REGION  3  /* DDR regions to save/restore */
+
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80004040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80008000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 14
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1200MHz DDR, DRC 600MHz operation */
+DATA 4   0xff190000   0x00000CC8   /* DRC0 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+//-------------------------------------------
+// Reset controller core domain (required to configure it)
+//--------------------------------------------
+DATA 4  0x41C80208  0x1
+DATA 4  0x41C80040  0xb
+DATA 4  0x41C80204  0x1
+
+//-------------------------------------------
+// Configure controller registers
+//--------------------------------------------
+/* DRAM controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000203  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0124F800  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0  0x0021F000
+DATA 4   DDRC_RFSHTMG_0  0x004900A8  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0    0x40030495  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0    0x00770000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0    0x00440024  // MR1, MR2
+DATA 4   DDRC_INIT4_0    0x00F100C0  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1618141A  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00050526  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x060E1514  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00909000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0B04060B  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02030909  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020006  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020510  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000AD  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x02580012  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x01E0493E  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x0499820A  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001708  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4	DDRC_ODTMAP_0     0x00000000	// rank[3:0]_wr_odt, rank[3:0]_wr_odt
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+
+//Performance optimizations
+DATA 4  DDRC_PWRCTL_0  0x0000010A
+DATA 4  DDRC_PWRTMG_0  0x00402010
+DATA 4  DDRC_HWLPCTL_0  0x003F0001
+
+DATA 4 DDRC_SCHED_0 0x7F001F05  // 30ns delay upon read store empty if write pending, CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100
+
+//-------------------------------------------
+// Release reset of controller core domain
+//--------------------------------------------
+DATA 4  0x41c80208  0x1
+DATA 4   0x41c80040  0xf
+DATA 4   0x41c80204  0x1
+
+//-------------------------------------------
+// Configure registers for PHY initialization
+//--------------------------------------------
+// Following are uncommented (to disable) or commented (to enable) particular byte lanes
+// DATA 4  DDR_PHY_DX2GCR1_0  0x55556000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR1_0  0x55556000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR1_0  0x55556000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR3_0  0x0029A4A4  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR3_0  0x0029A4A4  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR3_0  0x0029A4A4  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR4_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR4_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR4_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR5_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR5_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR5_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x0003000A
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00061032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00004578  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00071032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00004685  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00016578  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00004203  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00015867  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00004320  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX4DQMAP0_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_DX4DQMAP1_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0103AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0040  // DISDIC=1 (no uMCTL2 commands can go to memory), WDQSEXT=1, PUBMODE=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy) if 32-bit, else 0 if 16-bit data bus
+DATA 4  DDR_PHY_PGCR2_0  0x00F0A193  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x4B025810  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x3A981518  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x801C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x801C0000
+// SET_BIT 4  DDR_PHY_DX8SL1PLLCR0_0  0x20000000  // uncommented to disable byte lanes 2 and 3 PLL when configured for 16-bit data bus
+// SET_BIT 4  DDR_PHY_DX8SL2PLLCR0_0  0x20000000  // uncommented to disable byte lanes 4 and 5 PLL when configured for 16-bit data bus
+
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008B2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001BBBB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+
+//-------------------------------------------
+// Launch PLL init
+//--------------------------------------------
+DATA 4   DDR_PHY_PIR_0  0x10
+DATA 4   DDR_PHY_PIR_0  0x11
+
+// Wait end of PLL init (Wait for bit 0 of PGSR0 to be '1')
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+
+//-------------------------------------------
+// Switch to boot frequency and launch DCAL+ZCAL
+//--------------------------------------------
+DATA 4   DDR_PHY_PLLCR0_0  0xA01C0000  // Put PLL in power down state
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0xA01C0000
+// Switch to boot frequency
+DATA 4  0x41C80208  0x1  // Gate functional clock to avoid glitches
+DATA 4   0x41C80504  0x00800000  // Set bypass mode in DSC GPR control register
+DATA 4   0x41C80204  0x1  // Ungate functional clock
+// Set PLL timings for boot frequency
+DATA 4  DDR_PHY_PTR0_0  0x026012C1
+DATA 4  DDR_PHY_PTR1_0  0x01D500A9
+// Launch DCAL+ZCAL
+DATA 4   DDR_PHY_PIR_0  0x22
+DATA 4   DDR_PHY_PIR_0  0x23
+
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x44  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x24  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA and DQ ODT
+DATA 4  DDR_PHY_MR13_0  0xC0
+DATA 4  DDR_PHY_MR22_0  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x0C331A09  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28300411  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x0069615A  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800501  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01502B0C  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x194C160D  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF  // tWLDLYS
+DATA 4  DDR_PHY_PTR3_0  0x000124F8  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x0000004B  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x00001D4C  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x00B00026  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070801  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F0018F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH=0xA
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+
+//Enable PHY PLL to go into power down on DFI low power request
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+
+//-------------------------------------------
+// Wait end of PHY initialization then launch DRAM initialization
+//-------------------------------------------
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+
+//-------------------------------------------
+// Wait end of DRAM initialization then launch second DRAM initialization
+// This is required due to errata e10945:			
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+//-------------------------------------------
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+// tDINIT0 reduced to 2us instead of 2ms. No need to wait the 2ms for the second DRAM init.
+DATA 4   DDR_PHY_PTR3_0  0x0000004B
+// Launch DRAM initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+
+//-------------------------------------------
+// Wait end of second DRAM initialization
+//-------------------------------------------
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+
+//-------------------------------------------
+// Run CBT (Command Bus Training)
+//-------------------------------------------
+//Call run_cbt(initial DDR_PHY_PTR0 value, initial DDR_PHY_PTR1 value, total_num_drc) here
+run_cbt(0x4B025810, 0x3A981518, 1);
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys			
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4   DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4   DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947			
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240F7
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+#endif
+
+DATA 4 DDR_PHY_DX8SLbDDLCTL_0 0x00100002
+
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+
+//Enable QCHAN HWidle
+DATA 4   0x41c80504  0x400
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q_car/imx8qx_dcd_1.2GHz_nocbt.cfg b/uboot-firmware/imx8q_car/imx8qx_dcd_1.2GHz_nocbt.cfg
new file mode 100755
index 0000000..145e460
--- /dev/null
+++ b/uboot-firmware/imx8q_car/imx8qx_dcd_1.2GHz_nocbt.cfg
@@ -0,0 +1,334 @@
+#define __ASSEMBLY__
+
+#include <MX8/MX8_ddrc.h>
+#include <MX8/MX8_ddr_phy.h>
+
+/*! Enable LPDDR4 derate workaround */
+DEFINE LP4_MANUAL_DERATE_WORKAROUND
+
+/*! Configure DDR retention support */
+DEFINE  BD_DDR_RET        /* Add/remove DDR retention */
+
+DEFINE  BD_DDR_RET_NUM_DRC  1  /* Number for DRCs to retain */
+DEFINE   BD_DDR_RET_NUM_REGION  3  /* DDR regions to save/restore */
+
+/* Descriptor values for DDR regions saved/restored during retention */
+DEFINE  BD_DDR_RET_REGION1_ADDR  0x80000000
+DEFINE  BD_DDR_RET_REGION1_SIZE  64
+DEFINE  BD_DDR_RET_REGION2_ADDR  0x80004040
+DEFINE  BD_DDR_RET_REGION2_SIZE  16
+DEFINE  BD_DDR_RET_REGION3_ADDR  0x80008000
+DEFINE  BD_DDR_RET_REGION3_SIZE  48
+
+/*
+ * Device Configuration Data (DCD) Version 14
+ *
+ * Each entry must have the format:
+ * Addr-type           Address        Value
+ *
+ * where:
+ * Addr-type register length (1,2 or 4 bytes)
+ * Address   absolute address of the register
+ * value   value to be stored in the register
+ */
+
+#ifndef SCFW_DCD
+/* For 1200MHz DDR, DRC 600MHz operation */
+DATA 4   0xff190000   0x00000CC8   /* DRC0 bringup */
+#else
+if (action != BOARD_DDR_COLD_INIT)
+{
+  return SC_ERR_NONE;
+}
+#endif
+
+DATA 4  0x41C80208  0x1
+DATA 4  0x41C80040  0xb
+DATA 4  0x41C80204  0x1
+
+/* DRAM 0 controller configuration begin */
+DATA 4   DDRC_MSTR_0     0xC3080020  // Set LPDDR4, BL = 16 and active ranks
+DATA 4   DDRC_DERATEEN_0     0x00000203  // derate enable, derate values, byte to read MRR data
+DATA 4   DDRC_DERATEINT_0     0x0124F800  // derate MR4 interval read
+DATA 4   DDRC_RFSHCTL0_0  0x0021F000  // REFRESH_BURST = 7
+DATA 4   DDRC_RFSHTMG_0  0x004900A8  // tREFI, tRFC
+DATA 4   DDRC_INIT0_0    0x40030495  // pre_cke = 2ms, post_cke = 2us
+DATA 4   DDRC_INIT1_0    0x00770000  // dram_rstn = 200us
+DATA 4   DDRC_INIT3_0    0x00440024  // MR1, MR2
+DATA 4   DDRC_INIT4_0    0x00F10000  // MR3, MR13
+DATA 4  DDRC_RANKCTL_0    0x0000066F  // diff_rank_wr_gap, diff_rank_rd_gap, max_rank_rd
+DATA 4  DDRC_DRAMTMG0_0   0x1618141A  // wr2pr, tFAW, tRASmax, tRASmin
+DATA 4  DDRC_DRAMTMG1_0   0x00050526  // tXP, rd2pre, tRC
+DATA 4  DDRC_DRAMTMG2_0   0x060E1514  // WL, RL, rd2wr, wr2rd
+DATA 4  DDRC_DRAMTMG3_0   0x00909000  // tmrw, tmrd, tmod
+DATA 4  DDRC_DRAMTMG4_0   0x0B04060B  // trcd, tccd, trrd, trp
+DATA 4  DDRC_DRAMTMG5_0   0x02030909  // tCKCKEH, tCKCKEL, tckesr, tcke
+DATA 4  DDRC_DRAMTMG6_0   0x02020006  // tckdpde, tckdpdx, tckcsx
+DATA 4  DDRC_DRAMTMG7_0   0x00000301  // tckpde, tckpdx
+DATA 4  DDRC_DRAMTMG12_0  0x00020510  // tCMDCKE, tCKEHCMD
+DATA 4  DDRC_DRAMTMG13_0  0x0B100002  // tODTLoff, tCCDMW, tPPD
+DATA 4  DDRC_DRAMTMG14_0  0x000000AD  // txsr
+DATA 4  DDRC_ZQCTL0_0     0x02580012  // tZQCAL, tZQLAT
+DATA 4  DDRC_ZQCTL1_0     0x01E0493E  // tZQReset, tzq_short_interval
+DATA 4  DDRC_DFITMG0_0    0x0499820A  // dfi_t_ctrl_delay, dfi_t_rddata_en, dfi_tphy_wrdata, dfi_tphy_wrlat
+DATA 4  DDRC_DFITMG1_0    0x00070303  // dfi_t_wrdata_delay, dfi_t_dram_clk_disable, dfi_t_dram_clk_enable
+DATA 4  DDRC_DFITMG2_0    0x00001708  // dfi_tphy_rdcslat, dfi_tphy_wrcslat
+DATA 4  DDRC_DFIMISC_0    0x00000005  // dfi_data_cs_polarity
+DATA 4  DDRC_DFIUPD0_0    0x00400003  // Disable the automatic dfi_ctrlupd_req generation
+DATA 4  DDRC_DFIUPD1_0    0x008000A0  // dfi_ctrlupd_req generation interval generation (min and max)
+DATA 4  DDRC_DFIUPD2_0    0x80000000  // dfi_phyupd_en
+DATA 4  DDRC_ADDRMAP0_0   0x00000007  // addrmap_cs_bit0
+DATA 4  DDRC_ADDRMAP3_0   0x00000000  // addrmap_col_b9, addrmap_col_b8, addrmap_col_b7, addrmap_col_b6
+DATA 4  DDRC_ADDRMAP4_0   0x00001F1F  // addrmap_col_b10 and addrmap_col_b11 set to de-activated
+DATA 4  DDRC_ADDRMAP1_0   0x00080808  // addrmap_bank_b2, addrmap_bank_b1, addrmap_bank_b0
+DATA 4  DDRC_ADDRMAP5_0   0x08080808  // addrmap_row_b11, addrmap_row_b10_b2, addrmap_row_b1, addrmap_row_b0
+DATA 4  DDRC_ADDRMAP6_0   0x48080808  // addrmap_row_b15, addrmap_row_b14, addrmap_row_b13, addrmap_row_b12
+DATA 4  DDRC_DBICTL_0     0x00000007  // rd_dbi_en=wr_dbi_en=dm_en=1
+DATA 4	DDRC_ODTMAP_0   	0x00000000	// rank[3:0]_wr_odt, rank[3:0]_wr_odt		
+DATA 4  DDRC_PCTRL_0_0    0x00000001  // Enable port 0
+DATA 4  DDRC_HWLPCTL_0  0x003F0001  // Enable Hardware idle period
+
+DATA 4 DDRC_SCHED_0 0x7F001F05  // 30ns delay upon read store empty if write pending, CAM (32 entries)
+
+//Enables DFI Low Power interface
+DATA 4  DDRC_DFILPCFG0_0  0x0700B100  // dfi_lp_en_sr, dfi_lp_wakeup_sr config
+
+DATA 4  DDRC_DFITMG0_SHADOW_0  0x00808000
+
+DATA 4  DDRC_PWRCTL_0  0x0000010A
+DATA 4  DDRC_PWRTMG_0  0x00402010
+
+DATA 4  0x41c80208  0x1
+DATA 4   0x41c80040  0xf
+DATA 4   0x41c80204  0x1
+
+//-------------------------------------------
+// Configure registers for PHY initialization
+// Timings are computed for 1200MHz DRAM operation
+//--------------------------------------------
+// Following are uncommented (to disable) or commented (to enable) particular byte lanes
+// DATA 4  DDR_PHY_DX2GCR1_0  0x55556000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR1_0  0x55556000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR1_0  0x55556000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR2_0  0xAAAAAAAA  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR3_0  0x0029A4A4  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR3_0  0x0029A4A4  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR3_0  0x0029A4A4  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR4_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR4_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR4_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+// DATA 4  DDR_PHY_DX2GCR5_0  0x00000000  // uncommented to disable byte lane 2 when configured for 16-bit data bus
+// DATA 4  DDR_PHY_DX3GCR5_0  0x00000000  // uncommented to disable byte lane 3 when configured for 16-bit data bus
+DATA 4   DDR_PHY_DX4GCR5_0  0x00000000  // uncommented to disable byte lane 4 since it is not used for LPDDR4
+
+// Set-up DRAM Configuration Register
+DATA 4  DDR_PHY_DCR_0  0x0000040D  // LPDDR4 selection with 8 bank
+// Set-up byte and bit swapping registers
+DATA 4  DDR_PHY_PGCR8_0      0x0003000A
+DATA 4  DDR_PHY_DX0DQMAP0_0  0x00061032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX0DQMAP1_0  0x00004578  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX1DQMAP0_0  0x00071032  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX1DQMAP1_0  0x00004685  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX2DQMAP0_0  0x00016578  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX2DQMAP1_0  0x00004203  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX3DQMAP0_0  0x00015867  // DQ bit 0/1/2/3/4 remapping
+DATA 4  DDR_PHY_DX3DQMAP1_0  0x00004320  // DQ bit 5/6/7 and DM remapping
+DATA 4  DDR_PHY_DX4DQMAP0_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_DX4DQMAP1_0  0x00000000  // Clear these as they are unused for LPDDR4
+DATA 4  DDR_PHY_CATR0_0      0x00141032  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+DATA 4  DDR_PHY_CATR1_0      0x0103AAAA  // Only for LPDDR3 but used here to know how LPDDR4 bytes are connected to PHY
+// Set-up PHY General Configuration Register
+// PGCR1,4,5,6,7 are untouched
+SET_BIT 4   DDR_PHY_PGCR1_0  0x000A0000  // DISDIC=1 (no uMCTL2 commands can go to memory) and WDQSEXT=1
+DATA 4  DDR_PHY_PGCR0_0  0x87001E00  // Set ADCP=1 (Address Copy) if 32-bit, else 0 if 16-bit data bus
+DATA 4  DDR_PHY_PGCR2_0  0x00F0A193  // Set tREFPRD
+DATA 4  DDR_PHY_PGCR3_0  0x050A1080  // CKEN/CKNEN toggling and polarity
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR0_0  0x4B025810  // tPLLPD, tPLLGS, tPHYRST
+DATA 4  DDR_PHY_PTR1_0  0x3A981518  // tPLLLOCK, tPLLRST
+// Set-up PLL Control Register
+DATA 4  DDR_PHY_PLLCR0_0        0x001C0000
+DATA 4  DDR_PHY_DX8SLbPLLCR0_0  0x001C0000
+// SET_BIT 4  DDR_PHY_DX8SL1PLLCR0_0  0x20000000  // uncommented to disable byte lanes 2 and 3 PLL when configured for 16-bit data bus
+// SET_BIT 4  DDR_PHY_DX8SL2PLLCR0_0  0x20000000  // uncommented to disable byte lanes 4 and 5 PLL when configured for 16-bit data bus
+
+// Set-up Impedance Control Register
+DATA 4  DDR_PHY_ZQCR_0  0x008B2C58  // Set ODT_MODE=0b10(LPDDR4 stype pullup)
+// ZPROG_DRAM_ODT and ZPROG_HOST_ODT
+DATA 4   DDR_PHY_ZQ0PR0_0  0x0001BBBB  // Impedance control for CA bus
+DATA 4   DDR_PHY_ZQ1PR0_0  0x0001B9BB  // Impedance control for DQ bus
+// Set-up PHY Initialization Register
+DATA 4   DDR_PHY_PIR_0  0x32
+// Launch initialization (set bit 0)
+DATA 4  DDR_PHY_PIR_0  0x33
+
+//-------------------------------------------
+// Configure registers for DRAM initialization
+//-------------------------------------------
+// Set-up Mode Register
+// MR0, MR3, MR4, MR5 MR6 are untouched
+DATA 4  DDR_PHY_MR1_0  0x44  // Set BL, WR-PRE, nWR, RPST
+DATA 4  DDR_PHY_MR2_0  0x24  // Set RL/WL
+DATA 4  DDR_PHY_MR3_0  0xF1  // Set drive strength
+
+DATA 4  DDR_PHY_MR11_0  0x54  // Set CA and DQ ODT
+DATA 4  DDR_PHY_MR22_0  0x15  // Set ODTE-CS=1 (overrides ODT_CA for CS1 as CS not shared between ranks)
+/* LPDDR4 mode register writes for CA and DQ VREF settings */
+DATA 4  DDR_PHY_MR12_0  0x48
+DATA 4  DDR_PHY_MR14_0  0x48
+// Set-up DRAM Timing Parameters Register
+// DTPR6 is untouched
+DATA 4  DDR_PHY_DTPR0_0  0x0C331A09  // tRRD, tRAS, tRP, tRTP
+DATA 4  DDR_PHY_DTPR1_0  0x28300411  // tWLMRD, tFAW, tODTUP, tMRD
+DATA 4  DDR_PHY_DTPR2_0  0x0069615A  // tRTW, tRTODT, tCMDCKE, tCKE, tVRCG, tXS
+DATA 4  DDR_PHY_DTPR3_0  0x01800501  // tODX, tCCD, tDLLK, tDQSCKmax, tDQSCK
+DATA 4  DDR_PHY_DTPR4_0  0x01502B0C  // tRFC, tWLO, tXP
+DATA 4  DDR_PHY_DTPR5_0  0x194C160D  // tRC, tRCD, tWTR
+// Set-up PHY Timing Register
+DATA 4  DDR_PHY_PTR2_0  0x000A3DEF  // tWLDLYS
+DATA 4  DDR_PHY_PTR3_0  0x00249F00  // tDINIT0
+DATA 4  DDR_PHY_PTR4_0  0x00000960  // tDINIT1
+DATA 4  DDR_PHY_PTR5_0  0x0003A980  // tDINIT2
+DATA 4  DDR_PHY_PTR6_0  0x027004B0  // tDINIT4, tDINIT3
+// Set-up ODT Configuration Register
+// DDR ODT_CA signal is tied at boundary of DDR. Thus no need to drive it dynamically.
+DATA 4  DDR_PHY_RANKIDR_0  0x00000001  // Select rank 1 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank1 disabled
+DATA 4  DDR_PHY_RANKIDR_0  0x00000000  // Select rank 0 to write
+DATA 4  DDR_PHY_ODTCR_0  0x00000000  // ODT of rank0 disabled
+// Set-up AC I/O Configuration Register
+// ACIOCR1-4 are untouched
+DATA 4  DDR_PHY_ACIOCR0_0  0x30070800  // PNUM2 (i.e.LPDDR4) selection  [10:11] = 0x2
+DATA 4  DDR_PHY_ACIOCR5_0  0x09000000  // I/O mode = LPDDR4
+// Due to address copy set A[13] (=cke_B[0]) and A[15] (=cke_B[1]) outputs as always ON.
+DATA 4  DDR_PHY_ACIOCR1_0  0x44000000
+// Set-up VREF Training Control Registers
+DATA 4  DDR_PHY_VTCR0_0  0xF0032008  // CK1, CK0, DRAM VREF set to same as MR12
+DATA 4  DDR_PHY_VTCR1_0  0x07F0018F  // HVIO=1, SHREN=1, SHRNK=0
+// Set-up DATX8 General Configuration Registers
+// DXnGCR0-4 are untouched
+SET_BIT 4  DDR_PHY_PGCR5_0  0x4
+DATA 4  DDR_PHY_PGCR6_0  0x00033200  // Enable CSN Bit Delay VT Compensation (AC already enabled by default) + drift limit
+// Set-up DATX8 General Configuration Registers
+DATA 4  DDR_PHY_DX0GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR5_0  0x09092020  // Set DXREFISELR0 and DXREFISELR1 to 0x30, maintain other defaults
+DATA 4  DDR_PHY_DX0GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX1GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX2GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+DATA 4  DDR_PHY_DX3GCR4_0  0x0E00BF3C  // Set DXREFSSEL,DXREFSSELRANGE,DXREFSEN,DXREFIEN, maintain other defaults
+// Set-up DATX8 DX Control Register 2
+// PREOEX=2.5tCK (0.5 more than MR1), POSOEX=1tCK (0.5 more than in MR3), LPWAKEUP_THRSH=0xA
+DATA 4  DDR_PHY_DX8SLbDXCTL2_0  0x001C1600
+
+//Enable PHY PLL to go into power down on DFI low power request
+DATA 4  DDR_PHY_PGCR4_0  0x001900B1
+
+// Set-up DATX8 IO Control Register
+DATA 4  DDR_PHY_DX8SLbIOCR_0  0x79000000  // I/O mode = LPDDR4
+
+// Wait PHY initialization end then launch DRAM initialization
+// Wait for bit 0 of PGSR0 to be '1'
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x7FF40000  // Check that no error occured
+
+// Launch DRAM 0 initialization (set bit 0)
+DATA 4   DDR_PHY_PIR_0  0x180
+DATA 4   DDR_PHY_PIR_0  0x181
+
+// DRAM 0 initialization end
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x7FF40000
+
+// Launch a second time DRAM initialization due to errata e10945:					
+// Title: "PUB does not program LPDDR4 DRAM MR22 prior to running DRAM ZQ calibration"
+// Workaround: "Run DRAM Initialization twice"
+DATA 4   DDR_PHY_PIR_0  0x100
+DATA 4   DDR_PHY_PIR_0  0x101
+
+// Wait (second time) DRAM 0 initialization end
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x7FF40000
+
+//---------------------------------------------------------------//
+// DATA training
+//---------------------------------------------------------------//
+// configure PHY for data training
+// The following register writes are recommended by SNPS prior to running training
+CLR_BIT 4   DDR_PHY_DQSDR0_0  0x00000001  // Disable drift
+SET_BIT 4   DDR_PHY_PGCR6_0  0x00000001  // Disable VT compensation
+CHECK_BITS_SET 4   DDR_PHY_PGSR1_0  0x40000000  // Disable VT compensation
+SET_BIT 4   DDR_PHY_PGCR1_0  0x00020040  // DISDIC=1; PUBMODE=1
+// Per SNPS initialize BIST registers for VREF training
+DATA 4   DDR_PHY_BISTAR1_0  0x00010100  //BMRANK=1 (maximum rank minus 1); BIST Address Increment: 0x10 (16)
+DATA 4   DDR_PHY_BISTAR2_0  0x700003FF  // BMBANK=8; BMCOL=0x400 (limit to min cols in JEDEC)
+DATA 4   DDR_PHY_BISTAR4_0  0x00003FFF  // BMROW=0x4000 (limit to min rows in JEDEC)
+
+// Set-up Data Training Configuration Register
+// Note that DTCR0.RFSHDT are set to 0x0 as a workaround for errata e10946 (Synopsys					
+// case 9001045655: Design limitation in LPDDR4 mode: REFRESH must be disabled during DQS2DQ training).
+DATA 4   DDR_PHY_DTCR0_0  0x000031C7  // Set DTRPTN to 0x7. RFSHDT=0
+DATA 4   DDR_PHY_DTCR1_0  0x00030236  // Set RANKEN
+
+// Launch Write leveling
+DATA 4   DDR_PHY_PIR_0  0x200
+DATA 4   DDR_PHY_PIR_0  0x201
+// Wait Write leveling to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0  0x00200000
+
+// Set DQS/DQSn glitch suppression resistor for training PHY0 to satisfy errata e10947					
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x012240F7
+// Launch Read DQS training
+DATA 4   DDR_PHY_PIR_0  0x400
+DATA 4   DDR_PHY_PIR_0  0x401
+// Wait Read DQS training to complete PHY0
+CHECK_BITS_SET 4   DDR_PHY_PGSR0_0  0x1
+CHECK_BITS_CLR 4   DDR_PHY_PGSR0_0  0x00400000
+// Remove DQS/DQSn glitch suppression resistor PHY0
+DATA 4   DDR_PHY_DX8SLbDQSCTL_0  0x01224000
+
+// DQS2DQ training, Write leveling, Deskew and eye trainings
+DATA 4  DDR_PHY_PIR_0  0x0010F800
+DATA 4  DDR_PHY_PIR_0  0x0010F801
+// Wait for training to complete
+CHECK_BITS_SET 4  DDR_PHY_PGSR0_0   0x1
+CHECK_BITS_CLR 4  DDR_PHY_PGSR0_0   0x7FF40000
+
+// run rdbi deskew training
+RDBI_bit_deskew(0);
+
+#ifdef MINIMIZE
+// Launch VREF training
+DRAM_VREF_training_hw(0);
+#else
+// Run vref training
+DRAM_VREF_training_sw(0);
+#endif
+
+DATA 4	DDR_PHY_DX8SLbDDLCTL_0	0x00100002			
+					
+//Re-allow uMCTL2 to send commands to DDR
+CLR_BIT 4  DDR_PHY_PGCR1_0  0x00020040  // DISDIC=0, PUBMODE=0
+
+//DQS Drift Registers PHY0
+CLR_BIT 4  DDR_PHY_DX0GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX1GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX2GCR3_0  0x08000000
+CLR_BIT 4  DDR_PHY_DX3GCR3_0  0x08000000
+// Enable DQS drift detection PHY0
+DATA 4   DDR_PHY_DQSDR0_0  0x20188005
+DATA 4   DDR_PHY_DQSDR1_0  0xA8AA0000
+DATA 4   DDR_PHY_DQSDR2_0  0x00070200
+
+// Enable VT compensation
+CLR_BIT 4  DDR_PHY_PGCR6_0  0x1
+
+DATA 4   0x41c80504  0x400
+//Check that controller is ready to operate
+CHECK_BITS_SET 4  DDRC_STAT_0  0x1
+
+ddrc_lpddr4_derate_init(BD_DDR_RET_NUM_DRC);
diff --git a/uboot-firmware/imx8q_car/mx8dx-scfw-tcm.bin b/uboot-firmware/imx8q_car/mx8dx-scfw-tcm.bin
new file mode 100755
index 0000000..1c40241
Binary files /dev/null and b/uboot-firmware/imx8q_car/mx8dx-scfw-tcm.bin differ
diff --git a/uboot-firmware/imx8q_car/mx8qm-scfw-tcm.bin b/uboot-firmware/imx8q_car/mx8qm-scfw-tcm.bin
index a91e761..fed31fc 100755
Binary files a/uboot-firmware/imx8q_car/mx8qm-scfw-tcm.bin and b/uboot-firmware/imx8q_car/mx8qm-scfw-tcm.bin differ
diff --git a/uboot-firmware/imx8q_car/mx8qx-scfw-tcm.bin b/uboot-firmware/imx8q_car/mx8qx-scfw-tcm.bin
index 4029020..4532f35 100755
Binary files a/uboot-firmware/imx8q_car/mx8qx-scfw-tcm.bin and b/uboot-firmware/imx8q_car/mx8qx-scfw-tcm.bin differ
