a5b2ac0 Jay 2021-11-24

AOS-777: support light sensor hal

Copy ST snesor HAL from hardware/STMicroelectronics/SensorHAL_Inputand
an implement light sensor hal into sensor hal.

Change-Id: I99b58872692580c02537b904b51b0f19182af32f

diff --git a/AccelSensor.cpp b/AccelSensor.cpp
new file mode 100644
index 0000000..e77d188
--- /dev/null
+++ b/AccelSensor.cpp
@@ -0,0 +1,674 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "AccelSensor.h"
+
+#define FETCH_FULL_EVENT_BEFORE_RETURN		0
+#define MS2_TO_G(x)				(x / 9.8)
+
+/*****************************************************************************/
+
+sensors_vec_t  AccelSensor::dataBuffer;
+int AccelSensor::mEnabled = 0;
+int64_t AccelSensor::delayms = 0;
+int AccelSensor::current_fullscale = 0;
+int64_t AccelSensor::setDelayBuffer[numSensors] = {0};
+int64_t AccelSensor::writeDelayBuffer[numSensors] = {0};
+int AccelSensor::DecimationBuffer[numSensors] = {0};
+int AccelSensor::DecimationCount = 0;
+pthread_mutex_t AccelSensor::dataMutex;
+
+AccelSensor::AccelSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_ACCELEROMETER),
+	mInputReader(6),
+	mHasPendingEvent(false)
+{
+	pthread_mutex_init(&dataMutex, NULL);
+
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+
+	mPendingEvents[Acceleration].version = sizeof(sensors_event_t);
+	mPendingEvents[Acceleration].sensor = ID_ACCELEROMETER;
+	mPendingEvents[Acceleration].type = SENSOR_TYPE_ACCELEROMETER;
+	mPendingEvents[Acceleration].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+
+#if (SENSORS_UNCALIB_ACCELEROMETER_ENABLE == 1)
+	mPendingEvents[AccelUncalib].version = sizeof(sensors_event_t);
+	mPendingEvents[AccelUncalib].sensor = ID_UNCALIB_ACCELEROMETER;
+	mPendingEvents[AccelUncalib].type = SENSOR_TYPE_ACCELEROMETER_UNCALIBRATED;
+	memset(mPendingEvents[AccelUncalib].data, 0, sizeof(mPendingEvents[AccelUncalib].data));
+	mPendingEvents[AccelUncalib].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+	mPendingEvents[SignificantMotion].version = sizeof(sensors_event_t);
+	mPendingEvents[SignificantMotion].sensor = ID_SIGNIFICANT_MOTION;
+	mPendingEvents[SignificantMotion].type = SENSOR_TYPE_SIGNIFICANT_MOTION;
+	mPendingEvents[SignificantMotion].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+	mPendingEvents[ActivityReco].version = sizeof(sensors_event_t);
+	mPendingEvents[ActivityReco].sensor = ID_ACTIVITY_RECOGNIZER;
+	mPendingEvents[ActivityReco].type = SENSOR_TYPE_ACTIVITY;
+	mPendingEvents[ActivityReco].data[0] = 1.0f;
+#endif
+
+	if (data_fd) {
+		STLOGI("AccelSensor::AccelSensor accel_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("AccelSensor::AccelSensor accel_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+
+	data_raw[0] = data_raw[1] = data_raw[2] = 0.0;
+}
+
+AccelSensor::~AccelSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_ACCELEROMETER_HANDLE, 0, 0);
+	}
+	pthread_mutex_destroy(&dataMutex);
+}
+
+#if !defined(NOT_SET_ACC_INITIAL_STATE)
+int AccelSensor::setInitialState()
+{
+	struct input_absinfo absinfo_x;
+	struct input_absinfo absinfo_y;
+	struct input_absinfo absinfo_z;
+
+	if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_ACCEL_X), &absinfo_x) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_ACCEL_Y), &absinfo_y) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_ACCEL_Z), &absinfo_z))
+	{
+		mHasPendingEvent = true;
+	}
+
+	setFullScale(SENSORS_ACCELEROMETER_HANDLE, ACCEL_DEFAULT_FULLSCALE);
+	DecimationCount = 0;
+
+	return 0;
+}
+#endif
+
+int AccelSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+		case SENSORS_ACCELEROMETER_HANDLE:
+			what = Acceleration;
+			break;
+#if (SENSORS_UNCALIB_ACCELEROMETER_ENABLE == 1)
+		case SENSORS_UNCALIB_ACCELEROMETER_HANDLE:
+			what = AccelUncalib;
+			break;
+#endif
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+		case SENSORS_SIGNIFICANT_MOTION_HANDLE:
+			what = SignificantMotion;
+			break;
+#endif
+#if (SENSOR_FUSION_ENABLE == 1)
+		case SENSORS_SENSOR_FUSION_HANDLE:
+			what = iNemoAcceleration;
+			break;
+#endif
+#if (MAG_CALIBRATION_ENABLE == 1)
+		case SENSORS_MAGNETIC_FIELD_HANDLE:
+			what = MagCalAcceleration;
+			break;
+#endif
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+		case SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE:
+			what = GeoMagRotVectAcceleration;
+			break;
+#endif
+#if (SENSOR_FUSION_ENABLE == 0)
+  #if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+		case SENSORS_ORIENTATION_HANDLE:
+			what = Orientation;
+			break;
+  #endif
+  #if (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1)
+		case SENSORS_LINEAR_ACCELERATION_HANDLE:
+			what = Linear_Accel;
+			break;
+  #endif
+  #if (GEOMAG_GRAVITY_ENABLE == 1)
+		case SENSORS_GRAVITY_HANDLE:
+			what = Gravity_Accel;
+			break;
+  #endif
+#endif
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+		case SENSORS_VIRTUAL_GYROSCOPE_HANDLE:
+			what = VirtualGyro;
+			break;
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		case SENSORS_GYROSCOPE_HANDLE:
+			what = Gbias;
+			break;
+#endif
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+		case SENSORS_ACTIVITY_RECOGNIZER_HANDLE:
+			what = ActivityReco;
+			break;
+#endif
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int AccelSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0, errSM1 = 0, errSM2 = 0;
+	int flags = en ? 1 : 0;
+	int what = -1;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (flags) {
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+		if (what == SignificantMotion) {
+			//enable sysfs state machine
+			if(!(mEnabled & (1<<Acceleration)))
+				errSM1 = writeSysfsCommand(SENSORS_SIGNIFICANT_MOTION_HANDLE,
+								SIGN_MOTION_POLL_EN_FILE_NAME,
+								"%lld" ,0);
+
+			errSM2 = writeEnable(SENSORS_SIGNIFICANT_MOTION_HANDLE,
+								SIGN_MOTION_ENABLE_VALUE);
+
+		}
+		if (what == Acceleration) {
+			errSM2 = writeSysfsCommand(SENSORS_ACCELEROMETER_HANDLE,
+								SIGN_MOTION_POLL_EN_FILE_NAME,
+								"%lld", 1);
+		}
+#endif
+		mEnabled |= (1<<what);
+		writeMinDelay();
+
+		if ((mEnabled == (1<<what)) && (errSM1 >= 0) && (errSM2 >= 0)) {
+#if !defined(NOT_SET_ACC_INITIAL_STATE)
+			setInitialState();
+#endif
+			err = writeEnable(SENSORS_ACCELEROMETER_HANDLE, flags);	// Enable Accelerometer
+		}
+
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+		ST_AccCalibration_API_Init(ACCEL_CALIB_PERIOD_MS);
+#endif
+
+	} else {
+		int tmp = mEnabled;
+		mEnabled &= ~(1<<what);
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+		if (what == SignificantMotion)
+			errSM1 = writeEnable(SENSORS_SIGNIFICANT_MOTION_HANDLE,
+								SIGN_MOTION_DISABLE_VALUE);
+		if (what == Acceleration)
+			errSM2 = writeSysfsCommand(SENSORS_ACCELEROMETER_HANDLE,
+								SIGN_MOTION_POLL_EN_FILE_NAME,
+								"%lld", 0);
+#endif
+		if((!mEnabled) && (tmp != 0)) {
+			err = writeEnable(SENSORS_ACCELEROMETER_HANDLE, flags);
+		}
+		if ( (errSM1 < 0) || (errSM2 < 0) ){
+			err = -1;
+			mEnabled = tmp;
+		}
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+		ST_AccCalibration_API_DeInit(ACCEL_CALIB_PERIOD_MS);
+#endif
+		//setDelay(handle, DELAY_OFF);
+		if (mEnabled) {
+			writeMinDelay();
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("AccelSensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						flags, handle, what, mEnabled);
+	} else {
+		STLOGE("AccelSensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						flags, handle, what, mEnabled);
+	}
+
+	return err;
+}
+
+bool AccelSensor::hasPendingEvents() const
+{
+	return mHasPendingEvent;
+}
+
+int AccelSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err = 0;
+	int what = -1;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+
+	if(delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (mEnabled & (1<<SignificantMotion))
+	{
+		delay_ms = ACC_DEFAULT_DELAY;
+	}
+
+	/**
+	 * The handled sensor is disabled. Set 0 in its setDelayBuffer position
+	 * and update decimation buffer.
+	 */
+	if (delay_ms == NSEC_TO_MSEC(DELAY_OFF))
+		delay_ms = 0;
+
+	// Min setDelay Definition
+	setDelayBuffer[what] = delay_ms;
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("AccSensor::setDelayBuffer[] = %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld",
+						setDelayBuffer[0], setDelayBuffer[1],
+						setDelayBuffer[2], setDelayBuffer[3],
+						setDelayBuffer[4], setDelayBuffer[5],
+						setDelayBuffer[6], setDelayBuffer[7],
+						setDelayBuffer[8], setDelayBuffer[9],
+						setDelayBuffer[10]);
+#endif
+
+	// Update sysfs
+	if(mEnabled & 1 << what)
+	{
+		writeMinDelay();
+	}
+
+	return err;
+}
+
+int AccelSensor::writeMinDelay(void)
+{
+	int err = 0;
+	int kk;
+	int64_t Min_delay_ms = 0;
+
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if ((mEnabled & 1<<kk) != 0)
+		{
+			writeDelayBuffer[kk] = setDelayBuffer[kk];
+		}
+		else
+			writeDelayBuffer[kk] = 0;
+	}
+
+	// Min setDelay Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (Min_delay_ms != 0) {
+			if ((writeDelayBuffer[kk] != 0) && (writeDelayBuffer[kk] <= Min_delay_ms))
+				Min_delay_ms = writeDelayBuffer[kk];
+		} else
+			Min_delay_ms = writeDelayBuffer[kk];
+	}
+
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+	if(Min_delay_ms > ACCEL_CALIB_PERIOD_MS)
+		Min_delay_ms = ACCEL_CALIB_PERIOD_MS;
+#endif
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+	if ((mEnabled & (1 << ActivityReco)) &&
+		(Min_delay_ms > (1000 / ACTIVITY_RECOGNIZER_ODR)))
+			Min_delay_ms = 1000 / ACTIVITY_RECOGNIZER_ODR;
+#endif
+
+	if ((Min_delay_ms > 0) && (Min_delay_ms != delayms))
+	{
+		err = writeDelay(SENSORS_ACCELEROMETER_HANDLE, Min_delay_ms);
+		if(err >= 0) {
+			err = 0;
+			delayms = Min_delay_ms;
+			DecimationCount = 0;
+		}
+	}
+
+	// Decimation Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (kk == Acceleration || kk == Gbias)
+			continue;
+
+		if (delayms)
+			DecimationBuffer[kk] = writeDelayBuffer[kk]/delayms;
+		else
+			DecimationBuffer[kk] = 0;
+	}
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("AccSensor::writeDelayBuffer[] = %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld",
+						writeDelayBuffer[0], writeDelayBuffer[1],
+						writeDelayBuffer[2], writeDelayBuffer[3],
+						writeDelayBuffer[4], writeDelayBuffer[5],
+						writeDelayBuffer[6], writeDelayBuffer[7],
+						writeDelayBuffer[8], writeDelayBuffer[9],
+						writeDelayBuffer[10]);
+	STLOGD("AccSensor::Min_delay_ms = %lld, delayms = %lld, mEnabled = %d",
+						Min_delay_ms, delayms, mEnabled);
+	STLOGD("AccSensor::DecimationBuffer = %d, %d, %d, %d, %d, %d, %d, %d, %d, %d, %d",
+						DecimationBuffer[0], DecimationBuffer[1],
+						DecimationBuffer[2], DecimationBuffer[3],
+						DecimationBuffer[4], DecimationBuffer[5],
+						DecimationBuffer[6], DecimationBuffer[7],
+						DecimationBuffer[8], DecimationBuffer[9],
+						DecimationBuffer[10]);
+#endif
+
+	return err;
+}
+
+void AccelSensor::getAccDelay(int64_t *Acc_Delay_ms)
+{
+	*Acc_Delay_ms = delayms;
+
+	return;
+}
+
+
+int AccelSensor::setFullScale(int32_t  __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if(value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if(value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_ACCELEROMETER_HANDLE, value);
+		if(err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int AccelSensor::readEvents(sensors_event_t* data, int count)
+{
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+	float AccOffset[3];
+#endif
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+#if (FETCH_FULL_EVENT_BEFORE_RETURN)
+	again:
+#endif
+	while (count && mInputReader.readEvent(&event)) {
+		if (event->type == EVENT_TYPE_ACCEL) {
+#if (DEBUG_ACCELEROMETER == 1)
+	STLOGD("AccelSensor::readEvents (event_code=%d)", event->code);
+#endif
+			float value = (float) event->value;
+			if (event->code == EVENT_TYPE_ACCEL_X) {
+				data_raw[0] = value * CONVERT_A_X;
+			}
+			else if (event->code == EVENT_TYPE_ACCEL_Y) {
+				data_raw[1] = value * CONVERT_A_Y;
+			}
+			else if (event->code == EVENT_TYPE_ACCEL_Z) {
+				data_raw[2] = value * CONVERT_A_Z;
+			}
+#if defined(ACC_EVENT_HAS_TIMESTAMP)
+			else if (event->code == EVENT_TYPE_TIME_MSB) {
+				timestamp = ((int64_t)(event->value)) << 32;
+			}
+			else if (event->code == EVENT_TYPE_TIME_LSB) {
+				timestamp |= (uint32_t)(event->value);
+			}
+#endif
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+			else if (event->code == EVENT_TYPE_SIGNIFICANT_MOTION) {
+
+				if(mEnabled & (1<<SignificantMotion)) {
+					mPendingEvents[SignificantMotion].data[0] = value;
+					mPendingEvents[SignificantMotion].timestamp = timevalToNano(event->time);
+					mPendingMask |= 1<<SignificantMotion;
+  #if (DEBUG_ACCELEROMETER == 1)
+					STLOGD("AccelSensor::SignificantMotion event type (type = %d, code = %d)",
+							event->type, event->code);
+  #endif
+				}
+			}
+#endif
+			else
+				STLOGE("AccelSensor: unknown event code (type = %d, code = %d)",
+							event->type, event->code);
+		} else if (event->type == EV_SYN) {
+			data_rot[0] = data_raw[0]*matrix_acc[0][0] +
+					data_raw[1]*matrix_acc[1][0] +
+					data_raw[2]*matrix_acc[2][0];
+			data_rot[1] = data_raw[0]*matrix_acc[0][1] +
+					data_raw[1]*matrix_acc[1][1] +
+					data_raw[2]*matrix_acc[2][1];
+			data_rot[2] = data_raw[0]*matrix_acc[0][2] +
+					data_raw[1]*matrix_acc[1][2] +
+					data_raw[2]*matrix_acc[2][2];
+#if !defined(ACC_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+
+#endif
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+			accCalibIn.timestamp = timestamp;
+			accCalibIn.acc_raw[0] = data_rot[0];
+			accCalibIn.acc_raw[1] = data_rot[1];
+			accCalibIn.acc_raw[2] = data_rot[2];
+
+			ST_AccCalibration_API_Run(&accCalibOut, &accCalibIn);
+#if (DEBUG_ACCELEROMETER == 1)
+			STLOGD("Calibration accData [uT] -> raw_x:%f raw_y:%f raw_z:%f",
+					data_rot[0], data_rot[1], data_rot[2]);
+			STLOGD("Calibration accData [uT] -> uncal_x:%f uncal_y:%f uncal_z:%f",
+					accCalibOut.acc_cal[0], accCalibOut.acc_cal[1],
+					accCalibOut.acc_cal[2]);
+#endif /* DEBUG_ACCELEROMETER */
+#endif /* ACCEL_CALIBRATION_ENABLE */
+
+			DecimationCount++;
+
+			if ((mEnabled & ((1<<Acceleration) |
+							(1<<AccelUncalib))) &&
+			   ((DecimationCount >= DecimationBuffer[Acceleration]) ||
+				(DecimationCount >= DecimationBuffer[AccelUncalib]))) {
+				DecimationCount = 0;
+
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+				data_calibrated.v[0] = accCalibOut.acc_cal[0];
+				data_calibrated.v[1] = accCalibOut.acc_cal[1];
+				data_calibrated.v[2] = accCalibOut.acc_cal[2];
+				data_calibrated.status = accCalibOut.accuracy;
+				AccOffset[0] = accCalibOut.offset[0];
+				AccOffset[1] = accCalibOut.offset[1];
+				AccOffset[2] = accCalibOut.offset[2];
+
+#if (DEBUG_ACCELEROMETER == 1)
+				STLOGD("AccelSensor::AccCalibData: %f, %f, %f (accuracy: %d) (off: %f 5f %f)",
+						data_calibrated.v[0], data_calibrated.v[1], data_calibrated.v[2], data_calibrated.status,
+						AccOffset[0], AccOffset[1], AccOffset[2]);
+#endif /* DEBUG_ACCELEROMETER */
+#else
+				/**
+				 * No calibration is available!
+				 */
+				memcpy(data_calibrated.v, data_rot, sizeof(data_calibrated.v));
+				data_calibrated.status = SENSOR_STATUS_UNRELIABLE;
+#endif
+				if (mEnabled & (1<<Acceleration)) {
+					mPendingEvents[Acceleration].acceleration.status = data_calibrated.status;
+					memcpy(mPendingEvents[Acceleration].data, data_calibrated.v, sizeof(data_calibrated.v));
+					mPendingEvents[Acceleration].timestamp = timestamp;
+					mPendingMask |= 1<<Acceleration;
+				}
+#if (SENSORS_UNCALIB_ACCELEROMETER_ENABLE == 1)
+				if (mEnabled & (1<<AccelUncalib)) {
+					mPendingEvents[AccelUncalib].acceleration.status = data_calibrated.status;
+					memcpy(mPendingEvents[AccelUncalib].uncalibrated_accelerometer.uncalib,
+							data_rot, sizeof(data_rot));
+					memcpy(mPendingEvents[AccelUncalib].uncalibrated_accelerometer.bias,
+							AccOffset, sizeof(AccOffset));
+					mPendingEvents[AccelUncalib].timestamp = timestamp;
+					mPendingMask |= 1<<AccelUncalib;
+				}
+#endif
+			}
+
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+			if (mEnabled & (1<<ActivityReco))
+			{
+				int activity_changed = 0;
+
+				mPendingEvents[ActivityReco].data[0] =
+						(float)ActivityRecognizerFunction(
+							-MS2_TO_G(data_rot[0]),
+							-MS2_TO_G(data_rot[1]),
+							-MS2_TO_G(data_rot[2]),
+							&activity_changed);
+				if (activity_changed != 0) {
+#if (DEBUG_ACTIVITY_RECO == 1)
+					ALOGD("ActivityRecognizerSensor::readEvents, activity = %d",
+					      mPendingEvents[ActivityReco].data[0]);
+#endif
+
+					mPendingEvents[ActivityReco].timestamp = timestamp;
+					mPendingMask |= 1<<ActivityReco;
+				}
+			}
+#endif
+
+			if (mEnabled & ((1<<iNemoAcceleration) | (1<<MagCalAcceleration) |
+				(1<<GeoMagRotVectAcceleration) | (1<<Orientation) |
+				(1<<Linear_Accel) | (1<<Gravity_Accel) | (1<<Gbias) |
+				(1<<VirtualGyro)))
+			{
+				sensors_vec_t sData;
+				memcpy(sData.v, data_rot, sizeof(data_rot));
+				setBufferData(&sData);
+			}
+
+#if (DEBUG_ACCELEROMETER == 1)
+			STLOGD("AccelSensor(Acceleration)::readEvents (time = %lld), count(%d), received(%d)",
+						mPendingEvents[Acceleration].timestamp,
+						count, numEventReceived);
+#endif
+		} else {
+			STLOGE("AccelSensor: unknown event type (type = %d, code = %d)", event->type, event->code);
+		}
+
+		for (int j=0 ; count && mPendingMask && j<numSensors ; j++) {
+			if (mPendingMask & (1<<j)) {
+				mPendingMask &= ~(1<<j);
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+				if((j == SignificantMotion) && mPendingEvents[j].data[0] == 0.0f)
+					enable(SENSORS_SIGNIFICANT_MOTION_HANDLE, 0, 0);
+#endif
+				if (mEnabled & (1<<j)) {
+					*data++ = mPendingEvents[j];
+					count--;
+					numEventReceived++;
+				}
+			}
+		}
+		mInputReader.next();
+	}
+
+#if (FETCH_FULL_EVENT_BEFORE_RETURN)
+	/* if we didn't read a complete event, see if we can fill and
+	try again instead of returning with nothing and redoing poll. */
+	if (numEventReceived == 0 && (mEnabled > 0)) {
+		n = mInputReader.fill(data_fd);
+		if (n)
+			goto again;
+	}
+#endif
+
+	return numEventReceived;
+}
+
+bool AccelSensor::setBufferData(sensors_vec_t *value)
+{
+	pthread_mutex_lock(&dataMutex);
+	memcpy(&dataBuffer, value, sizeof(sensors_vec_t));
+	pthread_mutex_unlock(&dataMutex);
+
+	return true;
+}
+
+bool AccelSensor::getBufferData(sensors_vec_t *lastBufferedValues)
+{
+	pthread_mutex_lock(&dataMutex);
+	memcpy(lastBufferedValues, &dataBuffer, sizeof(sensors_vec_t));
+	pthread_mutex_unlock(&dataMutex);
+
+#if (DEBUG_ACCELEROMETER == 1)
+	STLOGD("AccelSensor: getBufferData got values: x:(%f),y:(%f), z:(%f).",
+					lastBufferedValues->x, lastBufferedValues->y,
+					lastBufferedValues->z);
+#endif
+
+	return true;
+}
+
+#endif /* SENSORS_ACCELEROMETER_ENABLE */
diff --git a/AccelSensor.h b/AccelSensor.h
new file mode 100644
index 0000000..b78f377
--- /dev/null
+++ b/AccelSensor.h
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+
+#ifndef ANDROID_ACC_SENSOR_H
+#define ANDROID_ACC_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+extern "C"
+{
+	#include "ActivityRecoLib.h"
+};
+#endif
+#if (ACCEL_CALIBRATION_ENABLE == 1)
+extern "C"
+{
+	#include "STAccCalibration_API.h"
+};
+#endif
+
+/*****************************************************************************/
+
+struct input_event;
+
+class AccelSensor : public SensorBase {
+	enum {
+		Acceleration = 0,
+		AccelUncalib,
+		SignificantMotion,
+		iNemoAcceleration,
+		MagCalAcceleration,
+		GeoMagRotVectAcceleration,
+		Orientation,
+		Gravity_Accel,
+		Linear_Accel,
+		VirtualGyro,
+		Gbias,
+		ActivityReco,
+		numSensors
+	};
+	static int mEnabled;
+	static int64_t delayms;
+	static int current_fullscale;
+	InputEventCircularReader mInputReader;
+	uint32_t mPendingMask;
+	sensors_event_t mPendingEvents[numSensors];
+	bool mHasPendingEvent;
+	int setInitialState();
+#if ACCEL_CALIBRATION_ENABLE == 1
+	STAccCalibration_Input accCalibIn;
+	STAccCalibration_Output accCalibOut;
+#endif
+
+private:
+	static sensors_vec_t  dataBuffer;
+	static int64_t setDelayBuffer[numSensors];
+	static int64_t writeDelayBuffer[numSensors];
+	static int DecimationBuffer[numSensors];
+	static int DecimationCount;
+	virtual bool setBufferData(sensors_vec_t *value);
+	float data_raw[3];
+	float data_rot[3];
+	sensors_vec_t data_calibrated;
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+
+public:
+	AccelSensor();
+	virtual ~AccelSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int writeMinDelay(void);
+	static void getAccDelay(int64_t *Acc_Delay_ms);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_ACCEL_SENSOR_H
+
+#endif /* SENSORS_ACCELEROMETER_ENABLE */
diff --git a/Android.mk b/Android.mk
new file mode 100644
index 0000000..502bc1e
--- /dev/null
+++ b/Android.mk
@@ -0,0 +1,78 @@
+# Copyright (c) 2021 ID TECH.
+# Author: Jay Deng <jay.deng@idtechproducts.com>
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+ifeq ($(BOARD_USE_IDT_SENSOR_INPUT),true)
+    COMPILE_IDT_SENSOR_INPUT = true
+endif
+
+ifeq ($(COMPILE_IDT_SENSOR_INPUT),true)
+LOCAL_PATH := $(call my-dir)
+
+include $(CLEAR_VARS)
+
+LOCAL_PRELINK_MODULE := false
+LOCAL_PROPRIETARY_MODULE := true
+LOCAL_MODULE_OWNER := IDTech
+
+ifeq ($(shell test $(PLATFORM_SDK_VERSION) -lt 21 && echo true),true)
+LOCAL_MODULE_PATH := $(TARGET_OUT_SHARED_LIBRARIES)/../vendor/lib/hw
+else
+LOCAL_MODULE_RELATIVE_PATH := hw
+endif
+LOCAL_MODULE_TAGS := optional
+
+ifdef TARGET_BOARD_PLATFORM
+LOCAL_MODULE := sensors.$(TARGET_BOARD_PLATFORM)
+else
+LOCAL_MODULE := sensors.default
+endif # TARGET_BOARD_PLATFORM
+
+define all-module-under-lib
+	$(wildcard $(LOCAL_PATH)/lib/*/module.mk)
+endef
+
+define all-dir-under-lib
+	$(foreach directory,$(shell cd $(LOCAL_PATH);find lib/ -type d),\
+		$(addprefix $(LOCAL_PATH)/,$(directory)))
+endef
+
+define def_macro
+	$(foreach d,$1,$(addprefix -D,$(d)))
+endef
+
+define all-cpp-source-files
+       $(patsubst ./%,%, \
+               $(shell cd $(LOCAL_PATH); find . -name "*.cpp"))
+endef
+
+LOCAL_C_INCLUDES := $(call all-dir-under-lib) \
+		    $(LOCAL_PATH)/include/ \
+		    $(LOCAL_PATH)/conf/ \
+		    bionic
+
+LOCAL_STATIC_LIBRARIES :=
+
+include $(call all-module-under-lib)
+
+LOCAL_CFLAGS := -DLOG_TAG=\"Sensors\" \
+		-DANDROID_VERSION=$(PLATFORM_SDK_VERSION) \
+		$(call def_macro, $(ENABLED_SENSORS)) \
+		$(call def_macro, $(ENABLED_MODULES))
+
+LOCAL_SRC_FILES := $(call all-cpp-source-files)
+
+LOCAL_SHARED_LIBRARIES := liblog libcutils libutils libdl libc
+LOCAL_HEADER_LIBRARIES := libhardware_headers libsystem_headers
+LOCAL_VENDOR_MODULE := true
+
+include $(BUILD_SHARED_LIBRARY)
+include $(call all-makefiles-under,$(LOCAL_PATH))
+endif # COMPILE_IDT_SENSOR_INPUT
diff --git a/BodyTempSensor.cpp b/BodyTempSensor.cpp
new file mode 100644
index 0000000..3aedd0b
--- /dev/null
+++ b/BodyTempSensor.cpp
@@ -0,0 +1,216 @@
+/*
+ *  MELEXIS IR thermal sensor HAL layer
+ *
+ *  Copyright (c) 2020 ID TECH.
+ *  Author: Jay Deng <jay.deng@idtechproducts.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include "configuration.h"
+
+/* Standalone Temperature sensor */
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/select.h>
+#include <log/log.h>
+
+#include "BodyTempSensor.h"
+
+int BodyTempSensor::current_fullscale = 0;
+int unsigned BodyTempSensor::mEnabled = 0;
+int unsigned BodyTempSensor::enabled = 0;
+
+BodyTempSensor::BodyTempSensor() :
+	SensorBase(NULL, SENSOR_OBJECT_TEMP),
+	mPendingMask(0),
+	mInputReader(4),
+	mHasPendingEvent(false)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+
+	mPendingEvents[Temperature].version = sizeof(sensors_event_t);
+	mPendingEvents[Temperature].sensor = ID_BODY_TEMPERATURE;
+	mPendingEvents[Temperature].type = SENSOR_TYPE_AMBIENT_TEMPERATURE;
+
+	if (data_fd) {
+		STLOGI("BodyTempSensor::BodyTempSensor temp_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("BodyTempSensor::BodyTempSensor temp_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+BodyTempSensor::~BodyTempSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_BODY_TEMPERATURE_HANDLE, 0, 0);
+	}
+}
+
+int BodyTempSensor::setInitialState()
+{
+	return 0;
+}
+
+int BodyTempSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch (handle) {
+		case SENSORS_BODY_TEMPERATURE_HANDLE:
+			what = Temperature;
+			break;
+		default:
+			break;
+	}
+
+	return what;
+}
+
+int BodyTempSensor::writeSensorDelay(int handle)
+{
+	int err = writeDelay(handle, delayms);
+
+	return err;
+}
+
+int BodyTempSensor::enable(int32_t handle, int en, int type __attribute__((unused)))
+{
+	int err = 0;
+	int what = -1;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (en) {
+		if(!enabled) {
+			enabled = 1;
+			mEnabled |= (1<<what);
+		}
+
+	} else {
+		if (enabled) {
+			enabled = 0;
+			mEnabled &= ~(1<<what);
+		}
+	}
+
+	if (enabled)
+		setInitialState();
+
+	return err;
+}
+
+int BodyTempSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err = -1, what;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+
+	if (delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	delayms = delay_ms;
+
+	if (mEnabled & (1 << what))
+		err = writeSensorDelay(handle);
+
+	return err;
+}
+
+int BodyTempSensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if (value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if (value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_TEMPERATURE_HANDLE, value);
+		if (err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+		err = 0;
+	}
+	return err;
+}
+
+int BodyTempSensor::readEvents(sensors_event_t* data, int count)
+{
+	static float lastTempValue = 0.0f;
+	int64_t timestamp;
+
+#if DEBUG_BODY_TEMPERATURE_SENSOR == 1
+	STLOGD("BodyTempSensor::readEvents (count=%d)",count);
+#endif
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+	struct timeval tv;
+	struct timezone tz;
+
+	while (count && mInputReader.readEvent(&event)) {
+#if DEBUG_TEMPERATURE_SENSOR == 1
+		STLOGD("TempSensor::readEvents (count=%d),type(%d)", count, event->type);
+#endif
+		gettimeofday(&tv,&tz);
+		timestamp = timevalToNano(tv);
+		if (event->type == EV_MSC) {
+			int value = event->value;
+
+			if (event->code == MSC_SERIAL) {
+				lastTempValue = value;
+				mPendingEvents[Temperature].temperature = (SENSOR_TEMP_OFFSET + value) * SENSOR_DEGREE_PER_UNIT;
+				mPendingEvents[Temperature].timestamp = timestamp;
+			}
+		} else if (event->type == EV_SYN) {
+			if (mEnabled & (1 << Temperature))
+				mPendingMask |= 1 << Temperature;
+
+
+			for (int j = 0; count && mPendingMask && (j < numSensors); j++) {
+				if (mPendingMask & (1 << j)) {
+					mPendingMask &= ~(1 << j);
+					mPendingEvents[j].timestamp = timestamp;
+					if (mEnabled & (1 << j)) {
+						*data++ = mPendingEvents[j];
+						count--;
+						numEventReceived++;
+					}
+				}
+			}
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_TEMP_ENABLE */
diff --git a/BodyTempSensor.h b/BodyTempSensor.h
new file mode 100644
index 0000000..0497f96
--- /dev/null
+++ b/BodyTempSensor.h
@@ -0,0 +1,62 @@
+/*
+ *  MELEXIS IR thermal sensor HAL layer
+ *
+ *  Copyright (c) 2020 ID TECH.
+ *  Author: Jay Deng <jay.deng@idtechproducts.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include "configuration.h"
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+
+#ifndef ANDROID_BODY_TEMP_SENSOR_H
+#define ANDROID_BODY_TEMP_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+class BodyTempSensor : public SensorBase {
+private:
+	enum {
+		Temperature,
+		numSensors
+	};
+	static unsigned int mEnabled;
+	static int current_fullscale;
+	static unsigned int enabled;
+	uint32_t mPendingMask;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[numSensors];
+	bool mHasPendingEvent;
+
+	int setInitialState(void);
+
+	enum channelid{
+		tempChan = 0
+	};
+	int64_t delayms;
+
+	int writeSensorDelay(int handle);
+
+public:
+	BodyTempSensor();
+	virtual ~BodyTempSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents(void) const { return mHasPendingEvent; }
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_TEMP_SENSOR_H
+#endif /* SENSORS_TEMP_ENABLE */
diff --git a/GyroSensor.cpp b/GyroSensor.cpp
new file mode 100644
index 0000000..0d0e426
--- /dev/null
+++ b/GyroSensor.cpp
@@ -0,0 +1,567 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "GyroSensor.h"
+
+#define FETCH_FULL_EVENT_BEFORE_RETURN		0
+
+/*****************************************************************************/
+sensors_vec_t  GyroSensor::dataBuffer;
+int GyroSensor::mEnabled = 0;
+int64_t GyroSensor::delayms = 0;
+int GyroSensor::startup_samples = DEFAULT_SAMPLES_TO_DISCARD;
+int GyroSensor::current_fullscale = 0;
+int GyroSensor::samples_to_discard = DEFAULT_SAMPLES_TO_DISCARD;
+float GyroSensor::gbias_out[3] = {0};
+int64_t GyroSensor::setDelayBuffer[numSensors] = {0};
+int64_t GyroSensor::writeDelayBuffer[numSensors] = {0};
+int GyroSensor::DecimationBuffer[numSensors] = {0};
+int GyroSensor::DecimationCount[numSensors] = {0};
+pthread_mutex_t GyroSensor::dataMutex;
+#if (SENSORS_ACCELEROMETER_ENABLE == 1) && (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+AccelSensor* GyroSensor::acc = NULL;
+#endif
+
+GyroSensor::GyroSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_GYROSCOPE),
+	mInputReader(6),
+	mHasPendingEvent(false)
+{
+	pthread_mutex_init(&dataMutex, NULL);
+
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 0)
+	mPendingEvent[Gyro].version = sizeof(sensors_event_t);
+	mPendingEvent[Gyro].sensor = ID_GYROSCOPE;
+	mPendingEvent[Gyro].type = SENSOR_TYPE_GYROSCOPE;
+	mPendingEvent[Gyro].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+
+  #if ((SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1) && (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1))
+	mPendingEvent[GyroUncalib].version = sizeof(sensors_event_t);
+	mPendingEvent[GyroUncalib].sensor = ID_UNCALIB_GYROSCOPE;
+	mPendingEvent[GyroUncalib].type = SENSOR_TYPE_GYROSCOPE_UNCALIBRATED;
+	mPendingEvent[GyroUncalib].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+  #endif
+#endif
+
+#if defined(STORE_CALIB_GYRO_ENABLED)
+	pStoreCalibration = StoreCalibration::getInstance();
+#endif
+
+	if (data_fd) {
+		STLOGI("GyroSensor::GyroSensor gyro_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("GyroSensor::GyroSensor gyro_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+
+	memset(data_raw, 0, sizeof(data_raw));
+
+#if (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+	iNemoEngine_API_gbias_Initialization(false);
+  #if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	acc = new AccelSensor();
+  #endif
+#endif
+}
+
+GyroSensor::~GyroSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_GYROSCOPE_HANDLE, 0, 0);
+	}
+#if ((SENSORS_ACCELEROMETER_ENABLE == 1) && (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1))
+	acc->~AccelSensor();
+#endif
+	pthread_mutex_destroy(&dataMutex);
+}
+
+#if !defined(NOT_SET_GYRO_INITIAL_STATE)
+int GyroSensor::setInitialState()
+{
+	struct input_absinfo absinfo_x;
+	struct input_absinfo absinfo_y;
+	struct input_absinfo absinfo_z;
+
+	if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_GYRO_X), &absinfo_x) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_GYRO_Y), &absinfo_y) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_GYRO_Z), &absinfo_z))
+	{
+		mHasPendingEvent = true;
+	}
+
+	setFullScale(SENSORS_GYROSCOPE_HANDLE, GYRO_DEFAULT_FULLSCALE);
+	startup_samples = samples_to_discard;
+	memset(DecimationCount, 0, sizeof(DecimationCount));
+
+	return 0;
+}
+#endif
+
+int GyroSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+		case SENSORS_GYROSCOPE_HANDLE:
+			what = Gyro;
+			break;
+#if ((SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1) && (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1))
+		case SENSORS_UNCALIB_GYROSCOPE_HANDLE:
+			what = GyroUncalib;
+			break;
+#endif
+#if (SENSOR_FUSION_ENABLE == 1)
+		case SENSORS_SENSOR_FUSION_HANDLE:
+			what = iNemoGyro;
+			break;
+#endif
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int GyroSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+	int what = -1;
+	int mEnabledPrev;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (flags) {
+		mEnabled |= (1<<what);
+		writeMinDelay();
+
+		if (mEnabled == (1<<what)) {
+#if ((GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1) && (SENSORS_ACCELEROMETER_ENABLE == 1))
+			acc->enable(SENSORS_GYROSCOPE_HANDLE, flags, 1);
+			iNemoEngine_API_gbias_enable(flags);
+#endif
+#if !defined(NOT_SET_GYRO_INITIAL_STATE)
+			setInitialState();
+#endif
+			err = writeEnable(SENSORS_GYROSCOPE_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+
+	} else {
+		mEnabledPrev = mEnabled;
+		mEnabled &= ~(1<<what);
+
+		if ((!mEnabled) && (mEnabledPrev)){
+			err = writeEnable(SENSORS_GYROSCOPE_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+
+#if ((GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1) && (SENSORS_ACCELEROMETER_ENABLE == 1))
+			acc->enable(SENSORS_GYROSCOPE_HANDLE, flags, 1);
+			STLOGD("GyroSensor::Acc OFF");
+			iNemoEngine_API_gbias_enable(false);
+#endif
+
+		}
+		//setDelay(handle, DELAY_OFF);
+		if (mEnabled) {
+			writeMinDelay();
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("GyroSensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						flags, handle, what, mEnabled);
+	} else {
+		STLOGE("GyroSensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						flags, handle, what, mEnabled);
+	}
+
+	return err;
+}
+
+bool GyroSensor::hasPendingEvents() const
+{
+	return mHasPendingEvent;
+}
+
+int GyroSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int what = -1;
+	int err = 0;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+
+	if(delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+#if (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+  #if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	if (delay_ns >= 10000000)
+		acc->setDelay(SENSORS_GYROSCOPE_HANDLE, delay_ns);
+	else
+		acc->setDelay(SENSORS_GYROSCOPE_HANDLE, 10000000);
+
+  #endif
+#endif
+
+	/**
+	 * The handled sensor is disabled. Set 0 in its setDelayBuffer position
+	 * and update decimation buffer.
+	 */
+	if (delay_ms == NSEC_TO_MSEC(DELAY_OFF))
+		delay_ms = 0;
+
+	// Min setDelay Definition
+	setDelayBuffer[what] = delay_ms;
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("GyroSensor::setDelayBuffer[] = %lld, %lld, %lld", setDelayBuffer[0], setDelayBuffer[1], setDelayBuffer[2]);
+#endif
+
+	// Update sysfs
+	if(mEnabled & 1<<what)
+	{
+		writeMinDelay();
+	}
+
+	return err;
+}
+
+int GyroSensor::writeMinDelay(void)
+{
+	int err = 0;
+	int kk;
+	int64_t Min_delay_ms = 0;
+
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if ((mEnabled & 1<<kk) != 0)
+		{
+			writeDelayBuffer[kk] = setDelayBuffer[kk];
+		}
+		else
+			writeDelayBuffer[kk] = 0;
+	}
+
+	// Min setDelay Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (Min_delay_ms != 0) {
+			if ((writeDelayBuffer[kk] != 0) && (writeDelayBuffer[kk] <= Min_delay_ms))
+				Min_delay_ms = writeDelayBuffer[kk];
+		} else
+			Min_delay_ms = writeDelayBuffer[kk];
+	}
+
+	if ((Min_delay_ms > 0) && (Min_delay_ms != delayms))
+	{
+		samples_to_discard = (int)(GYRO_STARTUP_TIME_MS/Min_delay_ms)+1;
+		startup_samples = samples_to_discard;
+		err = writeDelay(SENSORS_GYROSCOPE_HANDLE, Min_delay_ms);
+		if(err >= 0) {
+			err = 0;
+			delayms = Min_delay_ms;
+			memset(DecimationCount, 0, sizeof(DecimationCount));
+#if (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+			iNemoEngine_API_gbias_set_frequency(1000.0f /
+							(float)Min_delay_ms);
+  #if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			if (Min_delay_ms >= 10)
+				acc->setDelay(SENSORS_GYROSCOPE_HANDLE,(float)Min_delay_ms*1000000);
+			else
+				acc->setDelay(SENSORS_GYROSCOPE_HANDLE,10000000);
+  #endif
+#endif
+		}
+	}
+
+	// Decimation Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (kk == Gyro || kk == GyroUncalib)
+			continue;
+
+		if (delayms)
+			DecimationBuffer[kk] = writeDelayBuffer[kk]/delayms;
+		else
+			DecimationBuffer[kk] = 0;
+	}
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("GyroSensor::writeDelayBuffer[] = %lld, %lld, %lld", writeDelayBuffer[0], writeDelayBuffer[1], writeDelayBuffer[2]);
+	STLOGD("GyroSensor::Min_delay_ms = %lld, delayms = %lld, mEnabled = %d", Min_delay_ms, delayms, mEnabled);
+	STLOGD("GyroSensor::samples_to_discard = %d", samples_to_discard);
+	STLOGD("GyroSensor::DecimationBuffer = %d, %d, %d", DecimationBuffer[0], DecimationBuffer[1], DecimationBuffer[2]);
+#endif
+
+	return err;
+
+}
+
+
+void GyroSensor::getGyroDelay(int64_t *Gyro_Delay_ms)
+{
+	*Gyro_Delay_ms = delayms;
+
+	return;
+}
+
+
+int GyroSensor::setFullScale(int32_t  __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if(value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if(value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_GYROSCOPE_HANDLE, value);
+		if(err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int GyroSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+#if (FETCH_FULL_EVENT_BEFORE_RETURN)
+	again:
+#endif
+
+	while (count && mInputReader.readEvent(&event)) {
+
+		if (event->type == EVENT_TYPE_GYRO) {
+
+#if (DEBUG_GYROSCOPE == 1)
+	STLOGD("GyroSensor::readEvents (event_code=%d)", event->code);
+#endif
+
+			float value = (float) event->value;
+			if (event->code == EVENT_TYPE_GYRO_X) {
+				data_raw[0] = value * CONVERT_GYRO_X;
+			}
+			else if (event->code == EVENT_TYPE_GYRO_Y) {
+				data_raw[1] = value * CONVERT_GYRO_Y;
+			}
+			else if (event->code == EVENT_TYPE_GYRO_Z) {
+				data_raw[2] = value * CONVERT_GYRO_Z;
+			}
+#if defined(GYRO_EVENT_HAS_TIMESTAMP)
+			else if (event->code == EVENT_TYPE_TIME_MSB) {
+				timestamp = ((int64_t)(event->value)) << 32;
+			}
+			else if (event->code == EVENT_TYPE_TIME_LSB) {
+				timestamp |= (uint32_t)(event->value);
+			}
+#endif
+			else {
+				STLOGE("GyroSensor: unknown event code (type = %d, code = %d)", event->type, event->code);
+			}
+		} else if (event->type == EV_SYN) {
+
+			if (startup_samples) {
+				startup_samples--;
+
+#if (DEBUG_GYROSCOPE == 1)
+				STLOGD("GyroSensor::Start-up samples = %d", startup_samples);
+#endif
+				goto no_data;
+			}
+
+			data_rot[0] = data_raw[0]*matrix_gyr[0][0] +
+					data_raw[1]*matrix_gyr[1][0] +
+					data_raw[2]*matrix_gyr[2][0];
+			data_rot[1] = data_raw[0]*matrix_gyr[0][1] +
+					data_raw[1]*matrix_gyr[1][1] +
+					data_raw[2]*matrix_gyr[2][1];
+			data_rot[2] = data_raw[0]*matrix_gyr[0][2] +
+					data_raw[1]*matrix_gyr[1][2] +
+					data_raw[2]*matrix_gyr[2][2];
+
+#if defined(STORE_CALIB_GYRO_ENABLED)
+			data_rot[0] -= pStoreCalibration->getCalibration(
+					StoreCalibration::GYROSCOPE_BIAS,
+					StoreCalibration::XAxis);
+			data_rot[1] -= pStoreCalibration->getCalibration(
+					StoreCalibration::GYROSCOPE_BIAS,
+					StoreCalibration::YAxis);
+			data_rot[2] -= pStoreCalibration->getCalibration(
+					StoreCalibration::GYROSCOPE_BIAS,
+					StoreCalibration::ZAxis);
+			data_rot[0] *= pStoreCalibration->getCalibration(
+					StoreCalibration::GYROSCOPE_SENS,
+					StoreCalibration::XAxis);
+			data_rot[1] *= pStoreCalibration->getCalibration(
+					StoreCalibration::GYROSCOPE_SENS,
+					StoreCalibration::YAxis);
+			data_rot[2] *= pStoreCalibration->getCalibration(
+					StoreCalibration::GYROSCOPE_SENS,
+					StoreCalibration::ZAxis);
+#endif
+
+#if !defined(GYRO_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+
+#if !(GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+			memset(gbias_out, 0, sizeof(gbias_out));
+#if (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+			int bias_meas;
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			sensors_vec_t tmp_data_acc;
+			AccelSensor::getBufferData(&tmp_data_acc);
+			memcpy(data_acc, tmp_data_acc.v, sizeof(float) * 3);
+#else
+			memset(data_acc, 0, sizeof(data_acc));
+#endif
+			iNemoEngine_API_gbias_Run(data_acc, data_rot);
+			iNemoEngine_API_Get_gbias(gbias_out);
+#endif
+			DecimationCount[Gyro]++;
+			if(mEnabled & (1<<Gyro) && (DecimationCount[Gyro] >= DecimationBuffer[Gyro])) {
+				DecimationCount[Gyro] = 0;
+				mPendingEvent[Gyro].data[0] = data_rot[0] - gbias_out[0];
+				mPendingEvent[Gyro].data[1] = data_rot[1] - gbias_out[1];
+				mPendingEvent[Gyro].data[2] = data_rot[2] - gbias_out[2];
+				mPendingEvent[Gyro].timestamp = timestamp;
+				mPendingEvent[Gyro].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+
+				*data++ = mPendingEvent[Gyro];
+				count--;
+				numEventReceived++;
+			}
+
+  #if ((SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1) && (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1))
+			DecimationCount[GyroUncalib]++;
+			if(mEnabled & (1<<GyroUncalib) && (DecimationCount[GyroUncalib] >= DecimationBuffer[GyroUncalib])) {
+				DecimationCount[GyroUncalib] = 0;
+				mPendingEvent[GyroUncalib].uncalibrated_gyro.uncalib[0] = data_rot[0];
+				mPendingEvent[GyroUncalib].uncalibrated_gyro.uncalib[1] = data_rot[1];
+				mPendingEvent[GyroUncalib].uncalibrated_gyro.uncalib[2] = data_rot[2];
+				mPendingEvent[GyroUncalib].uncalibrated_gyro.bias[0] = gbias_out[0];
+				mPendingEvent[GyroUncalib].uncalibrated_gyro.bias[1] = gbias_out[1];
+				mPendingEvent[GyroUncalib].uncalibrated_gyro.bias[2] = gbias_out[2];
+				mPendingEvent[GyroUncalib].timestamp = timestamp;
+				mPendingEvent[GyroUncalib].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+
+				*data++ = mPendingEvent[GyroUncalib];
+				count--;
+				numEventReceived++;
+			}
+  #endif
+#endif
+			if(mEnabled & (1<<iNemoGyro)) {
+				sensors_vec_t sData;
+				sData.x = data_rot[0] - gbias_out[0];
+				sData.y = data_rot[1] - gbias_out[1];
+				sData.z = data_rot[2] - gbias_out[2];
+				setBufferData(&sData);
+			}
+
+#if (DEBUG_GYROSCOPE == 1)
+			STLOGD("GyroSensor::readEvents (time = %lld), count(%d), received(%d)",
+						mPendingEvent[Gyro].timestamp,
+						count, numEventReceived);
+#endif
+
+		} else {
+			STLOGE("GyroSensor: unknown event (type=%d, code=%d)",
+						event->type, event->code);
+		}
+no_data:
+		mInputReader.next();
+	}
+
+#if (FETCH_FULL_EVENT_BEFORE_RETURN)
+	/* if we didn't read a complete event, see if we can fill and
+	try again instead of returning with nothing and redoing poll. */
+	if (numEventReceived == 0 && mEnabled == 1) {
+		n = mInputReader.fill(data_fd);
+		if (n)
+			goto again;
+	}
+#endif
+
+	return numEventReceived;
+}
+
+bool GyroSensor::setBufferData(sensors_vec_t *value)
+{
+	pthread_mutex_lock(&dataMutex);
+	memcpy(&dataBuffer, value, sizeof(sensors_vec_t));
+	pthread_mutex_unlock(&dataMutex);
+
+	return true;
+}
+
+bool GyroSensor::getBufferData(sensors_vec_t *lastBufferedValues)
+{
+	pthread_mutex_lock(&dataMutex);
+	memcpy(lastBufferedValues, &dataBuffer, sizeof(sensors_vec_t));
+	pthread_mutex_unlock(&dataMutex);
+
+#if (DEBUG_GYROSCOPE == 1)
+	STLOGD("GyroSensor: getBufferData got values: x:(%f),y:(%f), z:(%f).",
+						lastBufferedValues->x,
+						lastBufferedValues->y,
+						lastBufferedValues->z);
+#endif
+
+	return true;
+}
+
+#endif /* SENSORS_GYROSCOPE_ENABLE */
diff --git a/GyroSensor.h b/GyroSensor.h
new file mode 100644
index 0000000..53d333b
--- /dev/null
+++ b/GyroSensor.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+
+#ifndef ANDROID_GYRO_SENSOR_H
+#define ANDROID_GYRO_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+#include "AccelSensor.h"
+
+#if defined(STORE_CALIB_GYRO_ENABLED)
+#include "StoreCalibration.h"
+#endif
+
+#if (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+extern "C"
+{
+#include <iNemoEngineAPI_gbias_estimation.h>
+};
+#endif
+
+/*****************************************************************************/
+
+struct input_event;
+
+class GyroSensor : public SensorBase
+{
+	enum {
+		Gyro = 0,
+		GyroUncalib,
+		iNemoGyro,
+		numSensors
+	};
+	static int mEnabled;
+	static int64_t delayms;
+	static int current_fullscale;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent[numSensors];
+	bool mHasPendingEvent;
+	int setInitialState();
+
+private:
+	static int startup_samples;
+	static int samples_to_discard;
+	static sensors_vec_t  dataBuffer;
+	static int64_t setDelayBuffer[numSensors];
+	static int64_t writeDelayBuffer[numSensors];
+	static int DecimationBuffer[numSensors];
+	static int DecimationCount[numSensors];
+	virtual bool setBufferData(sensors_vec_t *value);
+	static float gbias_out[3];
+	float data_raw[3];
+	float data_rot[3];
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+#if defined(STORE_CALIB_GYRO_ENABLED)
+	StoreCalibration *pStoreCalibration;
+#endif
+#if ((SENSORS_ACCELEROMETER_ENABLE == 1) && (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1))
+	static AccelSensor *acc;
+	float data_acc[3];
+#endif
+
+public:
+	GyroSensor();
+	virtual ~GyroSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int writeMinDelay(void);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+	static void getGyroDelay(int64_t *Gyro_Delay_ms);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_GYRO_SENSOR_H
+
+#endif /* SENSORS_GYROSCOPE_ENABLE */
diff --git a/HumiditySensor.cpp b/HumiditySensor.cpp
new file mode 100644
index 0000000..072239a
--- /dev/null
+++ b/HumiditySensor.cpp
@@ -0,0 +1,175 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+
+#include "HumiditySensor.h"
+
+HumiditySensor::HumiditySensor() :
+	SensorBase(NULL, SENSOR_DATANAME_HUMIDITY),
+	mEnabled(false),
+	current_fullscale(0),
+	mInputReader(4)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+	/* humidity sensor */
+	mPendingEvents[0].version = sizeof(sensors_event_t);
+	mPendingEvents[0].sensor = ID_HUMIDITY;
+	mPendingEvents[0].type = SENSOR_TYPE_RELATIVE_HUMIDITY;
+	/* temperature sensor */
+	mPendingEvents[1].version = sizeof(sensors_event_t);
+	mPendingEvents[1].sensor = ID_TEMPERATURE;
+	mPendingEvents[1].type = SENSOR_TYPE_TEMPERATURE;
+}
+
+HumiditySensor::~HumiditySensor()
+{
+	if (mEnabled)
+		enable(SENSORS_HUMIDITY_HANDLE, 0, 0);
+}
+
+int HumiditySensor::writeSensorDelay(int handle)
+{
+	int err = writeDelay(handle, delayms);
+
+	return err >= 0 ? 0 : err;
+}
+
+int HumiditySensor::enable(int32_t handle, int en, int type)
+{
+	int err = 0;
+
+	if (en) {
+		err = writeSensorDelay(SENSORS_HUMIDITY_HANDLE);
+		if (err < 0)
+			return err;
+
+		if (!mEnabled)
+			err = writeEnable(SENSORS_HUMIDITY_HANDLE, 1);
+
+		if (err >= 0) {
+			err = 0;
+			mEnabled = true;
+		}
+	} else {
+		err = writeEnable(SENSORS_HUMIDITY_HANDLE, 0);
+		if (err < 0)
+			return err;
+
+		mEnabled = false;
+		err = 0;
+	}
+
+	return err;
+}
+
+int HumiditySensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+	int err = 0;
+
+	if (delay_ms == 0)
+		return -EINVAL;
+
+	delayms = delay_ms;
+	if (mEnabled)
+		err = writeSensorDelay(SENSORS_HUMIDITY_HANDLE);
+
+	return err;
+}
+
+int HumiditySensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = 0;
+
+	if (value <= 0)
+		return -EINVAL;
+
+	if (value != current_fullscale) {
+		err = writeFullScale(SENSORS_HUMIDITY_HANDLE, value);
+		if (err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int HumiditySensor::readEvents(sensors_event_t* data, int count)
+{
+#if DEBUG_HUMIDITY_SENSOR == 1
+	STLOGD("HumiditySensor::readEvents (count=%d)",count);
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+#if DEBUG_HUMIDITY_SENSOR == 1
+		STLOGD("HumiditySensor::readEvents (count=%d),type(%d)",count,event->type);
+#endif
+
+		if (event->type == EV_MSC) {
+			float value = (float) event->value;
+#if SENSORS_HUMIDITY_ENABLE == 1
+			if (event->code == EVENT_TYPE_HUMIDITY) {
+				mPendingEvents[0].relative_humidity = value * CONVERT_RH;
+				mPendingEvents[0].timestamp = timevalToNano(event->time);
+				*data++ = mPendingEvents[0];
+				count--;
+				numEventReceived++;
+			}
+#endif
+#if SENSORS_TEMP_RH_ENABLE == 1
+			if (event->code == EVENT_TYPE_TEMPERATURE) {
+				mPendingEvents[1].temperature = value * CONVERT_TEMP;
+				mPendingEvents[1].timestamp = timevalToNano(event->time);
+				*data++ = mPendingEvents[1];
+				count--;
+				numEventReceived++;
+			}
+#endif
+		} else if (event->type != EV_SYN) {
+			STLOGE("HumiditySensor: unknown event type (type=%d, code=%d)",
+			       event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+#endif /* SENSORS_HUMIDITY_ENABLE */
+
diff --git a/HumiditySensor.h b/HumiditySensor.h
new file mode 100644
index 0000000..cb5b8d0
--- /dev/null
+++ b/HumiditySensor.h
@@ -0,0 +1,56 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+
+#ifndef ANDROID_HUMIDITY_SENSOR_H
+#define ANDROID_HUMIDITY_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+class HumiditySensor : public SensorBase {
+private:
+	bool mEnabled;
+	int current_fullscale;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[2];
+
+	int64_t delayms;
+	char device_sysfs_path_prs[PATH_MAX];
+	int device_sysfs_path_prs_len;
+	int writeSensorDelay(int handle);
+public:
+	HumiditySensor();
+	~HumiditySensor();
+	int readEvents(sensors_event_t* data, int count);
+	bool hasPendingEvents() const { return false; }
+	int setDelay(int32_t handle, int64_t ns);
+	int setFullScale(int32_t handle, int value);
+	int enable(int32_t handle, int enabled, int type);
+	int getWhatFromHandle(int32_t handle) { return 0; }
+};
+#endif /* ANDROID_HUMIDITY_SENSOR_H */
+#endif /* SENSORS_HUMIDITYURE_ENABLE || SENSORS_TEMP_RH_ENABLE */
diff --git a/InputEventReader.cpp b/InputEventReader.cpp
new file mode 100644
index 0000000..a406c6e
--- /dev/null
+++ b/InputEventReader.cpp
@@ -0,0 +1,88 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <stdint.h>
+#include <errno.h>
+#include <unistd.h>
+#include <poll.h>
+#include <string.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include <linux/input.h>
+
+#include <cutils/log.h>
+
+#include "InputEventReader.h"
+
+/*****************************************************************************/
+
+struct input_event;
+
+InputEventCircularReader::InputEventCircularReader(size_t numEvents)
+	: mBuffer(new input_event[numEvents * 2]),
+	mBufferEnd(mBuffer + numEvents),
+	mHead(mBuffer),
+	mCurr(mBuffer),
+	mFreeSpace(numEvents)
+{
+}
+
+InputEventCircularReader::~InputEventCircularReader()
+{
+	delete [] mBuffer;
+}
+
+ssize_t InputEventCircularReader::fill(int fd)
+{
+	size_t numEventsRead = 0;
+	if (mFreeSpace) {
+		const ssize_t nread = read(fd, mHead, mFreeSpace * sizeof(input_event));
+		if (nread<0 || nread % sizeof(input_event)) {
+			return nread < 0 ? -errno : -EINVAL;
+		}
+
+		numEventsRead = nread / sizeof(input_event);
+		if (numEventsRead) {
+			mHead += numEventsRead;
+			mFreeSpace -= numEventsRead;
+			if (mHead > mBufferEnd) {
+				size_t s = mHead - mBufferEnd;
+				memcpy(mBuffer, mBufferEnd, s * sizeof(input_event));
+				mHead = mBuffer + s;
+			}
+		}
+	}
+	return numEventsRead;
+}
+
+ssize_t InputEventCircularReader::readEvent(input_event const** events)
+{
+	*events = mCurr;
+	ssize_t available = (mBufferEnd - mBuffer) - mFreeSpace;
+	return available ? 1 : 0;
+}
+
+void InputEventCircularReader::next()
+{
+	mCurr++;
+	mFreeSpace++;
+	if(mCurr >= mBufferEnd) {
+		mCurr = mBuffer;
+	}
+}
diff --git a/InputEventReader.h b/InputEventReader.h
new file mode 100644
index 0000000..309b208
--- /dev/null
+++ b/InputEventReader.h
@@ -0,0 +1,49 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_INPUT_EVENT_READER_H
+#define ANDROID_INPUT_EVENT_READER_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+/*****************************************************************************/
+
+struct input_event;
+
+class InputEventCircularReader
+{
+	struct input_event* const mBuffer;
+	struct input_event* const mBufferEnd;
+	struct input_event* mHead;
+	struct input_event* mCurr;
+	ssize_t mFreeSpace;
+
+public:
+	InputEventCircularReader(size_t numEvents);
+	~InputEventCircularReader();
+	ssize_t fill(int fd);
+	ssize_t readEvent(input_event const** events);
+	void next();
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_INPUT_EVENT_READER_H
diff --git a/LightSensor.cpp b/LightSensor.cpp
new file mode 100644
index 0000000..9655762
--- /dev/null
+++ b/LightSensor.cpp
@@ -0,0 +1,219 @@
+/*
+ *  Light sensor HAL layer
+ *
+ *  Copyright (c) 2021 ID TECH.
+ *  Author: Jay Deng <jay.deng@idtechproducts.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include "configuration.h"
+
+/* Standalone Light sensor */
+#if ((SENSORS_LIGHT_ENABLE == 1) || (SENSORS_PROX_INC_LIGHT == 1))
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/select.h>
+#include <log/log.h>
+
+#include "LightSensor.h"
+
+int LightSensor::current_fullscale = 0;
+int unsigned LightSensor::mEnabled = 0;
+int unsigned LightSensor::enabled = 0;
+
+LightSensor::LightSensor(const char *object) :
+	SensorBase(NULL, object),
+	mPendingMask(0),
+	mInputReader(4),
+	mHasPendingEvent(false)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+
+	mPendingEvents[Light].version = sizeof(sensors_event_t);
+	mPendingEvents[Light].sensor = ID_LIGHT;
+	mPendingEvents[Light].type = SENSOR_TYPE_LIGHT;
+
+	if (data_fd) {
+		STLOGI("LightSensor::LightSensor temp_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("LightSensor::LightSensor temp_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+LightSensor::~LightSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_LIGHT_HANDLE, 0, 0);
+	}
+}
+
+int LightSensor::setInitialState()
+{
+	return 0;
+}
+
+int LightSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch (handle) {
+		case SENSORS_LIGHT_HANDLE:
+			what = Light;
+			break;
+		default:
+			break;
+	}
+
+	return what;
+}
+
+int LightSensor::writeSensorDelay(int handle)
+{
+	int err = writeDelay(handle, delayms);
+
+	return err;
+}
+
+int LightSensor::enable(int32_t handle, int en, int type __attribute__((unused)))
+{
+	int err = 0;
+	int what = -1;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (en) {
+		if(!enabled) {
+			enabled = 1;
+			mEnabled |= (1<<what);
+		}
+
+	} else {
+		if (enabled) {
+			enabled = 0;
+			mEnabled &= ~(1<<what);
+		}
+	}
+
+	if (enabled)
+		setInitialState();
+
+	return err;
+}
+
+int LightSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err = -1, what;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+
+	if (delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	delayms = delay_ms;
+
+	if (mEnabled & (1 << what))
+		err = writeSensorDelay(handle);
+
+	return err;
+}
+
+int LightSensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if (value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if (value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_LIGHT_HANDLE, value);
+		if (err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+		err = 0;
+	}
+	return err;
+}
+
+int LightSensor::readEvents(sensors_event_t* data, int count)
+{
+	static float lastTempValue = 0.0f;
+	int64_t timestamp;
+
+#if DEBUG_LIGHT_SENSOR == 1
+	STLOGD("LightSensor::readEvents (count=%d)",count);
+#endif
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+	struct timeval tv;
+	struct timezone tz;
+
+	while (count && mInputReader.readEvent(&event)) {
+#if DEBUG_LIGHT_SENSOR == 1
+		STLOGD("LightSensor::readEvents (count=%d),type(%d)", count, event->type);
+#endif
+		gettimeofday(&tv,&tz);
+		timestamp = timevalToNano(tv);
+		if (event->type == EV_MSC) {
+			int value = event->value;
+
+			if (event->code == MSC_SERIAL) {
+				lastTempValue = value;
+				mPendingEvents[Light].light = value;
+				mPendingEvents[Light].timestamp = timestamp;
+				*data++ = mPendingEvents[Light];
+				count--;
+				numEventReceived++;
+			}
+		} else if (event->type == EV_SYN) {
+			if (mEnabled & (1 << Light))
+				mPendingMask |= 1 << Light;
+
+
+			for (int j = 0; count && mPendingMask && (j < numSensors); j++) {
+				if (mPendingMask & (1 << j)) {
+					mPendingMask &= ~(1 << j);
+					mPendingEvents[j].timestamp = timestamp;
+					if (mEnabled & (1 << j)) {
+						*data++ = mPendingEvents[j];
+						count--;
+						numEventReceived++;
+					}
+				}
+			}
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_TEMP_ENABLE */
diff --git a/LightSensor.h b/LightSensor.h
new file mode 100644
index 0000000..36e7e33
--- /dev/null
+++ b/LightSensor.h
@@ -0,0 +1,59 @@
+/*
+ *  Light sensor HAL layer
+ *
+ *  Copyright (c) 2021 ID TECH.
+ *  Author: Jay Deng <jay.deng@idtechproducts.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_LIGHT_ENABLE == 1) || (SENSORS_PROX_INC_LIGHT == 1))
+
+#ifndef ANDROID_LIGHT_SENSOR_H
+#define ANDROID_LIGHT_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+class LightSensor : public SensorBase {
+private:
+	enum {
+		Light,
+		numSensors
+	};
+	static unsigned int mEnabled;
+	static int current_fullscale;
+	static unsigned int enabled;
+	uint32_t mPendingMask;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[numSensors];
+	bool mHasPendingEvent;
+
+	int setInitialState(void);
+
+	int64_t delayms;
+
+	int writeSensorDelay(int handle);
+
+public:
+	LightSensor(const char *object);
+	virtual ~LightSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents(void) const { return mHasPendingEvent; }
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_LIGHT_SENSOR_H
+#endif /* SENSORS_LIGHT_ENABLE */
diff --git a/MagnSensor.cpp b/MagnSensor.cpp
new file mode 100644
index 0000000..60fef1f
--- /dev/null
+++ b/MagnSensor.cpp
@@ -0,0 +1,751 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <linux/time.h>
+#include <string.h>
+#include <pthread.h>
+
+#include "MagnSensor.h"
+
+#if (SENSOR_GEOMAG_ENABLE == 1)
+#include "iNemoEngineGeoMagAPI.h"
+#endif
+
+#define FETCH_FULL_EVENT_BEFORE_RETURN		0
+#define MS2_TO_MG(x)				(x*102.040816327f)
+#define UT_TO_MGAUSS(x)				(x*10.0f)
+#define MGAUSS_TO_UT(x)				(x/10.0f)
+
+/*****************************************************************************/
+
+sensors_vec_t  MagnSensor::dataBuffer;
+int MagnSensor::freq = 0;
+int MagnSensor::count_call_ecompass = 0;
+int MagnSensor::mEnabled = 0;
+int64_t MagnSensor::delayms = 0;
+int MagnSensor::current_fullscale = 0;
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+AccelSensor* MagnSensor::acc = NULL;
+#endif
+int64_t MagnSensor::setDelayBuffer[numSensors] = {0};
+int64_t MagnSensor::writeDelayBuffer[numSensors] = {0};
+int MagnSensor::DecimationBuffer[numSensors] = {0};
+int MagnSensor::DecimationCount[numSensors] = {0};
+pthread_mutex_t MagnSensor::dataMutex;
+
+MagnSensor::MagnSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_MAGNETIC_FIELD),
+	mInputReader(6),
+	mHasPendingEvent(false)
+{
+//	int err;
+
+	pthread_mutex_init(&dataMutex, NULL);
+
+#if SENSOR_GEOMAG_ENABLE == 1
+	refFreq = (MAGN_MAX_ODR < GEOMAG_FREQUENCY) ? MAGN_MAX_ODR : GEOMAG_FREQUENCY;
+#endif
+
+	memset(mPendingEvent, 0, sizeof(mPendingEvent));
+	memset(DecimationCount, 0, sizeof(DecimationCount));
+
+	mPendingEvent[MagneticField].version = sizeof(sensors_event_t);
+	mPendingEvent[MagneticField].sensor = ID_MAGNETIC_FIELD;
+	mPendingEvent[MagneticField].type = SENSOR_TYPE_MAGNETIC_FIELD;
+	memset(mPendingEvent[MagneticField].data, 0, sizeof(mPendingEvent[MagneticField].data));
+	mPendingEvent[MagneticField].magnetic.status = SENSOR_STATUS_UNRELIABLE;
+
+#if (SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE == 1)
+	mPendingEvent[UncalibMagneticField].version = sizeof(sensors_event_t);
+	mPendingEvent[UncalibMagneticField].sensor = ID_UNCALIB_MAGNETIC_FIELD;
+	mPendingEvent[UncalibMagneticField].type = SENSOR_TYPE_MAGNETIC_FIELD_UNCALIBRATED;
+	memset(mPendingEvent[UncalibMagneticField].data, 0, sizeof(mPendingEvent[UncalibMagneticField].data));
+	mPendingEvent[UncalibMagneticField].magnetic.status = SENSOR_STATUS_UNRELIABLE;
+#endif
+#if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+	mPendingEvent[Orientation].version = sizeof(sensors_event_t);
+	mPendingEvent[Orientation].sensor = ID_ORIENTATION;
+	mPendingEvent[Orientation].type = SENSOR_TYPE_ORIENTATION;
+	memset(mPendingEvent[Orientation].data, 0, sizeof(mPendingEvent[Orientation].data));
+	mPendingEvent[Orientation].orientation.status = SENSOR_STATUS_UNRELIABLE;
+#endif
+#if (GEOMAG_GRAVITY_ENABLE == 1)
+	mPendingEvent[Gravity_Accel].version = sizeof(sensors_event_t);
+	mPendingEvent[Gravity_Accel].sensor = ID_GRAVITY;
+	mPendingEvent[Gravity_Accel].type = SENSOR_TYPE_GRAVITY;
+	memset(mPendingEvent[Gravity_Accel].data, 0, sizeof(mPendingEvent[Gravity_Accel].data));
+	mPendingEvent[Gravity_Accel].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+#if (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1)
+	mPendingEvent[Linear_Accel].version = sizeof(sensors_event_t);
+	mPendingEvent[Linear_Accel].sensor = ID_LINEAR_ACCELERATION;
+	mPendingEvent[Linear_Accel].type = SENSOR_TYPE_LINEAR_ACCELERATION;
+	memset(mPendingEvent[Linear_Accel].data, 0, sizeof(mPendingEvent[Linear_Accel].data));
+	mPendingEvent[Linear_Accel].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+	mPendingEvent[GeoMagRotVect_Magnetic].version = sizeof(sensors_event_t);
+	mPendingEvent[GeoMagRotVect_Magnetic].sensor = ID_GEOMAG_ROTATION_VECTOR;
+	mPendingEvent[GeoMagRotVect_Magnetic].type = SENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR;
+	memset(mPendingEvent[GeoMagRotVect_Magnetic].data, 0, sizeof(mPendingEvent[GeoMagRotVect_Magnetic].data));
+	mPendingEvent[GeoMagRotVect_Magnetic].magnetic.status = SENSOR_STATUS_UNRELIABLE;
+#endif
+
+#if (SENSOR_GEOMAG_ENABLE == 1)
+	memset(&sData, 0, sizeof(iNemoGeoMagSensorsData));
+	iNemoEngine_GeoMag_API_Initialization(100);
+#endif
+
+	if (data_fd) {
+		STLOGI("MagnSensor::MagnSensor magn_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("MagnSensor::MagnSensor magn_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+
+	memset(data_raw, 0, sizeof(data_raw));
+
+#if (SENSOR_GEOMAG_ENABLE == 1)
+	acc = new AccelSensor();
+#endif
+}
+
+MagnSensor::~MagnSensor() {
+	if (mEnabled) {
+		enable(SENSORS_MAGNETIC_FIELD_HANDLE, 0, 0);
+		mEnabled = 0;
+	}
+	pthread_mutex_destroy(&dataMutex);
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	acc->~AccelSensor();
+#endif
+}
+
+#if !defined(NOT_SET_MAG_INITIAL_STATE)
+int MagnSensor::setInitialState()
+{
+	struct input_absinfo absinfo_x;
+	struct input_absinfo absinfo_y;
+	struct input_absinfo absinfo_z;
+	float value;
+
+#if (MAG_CALIBRATION_ENABLE == 1)
+	data_read = 0;
+#endif
+
+	if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_MAG_X), &absinfo_x) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_MAG_Y), &absinfo_y) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_MAG_Z), &absinfo_z))
+	{
+		mHasPendingEvent = true;
+	}
+
+	setFullScale(SENSORS_MAGNETIC_FIELD_HANDLE, MAGN_DEFAULT_FULLSCALE);
+	memset(DecimationCount, 0, sizeof(DecimationCount));
+
+	return 0;
+}
+#endif
+
+int MagnSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+
+		case SENSORS_MAGNETIC_FIELD_HANDLE:
+			what = MagneticField;
+			break;
+
+#if (SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE == 1)
+		case SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE:
+			what = UncalibMagneticField;
+			break;
+#endif
+#if (SENSOR_FUSION_ENABLE == 1)
+		case SENSORS_SENSOR_FUSION_HANDLE:
+			what = iNemoMagnetic;
+			break;
+#endif
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+		case SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE:
+			what = GeoMagRotVect_Magnetic;
+			break;
+#endif
+#if (MAG_CALIBRATION_ENABLE == 1)
+	#if (GEOMAG_GRAVITY_ENABLE == 1)
+		case SENSORS_GRAVITY_HANDLE:
+			what = Gravity_Accel;
+			break;
+	#endif
+	#if (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1)
+		case SENSORS_LINEAR_ACCELERATION_HANDLE:
+			what = Linear_Accel;
+			break;
+	#endif
+	#if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+			case SENSORS_ORIENTATION_HANDLE:
+				what = Orientation;
+				break;
+	#endif
+	#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+			case SENSORS_VIRTUAL_GYROSCOPE_HANDLE:
+				what = VirtualGyro;
+				break;
+	#endif
+#endif
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int MagnSensor::enable(int32_t handle, int en, int __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+	int what = -1;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (flags) {
+		mEnabled |= (1<<what);
+		writeMinDelay();
+
+		if (mEnabled == (1<<what)) {
+#if !defined(NOT_SET_MAG_INITIAL_STATE)
+			setInitialState();
+#endif
+			err = writeEnable(SENSORS_MAGNETIC_FIELD_HANDLE, flags);
+			if(err >= 0) {
+				err = 0;
+			}
+		}
+
+#if (MAG_CALIBRATION_ENABLE == 1)
+		ST_MagCalibration_API_Init(CALIBRATION_PERIOD_MS);
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+		if (what == GeoMagRotVect_Magnetic)
+			acc->enable(SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE, flags, 3);
+#endif
+#if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+		if (what == Orientation)
+			acc->enable(SENSORS_ORIENTATION_HANDLE, flags, 4);
+#endif
+#if (GEOMAG_GRAVITY_ENABLE == 1)
+		if (what == Gravity_Accel)
+			acc->enable(SENSORS_GRAVITY_HANDLE, flags, 5);
+#endif
+#if (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1)
+		if (what == Linear_Accel)
+			acc->enable(SENSORS_LINEAR_ACCELERATION_HANDLE, flags, 6);
+#endif
+#endif /* MAG_CALIBRATION_ENABLE */
+	} else {
+		mEnabled &= ~(1<<what);
+
+		if (!mEnabled) {
+			err = writeEnable(SENSORS_MAGNETIC_FIELD_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+
+#if (MAG_CALIBRATION_ENABLE == 1)
+		ST_MagCalibration_API_DeInit(CALIBRATION_PERIOD_MS);
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+		if (what == GeoMagRotVect_Magnetic)
+			acc->enable(SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE, flags, 3);
+#endif
+#if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+		if (what == Orientation)
+			acc->enable(SENSORS_ORIENTATION_HANDLE, flags, 4);
+#endif
+#if (GEOMAG_GRAVITY_ENABLE == 1)
+		if (what == Gravity_Accel)
+			acc->enable(SENSORS_GRAVITY_HANDLE, flags, 5);
+#endif
+#if (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1)
+		if (what == Linear_Accel)
+			acc->enable(SENSORS_ORIENTATION_HANDLE, flags, 6);
+#endif
+#endif /* MAG_CALIBRATION_ENABLE */
+
+		if (mEnabled) {
+			writeMinDelay();
+		}
+	}
+
+	if(err >= 0 )
+		STLOGD("MagSensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						flags, handle, what, mEnabled);
+	else
+		STLOGE("MagSensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						flags, handle, what, mEnabled);
+
+	return err;
+}
+
+bool MagnSensor::hasPendingEvents() const
+{
+	return mHasPendingEvent;
+}
+
+int MagnSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err = 0;
+//	int kk;
+	int what = -1;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+//	int64_t Min_delay_ms = 0;
+
+	if(delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+	if (what == GeoMagRotVect_Magnetic)
+		acc->setDelay(SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE, SEC_TO_NSEC(1.0f / refFreq));
+#endif
+#if (MAG_CALIBRATION_ENABLE == 1)
+#if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+	if (what == Orientation)
+		acc->setDelay(SENSORS_ORIENTATION_HANDLE, SEC_TO_NSEC(1.0f / refFreq));
+#endif
+#if (GEOMAG_GRAVITY_ENABLE == 1)
+	if (what == Gravity_Accel)
+		acc->setDelay(SENSORS_GRAVITY_HANDLE, SEC_TO_NSEC(1.0f / refFreq));
+#endif
+#if (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1)
+	if (what == Linear_Accel)
+		acc->setDelay(SENSORS_LINEAR_ACCELERATION_HANDLE, SEC_TO_NSEC(1.0f / refFreq));
+#endif
+#endif
+	/**
+	 * The handled sensor is disabled. Set 0 in its setDelayBuffer position
+	 * and update decimation buffer.
+	 */
+	if (delay_ms == NSEC_TO_MSEC(DELAY_OFF))
+		delay_ms = 0;
+
+	// Min setDelay Definition
+	setDelayBuffer[what] = delay_ms;
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("MagSensor::setDelayBuffer[] = %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld",
+				setDelayBuffer[0], setDelayBuffer[1], setDelayBuffer[2],
+				setDelayBuffer[3], setDelayBuffer[4], setDelayBuffer[5],
+				setDelayBuffer[6], setDelayBuffer[7]);
+	STLOGD("MagSensor::Requested_delay_ms = %lld", delay_ms);
+#endif
+
+	// Update sysfs
+	if(mEnabled & 1<<what)
+	{
+		writeMinDelay();
+	}
+
+	return err;
+}
+
+int MagnSensor::writeMinDelay(void)
+{
+	int err = 0;
+	int kk;
+	int64_t Min_delay_ms = 0;
+
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if ((mEnabled & 1<<kk) != 0)
+		{
+			writeDelayBuffer[kk] = setDelayBuffer[kk];
+		}
+		else
+			writeDelayBuffer[kk] = 0;
+	}
+
+	// Min setDelay Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (Min_delay_ms != 0) {
+			if ((writeDelayBuffer[kk] != 0) && (writeDelayBuffer[kk] < Min_delay_ms))
+				Min_delay_ms = writeDelayBuffer[kk];
+		} else
+			Min_delay_ms = writeDelayBuffer[kk];
+	}
+
+#if (MAG_CALIBRATION_ENABLE == 1)
+	if(Min_delay_ms > CALIBRATION_PERIOD_MS)
+		Min_delay_ms = CALIBRATION_PERIOD_MS;
+#endif
+#if ((SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1) ||\
+     (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1) ||\
+	 (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1) ||\
+	 (GEOMAG_GRAVITY_ENABLE == 1))
+	if ((mEnabled & 1<<GeoMagRotVect_Magnetic) || (mEnabled & 1<<Orientation)
+			 || (mEnabled & 1<<Linear_Accel) || (mEnabled & 1<<Gravity_Accel)){
+		if(Min_delay_ms > (1000.0f / refFreq))
+			Min_delay_ms = 1000.0f / refFreq;
+	}
+#endif
+
+	if ((Min_delay_ms > 0) && (Min_delay_ms != delayms))
+	{
+		err = writeDelay(SENSORS_MAGNETIC_FIELD_HANDLE, Min_delay_ms);
+		if(err >= 0) {
+			err = 0;
+			delayms = Min_delay_ms;
+			freq = 1000.0f / Min_delay_ms;
+#if (MAG_CALIBRATION_ENABLE == 1)
+			count_call_ecompass = freq / CALIBRATION_FREQUENCY;
+#endif
+			memset(DecimationCount, 0, sizeof(DecimationCount));
+		}
+	}
+
+	// Decimation Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (kk == MagneticField || kk == UncalibMagneticField)
+			continue;
+
+		if (delayms)
+			DecimationBuffer[kk] = writeDelayBuffer[kk]/delayms;
+		else
+			DecimationBuffer[kk] = 0;
+	}
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("MagSensor::writeDelayBuffer[] = %lld, %lld, %lld, %lld, %lld, %lld, %lld, %lld",
+				writeDelayBuffer[0], writeDelayBuffer[1], writeDelayBuffer[2],
+				writeDelayBuffer[3], writeDelayBuffer[4], writeDelayBuffer[5],
+				writeDelayBuffer[6], writeDelayBuffer[7]);
+	STLOGD("MagSensor::Min_delay_ms = %lld, delayms = %lld, mEnabled = %d",
+				Min_delay_ms, delayms, mEnabled);
+	STLOGD("MagSensor::DecimationBuffer = %d, %d, %d, %d, %d, %d, %d, %d",
+				DecimationBuffer[0], DecimationBuffer[1], DecimationBuffer[2],
+				DecimationBuffer[3], DecimationBuffer[4], DecimationBuffer[5],
+				DecimationBuffer[6], DecimationBuffer[7]);
+	STLOGD("MagSensor::count_call_ecompass = %d", count_call_ecompass);
+#endif
+
+	return err;
+
+}
+
+void MagnSensor::getMagDelay(int64_t *Mag_Delay_ms)
+{
+	*Mag_Delay_ms = delayms;
+
+	return;
+}
+
+int MagnSensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if(value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if(value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_MAGNETIC_FIELD_HANDLE, value);
+		if(err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int MagnSensor::readEvents(sensors_event_t *data, int count)
+{
+//	int err;
+	float MagOffset[3];
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+#if FETCH_FULL_EVENT_BEFORE_RETURN
+	again:
+#endif
+
+	while (count && mInputReader.readEvent(&event)) {
+
+		if (event->type == EVENT_TYPE_MAG) {
+			float value = (float) event->value;
+
+			if (event->code == EVENT_TYPE_MAG_X) {
+				data_raw[0] = value * CONVERT_M_X;
+			} else if (event->code == EVENT_TYPE_MAG_Y) {
+				data_raw[1] = value * CONVERT_M_Y;
+			} else if (event->code == EVENT_TYPE_MAG_Z) {
+				data_raw[2] = value * CONVERT_M_Z;
+			}
+#if defined(MAG_EVENT_HAS_TIMESTAMP)
+			else if (event->code == EVENT_TYPE_TIME_MSB) {
+				timestamp = ((int64_t)(event->value)) << 32;
+			}
+			else if (event->code == EVENT_TYPE_TIME_LSB) {
+				timestamp |= (uint32_t)(event->value);
+			}
+#endif
+			else {
+				STLOGE("MagnSensor: unknown event code (type = %d, code = %d)", event->type, event->code);
+			}
+		} else if (event->type == EV_SYN) {
+			data_rot[0] =	data_raw[0] * matrix_mag[0][0] +
+					data_raw[1] * matrix_mag[1][0] +
+					data_raw[2] * matrix_mag[2][0];
+			data_rot[1] = 	data_raw[0] * matrix_mag[0][1] +
+					data_raw[1] * matrix_mag[1][1] +
+					data_raw[2] * matrix_mag[2][1];
+			data_rot[2] = 	data_raw[0] * matrix_mag[0][2] +
+					data_raw[1] * matrix_mag[1][2] +
+					data_raw[2] * matrix_mag[2][2];
+
+#if !defined(MAG_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			AccelSensor::getBufferData(&mSensorsBufferedVectors[ID_ACCELEROMETER]);
+#endif /* SENSORS_ACCELEROMETER_ENABLE */
+#if (MAG_CALIBRATION_ENABLE == 1)
+			magCalibIn.timestamp = timestamp;
+			magCalibIn.mag_raw[0] = data_rot[0];
+			magCalibIn.mag_raw[1] = data_rot[1];
+			magCalibIn.mag_raw[2] = data_rot[2];
+
+			ST_MagCalibration_API_Run(&magCalibOut, &magCalibIn);
+#if (DEBUG_CALIBRATION == 1)
+				STLOGD("Calibration MagData [uT] -> raw_x:%f raw_y:%f raw_z:%f",
+					data_rot[0], data_rot[1], data_rot[2]);
+				STLOGD("Calibration MagData [uT] -> uncal_x:%f uncal_y:%f uncal_z:%f",
+					magCalibOut.mag_cal[0], magCalibOut.mag_cal[1],
+					magCalibOut.mag_cal[2]);
+#endif /* DEBUG_CALIBRATION */
+#endif /* MAG_CALIBRATION_ENABLE */
+			if (mEnabled & ((1 << MagneticField) |
+						(1 << UncalibMagneticField) |
+						(1 << GeoMagRotVect_Magnetic) |
+						(1 << Orientation) |
+						(1 << Linear_Accel) |
+						(1 << Gravity_Accel) |
+						(1 << iNemoMagnetic) |
+						(1 << VirtualGyro))) {
+				/**
+				 * Get and apply Hard Iron calibration to raw mag data
+				 */
+#if (MAG_CALIBRATION_ENABLE == 1)
+				data_calibrated.v[0] = magCalibOut.mag_cal[0];
+				data_calibrated.v[1] = magCalibOut.mag_cal[1];
+				data_calibrated.v[2] = magCalibOut.mag_cal[2];
+				data_calibrated.status = magCalibOut.accuracy;
+				MagOffset[0] = magCalibOut.offset[0];
+				MagOffset[1] = magCalibOut.offset[1];
+				MagOffset[2] = magCalibOut.offset[2];
+
+#if (DEBUG_MAGNETOMETER == 1)
+				STLOGD("MagnSensor::MagCalibData: %f, %f, %f", data_calibrated.v[0], data_calibrated.v[1], data_calibrated.v[2]);
+#endif
+#else
+				/**
+				 * No calibration is available!
+				 */
+				memcpy(data_calibrated.v, data_rot, sizeof(data_calibrated.v));
+				data_calibrated.status = SENSOR_STATUS_UNRELIABLE;
+#endif
+
+#if ((SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1) ||\
+	 (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1) ||\
+	 (GEOMAG_LINEAR_ACCELERATION_ENABLE == 1) ||\
+	 (GEOMAG_GRAVITY_ENABLE == 1))
+				memcpy(sData.accel,
+				       mSensorsBufferedVectors[ID_ACCELEROMETER].v,
+							sizeof(sData.accel));
+				memcpy(sData.magn, data_calibrated.v,
+							sizeof(data_calibrated.v));
+				iNemoEngine_GeoMag_API_Run(MagnSensor::delayms, &sData);
+#endif
+				DecimationCount[MagneticField]++;
+				if((mEnabled & (1<<MagneticField)) && (DecimationCount[MagneticField] >= DecimationBuffer[MagneticField])) {
+					DecimationCount[MagneticField] = 0;
+					mPendingEvent[MagneticField].magnetic.status =
+							data_calibrated.status;
+					memcpy(mPendingEvent[MagneticField].data,
+							data_calibrated.v,
+							sizeof(data_calibrated.v));
+					mPendingEvent[MagneticField].timestamp = timestamp;
+					*data++ = mPendingEvent[MagneticField];
+					count--;
+					numEventReceived++;
+				}
+#if (SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE == 1)
+				DecimationCount[UncalibMagneticField]++;
+				if((mEnabled & (1<<UncalibMagneticField)) && (DecimationCount[UncalibMagneticField] >= DecimationBuffer[UncalibMagneticField])) {
+					DecimationCount[UncalibMagneticField] = 0;
+					mPendingEvent[UncalibMagneticField].magnetic.status = 
+							data_calibrated.status;
+					memcpy(mPendingEvent[UncalibMagneticField].uncalibrated_magnetic.uncalib,
+							data_rot, sizeof(data_rot));
+					memcpy(mPendingEvent[UncalibMagneticField].uncalibrated_magnetic.bias,
+							MagOffset, sizeof(MagOffset));
+					mPendingEvent[UncalibMagneticField].timestamp = timestamp;
+					*data++ = mPendingEvent[UncalibMagneticField];
+					count--;
+					numEventReceived++;
+				}
+#endif
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+				DecimationCount[GeoMagRotVect_Magnetic]++;
+				if((mEnabled & (1<<GeoMagRotVect_Magnetic)) && (DecimationCount[GeoMagRotVect_Magnetic] >= DecimationBuffer[GeoMagRotVect_Magnetic])) {
+					DecimationCount[GeoMagRotVect_Magnetic] = 0;
+
+					err = iNemoEngine_GeoMag_API_Get_Quaternion(mPendingEvent[GeoMagRotVect_Magnetic].data);
+					if (err == 0) {
+						mPendingEvent[GeoMagRotVect_Magnetic].magnetic.status =
+							data_calibrated.status;
+						mPendingEvent[GeoMagRotVect_Magnetic].data[4] = -1;
+						mPendingEvent[GeoMagRotVect_Magnetic].timestamp = timestamp;
+						*data++ = mPendingEvent[GeoMagRotVect_Magnetic];
+						count--;
+						numEventReceived++;
+					}
+				}
+#endif
+#if ((GEOMAG_LINEAR_ACCELERATION_ENABLE == 1))
+				DecimationCount[Linear_Accel]++;
+				if((mEnabled & (1<<Linear_Accel)) && (DecimationCount[Linear_Accel] >= DecimationBuffer[Linear_Accel])) {
+					DecimationCount[Linear_Accel] = 0;
+					err = iNemoEngine_GeoMag_API_Get_LinAcc(mPendingEvent[Linear_Accel].data);
+					if (err == 0) {
+						mPendingEvent[Linear_Accel].timestamp = timestamp;
+						*data++ = mPendingEvent[Linear_Accel];
+						count--;
+						numEventReceived++;
+					}
+				}
+#endif
+#if ((GEOMAG_GRAVITY_ENABLE == 1))
+				DecimationCount[Gravity_Accel]++;
+				if((mEnabled & (1<<Gravity_Accel)) && (DecimationCount[Gravity_Accel] >= DecimationBuffer[Gravity_Accel])) {
+					DecimationCount[Gravity_Accel] = 0;
+					err = iNemoEngine_GeoMag_API_Get_Gravity(mPendingEvent[Gravity_Accel].data);
+					if (err == 0) {
+						mPendingEvent[Gravity_Accel].timestamp = timestamp;
+						*data++ = mPendingEvent[Gravity_Accel];
+						count--;
+						numEventReceived++;
+					}
+				}
+#endif
+#if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+				DecimationCount[Orientation]++;
+				if((mEnabled & (1<<Orientation)) && (DecimationCount[Orientation] >= DecimationBuffer[Orientation])) {
+					DecimationCount[Orientation] = 0;
+					err = iNemoEngine_GeoMag_API_Get_Hpr(mPendingEvent[Orientation].data);
+					if (err == 0) {
+						mPendingEvent[Orientation].orientation.status =
+							data_calibrated.status;
+						mPendingEvent[Orientation].timestamp = timestamp;
+						*data++ = mPendingEvent[Orientation];
+						count--;
+						numEventReceived++;
+					}
+				}
+#endif
+#if (SENSOR_FUSION_ENABLE == 1) || \
+    (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+				if(mEnabled & ((1<<iNemoMagnetic) |
+					       (1<<VirtualGyro)))
+					setBufferData(&data_calibrated);
+#endif
+#if DEBUG_MAGNETOMETER == 1
+				STLOGD("MagnSensor::readEvents (time = %lld),"
+						"count(%d), received(%d)",
+						mPendingEvent[MagneticField].timestamp,
+						count, numEventReceived);
+#endif
+			}
+		} else
+			STLOGE("MagnSensor: unknown event (type = %d, code = %d)",
+							event->type, event->code);
+
+		mInputReader.next();
+	}
+#if FETCH_FULL_EVENT_BEFORE_RETURN
+	/**
+	 * if we didn't read a complete event, see if we can fill and
+	 * try again instead of returning with nothing and redoing poll.
+	 */
+	if (numEventReceived == 0 && mEnabled != 0) {
+		n = mInputReader.fill(data_fd);
+		if (n)
+			goto again;
+	}
+#endif
+	return numEventReceived;
+}
+
+bool MagnSensor::setBufferData(sensors_vec_t *value)
+{
+	pthread_mutex_lock(&dataMutex);
+	memcpy(&dataBuffer, value, sizeof(sensors_vec_t));
+	pthread_mutex_unlock(&dataMutex);
+
+	return true;
+}
+
+bool MagnSensor::getBufferData(sensors_vec_t *lastBufferedValues)
+{
+	pthread_mutex_lock(&dataMutex);
+	memcpy(lastBufferedValues, &dataBuffer, sizeof(sensors_vec_t));
+	pthread_mutex_unlock(&dataMutex);
+
+	return true;
+}
+
+#endif /* SENSORS_MAGNETIC_FIELD_ENABLE */
diff --git a/MagnSensor.h b/MagnSensor.h
new file mode 100644
index 0000000..8f1bf16
--- /dev/null
+++ b/MagnSensor.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+
+#ifndef ANDROID_MAGN_SENSOR_H
+#define ANDROID_MAGN_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "configuration.h"
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+#include "AccelSensor.h"
+
+#if MAG_CALIBRATION_ENABLE == 1
+extern "C"
+{
+	#include "STMagCalibration_API.h"
+};
+#endif
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+extern "C"
+{
+	#include "iNemoEngineGeoMagAPI.h"
+};
+#endif
+/*****************************************************************************/
+
+struct input_event;
+
+
+class MagnSensor : public SensorBase
+{
+	enum {
+		MagneticField = 0,
+		UncalibMagneticField,
+		iNemoMagnetic,
+		GeoMagRotVect_Magnetic,
+		Orientation,
+		Gravity_Accel,
+		Linear_Accel,
+		VirtualGyro,
+		numSensors
+	};
+	static int mEnabled;
+	static int64_t delayms;
+	static int current_fullscale;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent[numSensors];
+	bool mHasPendingEvent;
+	int data_read;
+	int setInitialState();
+#if SENSOR_GEOMAG_ENABLE == 1
+	int refFreq;
+#endif
+#if MAG_CALIBRATION_ENABLE == 1
+	STMagCalibration_Input magCalibIn;
+	STMagCalibration_Output magCalibOut;
+#endif
+
+private:
+	static sensors_vec_t  dataBuffer;
+	static int64_t setDelayBuffer[numSensors];
+	static int64_t writeDelayBuffer[numSensors];
+	static int DecimationBuffer[numSensors];
+	static int DecimationCount[numSensors];
+	sensors_vec_t mSensorsBufferedVectors[3];
+	virtual bool setBufferData(sensors_vec_t *value);
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	static AccelSensor *acc;
+#endif
+#if (SENSOR_GEOMAG_ENABLE == 1)
+	iNemoGeoMagSensorsData sData;
+#endif
+	float data_raw[3];
+	float data_rot[3];
+	sensors_vec_t data_calibrated;
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+
+public:
+	MagnSensor();
+	virtual ~MagnSensor();
+	virtual int readEvents(sensors_event_t* data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int writeMinDelay(void);
+	static void getMagDelay(int64_t *Mag_Delay_ms);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	virtual int getWhatFromHandle(int32_t handle);
+	int64_t getDelayms() {
+		return delayms;
+	};
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+	static int count_call_ecompass;
+	static int freq;
+};
+
+#endif  /* ANDROID_MAGN_SENSOR_H */
+
+#endif /* SENSORS_MAGNETIC_FIELD_ENABLE */
diff --git a/PressSensor.cpp b/PressSensor.cpp
new file mode 100644
index 0000000..970110a
--- /dev/null
+++ b/PressSensor.cpp
@@ -0,0 +1,272 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+
+#include "PressSensor.h"
+
+int PressSensor::current_fullscale = 0;
+int unsigned PressSensor::mEnabled = 0;
+
+PressSensor::PressSensor() :
+	SensorBase(NULL, SENSOR_DATANAME_BAROMETER),
+	mPendingMask(0),
+	mInputReader(4),
+	mHasPendingEvent(false)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+
+	mPendingEvents[Pressure].version = sizeof(sensors_event_t);
+	mPendingEvents[Pressure].sensor = ID_PRESSURE;
+	mPendingEvents[Pressure].type = SENSOR_TYPE_PRESSURE;
+
+#if (SENSORS_TEMP_PRESS_ENABLE == 1)
+	mPendingEvents[Temperature].version = sizeof(sensors_event_t);
+	mPendingEvents[Temperature].sensor = ID_TEMPERATURE;
+	mPendingEvents[Temperature].type = SENSOR_TYPE_TEMPERATURE;
+#endif
+
+	if (data_fd) {
+		STLOGI("PressSensor::PressSensor press_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("PressSensor::PressSensor press_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+PressSensor::~PressSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_PRESSURE_HANDLE, 0, 0);
+#if (SENSORS_TEMP_PRESS_ENABLE == 1)
+		enable(SENSORS_TEMPERATURE_HANDLE, 0, 0);
+#endif
+	}
+}
+
+int PressSensor::setInitialState()
+{
+	struct input_absinfo absinfo_pressure;
+	struct input_absinfo absinfo_temperature;
+	float value;
+
+	if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_PRESSURE), &absinfo_pressure) &&
+		!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_TEMPERATURE), &absinfo_temperature))
+	{
+		value = absinfo_temperature.value;
+		mPendingEvents[Pressure].data[tempChan] = TEMPERATURE_OFFSET + value * CONVERT_TEMP;
+		mPendingEvents[Temperature].temperature = TEMPERATURE_OFFSET + value * CONVERT_TEMP;
+
+		value = absinfo_pressure.value;
+		mPendingEvents[Pressure].data[pressChan] = value * CONVERT_PRESS;
+		mHasPendingEvent = true;
+	}
+
+	return 0;
+}
+
+int PressSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+		case SENSORS_PRESSURE_HANDLE:
+			what = Pressure;
+			break;
+#if (SENSORS_TEMP_PRESS_ENABLE == 1)
+		case SENSORS_TEMPERATURE_HANDLE:
+			what = Temperature;
+			break;
+#endif
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int PressSensor::writeSensorDelay(int handle)
+{
+	int err = writeDelay(handle, delayms);
+
+	return err >= 0 ? 0 : err;
+}
+
+int PressSensor::enable(int32_t handle, int en, int type __attribute__((unused)))
+{
+	int err = 0;
+	int what = -1;
+	static int enabled = 0;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if(en) {
+		err = writeSensorDelay(handle);
+		if (err < 0)
+			return err;
+
+		if(mEnabled == 0) {
+			enabled = 1;
+			err = writeEnable(SENSORS_PRESSURE_HANDLE, 1);
+		}
+		if(err >= 0) {
+			mEnabled |= (1<<what);
+			err = 0;
+			enabled = 0;
+		}
+	} else {
+		int tmp = mEnabled;
+		mEnabled &= ~(1<<what);
+		if((mEnabled == 0) && (tmp != 0))
+			err = writeEnable(SENSORS_PRESSURE_HANDLE, 0);
+
+		if(err < 0)
+			mEnabled |= (1<<what);
+		else
+			err = 0;
+	}
+
+	if(enabled == 1)
+		setInitialState();
+
+	return err;
+}
+
+int PressSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err = -1, what;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+
+	if (delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	delayms = delay_ms;
+
+	if (mEnabled & (1 << what))
+		err = writeSensorDelay(handle);
+
+	return err;
+}
+
+int PressSensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if(value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if(value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_PRESSURE_HANDLE, value);
+		if(err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int PressSensor::readEvents(sensors_event_t* data, int count)
+{
+	static float lastTempValue = 0.0f;
+
+#if DEBUG_PRESSURE_SENSOR == 1
+	STLOGD("PressSensor::readEvents (count=%d)",count);
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+#if DEBUG_PRESSURE_SENSOR == 1
+		STLOGD("PressSensor::readEvents (count=%d),type(%d)",count,event->type);
+#endif
+
+		if (event->type == EV_MSC) {
+			float value = (float) event->value;
+
+			if (event->code == EVENT_TYPE_PRESSURE) {
+				mPendingEvents[Pressure].data[pressChan] = value * CONVERT_PRESS;
+				mPendingEvents[Pressure].data[tempChan] = TEMPERATURE_OFFSET + lastTempValue * CONVERT_TEMP;
+			}
+#if (SENSORS_TEMP_PRESS_ENABLE == 1)
+			else if (event->code == EVENT_TYPE_TEMPERATURE) {
+				lastTempValue = value;
+				mPendingEvents[Temperature].temperature = TEMPERATURE_OFFSET + value * CONVERT_TEMP;
+			}
+#endif
+			else {
+				STLOGE("PressSensor: unknown event code (type=%d, code=%d)", event->type,event->code);
+			}
+		} else if (event->type == EV_SYN) {
+			if(mEnabled & (1<<Pressure))
+				mPendingMask |= 1<<Pressure;
+			if(mEnabled & (1<<Temperature))
+				mPendingMask |= 1<<Temperature;
+
+			int64_t time = timevalToNano(event->time);
+			for (int j=0 ; count && mPendingMask && j<numSensors ; j++) {
+				if (mPendingMask & (1<<j)) {
+					mPendingMask &= ~(1<<j);
+					mPendingEvents[j].timestamp = time;
+					if (mEnabled & (1<<j)) {
+						*data++ = mPendingEvents[j];
+						count--;
+						numEventReceived++;
+					}
+				}
+			}
+		} else {
+			STLOGE("PressSensor: unknown event type (type=%d, code=%d)", event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_PRESSURE_ENABLE */
diff --git a/PressSensor.h b/PressSensor.h
new file mode 100644
index 0000000..c29fa3d
--- /dev/null
+++ b/PressSensor.h
@@ -0,0 +1,71 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+
+#ifndef ANDROID_PRESS_SENSOR_H
+#define ANDROID_PRESS_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+class PressSensor : public SensorBase {
+private:
+	enum {
+		Pressure = 0,
+		Temperature,
+		numSensors
+	};
+	static unsigned int mEnabled;
+	static int current_fullscale;
+	uint32_t mPendingMask;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[numSensors];
+	bool mHasPendingEvent;
+
+	int setInitialState();
+
+	enum channelid{
+		pressChan = 0,
+		tempChan
+	};
+	int64_t delayms;
+
+	//char device_sysfs_path_prs[PATH_MAX];
+	//int device_sysfs_path_prs_len;
+	int writeSensorDelay(int handle);
+public:
+	PressSensor();
+	virtual ~PressSensor();
+	virtual int readEvents(sensors_event_t* data, int count);
+	virtual bool hasPendingEvents() const { return mHasPendingEvent; }
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_PRESS_SENSOR_H
+#endif /* SENSORS_TEMP_PRESS_ENABLE | SENSORS_PRESSURE_ENABLE */
diff --git a/ProximitySensor.cpp b/ProximitySensor.cpp
new file mode 100644
index 0000000..834a7e7
--- /dev/null
+++ b/ProximitySensor.cpp
@@ -0,0 +1,188 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+
+#include "ProximitySensor.h"
+
+ProximitySensor::ProximitySensor() :
+	SensorBase(NULL, SENSOR_DATANAME_PROXIMITY),
+	mEnabled(false),
+	current_fullscale(0),
+	mInputReader(4)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+	/* proximity sensor */
+	mPendingEvents[Proximity].version = sizeof(sensors_event_t);
+	mPendingEvents[Proximity].sensor = ID_PROXIMITY;
+	mPendingEvents[Proximity].type = SENSOR_TYPE_PROXIMITY;
+}
+
+ProximitySensor::~ProximitySensor()
+{
+	if (mEnabled)
+		enable(SENSORS_PROXIMITY_HANDLE, 0, 0);
+}
+
+int ProximitySensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+		case SENSORS_PROXIMITY_HANDLE:
+			what = Proximity;
+			break;
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int ProximitySensor::writeSensorDelay(int handle)
+{
+	int err = writeDelay(handle, delayms);
+
+	return err >= 0 ? 0 : err;
+}
+
+int ProximitySensor::enable(int32_t handle, int en, int type __attribute__((unused)))
+{
+	int err = 0;
+	int what = -1;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (en) {
+		err = writeSensorDelay(SENSORS_PROXIMITY_HANDLE);
+		if (err < 0)
+			return err;
+
+		if (!mEnabled)
+			err = writeEnable(SENSORS_PROXIMITY_HANDLE, 1);
+
+		if (err >= 0) {
+			err = 0;
+			mEnabled = true;
+		}
+	} else {
+		err = writeEnable(SENSORS_PROXIMITY_HANDLE, 0);
+		if (err < 0)
+			return err;
+
+		mEnabled = false;
+		err = 0;
+	}
+
+	if(err >= 0 )
+		STLOGD("ProximitySensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						en, handle, what, mEnabled);
+	else
+		STLOGE("ProximitySensor::enable(%d), handle: %d, what: %d, mEnabled: %x",
+						en, handle, what, mEnabled);
+	return err;
+}
+
+int ProximitySensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+	int err = 0;
+
+	if (delay_ms == 0)
+		return -EINVAL;
+
+	delayms = delay_ms;
+	if (mEnabled)
+		err = writeSensorDelay(handle);
+
+	return err;
+}
+
+int ProximitySensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = 0;
+
+	if (value <= 0)
+		return -EINVAL;
+
+	if (value != current_fullscale) {
+		err = writeFullScale(SENSORS_PROXIMITY_HANDLE, value);
+		if (err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int ProximitySensor::readEvents(sensors_event_t* data, int count)
+{
+#if DEBUG_PROXIMITY_SENSOR == 1
+	STLOGD("ProximitySensor::readEvents (count=%d)",count);
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+#if DEBUG_PROXIMITY_SENSOR == 1
+		STLOGD("ProximitySensor::readEvents (count=%d),type(%d)",count,event->type);
+#endif
+
+		if (event->type == EV_MSC) {
+			float value = (float) event->value;
+#if SENSORS_PROXIMITY_ENABLE == 1
+			if (event->code == MSC_SERIAL) {
+				mPendingEvents[Proximity].distance = value;
+				mPendingEvents[Proximity].timestamp = timevalToNano(event->time);
+				*data++ = mPendingEvents[Proximity];
+				count--;
+				numEventReceived++;
+			}
+#endif
+		} else if (event->type != EV_SYN) {
+			STLOGE("ProximitySensor: unknown event type (type=%d, code=%d)",
+			       event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+#endif /* SENSORS_PROXIMITY_ENABLE */
+
diff --git a/ProximitySensor.h b/ProximitySensor.h
new file mode 100644
index 0000000..addbfd3
--- /dev/null
+++ b/ProximitySensor.h
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+
+#ifndef ANDROID_PROXIMITY_SENSOR_H
+#define ANDROID_PROXIMITY_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+class ProximitySensor : public SensorBase {
+private:
+	enum {
+		Proximity,
+		numSensors
+	};
+	bool mEnabled;
+	int current_fullscale;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[numSensors];
+
+	int64_t delayms;
+	int writeSensorDelay(int handle);
+public:
+	ProximitySensor();
+	~ProximitySensor();
+	int readEvents(sensors_event_t* data, int count);
+	bool hasPendingEvents() const { return false; }
+	int setDelay(int32_t handle, int64_t ns);
+	int setFullScale(int32_t handle, int value);
+	int enable(int32_t handle, int enabled, int type);
+	int getWhatFromHandle(int32_t handle);
+};
+#endif /* ANDROID_PROXIMITY_SENSOR_H */
+#endif /* SENSORS_PROXIMITY_ENABLE */
diff --git a/README.md b/README.md
new file mode 100644
index 0000000..e895e9b
--- /dev/null
+++ b/README.md
@@ -0,0 +1,214 @@
+Index
+=====
+	* Introduction
+	* Software architecture
+	* Integration details
+	* STM proprietary libraries
+	* More information
+	* Copyright
+
+
+Introduction
+=========
+The STM Android sensor Hardware Abstraction Layer (*HAL*) defines a standard interface for STM sensors allowing Android to be agnostic about [lower-level driver implementations](https://github.com/STMicroelectronics/STMems_Linux_Input_drivers/tree/linux-3.10.y-gh) . The HAL library is packaged into modules (.so) file and loaded by the Android system at the appropriate time. For more information see [AOSP HAL Interface](https://source.android.com/devices/sensors/hal-interface.html) 
+
+STM Sensor HAL is leaning on [Linux Input framework](https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/tree/Documentation/input) to gather data from sensor device drivers and to forward samples to the Android Framework
+
+Currently supported sensors are:
+
+### Inertial Module Unit (IMU):
+
+> ASM330LXH, LSM330, LSM330DLC, LSM6DS0,  LSM6DS3, LSM6DSM, LSM6DSL, LSM9DS0, LSM9DS1, LSM330D, ASM330LHH, ISM330DLC
+
+### eCompass:
+
+> LSM303AGR, LSM303AH, LSM303C, LSM303D, LSM303DLHC, ISM303DAC
+
+### Accelerometer:
+
+> AIS328DQ, LIS2DE, LIS2DH12, LIS2DS12, LIS2HH12, LIS3DH, LIS2DW12, LIS3DHH, IIS2DH, IIS3DHHC
+
+### Gyroscope:
+
+> A3G4250D, L3GD20, L3GD20H
+
+### Magnetometer:
+
+> LIS3MDL, LIS2MDL, IIS2MDC
+
+### Pressure and Temperature:
+
+> LPS22HB, LPS22HD, LPS25H, LPS33HW, LPS35HW
+
+### Humidity and Temperature:
+
+> HTS221
+
+Software architecture
+===============
+STM Sensor HAL is written in *C++* language using object-oriented design. For each hw sensor there is a custom class file (*AccelSensor.cpp*, *MagnSensor.cpp*, *GyroSensor.cpp*, *PressSensor.cpp* and *HumiditySensor.cpp*) which extends the common base class (*SensorBase.cpp*).
+
+Configuration parameters for each device (such as the name of the sensor, default full scale, names of the sysfs files, etc.) are specified in a dedicated file placed in the *conf* directory and named *conf_<sensor_name\>.h* (e.g. *conf_LSM6DSM.h*)
+
+	/* ACCELEROMETER SENSOR */
+	#define SENSOR_ACC_LABEL				"LSM6DSM 3-axis Accelerometer Sensor"
+	#define SENSOR_DATANAME_ACCELEROMETER	"ST LSM6DSM Accelerometer Sensor"
+	#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"
+	#define ACCEL_ENABLE_FILE_NAME			"accel/enable"
+	#define ACCEL_RANGE_FILE_NAME			"accel/scale"
+	#define ACCEL_MAX_RANGE					8 * GRAVITY_EARTH
+	#define ACCEL_MAX_ODR					200
+	#define ACCEL_MIN_ODR					13
+	#define ACCEL_POWER_CONSUMPTION			0.6f
+	#define ACCEL_DEFAULT_FULLSCALE			4
+	
+	/* GYROSCOPE SENSOR */
+	#define SENSOR_GYRO_LABEL				"LSM6DSM 3-axis Gyroscope sensor"
+	#define SENSOR_DATANAME_GYROSCOPE		"ST LSM6DSM Gyroscope Sensor"
+	#define GYRO_DELAY_FILE_NAME			"gyro/polling_rate"
+	#define GYRO_ENABLE_FILE_NAME			"gyro/enable"
+	#define GYRO_RANGE_FILE_NAME			"gyro/scale"
+	#define GYRO_MAX_RANGE					(2000.0f * (float)M_PI/180.0f)
+	#define GYRO_MAX_ODR					200
+	#define GYRO_MIN_ODR					13
+	#define GYRO_POWER_CONSUMPTION			4.0f
+	#define GYRO_DEFAULT_FULLSCALE			2000
+	
+...
+
+	#define EVENT_TYPE_ACCEL			EV_MSC
+	#define EVENT_TYPE_GYRO				EV_MSC
+	
+	#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+	#define EVENT_TYPE_TIME_LSB			MSC_MAX
+	
+	#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+	#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+	#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+	
+	#define EVENT_TYPE_GYRO_X			MSC_SERIAL
+	#define EVENT_TYPE_GYRO_Y			MSC_PULSELED
+	#define EVENT_TYPE_GYRO_Z			MSC_GESTURE
+	
+...
+		
+	/* In this section the user must define the axis mapping to individuate only one coordinate system ENU
+	 *
+	 * Example:
+	 *                                                 y'     /| z'
+	 *                                                  ^   /
+	 *                                                  |  / 
+	 *                                                  | /
+	 *                                                  |/ 
+	 *   +----------------------------------------------+---------> x'
+	 *   |          ^ x                                 |
+	 *   |          |                       ^ z         |
+	 *   |          |                       |           |
+	 *   |    +-----+---> y                 |           |
+	 *   |    | ACC |             <---+-----+           |
+	 *   |    |     |             x   | GYR |           |
+	 *   |    +-----+                 |     |           |
+	 *   |   /                        +-----+           |
+	 *   | |/       y ^  /| z              /            |
+	 *   |  z         | /                |/             |
+	 *   |            |/                   y            |
+	 *   |      +-----+---> x                           |
+	 *   |      | MAG |                                 |
+	 *   |      |     |                                 |
+	 *   |      +-----+                                 |
+	 *   |                                        BOARD |
+	 *   +----------------------------------------------+
+	 *
+	 *
+	 *   ACCELEROMETER:
+	 *
+	 *     board        acc     |  0  1  0 |
+	 *   [x' y' z'] = [x y z] * |  1  0  0 |
+	 *                          |  0  0 -1 |
+	 *
+	 *   GYROSCOPE:
+	 *
+	 *     board        gyr     | -1  0  0 |
+	 *   [x' y' z'] = [x y z] * |  1  0  0 |
+	 *                          |  0  -1 0 |
+	 *
+	*/
+	static short matrix_acc[3][3] = {
+					{ 0, 1, 0 },
+					{ -1, 0, 0 },
+					{ 0, 0, 1 }
+					};
+	
+	static short matrix_gyr[3][3] = {
+					{ 0, 1, 0 },
+					{ -1, 0, 0 },
+					{ 0, 0, 1 }
+					};
+	
+	
+
+Integration details
+=============
+
+Copy the HAL source code into *<AOSP_DIR\>/hardware/STMicroelectronics/SensorHAL_Input* folder. During building process Android will include automatically the SensorHAL Android.mk.
+In *<AOSP_DIR\>/device/<vendor\>/<board\>/device.mk* add package build information:
+
+	PRODUCT_PACKAGES += sensors.{TARGET_BOARD_PLATFORM}
+
+	Note: device.mk can not read $(TARGET_BOARD_PLATFORM) variable, read and replace the value from your BoardConfig.mk (e.g. PRODUCT_PACKAGES += sensors.msm8974 for Nexus 5)
+
+  The Android.mk file defines the list of all supported devices. To enable a sensor put its name (e.g. *LSM6DSM*) in the *ENABLED_SENSORS* macro:
+
+	ENABLED_SENSORS := LSM6DSM
+
+To compile SensorHAL_Input just build AOSP source code from *$TOP* folder
+
+	$ cd <AOSP_DIR>
+	$ source build/envsetup.sh
+	$ lunch <select target platform>
+	$ make V=99
+
+The compiled library will be placed in *<AOSP_DIR\>/out/target/product/<board\>/system/vendor/lib/hw/sensor.{TARGET_BOARD_PLATFORM}.so*
+
+For more information on compiling an Android project, please consult the [AOSP website](https://source.android.com/source/requirements.html) 
+
+
+STM proprietary libraries
+================
+
+STM proprietary libraries are used to define composite sensors based on hardware (accelerometer, gyroscope, magnetometer) or to provide sensor calibration
+
+### SENSOR_FUSION:
+> The STM Sensor Fusion library is a complete 9-axis/6-axis solution which combines the measurements from a 3-axis gyroscope, a 3-axis magnetometer and a 3-axis accelerometer to provide a robust absolute orientation vector and game orientation vector
+
+### GEOMAG_FUSION:
+> The STM GeoMag Fusion library is a complete 6-axis solution which combines the measurements from a 3-axis magnetometer and a 3-axis accelerometer to provide a robust geomagnetic orientation vector
+
+### GBIAS:
+> The STM Gbias Calibration library provides an efficient gyroscope bias runtime compensation
+
+### MAGCALIB:
+> The STM Magnetometer Calibration library provides an accurate magnetometer Hard Iron (HI) and Soft Iron (SI) runtime compensation
+
+The *Android.mk* file enumerates STM libraries supported by the HAL. The *ENABLED_MODULES* variable is used to enable support for proprietary STM libraries
+
+	ENABLED_MODULES := SENSOR_FUSION MAGCALIB GBIAS
+
+The release of STM proprietary libraries is subject to signature of a License User Agreement (LUA); please contact an STMicroelectronics sales office and representatives for further information.
+
+
+Copyright
+========
+Copyright (C) 2016 STMicroelectronics
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
diff --git a/SensorBase.cpp b/SensorBase.cpp
new file mode 100644
index 0000000..d78b3c0
--- /dev/null
+++ b/SensorBase.cpp
@@ -0,0 +1,460 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <linux/input.h>
+#include <stdio.h>
+#include <string.h>
+#include <linux/ioctl.h>
+#include <linux/rtc.h>
+#include <utils/Atomic.h>
+
+#include "SensorBase.h"
+#include "configuration.h"
+#include "sensors.h"
+
+/*****************************************************************************/
+
+SensorBase::SensorBase(const char* dev_name, const char* data_name)
+	: dev_name(dev_name), data_name(data_name),
+	dev_fd(-1), data_fd(-1)
+{
+	if(data_name)
+		data_fd = openInput(data_name);
+}
+
+SensorBase::~SensorBase()
+{
+	if (data_fd >= 0)
+		close(data_fd);
+
+	if (dev_fd >= 0)
+		close(dev_fd);
+}
+
+int SensorBase::open_device()
+{
+	if (dev_fd<0 && dev_name) {
+		dev_fd = open(dev_name, O_RDONLY);
+		STLOGE_IF(dev_fd < 0, "Couldn't open %s (%s)", dev_name, strerror(errno));
+	}
+	return 0;
+}
+
+int SensorBase::close_device()
+{
+	if (dev_fd >= 0) {
+		close(dev_fd);
+		dev_fd = -1;
+	}
+	return 0;
+}
+
+int SensorBase::getFd() const
+{
+	if (!data_name)
+		return dev_fd;
+
+	return data_fd;
+}
+
+int SensorBase::setDelay(int32_t  __attribute__((unused)) handle,
+			 int64_t  __attribute__((unused)) ns)
+{
+	return 0;
+}
+
+bool SensorBase::hasPendingEvents() const
+{
+	return false;
+}
+
+int SensorBase::openInput(const char* inputDeviceName)
+{
+	int fd = -1;
+
+	fd = getSysfsDevicePath(sysfs_device_path, inputDeviceName);
+	sysfs_device_path_len = strlen(sysfs_device_path);
+
+	return fd;
+}
+
+
+int SensorBase::getSysfsDevicePath(char* sysfs_path ,const char* inputDeviceName)
+{
+	int fd = -1;
+	const char *dirname = "/dev/input";
+	char devname[PATH_MAX];
+	char *filename;
+	DIR *dir;
+	struct dirent *de;
+
+	sysfs_path[0] =' ';
+	dir = opendir(dirname);
+
+	if(dir == NULL)
+		return -1;
+STLOGE("[Jay][%s] sysfs_path: %s, inputDeviceName: %s
", __func__, sysfs_path, inputDeviceName);
+	strcpy(devname, dirname);
+	filename = devname + strlen(devname);
+	*filename++ = '/';
+
+	while((de = readdir(dir))) {
+		if(de->d_name[0] == '.' && (de->d_name[1] == ' ' || (de->d_name[1] == '.' && de->d_name[2] == ' ')))
+			continue;
+
+		strcpy(filename, de->d_name);
+		fd = open(devname, O_RDONLY);
+		if (fd >= 0) {
+			char name[80];
+			if (ioctl(fd, EVIOCGNAME(sizeof(name) - 1), &name) < 1)
+				name[0] = ' ';
+
+			if (!strcmp(name, inputDeviceName)) {
+				strcpy(sysfs_path,"/sys/class/input/");
+				strcat(sysfs_path,filename);
+				strcat(sysfs_path,"/device/");
+
+				break;
+			} else {
+				close(fd);
+				fd = -1;
+			}
+		}
+	}
+
+	closedir(dir);
+	STLOGE_IF(fd < 0, "couldn't find sysfs path for device '%s' ", inputDeviceName);
+
+	return fd;
+}
+
+int SensorBase::writeFullScale(int32_t handle, int value)
+{
+	int fd;
+	int err;
+	char buf[6];
+	const char *className;
+
+	switch(handle) {
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		case SENSORS_ACCELEROMETER_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], ACCEL_RANGE_FILE_NAME);
+			className = "AccelSensor::setFullScale()";
+			break;
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+		case SENSORS_MAGNETIC_FIELD_HANDLE:
+		case SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], MAGN_RANGE_FILE_NAME);
+			className = "MagnSensor::setFullScale()";
+			break;
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		case SENSORS_GYROSCOPE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], GYRO_RANGE_FILE_NAME);
+			className = "Gyro::setFullScale()";
+			break;
+#endif
+		default:
+			return -1;
+	}
+
+
+	fd = open(sysfs_device_path, O_RDWR);
+	sprintf(buf,"%d", value);
+	err = write(fd, buf, sizeof(buf));
+	close(fd);
+
+	if(err >= 0) {
+		STLOGI("%s Set new full-scale to %d", className, value);
+	} else {
+		STLOGE("%s Failed to set Full-scale: %d - %s", className, value, sysfs_device_path);
+	}
+
+	return err >= 0 ? 0 : -1;
+}
+
+int SensorBase::writeEnable(int32_t handle, int enable)
+{
+	int fd;
+	int err;
+	char buf[6];
+	const char *className;
+
+	switch(handle) {
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		case SENSORS_ACCELEROMETER_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], ACCEL_ENABLE_FILE_NAME);
+			className = "AccelSensor::Enable(Accel)";
+			break;
+#endif
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+		case SENSORS_SIGNIFICANT_MOTION_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], SIGN_MOTION_ENABLE_FILE_NAME);
+			className = "AccelSensor::Enable(SigMotion)";
+			break;
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+		case SENSORS_MAGNETIC_FIELD_HANDLE:
+		case SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], MAGN_ENABLE_FILE_NAME);
+			className = "MagnSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		case SENSORS_GYROSCOPE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], GYRO_ENABLE_FILE_NAME);
+			className = "GyroSensor::Enable()";
+			break;
+#endif
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+		case SENSORS_PRESSURE_HANDLE:
+		case SENSORS_TEMPERATURE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], PRESS_ENABLE_FILE_NAME);
+			className = "PressTempSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_TEMP_ENABLE == 1)
+		case SENSORS_TEMPERATURE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], TEMP_ENABLE_FILE_NAME);
+			className = "TempSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_TILT_ENABLE == 1)
+		case SENSORS_TILT_DETECTOR_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], TILT_ENABLE_FILE_NAME);
+			className = "TiltSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+		case SENSORS_STEP_COUNTER_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], STEP_C_ENABLE_FILE_NAME);
+			className = "StepCounterSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_STEP_DETECTOR_ENABLE == 1)
+		case SENSORS_STEP_DETECTOR_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], STEP_D_ENABLE_FILE_NAME);
+			className = "StepDetectorSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_SIGN_MOTION_ENABLE == 1)
+		case SENSORS_SIGN_MOTION_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], SIGN_M_ENABLE_FILE_NAME);
+			className = "SignMotionSensor::Enable()";
+			break;
+#endif
+#if (SENSORS_TAP_ENABLE == 1)
+		case SENSORS_TAP_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], TAP_ENABLE_FILE_NAME);
+			className = "TapSensor::Enable()";
+			break;
+#endif
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+		case SENSORS_TEMPERATURE_HANDLE:
+		case SENSORS_HUMIDITY_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], HUMIDITY_ENABLE_FILE_NAME);
+			className = "HimiditySensor::Enable()";
+			break;
+#endif
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+		case SENSORS_PROXIMITY_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], PROXIMITY_ENABLE_FILE_NAME);
+			className = "ProximitySensor::Enable()";
+			break;
+#endif
+		default:
+			return -1;
+	}
+
+	fd = open(sysfs_device_path, O_RDWR);
+	sprintf(buf,"%d", enable);
+	err = write(fd, buf, sizeof(buf));
+	close(fd);
+
+	if(err > 0) {
+		STLOGI("%s Set enable to %d", className, enable);
+	} else {
+		STLOGE("%s Failed to set enable: %d - %s", className, enable, sysfs_device_path);
+	}
+
+	return err > 0 ? 0 : -1;
+}
+
+int SensorBase::writeDelay(int32_t handle, int64_t delay_ms)
+{
+	int fd;
+	int err;
+	char buf[8];
+	const char *className;
+
+	STLOGD( "SensorBase: setDelay handle = %d", handle);
+
+	switch(handle) {
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		case SENSORS_ACCELEROMETER_HANDLE:
+		case SENSORS_SIGNIFICANT_MOTION_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], ACCEL_DELAY_FILE_NAME);
+			className = "AccelSensor::Delay()";
+			break;
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+		case SENSORS_MAGNETIC_FIELD_HANDLE:
+		case SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], MAGN_DELAY_FILE_NAME);
+			className = "MagnSensor::Delay()";
+			break;
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		case SENSORS_GYROSCOPE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], GYRO_DELAY_FILE_NAME);
+			className = "Gyro::Delay()";
+			break;
+#endif
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+		case SENSORS_STEP_COUNTER_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], STEP_C_DELAY_FILE_NAME);
+			className = "StepCounterSensor::Delay()";
+			break;
+#endif
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+		case SENSORS_PRESSURE_HANDLE:
+		case SENSORS_TEMPERATURE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], PRESS_DELAY_FILE_NAME);
+			className = "PressTempSensor::Delay()";
+			break;
+#endif
+#if (SENSORS_TEMP_ENABLE == 1)
+		case SENSORS_TEMPERATURE_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], TEMP_DELAY_FILE_NAME);
+			className = "TempSensor::Delay()";
+			break;
+#endif
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+		case SENSORS_TEMPERATURE_HANDLE:
+		case SENSORS_HUMIDITY_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], HUMIDITY_DELAY_FILE_NAME);
+			className = "HimiditySensor::Delay()";
+			break;
+#endif
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+		case SENSORS_PROXIMITY_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], PROXIMITY_DELAY_FILE_NAME);
+			className = "ProximitySensor::Delay()";
+			break;
+#endif
+		default:
+			return -1;
+	}
+
+	fd = open(sysfs_device_path, O_RDWR);
+	if (!fd) {
+		STLOGE("%s Failed to open device: %s", className, sysfs_device_path);
+		return -1;
+	}
+
+	sprintf(buf,"%lld", (long long)delay_ms);
+	err = write(fd, buf, sizeof(buf));
+	close(fd);
+
+	if(err > 0) {
+		STLOGI("%s Set delay to %lld [ms]", className, (long long)delay_ms);
+	} else {
+		STLOGE("%s Failed to set delay: %lld [ms] - %s", className, (long long)delay_ms, sysfs_device_path);
+	}
+
+        return err > 0 ? 0 : -1;
+}
+
+int SensorBase::writeSysfsCommand(int32_t handle, const char *sysfsFilename, const char *dataFormat, int64_t param)
+{
+	int fd;
+	int err;
+	char buf[8];
+	const char *className;
+
+	char formatstring1[50] = "%s Set %s to ";
+	char formatstring2[100] = "%s Failed to set %s: ";
+
+	switch(handle) {
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		case SENSORS_ACCELEROMETER_HANDLE:
+		case SENSORS_SIGNIFICANT_MOTION_HANDLE:
+			strcpy(&sysfs_device_path[sysfs_device_path_len], sysfsFilename);
+			className = "AccelSensor::Command()";
+			break;
+#endif
+		default:
+			return -1;
+	}
+
+	fd = open(sysfs_device_path, O_RDWR);
+	sprintf(buf, dataFormat, param);
+	err = write(fd, buf, sizeof(buf));
+	close(fd);
+
+
+	strcat(formatstring1, dataFormat);
+	strcat(formatstring2, dataFormat);
+	strcat(formatstring2, " - %s");
+
+	if(err > 0) {
+		STLOGI(formatstring1, className, sysfsFilename, param);
+	} else {
+		STLOGE(formatstring2, className, sysfsFilename, param, sysfs_device_path);
+	}
+
+        return err > 0 ? 0 : -1;
+}
+
+/*
+ * The following functions are the same used by Android to retrieve system
+ * boot time (system/core/libutils/SystemClock.cpp).
+ * These function are here reported to be consistent with the
+ * timestamp check used into CTS tests.
+ */
+enum {
+	SYSTEM_TIME_REALTIME = 0,  // system-wide realtime clock
+	SYSTEM_TIME_MONOTONIC = 1, // monotonic time since unspecified starting point
+	SYSTEM_TIME_PROCESS = 2,   // high-resolution per-process clock
+	SYSTEM_TIME_THREAD = 3,    // high-resolution per-thread clock
+	SYSTEM_TIME_BOOTTIME = 4   // same as SYSTEM_TIME_MONOTONIC, but including CPU suspend time
+};
+
+int64_t systemTime(int clock)
+{
+	static const clockid_t clocks[] = {
+		CLOCK_REALTIME,
+		CLOCK_MONOTONIC,
+		CLOCK_PROCESS_CPUTIME_ID,
+		CLOCK_THREAD_CPUTIME_ID,
+		CLOCK_BOOTTIME
+	};
+	struct timespec t;
+	t.tv_sec = t.tv_nsec = 0;
+	clock_gettime(clocks[clock], &t);
+	return int64_t(t.tv_sec)*1000000000LL + t.tv_nsec;
+}
diff --git a/SensorBase.h b/SensorBase.h
new file mode 100644
index 0000000..1e2ca3f
--- /dev/null
+++ b/SensorBase.h
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SENSOR_BASE_H
+#define ANDROID_SENSOR_BASE_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#define DELAY_OFF		(-1000000)
+#define MSEC_TO_SEC(x)		((x) / 1000)
+#define NSEC_TO_MSEC(x)		((x) / 1000000)
+#define MSEC_TO_NSEC(x)		((x) * 1000000)
+#define SEC_TO_MSEC(x)		((x) * 1000)
+#define SEC_TO_NSEC(x)		(MSEC_TO_NSEC(SEC_TO_MSEC(x)))
+/*****************************************************************************/
+
+struct sensors_event_t;
+
+class SensorBase {
+
+protected:
+	const char* dev_name;
+	const char* data_name;
+	char sysfs_device_path[PATH_MAX];
+	int sysfs_device_path_len;
+	int dev_fd;
+	int data_fd;
+
+	int openInput(const char* inputDeviceName);
+
+
+	static int64_t timevalToNano(timeval const& t) {
+		return t.tv_sec*1000000000LL + t.tv_usec*1000;
+	}
+
+	int open_device();
+	int close_device();
+	int getSysfsDevicePath(char* sysfs_path, const char* inputDeviceName);
+
+public:
+	SensorBase(const char* dev_name, const char* data_name);
+	virtual ~SensorBase();
+
+	virtual int readEvents(sensors_event_t* data, int count) = 0;
+	virtual bool hasPendingEvents() const;
+	virtual int getFd() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type) = 0;
+	virtual int writeFullScale(int32_t handle, int value);
+	virtual int writeEnable(int32_t handle, int enable);
+	virtual int writeDelay(int32_t handle, int64_t delay_ms);
+	virtual int writeSysfsCommand(int32_t handle, const char *sysfsFilename, const char *dataFormat, int64_t param);
+	virtual int getWhatFromHandle(int32_t handle) = 0;
+};
+
+/*****************************************************************************/
+
+#endif  // ANDROID_SENSOR_BASE_H
diff --git a/SignMotionSensor.cpp b/SignMotionSensor.cpp
new file mode 100644
index 0000000..27c0cad
--- /dev/null
+++ b/SignMotionSensor.cpp
@@ -0,0 +1,174 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_SIGN_MOTION_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+#include "SignMotionSensor.h"
+
+
+/*****************************************************************************/
+int SignMotionSensor::mEnabled = 0;
+
+SignMotionSensor::SignMotionSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_SIGN_M),
+	mInputReader(4)
+{
+	mPendingEvent.version = sizeof(sensors_event_t);
+	mPendingEvent.sensor = ID_SIGN_MOTION;
+	mPendingEvent.type = SENSOR_TYPE_SIGNIFICANT_MOTION;
+	mPendingEvent.data[0] = 1.0f;
+
+	if (data_fd) {
+		STLOGI("SignMotionSensor::SignMotionSensor device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("SignMotionSensor::SignMotionSensor device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+SignMotionSensor::~SignMotionSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_SIGN_MOTION_HANDLE, 0, 0);
+	}
+}
+
+int SignMotionSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+
+	if (flags) {
+		if (!mEnabled) {
+			err = writeEnable(SENSORS_SIGN_MOTION_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+		mEnabled = 1;
+	} else {
+		if (mEnabled){
+			err = writeEnable(SENSORS_SIGN_MOTION_HANDLE, flags);
+			if(err >= 0) {
+				err = 0;
+				mEnabled = 0;
+			}
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("SignMotionSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	} else {
+		STLOGE("SignMotionSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	}
+
+	return err;
+}
+
+int SignMotionSensor::getWhatFromHandle(int32_t __attribute__((unused))handle)
+{
+	return 0;
+}
+
+bool SignMotionSensor::hasPendingEvents() const
+{
+	return false;
+}
+
+int SignMotionSensor::setDelay(int32_t __attribute__((unused))handle,
+					int64_t __attribute__((unused))delay_ns)
+{
+	return 0;
+}
+
+int SignMotionSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+
+		if (event->type == EVENT_TYPE_SIGN_M) {
+
+#if (DEBUG_SIGN_M == 1)
+	STLOGD("SignMotionSensor::readEvents (event_code=%d)", event->code);
+#endif
+			switch(event->code) {
+			case EVENT_TYPE_SIGN_M_DATA:
+
+				break;
+#if defined(INPUT_EVENT_HAS_TIMESTAMP)
+			case EVENT_TYPE_TIME_MSB:
+				timestamp = ((int64_t)(event->value)) << 32;
+
+				break;
+			case EVENT_TYPE_TIME_LSB:
+				timestamp |= (uint32_t)(event->value);
+
+				break;
+#endif
+			default:
+				STLOGE("SignMotionSensor: unknown event code \
+					(type = %d, code = %d)", event->type,
+								event->code);
+			}
+		} else if (event->type == EV_SYN) {
+
+			enable(SENSORS_SIGN_MOTION_HANDLE, 0, 0);
+#if !defined(INPUT_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+			mPendingEvent.timestamp = timestamp;
+			memcpy(data, &mPendingEvent, sizeof(mPendingEvent));
+			data++;
+			count--;
+			numEventReceived++;
+#if (DEBUG_SIGN_M == 1)
+			STLOGD("SignMotionSensor::readEvents (time = %lld), count(%d), received(%d)",
+						mPendingEvent.timestamp,
+						count, numEventReceived);
+#endif
+
+		} else {
+			STLOGE("SignMotionSensor: unknown event (type=%d, code=%d)",
+						event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_SIGN_MOTION_ENABLE */
diff --git a/SignMotionSensor.h b/SignMotionSensor.h
new file mode 100644
index 0000000..b7ed2e4
--- /dev/null
+++ b/SignMotionSensor.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_SIGN_MOTION_ENABLE == 1)
+
+#ifndef ANDROID_SIGN_MOTION_SENSOR_H
+#define ANDROID_SIGN_MOTION_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+struct input_event;
+
+class SignMotionSensor : public SensorBase
+{
+	static int mEnabled;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+
+private:
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+	int32_t steps;
+
+public:
+	SignMotionSensor();
+	virtual ~SignMotionSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int getWhatFromHandle(int32_t handle);
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+};
+
+#endif  // ANDROID_SIGN_MOTION_SENSOR_H
+
+#endif
diff --git a/StepCounterSensor.cpp b/StepCounterSensor.cpp
new file mode 100644
index 0000000..d206134
--- /dev/null
+++ b/StepCounterSensor.cpp
@@ -0,0 +1,184 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+#include "StepCounterSensor.h"
+
+
+/*****************************************************************************/
+int StepCounterSensor::mEnabled = 0;
+
+StepCounterSensor::StepCounterSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_STEP_C),
+	mInputReader(4)
+{
+	mPendingEvent.version = sizeof(sensors_event_t);
+	mPendingEvent.sensor = ID_STEP_COUNTER;
+	mPendingEvent.type = SENSOR_TYPE_STEP_COUNTER;
+	memset(&mPendingEvent.u64, 0, sizeof(mPendingEvent.u64));
+	delivery_rate = 0;
+
+	if (data_fd) {
+		STLOGI("StepCounterSensor::StepCounterSensor device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("StepCounterSensor::StepCounterSensor device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+StepCounterSensor::~StepCounterSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_STEP_COUNTER_HANDLE, 0, 0);
+	}
+}
+
+int StepCounterSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+
+	if (flags) {
+		if (!mEnabled) {
+			err = writeEnable(SENSORS_STEP_COUNTER_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+		mEnabled = 1;
+	} else {
+		if (mEnabled){
+			err = writeEnable(SENSORS_STEP_COUNTER_HANDLE, flags);
+			if(err >= 0) {
+				err = 0;
+				mEnabled = 0;
+			}
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("StepCounterSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	} else {
+		STLOGE("StepCounterSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	}
+
+	return err;
+}
+
+int StepCounterSensor::getWhatFromHandle(int32_t __attribute__((unused))handle)
+{
+	return 0;
+}
+
+bool StepCounterSensor::hasPendingEvents() const
+{
+	return false;
+}
+
+int StepCounterSensor::setDelay(int32_t __attribute__((unused))handle,
+							int64_t delay_ns)
+{
+	int err = 0;
+
+	if (delay_ns != delivery_rate) {
+		err = writeDelay(SENSORS_STEP_COUNTER_HANDLE,
+						NSEC_TO_MSEC(delay_ns));
+		if(err >= 0)
+			delivery_rate = delay_ns;
+	}
+	return err;
+}
+
+int StepCounterSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+
+		if (event->type == EVENT_TYPE_STEP_C) {
+
+#if (DEBUG_STEP_C == 1)
+	STLOGD("StepCounterSensor::readEvents (event_code=%d)", event->code);
+#endif
+			switch(event->code) {
+			case EVENT_TYPE_STEP_C_DATA:
+				steps = (uint32_t)event->value;
+
+				break;
+#if defined(INPUT_EVENT_HAS_TIMESTAMP)
+			case EVENT_TYPE_TIME_MSB:
+				timestamp = ((int64_t)(event->value)) << 32;
+
+				break;
+			case EVENT_TYPE_TIME_LSB:
+				timestamp |= (uint32_t)(event->value);
+
+				break;
+#endif
+			default:
+				STLOGE("StepCounterSensor: unknown event code \
+					(type = %d, code = %d)", event->type,
+								event->code);
+			}
+		} else if (event->type == EV_SYN) {
+
+#if !defined(INPUT_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+			mPendingEvent.u64.step_counter = (uint64_t)steps;
+			mPendingEvent.timestamp = timestamp;
+			memcpy(data, &mPendingEvent, sizeof(mPendingEvent));
+			data++;
+			count--;
+			numEventReceived++;
+#if (DEBUG_STEP_C == 1)
+			STLOGD("StepCounterSensor::readEvents (time = %lld), count(%d), received(%d), steps(%d)",
+						mPendingEvent.timestamp,
+						count, numEventReceived, steps);
+#endif
+
+		} else {
+			STLOGE("StepCounterSensor: unknown event (type=%d, code=%d)",
+						event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_STEP_COUNTER_ENABLE */
diff --git a/StepCounterSensor.h b/StepCounterSensor.h
new file mode 100644
index 0000000..a4f3c64
--- /dev/null
+++ b/StepCounterSensor.h
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+
+#ifndef ANDROID_STEP_COUNTER_SENSOR_H
+#define ANDROID_STEP_COUNTER_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+struct input_event;
+
+class StepCounterSensor : public SensorBase
+{
+	static int mEnabled;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+
+private:
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+	uint32_t steps;
+	int64_t delivery_rate;
+
+public:
+	StepCounterSensor();
+	virtual ~StepCounterSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int getWhatFromHandle(int32_t handle);
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+};
+
+#endif  // ANDROID_STEP_COUNTER_SENSOR_H
+
+#endif
diff --git a/StepDetectorSensor.cpp b/StepDetectorSensor.cpp
new file mode 100644
index 0000000..c22eff3
--- /dev/null
+++ b/StepDetectorSensor.cpp
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_STEP_DETECTOR_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+#include "StepDetectorSensor.h"
+
+
+/*****************************************************************************/
+int StepDetectorSensor::mEnabled = 0;
+
+StepDetectorSensor::StepDetectorSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_STEP_D),
+	mInputReader(4)
+{
+	mPendingEvent.version = sizeof(sensors_event_t);
+	mPendingEvent.sensor = ID_STEP_DETECTOR;
+	mPendingEvent.type = SENSOR_TYPE_STEP_DETECTOR;
+	mPendingEvent.data[0] = 1.0f;
+
+	if (data_fd) {
+		STLOGI("StepDetectorSensor::StepDetectorSensor device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("StepDetectorSensor::StepDetectorSensor device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+StepDetectorSensor::~StepDetectorSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_STEP_DETECTOR_HANDLE, 0, 0);
+	}
+}
+
+int StepDetectorSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+
+	if (flags) {
+		if (!mEnabled) {
+			err = writeEnable(SENSORS_STEP_DETECTOR_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+		mEnabled = 1;
+	} else {
+		if (mEnabled){
+			err = writeEnable(SENSORS_STEP_DETECTOR_HANDLE, flags);
+			if(err >= 0) {
+				err = 0;
+				mEnabled = 0;
+			}
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("StepDetectorSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	} else {
+		STLOGE("StepDetectorSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	}
+
+	return err;
+}
+
+int StepDetectorSensor::getWhatFromHandle(int32_t __attribute__((unused))handle)
+{
+	return 0;
+}
+
+bool StepDetectorSensor::hasPendingEvents() const
+{
+	return false;
+}
+
+int StepDetectorSensor::setDelay(int32_t __attribute__((unused))handle,
+					int64_t __attribute__((unused))delay_ns)
+{
+	return 0;
+}
+
+int StepDetectorSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+
+		if (event->type == EVENT_TYPE_STEP_D) {
+
+#if (DEBUG_STEP_D == 1)
+	STLOGD("StepDetectorSensor::readEvents (event_code=%d)", event->code);
+#endif
+			switch(event->code) {
+			case EVENT_TYPE_STEP_D_DATA:
+
+				break;
+#if defined(INPUT_EVENT_HAS_TIMESTAMP)
+			case EVENT_TYPE_TIME_MSB:
+				timestamp = ((int64_t)(event->value)) << 32;
+
+				break;
+			case EVENT_TYPE_TIME_LSB:
+				timestamp |= (uint32_t)(event->value);
+
+				break;
+#endif
+			default:
+				STLOGE("StepDetectorSensor: unknown event code \
+					(type = %d, code = %d)", event->type,
+								event->code);
+			}
+		} else if (event->type == EV_SYN) {
+
+#if !defined(INPUT_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+			mPendingEvent.timestamp = timestamp;
+			memcpy(data, &mPendingEvent, sizeof(mPendingEvent));
+			data++;
+			count--;
+			numEventReceived++;
+#if (DEBUG_STEP_D == 1)
+			STLOGD("StepDetectorSensor::readEvents (time = %lld), count(%d), received(%d)",
+						mPendingEvent.timestamp,
+						count, numEventReceived);
+#endif
+
+		} else {
+			STLOGE("StepDetectorSensor: unknown event (type=%d, code=%d)",
+						event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_STEP_DETECTOR_ENABLE */
diff --git a/StepDetectorSensor.h b/StepDetectorSensor.h
new file mode 100644
index 0000000..273ffd2
--- /dev/null
+++ b/StepDetectorSensor.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_STEP_DETECTOR_ENABLE == 1)
+
+#ifndef ANDROID_STEP_DETECTOR_SENSOR_H
+#define ANDROID_STEP_DETECTOR_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+struct input_event;
+
+class StepDetectorSensor : public SensorBase
+{
+	static int mEnabled;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+
+private:
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+	int32_t steps;
+
+public:
+	StepDetectorSensor();
+	virtual ~StepDetectorSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int getWhatFromHandle(int32_t handle);
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+};
+
+#endif  // ANDROID_STEP_DETECTOR_SENSOR_H
+
+#endif
diff --git a/StoreCalibration.cpp b/StoreCalibration.cpp
new file mode 100644
index 0000000..786c047
--- /dev/null
+++ b/StoreCalibration.cpp
@@ -0,0 +1,264 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#define CLASS_NAME "StoreCalibration"
+#include <sys/stat.h>
+#include "StoreCalibration.h"
+#include <fcntl.h>
+#include <cutils/log.h>
+#include <unistd.h>
+#include <sys/mman.h>
+#include <pthread.h>
+
+#if defined(STORE_CALIB_ENABLED)
+#include <private/android_filesystem_config.h>
+
+#include <fstream>
+using std::ifstream;
+
+#include <iostream>
+using std::cout;
+using std::endl;
+
+#define PACKAGES_LIST_FILE  "/data/system/packages.list"
+
+
+static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
+
+int StoreCalibration::instanceCount = 0;
+StoreCalibration* StoreCalibration::single = NULL;
+time_t StoreCalibration::oldMTime = 0;
+int StoreCalibration::cal_file = 0;
+int StoreCalibration::observer_fd = 0;
+int StoreCalibration::watch_fd = 0;
+calib_out_t StoreCalibration::calibration;
+bool StoreCalibration::is_changed = false;
+
+static const struct sensor_spec_t {
+	uint8_t id;
+	char token[9];
+	float reset_value;
+} sensor_spec[] = {
+	{
+		StoreCalibration::GYROSCOPE_BIAS,
+		"GyroBias",
+		0.0,
+	},
+	{
+		StoreCalibration::GYROSCOPE_SENS,
+		"GyroSens",
+		1.0,
+	},
+	{
+		StoreCalibration::ACCELEROMETER_BIAS,
+		"AccBias",
+		0.0,
+	},
+	{
+		StoreCalibration::ACCELEROMETER_SENS,
+		"AccSens",
+		1.0,
+	},
+	{
+		StoreCalibration::MAGNETOMETER_BIAS,
+		"MagBias",
+		0.0,
+	},
+	{
+		StoreCalibration::MAGNETOMETER_SENS,
+		"MagSens",
+		1.0,
+	},
+};
+
+int StoreCalibration::eventCheck(int fd)
+{
+	fd_set rfds;
+
+	FD_ZERO (&rfds);
+	FD_SET (fd, &rfds);
+	/* Wait until an event happens */
+
+	return select(FD_SETSIZE, &rfds, NULL, NULL, NULL);
+}
+
+StoreCalibration::StoreCalibration()
+{
+	int rc = 0;
+
+	readCalibrationFile();
+	observer_fd = inotify_init();
+	if (!observer_fd) {
+		ALOGE("Error to start inotify!!!");
+		return;
+	}
+
+	rc = pthread_create(&thread, NULL,
+			    StoreCalibration::checkChangesThread, NULL);
+	if (rc) {
+		ALOGE("Error to create pthread
");
+	}
+}
+
+StoreCalibration* StoreCalibration::getInstance()
+{
+	if(instanceCount == 0)
+	{
+		    single = new StoreCalibration();
+		    instanceCount = 1;
+
+		    return single;
+	} else {
+		    instanceCount++;
+
+		    return single;
+	}
+}
+
+void* StoreCalibration::checkChangesThread(void  __attribute__((unused))*arg)
+{
+	char event_buf[EVENT_BUF_SIZE];
+	struct inotify_event* event;
+	int num_bytes = 0;
+	int event_pos, i;
+	int event_size;
+	struct stat s;
+
+	while (stat(CAL_DIR, &s)<0) {
+		/* sleep until the calibration directory is present */
+		usleep(THD_SLEEP_USEC);
+	}
+
+	watch_fd = inotify_add_watch(observer_fd, CAL_DIR, OBS_MASK);
+	if (!watch_fd) {
+		ALOGE("Error while adding inotify watcher!!!");
+		pthread_exit(NULL);
+		return NULL;
+	}
+
+	while (true) {
+		if (eventCheck(observer_fd)) {
+			num_bytes = read(observer_fd, event_buf, EVENT_BUF_SIZE);
+			event_pos = 0;
+			while (num_bytes >= (int)sizeof(*event)) {
+				event = (struct inotify_event *)(event_buf + event_pos);
+				if (event->len) {
+					if (event->mask & (IN_MODIFY /*| IN_CREATE*/)) {
+
+						if (!strcmp(event->name, CAL_FILE)) {
+							ALOGI("Changes on Calibration file detected");
+							readCalibrationFile();
+						}
+					} else if (event->mask & (IN_DELETE)) {
+						ALOGI("Calibration file deleted");
+
+						pthread_mutex_lock(&lock);
+						memset(calibration, 0, sizeof(calibration));
+						is_changed = true;
+						pthread_mutex_unlock(&lock);
+					} else {
+						ALOGI("Event not used %d", event->mask);
+					}
+				}
+				event_size = sizeof(*event) + event->len;
+				num_bytes -= event_size;
+				event_pos += event_size;
+			}
+		}
+	}
+	pthread_exit(NULL);
+	return NULL;
+}
+
+void StoreCalibration::readCalibrationFile()
+{
+	ifstream fin;
+	char buf[MAX_CHARS_PER_LINE];
+	const char* token[MAX_TOKENS_PER_LINE] = {};
+	int n, i;
+
+	fin.open(concat(CAL_DIR,CAL_FILE));
+	pthread_mutex_lock(&lock);
+	for (n = 0; n < SPEC_NUM; n++)
+		for (i = 0; i < NumAxis; i++)
+			calibration[sensor_spec[n].id][i] = sensor_spec[n].reset_value;
+
+	if (!fin.good()) {
+		ALOGI("Calibration File is not present! %s", concat(CAL_DIR,CAL_FILE));
+	} else {
+		ALOGI("Calibration File is present!");
+		while (!fin.eof())
+		{
+			fin.getline(buf, MAX_CHARS_PER_LINE);
+
+			token[0] = strtok(buf, DELIMITER);
+			if (token[0]) // zero if line is blank
+			{
+			        for (n = 1; n < MAX_TOKENS_PER_LINE; n++)
+				{
+					token[n] = strtok(0, DELIMITER);
+					if (!token[n]) break;
+				}
+				for (n = 0; n < SPEC_NUM; n++)
+				{
+					if(strcmp(sensor_spec[n].token, token[0]) == 0)
+						break;
+				}
+				if (n == SPEC_NUM)
+					break;
+
+				calibration[sensor_spec[n].id][XAxis] = atof(token[1]);
+				calibration[sensor_spec[n].id][YAxis] = atof(token[2]);
+				calibration[sensor_spec[n].id][ZAxis] = atof(token[3]);
+				ALOGD("Sensor %s = %f	%f	%f",
+					sensor_spec[n].token,
+					calibration[sensor_spec[n].id][XAxis],
+					calibration[sensor_spec[n].id][YAxis],
+					calibration[sensor_spec[n].id][ZAxis]);
+			}
+		}
+		is_changed = true;
+	}
+
+	pthread_mutex_unlock(&lock);
+	fin.close();
+}
+
+float StoreCalibration::getCalibration(int sensorId, int axis)
+{
+	if ((sensorId < NUM_OF_SENSORS) && (axis < NUM_OF_AXIS)) {
+		return calibration[sensorId][axis];
+	} else {
+		ALOGE("Invalid argument to getCalibration");
+		return 0;
+	}
+}
+
+bool StoreCalibration::isChanged()
+{
+	bool temp;
+
+	pthread_mutex_lock(&lock);
+	temp = is_changed;
+	is_changed = false;
+	pthread_mutex_unlock(&lock);
+
+	return temp;
+}
+
+#endif /* STORE_CALIB_ENABLED */
diff --git a/StoreCalibration.h b/StoreCalibration.h
new file mode 100644
index 0000000..3a669ca
--- /dev/null
+++ b/StoreCalibration.h
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef _STORE_CALIBRATION_H
+#define _STORE_CALIBRATION_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+#include <time.h>
+#include <sys/inotify.h>
+#include <pthread.h>
+#include "configuration.h"
+
+#if defined(STORE_CALIB_ENABLED)
+#define concat(first, second)		first second
+#define PACKAGENAME			"com.st.mems.st_gyrocal"
+#define CAL_FILE 			"calibration.txt"
+#define CAL_DIR				"/data/"
+#define OBS_MASK 			(IN_MODIFY | IN_DELETE | IN_CREATE)
+#define NUM_OF_SENSORS			6
+#define NUM_OF_AXIS			3
+#define THD_SLEEP_USEC			3000000
+#define EVENT_SIZE			(sizeof(struct inotify_event))
+#define MAX_CHARS_PER_LINE		512
+#define DELIMITER			" "
+#define MAX_TOKENS_PER_LINE		4
+#define EVENT_BUF_SIZE			512
+
+typedef float calib_out_t[NUM_OF_SENSORS][NUM_OF_AXIS];
+
+typedef struct {
+    uid_t  uid;
+    char   isDebuggable;
+    char   dataDir[PATH_MAX];
+    char   seinfo[PATH_MAX];
+} PackageInfo;
+
+class StoreCalibration {
+private:
+	StoreCalibration();
+	static void* checkChangesThread(void *arg);
+	static void readCalibrationFile();
+	static int eventCheck(int fd);
+
+	static int instanceCount;
+	static StoreCalibration *single;
+	static calib_out_t calibration;
+	static time_t oldMTime;
+	static int observer_fd;
+	static int watch_fd;
+	static int cal_file;
+	pthread_t thread;
+	static bool is_changed;
+
+public:
+	enum {
+		GYROSCOPE_BIAS = 0,
+		GYROSCOPE_SENS,
+		ACCELEROMETER_BIAS,
+		ACCELEROMETER_SENS,
+		MAGNETOMETER_BIAS,
+		MAGNETOMETER_SENS,
+		SPEC_NUM,
+	};
+
+	enum {
+		XAxis = 0,
+		YAxis,
+		ZAxis,
+		NumAxis,
+	};
+
+	static StoreCalibration* getInstance();
+	~StoreCalibration() {
+		instanceCount--;
+		if (instanceCount == 0) {
+			inotify_rm_watch(observer_fd, watch_fd);
+		}
+	}
+	float getCalibration(int sensorId, int axis);
+	bool isChanged();
+};
+#endif /* STORE_CALIB_ENABLED */
+#endif /* _STORE_CALIBRATION_H */
\ No newline at end of file
diff --git a/TapSensor.cpp b/TapSensor.cpp
new file mode 100644
index 0000000..5552aa8
--- /dev/null
+++ b/TapSensor.cpp
@@ -0,0 +1,176 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_TAP_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+
+#include "TapSensor.h"
+
+
+/*****************************************************************************/
+int TapSensor::mEnabled = 0;
+
+TapSensor::TapSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_TAP),
+	mInputReader(4)
+{
+	mPendingEvent.version = sizeof(sensors_event_t);
+	mPendingEvent.sensor = ID_TAP;
+	mPendingEvent.type = SENSOR_TYPE_TAP;
+	mPendingEvent.data[0] = 1.0f;
+
+	if (data_fd) {
+		STLOGI("TapSensor::TapSensor device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("TapSensor::TapSensor device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+TapSensor::~TapSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_TAP_HANDLE, 0, 0);
+	}
+}
+
+int TapSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+	int mEnabledPrev;
+
+	if (flags) {
+		if (!mEnabled) {
+			err = writeEnable(SENSORS_TAP_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+		mEnabled = 1;
+	} else {
+		if (mEnabled){
+			err = writeEnable(SENSORS_TAP_HANDLE, flags);
+			if(err >= 0) {
+				err = 0;
+				mEnabled = 0;
+			}
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("TapSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	} else {
+		STLOGE("TapSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	}
+
+	return err;
+}
+
+int TapSensor::getWhatFromHandle(int32_t __attribute__((unused))handle)
+{
+	return 0;
+}
+
+bool TapSensor::hasPendingEvents() const
+{
+	return false;
+}
+
+int TapSensor::setDelay(int32_t __attribute__((unused))handle,
+					int64_t __attribute__((unused))delay_ns)
+{
+	return 0;
+}
+
+int TapSensor::readEvents(sensors_event_t* data, int count)
+{
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+
+		if (event->type == EVENT_TYPE_TAP) {
+
+#if (DEBUG_TAP == 1)
+	STLOGD("TapSensor::readEvents (event_code=%d)", event->code);
+#endif
+			switch(event->code) {
+			case EVENT_TYPE_TAP_DATA:
+
+				break;
+#if defined(INPUT_EVENT_HAS_TIMESTAMP)
+			case EVENT_TYPE_TIME_MSB:
+				timestamp = ((int64_t)(event->value)) << 32;
+
+				break;
+			case EVENT_TYPE_TIME_LSB:
+				timestamp |= (uint32_t)(event->value);
+
+				break;
+#endif
+			default:
+				STLOGE("TapSensor: unknown event code \
+					(type = %d, code = %d)", event->type,
+								event->code);
+			}
+		} else if (event->type == EV_SYN) {
+
+#if !defined(INPUT_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+			mPendingEvent.timestamp = timestamp;
+			memcpy(data, &mPendingEvent, sizeof(mPendingEvent));
+			data++;
+			count--;
+			numEventReceived++;
+#if (DEBUG_TAP == 1)
+			STLOGD("TapSensor::readEvents (time = %lld), count(%d), received(%d)",
+						mPendingEvent.timestamp,
+						count, numEventReceived);
+#endif
+
+		} else {
+			STLOGE("TapSensor: unknown event (type=%d, code=%d)",
+						event->type, event->code);
+		}
+no_data:
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_TAP_ENABLE */
diff --git a/TapSensor.h b/TapSensor.h
new file mode 100644
index 0000000..5cf3445
--- /dev/null
+++ b/TapSensor.h
@@ -0,0 +1,61 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_TAP_ENABLE == 1)
+
+#ifndef ANDROID_TAP_SENSOR_H
+#define ANDROID_TAP_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+struct input_event;
+
+class TapSensor : public SensorBase
+{
+	static int mEnabled;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+
+private:
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+	int32_t steps;
+
+public:
+	TapSensor();
+	virtual ~TapSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int getWhatFromHandle(int32_t handle);
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+};
+
+#endif  // ANDROID_TAP_SENSOR_H
+
+#endif
diff --git a/TempSensor.cpp b/TempSensor.cpp
new file mode 100644
index 0000000..e60be71
--- /dev/null
+++ b/TempSensor.cpp
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+
+/* Standalone Temperature sensor */
+#if (SENSORS_TEMP_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <string.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+
+#include "TempSensor.h"
+
+int TempSensor::current_fullscale = 0;
+int unsigned TempSensor::mEnabled = 0;
+
+TempSensor::TempSensor() :
+	SensorBase(NULL, SENSOR_DATANAME_TERMOMETER),
+	mPendingMask(0),
+	mInputReader(4),
+	mHasPendingEvent(false)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+
+	mPendingEvents[Temperature].version = sizeof(sensors_event_t);
+	mPendingEvents[Temperature].sensor = ID_TEMPERATURE;
+	mPendingEvents[Temperature].type = SENSOR_TYPE_TEMPERATURE;
+
+	if (data_fd) {
+		STLOGI("TempSensor::TempSensor temp_device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("TempSensor::TempSensor temp_device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+TempSensor::~TempSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_TEMPERATURE_HANDLE, 0, 0);
+	}
+}
+
+int TempSensor::setInitialState()
+{
+	struct input_absinfo absinfo_temperature;
+	float value;
+
+	if (!ioctl(data_fd, EVIOCGABS(EVENT_TYPE_TEMPERATURE), &absinfo_temperature))
+	{
+		value = absinfo_temperature.value;
+		mPendingEvents[Temperature].temperature = TEMPERATURE_OFFSET + value * CONVERT_TEMP;
+		mHasPendingEvent = true;
+	}
+
+	return 0;
+}
+
+int TempSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+		case SENSORS_TEMPERATURE_HANDLE:
+			what = Temperature;
+			break;
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int TempSensor::writeSensorDelay(int handle)
+{
+	int err = writeDelay(handle, delayms);
+
+	return err >= 0 ? 0 : err;
+}
+
+int TempSensor::enable(int32_t handle, int en, int type __attribute__((unused)))
+{
+	int err = 0;
+	int what = -1;
+	static int enabled = 0;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if(en) {
+		err = writeSensorDelay(handle);
+		if (err < 0)
+			return err;
+
+		if(mEnabled == 0) {
+			enabled = 1;
+			err = writeEnable(SENSORS_TEMPERATURE_HANDLE, 1);
+		}
+		if(err >= 0) {
+			mEnabled |= (1<<what);
+			err = 0;
+			enabled = 0;
+		}
+	} else {
+		int tmp = mEnabled;
+		mEnabled &= ~(1<<what);
+		if((mEnabled == 0) && (tmp != 0))
+			err = writeEnable(SENSORS_TEMPERATURE_HANDLE, 0);
+
+		if(err < 0)
+			mEnabled |= (1<<what);
+		else
+			err = 0;
+	}
+
+	if(enabled == 1)
+		setInitialState();
+
+	return err;
+}
+
+int TempSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err = -1, what;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+
+	if (delay_ms == 0)
+		return err;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	delayms = delay_ms;
+
+	if (mEnabled & (1 << what))
+		err = writeSensorDelay(handle);
+
+	return err;
+}
+
+int TempSensor::setFullScale(int32_t __attribute__((unused))handle, int value)
+{
+	int err = -1;
+
+	if(value <= 0)
+		return err;
+	else
+		err = 0;
+
+	if(value != current_fullscale)
+	{
+		err = writeFullScale(SENSORS_TEMPERATURE_HANDLE, value);
+		if(err >= 0) {
+			err = 0;
+			current_fullscale = value;
+		}
+	}
+	return err;
+}
+
+int TempSensor::readEvents(sensors_event_t* data, int count)
+{
+	static float lastTempValue = 0.0f;
+#if defined(TEMP_EVENT_HAS_TIMESTAMP)
+	int64_t timestamp;
+#endif
+
+#if DEBUG_TEMPERATURE_SENSOR == 1
+	STLOGD("TempSensor::readEvents (count=%d)",count);
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	int numEventReceived = 0;
+	input_event const* event;
+
+	while (count && mInputReader.readEvent(&event)) {
+#if DEBUG_TEMPERATURE_SENSOR == 1
+		STLOGD("TempSensor::readEvents (count=%d),type(%d)", count, event->type);
+#endif
+
+		if (event->type == EV_MSC) {
+			int value = event->value;
+
+			if (event->code == EVENT_TYPE_TEMPERATURE) {
+				lastTempValue = value;
+				mPendingEvents[Temperature].temperature = TEMPERATURE_OFFSET + value * CONVERT_TEMP;
+			}
+#if defined(TEMP_EVENT_HAS_TIMESTAMP)
+			else if (event->code == EVENT_TYPE_TIME_MSB) {
+				timestamp = ((int64_t)(event->value)) << 32;
+			}
+			else if (event->code == EVENT_TYPE_TIME_LSB) {
+				timestamp |= (uint32_t)(event->value);
+			}
+#endif
+		} else if (event->type == EV_SYN) {
+			if(mEnabled & (1 << Temperature))
+				mPendingMask |= 1 << Temperature;
+
+#if !defined(TEMP_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+			for (int j = 0; count && mPendingMask && (j < numSensors); j++) {
+				if (mPendingMask & (1 << j)) {
+					mPendingMask &= ~(1 << j);
+					mPendingEvents[j].timestamp = timestamp;
+					if (mEnabled & (1 << j)) {
+						*data++ = mPendingEvents[j];
+						count--;
+						numEventReceived++;
+					}
+				}
+			}
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_TEMP_ENABLE */
diff --git a/TempSensor.h b/TempSensor.h
new file mode 100644
index 0000000..1b84828
--- /dev/null
+++ b/TempSensor.h
@@ -0,0 +1,70 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_TEMP_ENABLE == 1)
+
+#ifndef ANDROID_TEMP_SENSOR_H
+#define ANDROID_TEMP_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+class TempSensor : public SensorBase {
+private:
+	enum {
+		Temperature,
+		numSensors
+	};
+	static unsigned int mEnabled;
+	static int current_fullscale;
+	uint32_t mPendingMask;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[numSensors];
+	bool mHasPendingEvent;
+
+	int setInitialState();
+
+	enum channelid{
+		tempChan = 0
+	};
+	int64_t delayms;
+	int64_t timestamp;
+
+	//char device_sysfs_path_prs[PATH_MAX];
+	//int device_sysfs_path_prs_len;
+	int writeSensorDelay(int handle);
+public:
+	TempSensor();
+	virtual ~TempSensor();
+	virtual int readEvents(sensors_event_t* data, int count);
+	virtual bool hasPendingEvents() const { return mHasPendingEvent; }
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_TEMP_SENSOR_H
+#endif /* SENSORS_TEMP_ENABLE */
diff --git a/TiltSensor.cpp b/TiltSensor.cpp
new file mode 100644
index 0000000..d4e6075
--- /dev/null
+++ b/TiltSensor.cpp
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+#include "TiltSensor.h"
+
+
+/*****************************************************************************/
+int TiltSensor::mEnabled = 0;
+
+TiltSensor::TiltSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_TILT),
+	mInputReader(4)
+{
+	mPendingEvent.version = sizeof(sensors_event_t);
+	mPendingEvent.sensor = ID_TILT_DETECTOR;
+	mPendingEvent.type = SENSOR_TYPE_TILT_DETECTOR;
+	mPendingEvent.data[0] = 1.0f;
+
+	if (data_fd) {
+		STLOGI("TiltSensor::TiltSensor device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("TiltSensor::TiltSensor device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+}
+
+TiltSensor::~TiltSensor()
+{
+	if (mEnabled)
+		enable(SENSORS_TILT_DETECTOR_HANDLE, 0, 0);
+}
+
+int TiltSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+
+	if (flags) {
+		if (!mEnabled) {
+			err = writeEnable(SENSORS_TILT_DETECTOR_HANDLE, flags);
+			if(err >= 0)
+				err = 0;
+		}
+		mEnabled = 1;
+	} else {
+		if (mEnabled){
+			err = writeEnable(SENSORS_TILT_DETECTOR_HANDLE, flags);
+			if(err >= 0) {
+				err = 0;
+				mEnabled = 0;
+			}
+		}
+	}
+
+	if(err >= 0 ) {
+		STLOGD("TiltSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	} else {
+		STLOGE("TiltSensor::enable(%d), handle: %d, mEnabled: %d",
+						flags, handle, mEnabled);
+	}
+
+	return err;
+}
+
+int TiltSensor::getWhatFromHandle(int32_t __attribute__((unused))handle)
+{
+	return 0;
+}
+
+bool TiltSensor::hasPendingEvents() const
+{
+	return false;
+}
+
+int TiltSensor::setDelay(int32_t __attribute__((unused))handle,
+					int64_t __attribute__((unused))delay_ns)
+{
+	ALOGD("SetDelay not allowed for Tilt sensor");
+
+	return 0;
+}
+
+int TiltSensor::readEvents(sensors_event_t* data, int count)
+{
+	int numEventReceived = 0;
+	input_event const* event;
+
+	if (count < 1)
+		return -EINVAL;
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	while (count && mInputReader.readEvent(&event)) {
+		if (event->type == EVENT_TYPE_TILT) {
+#if (DEBUG_TILT == 1)
+	STLOGD("TiltSensor::readEvents (event_code=%d)", event->code);
+#endif
+			switch(event->code) {
+			case EVENT_TYPE_TILT_DATA:
+				tilt_data = event->value;
+
+				break;
+#if defined(INPUT_EVENT_HAS_TIMESTAMP)
+			case EVENT_TYPE_TIME_MSB:
+				timestamp = ((int64_t)(event->value)) << 32;
+
+				break;
+			case EVENT_TYPE_TIME_LSB:
+				timestamp |= (uint32_t)(event->value);
+
+				break;
+#endif
+			default:
+				STLOGE("TiltSensor: unknown event code (type = %d, code = %d)",
+							event->type, event->code);
+			}
+		} else if (event->type == EV_SYN) {
+#if !defined(INPUT_EVENT_HAS_TIMESTAMP)
+			timestamp = timevalToNano(event->time);
+#endif
+			mPendingEvent.timestamp = timestamp;
+			memcpy(data, &mPendingEvent, sizeof(mPendingEvent));
+			data++;
+			count--;
+			numEventReceived++;
+#if (DEBUG_TILT == 1)
+			STLOGD("TiltSensor::readEvents (time = %lld), count(%d), received(%d)",
+						mPendingEvent.timestamp,
+						count, numEventReceived);
+#endif
+		} else {
+			STLOGE("TiltSensor: unknown event (type=%d, code=%d)",
+						event->type, event->code);
+		}
+		mInputReader.next();
+	}
+
+	return numEventReceived;
+}
+
+#endif /* SENSORS_TILT_ENABLE */
diff --git a/TiltSensor.h b/TiltSensor.h
new file mode 100644
index 0000000..c7209bd
--- /dev/null
+++ b/TiltSensor.h
@@ -0,0 +1,60 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2015 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+
+#ifndef ANDROID_TILT_SENSOR_H
+#define ANDROID_TILT_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+struct input_event;
+
+class TiltSensor : public SensorBase
+{
+	static int mEnabled;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvent;
+
+private:
+	static pthread_mutex_t dataMutex;
+	int64_t timestamp;
+	int32_t tilt_data;
+
+public:
+	TiltSensor();
+	virtual ~TiltSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int getWhatFromHandle(int32_t handle);
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+};
+
+#endif  // ANDROID_TILT_SENSOR_H
+#endif /* ANDROID_VERSION */
diff --git a/VirtualGyroSensor.cpp b/VirtualGyroSensor.cpp
new file mode 100644
index 0000000..0ae9c5d
--- /dev/null
+++ b/VirtualGyroSensor.cpp
@@ -0,0 +1,420 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <string.h>
+
+#include "VirtualGyroSensor.h"
+
+#define DEG_TO_RAD(x)		(x * 3.14f / 180.0f)
+
+/****************************************************************************/
+
+sensors_vec_t  VirtualGyroSensor::dataBuffer;
+int VirtualGyroSensor::mEnabled = 0;
+int64_t VirtualGyroSensor::delayms = 0;
+int VirtualGyroSensor::startup_samples = 0;
+int VirtualGyroSensor::current_fullscale = 0;
+int VirtualGyroSensor::samples_to_discard = 0;
+int64_t VirtualGyroSensor::MagDelay_ms = MAG_DEFAULT_DELAY;
+int64_t VirtualGyroSensor::setDelayBuffer[numSensors] = {0};
+int VirtualGyroSensor::DecimationBuffer[numSensors] = {0};
+int VirtualGyroSensor::DecimationCount = 0;
+pthread_mutex_t VirtualGyroSensor::dataMutex;
+
+VirtualGyroSensor::VirtualGyroSensor()
+	: SensorBase(NULL, SENSOR_DATANAME_MAGNETIC_FIELD),
+	mInputReader(4),
+	mHasPendingEvent(false)
+{
+	pthread_mutex_init(&dataMutex, NULL);
+
+	memset(mPendingEvent, 0, sizeof(mPendingEvent));
+	mPendingEvent[VirtualGyro].version = sizeof(sensors_event_t);
+	mPendingEvent[VirtualGyro].sensor = ID_VIRTUAL_GYROSCOPE;
+	mPendingEvent[VirtualGyro].type = SENSOR_TYPE_GYROSCOPE;
+	mPendingEvent[VirtualGyro].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+	memset(gyro, 0, sizeof(gyro));
+
+	if (data_fd) {
+		STLOGI("VirtualGyroSensor::VirtualGyroSensor main driver"
+			" device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("VirtualGyroSensor::VirtualGyroSensor main driver"
+			" device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+
+	/* GeoMag library execution here only if GeoMag sensors are disabled */
+	mag = new MagnSensor();
+	acc = new AccelSensor();
+#if (SENSOR_GEOMAG_ENABLE == 0)
+	iNemoEngine_GeoMag_API_Initialization(100);
+#endif
+}
+
+VirtualGyroSensor::~VirtualGyroSensor()
+{
+	if (mEnabled) {
+		enable(SENSORS_VIRTUAL_GYROSCOPE_HANDLE, 0, 0);
+	}
+	pthread_mutex_destroy(&dataMutex);
+	acc->~SensorBase();
+	mag->~SensorBase();
+}
+
+int VirtualGyroSensor::setInitialState()
+{
+	mHasPendingEvent = true;
+	setFullScale(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+		     VIRTUAL_GYRO_DEFAULT_FULLSCALE);
+	startup_samples = samples_to_discard;
+
+	return 0;
+}
+
+int VirtualGyroSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+		case SENSORS_VIRTUAL_GYROSCOPE_HANDLE:
+			what = VirtualGyro;
+			break;
+			#if SENSOR_FUSION_ENABLE == 1
+		case SENSORS_SENSOR_FUSION_HANDLE:
+			what = iNemoGyro;
+			break;
+			#endif
+		default:
+			what = -1;
+	}
+
+	return what;
+}
+
+int VirtualGyroSensor::enable(int32_t handle, int en, int type)
+{
+	int err = 0;
+	int flags = en ? 1 : 0;
+	int what = -1;
+	int mEnabledPrev;
+
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	if (VirtualGyroSensor::acc->getFd() <= 0)
+		return -1;
+#endif
+
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	if (VirtualGyroSensor::mag->getFd() <= 0)
+		return -1;
+#endif
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (flags) {
+		if (!mEnabled) {
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+ 			mag->enable(SENSORS_VIRTUAL_GYROSCOPE_HANDLE, flags, 1);
+ 			mag->setFullScale(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+ 							MAG_DEFAULT_RANGE);
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+ 			acc->enable(SENSORS_VIRTUAL_GYROSCOPE_HANDLE, flags, 1);
+ 			acc->setFullScale(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+ 							ACC_DEFAULT_RANGE);
+			setInitialState();
+#endif
+		}
+		mEnabled |= (1 << what);
+	} else {
+
+		mEnabledPrev = mEnabled;
+		mEnabled &= ~(1 << what);
+		if (!mEnabled && mEnabledPrev) {
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+  			mag->setFullScale(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+  							MAG_DEFAULT_RANGE);
+ 			mag->enable(SENSORS_VIRTUAL_GYROSCOPE_HANDLE, flags, 1);
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+  			acc->setFullScale(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+  							ACC_DEFAULT_RANGE);
+ 			acc->enable(SENSORS_VIRTUAL_GYROSCOPE_HANDLE, flags, 1);
+#endif
+		}
+		setDelay(handle, DELAY_OFF);
+	}
+
+	if(err >= 0 ) {
+		STLOGD("VirtualGyroSensor::enable(%d), handle: %d, what: %d,"
+				" mEnabled: %x",flags, handle, what, mEnabled);
+	} else {
+		STLOGE("VirtualGyroSensor::enable(%d), handle: %d, what: %d,"
+				" mEnabled: %x",flags, handle, what, mEnabled);
+	}
+
+	return err;
+}
+
+bool VirtualGyroSensor::hasPendingEvents() const
+{
+	return mHasPendingEvent;
+}
+
+int VirtualGyroSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int what = -1, err;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+	int64_t Min_delay_ms = 0;
+
+	if(delay_ms == 0)
+		return -1;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	/**
+	 * The handled sensor is disabled. Set 0 in its setDelayBuffer position
+	 * and update decimation buffer.
+	 */
+	if (delay_ms == NSEC_TO_MSEC(DELAY_OFF))
+	{
+		delay_ms = 0;
+		Min_delay_ms = 0;
+	}
+	else {
+		if (delay_ms < VGYRO_DEFAULT_DELAY)
+			Min_delay_ms = delay_ms;
+		else
+			Min_delay_ms = VGYRO_DEFAULT_DELAY;
+	}
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	err = mag->setDelay(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+			    (int64_t)MSEC_TO_NSEC(Min_delay_ms));
+	if(err < 0)
+		return -1;
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	err = acc->setDelay(SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+			    (int64_t)MSEC_TO_NSEC(Min_delay_ms));
+	if(err < 0)
+		return -1;
+#endif
+
+	/** Min setDelay Definition */
+	setDelayBuffer[what] = delay_ms;
+	updateDecimations(MagDelay_ms);
+
+	return 0;
+}
+
+void VirtualGyroSensor::updateDecimations(int64_t delayms)
+{
+	int kk;
+
+	if (delayms) {
+		samples_to_discard = (int)(GYRO_STARTUP_TIME_MS/delayms)+1;
+		startup_samples = samples_to_discard;
+	}
+
+	/** Decimation Definition */
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (delayms)
+			DecimationBuffer[kk] = setDelayBuffer[kk] / delayms;
+		else
+			DecimationBuffer[kk] = 0;
+	}
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("VirtualGyroSensor::setDelayBuffer[] = %lld, %lld, %lld",
+			setDelayBuffer[0], setDelayBuffer[1], setDelayBuffer[2]);
+	STLOGD("VirtualGyroSensor::delayms = %lld, "
+			"mEnabled = %d", delayms, mEnabled);
+	STLOGD("VirtualGyroSensor::samples_to_discard = %d",
+			samples_to_discard);
+	STLOGD("VirtualGyroSensor::DecimationBuffer = %d, %d, %d",
+	       DecimationBuffer[0], DecimationBuffer[1], DecimationBuffer[2]);
+#endif
+
+}
+
+
+void VirtualGyroSensor::getGyroDelay(int64_t *Gyro_Delay_ms)
+{
+	*Gyro_Delay_ms = delayms;
+}
+
+
+int VirtualGyroSensor::setFullScale(int32_t handle, int value)
+{
+	if(value <= 0)
+		return -1;
+
+	if(value != current_fullscale)
+	{
+		/** The full scale value is not used right now. */
+		current_fullscale = value;
+	}
+
+	return 0;
+}
+
+int VirtualGyroSensor::readEvents(sensors_event_t* data, int count)
+{
+	int numEventReceived = 0, deltatime = 0;
+	input_event const* event;
+	iNemoGeoMagSensorsData sdata;
+	static int64_t pre_time = -1;
+	int64_t cur_time = 0;
+	float tmp[3];
+	int64_t newMagDelay_ms = MAG_DEFAULT_DELAY;
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+	while (count && mInputReader.readEvent(&event)) {
+		if (event->type == EV_SYN) {
+			if (startup_samples) {
+				startup_samples--;
+
+#if (DEBUG_VIRTUAL_GYROSCOPE == 1)
+				STLOGD("VirtualGyroSensor::Start-up samples = %d",
+				       startup_samples);
+#endif
+				goto no_data;
+			}
+
+
+			VirtualGyroSensor::mag->getMagDelay(&newMagDelay_ms);
+			if((newMagDelay_ms != MagDelay_ms) && mEnabled) {
+				updateDecimations(newMagDelay_ms);
+				MagDelay_ms = newMagDelay_ms;
+			}
+
+
+#if (SENSOR_GEOMAG_ENABLE == 0)
+			/* GeoMag library execution here only if GeoMag sensors are disabled */
+			AccelSensor::getBufferData(&mSensorsBufferedVectors[Acceleration]);
+			MagnSensor::getBufferData(&mSensorsBufferedVectors[MagneticField]);
+
+			/** Copy accelerometer data [m/s^2] */
+			memcpy(sdata.accel, mSensorsBufferedVectors[Acceleration].v, sizeof(float) * 3);
+
+			/** Copy magnetometer data [uT] */
+			memcpy(sdata.magn, mSensorsBufferedVectors[MagneticField].v, sizeof(float) * 3);
+
+			cur_time = timevalToNano(event->time);
+			if (pre_time > 0)
+				deltatime = (int)NSEC_TO_MSEC(cur_time - pre_time);
+			pre_time = cur_time;
+			deltatime = (deltatime == 0) ? mag->getDelayms() : deltatime;
+
+			iNemoEngine_GeoMag_API_Run(deltatime, &sdata);
+#endif
+			iNemoEngine_GeoMag_API_Get_VirtualGyro(gyro);
+
+			DecimationCount++;
+
+			if(mEnabled & (1<<VirtualGyro) && (DecimationCount
+				>= DecimationBuffer[VirtualGyro])) {
+				/** Downsample VirtualGyro output */
+				DecimationCount = 0;
+				mPendingEvent[VirtualGyro].data[0] = gyro[0];
+				mPendingEvent[VirtualGyro].data[1] = gyro[1];
+				mPendingEvent[VirtualGyro].data[2] = gyro[2];
+				mPendingEvent[VirtualGyro].timestamp =
+						timevalToNano(event->time);
+				mPendingEvent[VirtualGyro].gyro.status =
+						SENSOR_STATUS_ACCURACY_HIGH;
+
+				*data++ = mPendingEvent[VirtualGyro];
+				count--;
+				numEventReceived++;
+			}
+
+			if(mEnabled & (1 << iNemoGyro)) {
+				/** Save axis data for iNemo library */
+				sensors_vec_t sData;
+				sData.x = gyro[0];
+				sData.y = gyro[1];
+				sData.z = gyro[2];
+				setBufferData(&sData);
+			}
+
+#if (DEBUG_VIRTUAL_GYROSCOPE == 1)
+			STLOGD("VirtualGyroSensor::readEvents (time = %lld),"
+			" count(%d), received(%d)",
+				mPendingEvent[VirtualGyro].timestamp, count,
+				numEventReceived);
+#endif
+		}
+no_data:
+		mInputReader.next();
+	}
+	return numEventReceived;
+}
+
+bool VirtualGyroSensor::setBufferData(sensors_vec_t *value)
+{
+	pthread_mutex_lock(&dataMutex);
+	dataBuffer.x = value->x;
+	dataBuffer.y = value->y;
+	dataBuffer.z = value->z;
+	pthread_mutex_unlock(&dataMutex);
+
+	return true;
+}
+
+bool VirtualGyroSensor::getBufferData(sensors_vec_t *lastBufferedValues)
+{
+	pthread_mutex_lock(&dataMutex);
+	lastBufferedValues->x = dataBuffer.x;
+	lastBufferedValues->y = dataBuffer.y;
+	lastBufferedValues->z = dataBuffer.z;
+	pthread_mutex_unlock(&dataMutex);
+#if (DEBUG_VIRTUAL_GYROSCOPE == 1)
+	STLOGD("VirtualGyroSensor: getBufferData got values: x:(%f),"
+		"y:(%f), z:(%f).", lastBufferedValues->x,
+		lastBufferedValues->y, lastBufferedValues->z);
+#endif
+	return true;
+}
+
+#endif /* SENSORS_GYROSCOPE_ENABLE */
diff --git a/VirtualGyroSensor.h b/VirtualGyroSensor.h
new file mode 100644
index 0000000..96fc51f
--- /dev/null
+++ b/VirtualGyroSensor.h
@@ -0,0 +1,95 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+
+#ifndef ANDROID_VIRTUAL_GYRO_SENSOR_H
+#define ANDROID_VIRTUAL_GYRO_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+#include "MagnSensor.h"
+#include "AccelSensor.h"
+
+extern "C"
+{
+	#include "iNemoEngineGeoMagAPI.h"
+};
+
+/*****************************************************************************/
+
+struct input_event;
+
+class VirtualGyroSensor : public SensorBase
+{
+	enum {
+		Acceleration = 0,
+		MagneticField,
+		VirtualGyro,
+		iNemoGyro,
+		numSensors
+	};
+	static int mEnabled;
+	static int64_t delayms;
+	static int current_fullscale;
+	sensors_event_t mPendingEvent[numSensors];
+	int setInitialState();
+	InputEventCircularReader mInputReader;
+	bool mHasPendingEvent;
+	sensors_vec_t mSensorsBufferedVectors[2];
+
+private:
+	static int startup_samples;
+	static int samples_to_discard;
+	static sensors_vec_t dataBuffer;
+	static int64_t MagDelay_ms;
+	static int64_t setDelayBuffer[numSensors];
+	static int DecimationBuffer[numSensors];
+	static int DecimationCount;
+	virtual bool setBufferData(sensors_vec_t *value);
+
+	float gyro[3];
+	MagnSensor *mag;
+	AccelSensor *acc;
+	static pthread_mutex_t dataMutex;
+
+public:
+	VirtualGyroSensor();
+	virtual ~VirtualGyroSensor();
+	virtual int readEvents(sensors_event_t *data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual void updateDecimations(int64_t Delay_ms);
+	virtual int setFullScale(int32_t handle, int value);
+	virtual int enable(int32_t handle, int enabled, int type);
+	static bool getBufferData(sensors_vec_t *lastBufferedValues);
+	static void getGyroDelay(int64_t *Gyro_Delay_ms);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_VIRTUAL_GYRO_SENSOR_H
+
+#endif /* SENSORS_GYROSCOPE_ENABLE */
diff --git a/conf/conf_A3G4250D.h b/conf/conf_A3G4250D.h
new file mode 100644
index 0000000..a89796f
--- /dev/null
+++ b/conf/conf_A3G4250D.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_A3G4250D_H
+#define CONFIGURATION_A3G4250D_H
+
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"A3G4250D 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_GYRO_LABEL	"A3G4250D 3-axis Uncalibrated Gyroscope sensor"
+#define SENSOR_DATANAME_GYROSCOPE	"a3g4250d_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(245.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			200					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		245					// Set default full-scale (value depends on the driver sysfs file)
+
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		245					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define GYROSCOPE_ACTIVE		1					// Enable Gyroscope sensor in Sensor Fusion -> [0]:off, [1]:on
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO		EV_MSC
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of gyro data to SI units (radian/sec)
+#define CONVERT_GYRO			((8.75f*((float)M_PI)) / 180000.0f)
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_A3G4250D_H	*/
diff --git a/conf/conf_ACCELCALIB.h b/conf/conf_ACCELCALIB.h
new file mode 100644
index 0000000..e676d2b
--- /dev/null
+++ b/conf/conf_ACCELCALIB.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Armando Visconti - Motion MEMS Product Div.
+ * Copyright (C) 2017 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_ACCELCAL_H
+#define CONFIGURATION_ACCELCAL_H
+
+#define ACCEL_CALIBRATION_ENABLE	(1 & ST_ACCEL_CALIB_MODULE_PRESENT & SENSORS_ACCELEROMETER_ENABLE)
+#define ACCEL_CALIB_FREQUENCY		(25)
+#define ACCEL_CALIB_PERIOD_MS		(1000.0f / ACCEL_CALIB_FREQUENCY)
+
+#endif /* CONFIGURATION_ACCELCAL_H */
+
diff --git a/conf/conf_ACT_RECO.h b/conf/conf_ACT_RECO.h
new file mode 100644
index 0000000..932f3d4
--- /dev/null
+++ b/conf/conf_ACT_RECO.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_ACTIVITY_RECO_H
+#define CONFIGURATION_ACTIVITY_RECO_H
+
+#define SENSORS_ACTIVITY_RECOGNIZER_ENABLE	(1 && ACTIVITY_RECOGNIZER_MODULE_PRESENT && SENSORS_ACCELEROMETER_ENABLE)
+#define SENSORS_ACTIVITY_RECOGNIZER_POWER	ACCEL_POWER_CONSUMPTION
+#define SENSOR_ACTIVITY_RECOGNIZERO_LABEL	"Activity Recognition"
+#define SENSOR_STRING_TYPE_ACTIVITY		"com.st.activity"
+#define ACTIVITY_RECOGNIZER_ODR			16
+
+#endif
\ No newline at end of file
diff --git a/conf/conf_AIS328DQ.h b/conf/conf_AIS328DQ.h
new file mode 100644
index 0000000..1724012
--- /dev/null
+++ b/conf/conf_AIS328DQ.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_AIS328DQ_H
+#define CONFIGURATION_AIS328DQ_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"AIS328DQ 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"ais328dq_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			8*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			200				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_AIS328DQ_H	*/
diff --git a/conf/conf_ASM330LHH.h b/conf/conf_ASM330LHH.h
new file mode 100644
index 0000000..a41b2d7
--- /dev/null
+++ b/conf/conf_ASM330LHH.h
@@ -0,0 +1,183 @@
+/*
+ * Copyright (C) 2017 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_ASM330LHH_H
+#define CONFIGURATION_ASM330LHH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_TEMP_ENABLE			(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"ASM330LHH 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST ASM330LHH Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				400					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL			"ASM330LHH 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE		"ST ASM330LHH Gyroscope Sensor"		// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME			"gyro/polling_rate"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME			"gyro/enable"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME			"gyro/scale"				// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE				(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR				400					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION			4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE			2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)				(x / 1000000.0f)
+
+#define SENSOR_TEMP_LABEL			"ASM330LHH Temperature sensor"		// Label views in Android Applications
+#define SENSOR_DATANAME_TERMOMETER		"ST ASM330LHH Temperature Sensor"	// Name of input device: struct input_dev->name
+#define TEMP_DELAY_FILE_NAME			"temp/polling_rate"			// name of sysfs file for setting the pollrate
+#define TEMP_ENABLE_FILE_NAME			"temp/enable"				// name of sysfs file for enable/disable the sensor state
+#define TEMP_MAX_RANGE				80					// Set Max Full-scale [Celsius]
+#define TEMPERATURE_OFFSET			25
+#define TEMP_MAX_ODR				52					// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR				52					// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION			0.6f					// Set sensor's power consumption [mA]
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE			2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE			4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY			10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD			475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD		(0)
+#define GYRO_STARTUP_TIME_MS			(0)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_GYRO				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X			MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y			MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z			MSC_GESTURE
+
+/* Event Type in temperature sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_TEMPERATURE			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD					((float)M_PI/180.0f)
+#define G_SENSITIVITY				(1.0f) //Already applied into the driver
+#define CONVERT_GYRO				(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X				(CONVERT_GYRO)
+#define CONVERT_GYRO_Y				(CONVERT_GYRO)
+#define CONVERT_GYRO_Z				(CONVERT_GYRO)
+
+// conversion of temperature data to SI units
+#define CONVERT_TEMP				(1.0f/256.0f)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define TEMP_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_ASM330LHH_H	*/
diff --git a/conf/conf_ASM330LXH.h b/conf/conf_ASM330LXH.h
new file mode 100644
index 0000000..769bb9f
--- /dev/null
+++ b/conf/conf_ASM330LXH.h
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2012 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_ASM330LXH_H
+#define CONFIGURATION_ASM330LXH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"ASM330LXH 3-axis Accelerometer"		// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"asm330lxh_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/accelerometer/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/accelerometer/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/accelerometer/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16 * GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			800					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR			12
+#define ACCEL_POWER_CONSUMPTION		0.6f						// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4						// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"ASM330LXH 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE	"asm330lxh_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/gyroscope/pollrate_ms"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/gyroscope/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/gyroscope/range"			// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			800					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR			12
+#define GYRO_POWER_CONSUMPTION		4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)			(x / 1000000.0f)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define ACCELEROMETER_ACTIVE		1					// Enable Accelerometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define GYROSCOPE_ACTIVE		1					// Enable Gyroscope sensor in Sensor Fusion -> [0]:off, [1]:on
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL	EV_MSC
+#define EVENT_TYPE_GYRO		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X	MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y	MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z	MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X	MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y	MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z	MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB	MSC_SCAN
+#define EVENT_TYPE_TIME_LSB	MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, 1, 0 },
+				{ 1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 0, 1, 0 },
+				{ 1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000.0f)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD				((float)M_PI/180.0f)
+#define G_SENSITIVITY			(1.0f) //Already applied into the driver
+#define CONVERT_GYRO			(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP▸       ▸       1
+#define ACC_EVENT_HAS_TIMESTAMP▸▸       ▸       1
+
+#endif	/*	CONFIGURATION_ASM330LXH_H	*/
diff --git a/conf/conf_FILE_CALIB.h b/conf/conf_FILE_CALIB.h
new file mode 100644
index 0000000..92154b0
--- /dev/null
+++ b/conf/conf_FILE_CALIB.h
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_FILE_CALIB_H
+#define CONFIGURATION_FILE_CALIB_H
+
+#define STORE_CALIB_ACCEL_ENABLED		1
+#define STORE_CALIB_GYRO_ENABLED		1
+#define STORE_CALIB_ENABLED			STORE_CALIB_GYRO_ENABLED
+#endif
diff --git a/conf/conf_FUSION.h b/conf/conf_FUSION.h
new file mode 100644
index 0000000..a45e702
--- /dev/null
+++ b/conf/conf_FUSION.h
@@ -0,0 +1,57 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_FUSION_H
+#define CONFIGURATION_FUSION_H
+
+#define REAL_9AXIS_AVAILABLE			(SENSORS_ACCELEROMETER_ENABLE && SENSORS_MAGNETIC_FIELD_ENABLE && SENSORS_GYROSCOPE_ENABLE)
+#define REAL_6AXIS_AVAILABLE			(SENSORS_ACCELEROMETER_ENABLE && SENSORS_GYROSCOPE_ENABLE && !SENSORS_MAGNETIC_FIELD_ENABLE)
+#define VIRTUAL_9AXIS_AVAILABLE			(SENSORS_ACCELEROMETER_ENABLE && SENSORS_MAGNETIC_FIELD_ENABLE && SENSORS_VIRTUAL_GYROSCOPE_ENABLE)
+#define SENSORS_ORIENTATION_ENABLE		(1 && (REAL_9AXIS_AVAILABLE || VIRTUAL_9AXIS_AVAILABLE) && SENSOR_FUSION_MODULE_PRESENT)
+#define SENSORS_GRAVITY_ENABLE			(1 && (REAL_9AXIS_AVAILABLE || VIRTUAL_9AXIS_AVAILABLE || REAL_6AXIS_AVAILABLE) && SENSOR_FUSION_MODULE_PRESENT)
+#define SENSORS_LINEAR_ACCELERATION_ENABLE	(1 && (REAL_9AXIS_AVAILABLE || VIRTUAL_9AXIS_AVAILABLE  || REAL_6AXIS_AVAILABLE) && SENSOR_FUSION_MODULE_PRESENT)
+#define SENSORS_ROTATION_VECTOR_ENABLE		(1 && (REAL_9AXIS_AVAILABLE || VIRTUAL_9AXIS_AVAILABLE) && SENSOR_FUSION_MODULE_PRESENT)
+#define SENSORS_GAME_ROTATION_ENABLE		(1 && SENSORS_ACCELEROMETER_ENABLE && (SENSORS_GYROSCOPE_ENABLE || SENSORS_VIRTUAL_GYROSCOPE_ENABLE) && OS_VERSION_ENABLE && SENSOR_FUSION_MODULE_PRESENT)
+#define SENSOR_FUSION_ENABLE			(SENSOR_FUSION_MODULE_PRESENT && (SENSORS_ORIENTATION_ENABLE || SENSORS_GRAVITY_ENABLE || SENSORS_LINEAR_ACCELERATION_ENABLE || SENSORS_ROTATION_VECTOR_ENABLE || SENSORS_GAME_ROTATION_ENABLE))
+#define FUSION_6AXIS				(SENSORS_GYROSCOPE_ENABLE && SENSORS_ACCELEROMETER_ENABLE)
+#define FUSION_9AXIS				(FUSION_6AXIS && SENSORS_MAGNETIC_FIELD_ENABLE)
+
+#if (FUSION_6AXIS && !FUSION_9AXIS)
+  #define FUSION_CONSUMPTION 			(GYRO_POWER_CONSUMPTION  + ACCEL_POWER_CONSUMPTION)
+#else
+  #if (FUSION_9AXIS)
+    #define FUSION_CONSUMPTION 			(GYRO_POWER_CONSUMPTION + MAGN_POWER_CONSUMPTION + ACCEL_POWER_CONSUMPTION)
+  #else
+    #define FUSION_CONSUMPTION 			(MAGN_POWER_CONSUMPTION + ACCEL_POWER_CONSUMPTION)
+  #endif
+#endif
+
+#if (SENSORS_ORIENTATION_ENABLE == 1)
+  #define ORIENTATION_POWER_CONSUMPTION 	(FUSION_CONSUMPTION)
+  #define ORIENTATION_MAX_ODR			(100)
+  #define ORIENTATION_MIN_ODR			(1)
+#endif
+
+#define GRAVITY_POWER_CONSUMPTION 		(FUSION_CONSUMPTION)
+#define LINEAR_ACCEL_POWER_CONSUMPTION 		(FUSION_CONSUMPTION)
+#define ROT_VEC_POWER_CONSUMPTION 		(FUSION_CONSUMPTION)
+#define FUSION_MAX_ODR				(100)
+#define FUSION_MIN_ODR				(1)
+
+#endif /* CONFIGURATION_FUSION_H */
diff --git a/conf/conf_GBIAS.h b/conf/conf_GBIAS.h
new file mode 100644
index 0000000..fd2851b
--- /dev/null
+++ b/conf/conf_GBIAS.h
@@ -0,0 +1,29 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_GBIAS_H
+#define CONFIGURATION_GBIAS_H
+
+#define GYROSCOPE_GBIAS_CALIBRATION (1 & GYROSCOPE_GBIAS_MODULE_PRESENT & SENSORS_GYROSCOPE_ENABLE)
+
+/* GYROSCOPE BIAS ESTIMATION */
+#define GYROSCOPE_GBIAS_ESTIMATION_FUSION (0 & GYROSCOPE_GBIAS_CALIBRATION & SENSOR_FUSION_ENABLE)
+#define GYROSCOPE_GBIAS_ESTIMATION_STANDALONE (1 & GYROSCOPE_GBIAS_CALIBRATION & !GYROSCOPE_GBIAS_ESTIMATION_FUSION)
+
+#endif /* CONFIGURATION_GBIAS_H */
diff --git a/conf/conf_GEOMAG.h b/conf/conf_GEOMAG.h
new file mode 100644
index 0000000..193fca2
--- /dev/null
+++ b/conf/conf_GEOMAG.h
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_GEOMAG_H
+#define CONFIGURATION_GEOMAG_H
+
+#define SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE	(1 & GEOMAG_FUSION_MODULE_PRESENT & SENSORS_MAGNETIC_FIELD_ENABLE && SENSORS_ACCELEROMETER_ENABLE && OS_VERSION_ENABLE)
+#define GEOMAG_COMPASS_ORIENTATION_ENABLE	(0 & GEOMAG_FUSION_MODULE_PRESENT & SENSORS_MAGNETIC_FIELD_ENABLE & SENSORS_ACCELEROMETER_ENABLE)
+#define GEOMAG_LINEAR_ACCELERATION_ENABLE	(0 & GEOMAG_FUSION_MODULE_PRESENT & SENSORS_MAGNETIC_FIELD_ENABLE & SENSORS_ACCELEROMETER_ENABLE)
+#define GEOMAG_GRAVITY_ENABLE				(0 & GEOMAG_FUSION_MODULE_PRESENT & SENSORS_MAGNETIC_FIELD_ENABLE & SENSORS_ACCELEROMETER_ENABLE)
+#define SENSOR_GEOMAG_ENABLE				(SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE || GEOMAG_COMPASS_ORIENTATION_ENABLE || GEOMAG_LINEAR_ACCELERATION_ENABLE || GEOMAG_GRAVITY_ENABLE)
+
+#define GEOMAG_FREQUENCY			(100)
+
+#endif /* CONFIGURATION_GEOMAG_H */
diff --git a/conf/conf_HTS221.h b/conf/conf_HTS221.h
new file mode 100644
index 0000000..c267f10
--- /dev/null
+++ b/conf/conf_HTS221.h
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2016 STMicroelectronics
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com> - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_HTS221_H
+#define CONFIGURATION_HTS221_H
+
+#define SENSORS_HUMIDITY_ENABLE		(0)
+#define SENSORS_TEMP_RH_ENABLE		(1)
+
+#define SENSOR_HUMIDITY_LABEL		"HTS221 Humidity sensor"		// Label views in Android Applications
+#define SENSOR_TEMP_LABEL		"HTS221 Temperature sensor"		// Label views in Android Applications
+#define SENSOR_DATANAME_HUMIDITY	"hts221"				// Name of input device: struct input_dev->name
+#define HUMIDITY_DELAY_FILE_NAME	"device/poll_ms"			// name of sysfs file for setting the pollrate
+#define HUMIDITY_ENABLE_FILE_NAME	"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define HUMIDITY_DELAY_FILE_NAME	"device/poll_ms"			// name of sysfs file for setting the pollrate
+#define HUMIDITY_MAX_RANGE		80					// Set Max Full-scale [Celsius]
+#define TEMP_MAX_RANGE			80					// Set Max Full-scale [Celsius]
+#define HUMIDITY_MAX_ODR		13					// Set Max value of ODR [Hz]
+#define HUMIDITY_MIN_ODR		1					// Set Min value of ODR [Hz]
+#define HUMIDITY_POWER_CONSUMPTION	0.015f					// Set sensor's power consumption [mA]
+#define TEMP_MAX_ODR			HUMIDITY_MAX_ODR			// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR			HUMIDITY_MIN_ODR			// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION		HUMIDITY_POWER_CONSUMPTION		// Set sensor's power consumption [mA]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_HUMIDITY		MSC_PULSELED
+#define EVENT_TYPE_TEMPERATURE		MSC_SERIAL
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+#define CONVERT_RH			(1.0f/1000.0f)
+#define CONVERT_TEMP			(1.0f/1000.0f)
+
+#endif	/* CONFIGURATION_HTS221_H */
diff --git a/conf/conf_IIS2DH.h b/conf/conf_IIS2DH.h
new file mode 100644
index 0000000..2e209e2
--- /dev/null
+++ b/conf/conf_IIS2DH.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2018 STMicroelectronics AMG/MSD Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_IIS2DH_H
+#define CONFIGURATION_IIS2DH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LIS2DH 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lis2dh_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			200				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_IIS2DH_H	*/
diff --git a/conf/conf_IIS2MDC.h b/conf/conf_IIS2MDC.h
new file mode 100644
index 0000000..8c62b87
--- /dev/null
+++ b/conf/conf_IIS2MDC.h
@@ -0,0 +1,111 @@
+/*
+ * Copyright (C) 2018 STMicroelectronics AMG/MSD Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_IIS2MDC_H
+#define CONFIGURATION_IIS2MDC_H
+
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL			"IIS2MDC 3-axis Magnetometer Sensor"
+#define SENSOR_UNCALIB_MAGN_LABEL		"IIS2MDC 3-axis Uncalibrated Magnetometer sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD		"ST IIS2MDC Magnetometer Sensor"
+#define MAGN_DELAY_FILE_NAME			"magn/polling_rate"
+#define MAGN_ENABLE_FILE_NAME			"magn/enable"
+#define MAGN_RANGE_FILE_NAME			"magn/range"
+#define CALIBRATION_ENABLE			1
+#define MAGN_MAX_RANGE				1000.0f
+#define MAGN_MAX_ODR				100
+#define MAGN_MIN_ODR			25
+#define MAGN_POWER_CONSUMPTION			0.077f
+#define MAGN_DEFAULT_FULLSCALE			50
+
+/* INEMO_ENGINE SENSOR */
+#define MAG_DEFAULT_RANGE		8					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define MAG_DEFAULT_DELAY		12					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_MAG				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+#define EVENT_TYPE_MAG_X			MSC_SERIAL
+#define EVENT_TYPE_MAG_Y			MSC_PULSELED
+#define EVENT_TYPE_MAG_Z			MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+#define CONVERT_M				(1.0f/10000.0f)
+#define CONVERT_M_X				(CONVERT_M)
+#define CONVERT_M_Y				(CONVERT_M)
+#define CONVERT_M_Z				(CONVERT_M)
+
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_MAG_INITIAL_STATE		1
+#define MAG_EVENT_HAS_TIMESTAMP			1
+
+#endif	/*	CONFIGURATION_IIS2MDC_H	*/
diff --git a/conf/conf_IIS3DHHC.h b/conf/conf_IIS3DHHC.h
new file mode 100644
index 0000000..70ffe27
--- /dev/null
+++ b/conf/conf_IIS3DHHC.h
@@ -0,0 +1,103 @@
+/*
+ * Copyright (C) 2018 STMicroelectronics AMG/MSD Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_IIS3DHHC_H
+#define CONFIGURATION_IIS3DHHC_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"IIS3DHHC 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"iis3dhhc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			2.5*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			1100				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		2.5				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		0.9				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000.0f)	// 1000000ug = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_IIS3DHHC_H	*/
diff --git a/conf/conf_ISM303DAC.h b/conf/conf_ISM303DAC.h
new file mode 100644
index 0000000..63a0a97
--- /dev/null
+++ b/conf/conf_ISM303DAC.h
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2018 STMicroelectronics AMG/MSD Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_ISM303DAC_H
+#define CONFIGURATION_ISM303DAC_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+#define SENSORS_TILT_ENABLE			(1)
+#define SENSORS_TAP_ENABLE			(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"ISM303DAC 3-axis Accelerometer Sensor"
+#define SENSOR_DATANAME_ACCELEROMETER		"lsm303ah_acc_accel"
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH
+#define ACCEL_MAX_ODR				200
+#define ACCEL_POWER_CONSUMPTION			0.6f
+#define ACCEL_DEFAULT_FULLSCALE			4
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL			"ISM303DAC 3-axis Magnetometer Sensor"
+#define SENSOR_UNCALIB_MAGN_LABEL		"ISM303DAC 3-axis Uncalibrated Magnetometer sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD		"ST ISM303DAC Magnetometer Sensor"
+#define MAGN_DELAY_FILE_NAME			"magn/polling_rate"
+#define MAGN_ENABLE_FILE_NAME			"magn/enable"
+#define MAGN_RANGE_FILE_NAME			"magn/range"
+#define CALIBRATION_ENABLE			1
+#define MAGN_MAX_RANGE				1000.0f
+#define MAGN_MAX_ODR				100
+#define MAGN_MIN_ODR			25
+#define MAGN_POWER_CONSUMPTION			0.077f
+#define MAGN_DEFAULT_FULLSCALE			50
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"ISM303DAC Tilt Detector sensor"
+#define SENSOR_DATANAME_TILT			"lsm303ah_acc_tilt"
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"
+#define TILT_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* STEP TAP SENSOR */
+#define SENSOR_TAP_LABEL			"ISM303DAC Tap Sensor"
+#define SENSOR_DATANAME_TAP			"lsm303ah_acc_tap"
+#define TAP_ENABLE_FILE_NAME			"tap/enable"
+#define TAP_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE			8
+#define ACC_DEFAULT_DELAY			10
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_MAG				EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_STEP_C			EV_MSC
+#define EVENT_TYPE_STEP_D			EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+#define EVENT_TYPE_TAP				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+#define EVENT_TYPE_MAG_X			MSC_SERIAL
+#define EVENT_TYPE_MAG_Y			MSC_PULSELED
+#define EVENT_TYPE_MAG_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_C_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_D_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+#define EVENT_TYPE_TAP_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+#define CONVERT_M				(1.0f/10000.0f)
+#define CONVERT_M_X				(CONVERT_M)
+#define CONVERT_M_Y				(CONVERT_M)
+#define CONVERT_M_Z				(CONVERT_M)
+
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_MAG_INITIAL_STATE		1
+#define MAG_EVENT_HAS_TIMESTAMP			1
+
+#endif	/*	CONFIGURATION_ISM303DAC_H	*/
diff --git a/conf/conf_ISM330DLC.h b/conf/conf_ISM330DLC.h
new file mode 100644
index 0000000..1f8ea40
--- /dev/null
+++ b/conf/conf_ISM330DLC.h
@@ -0,0 +1,178 @@
+/*
+ * Copyright (C) 2018 STMicroelectronics AMG/MSD Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_ISM330DLC_H
+#define CONFIGURATION_ISM330DLC_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+#define SENSORS_UNCALIB_ACCELEROMETER_ENABLE	(1 & SENSORS_ACCELEROMETER_ENABLE & ANDROID_VERSION >= ANDROID_O)
+
+#define SENSORS_TILT_ENABLE			(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"ISM330DLC 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST ISM330DLC Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL			"ISM330DLC 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE		"ST ISM330DLC Gyroscope Sensor"		// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME			"gyro/polling_rate"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME			"gyro/enable"		// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME			"gyro/scale"			// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE				(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION			4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE			2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)				(x / 1000000.0f)
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"ISM330DLC Tilt Detector sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TILT			"ST ISM330DLC Tilt Sensor"		// Name of input device: struct input_dev->name
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"		// name of sysfs file for enable/disable the sensor state
+#define TILT_POWER_CONSUMPTION			0.6f
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE			2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE			4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY			10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD			475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD		(0)
+#define GYRO_STARTUP_TIME_MS			(0)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_GYRO				EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X			MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y			MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD					((float)M_PI/180.0f)
+#define G_SENSITIVITY				(1.0f) //Already applied into the driver
+#define CONVERT_GYRO				(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X				(CONVERT_GYRO)
+#define CONVERT_GYRO_Y				(CONVERT_GYRO)
+#define CONVERT_GYRO_Z				(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+//#define NOT_SET_ACC_INITIAL_STATE		1
+//#define NOT_SET_GYRO_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_ISM330DLC_H	*/
diff --git a/conf/conf_L3GD20.h b/conf/conf_L3GD20.h
new file mode 100644
index 0000000..a1ec588
--- /dev/null
+++ b/conf/conf_L3GD20.h
@@ -0,0 +1,121 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_L3GD20_H
+#define CONFIGURATION_L3GD20_H
+
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"L3GD20 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_GYRO_LABEL	"L3GD20 3-axis Uncalibrated Gyroscope sensor"
+#define SENSOR_DATANAME_GYROSCOPE	"l3gd20_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			200					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define GYROSCOPE_ACTIVE		1					// Enable Gyroscope sensor in Sensor Fusion -> [0]:off, [1]:on
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO		EV_MSC
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of gyro data to SI units (radian/sec)
+#define CONVERT_GYRO			((7.0f*((float)M_PI)) / 18000.0f)
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_L3GD20_H	*/
diff --git a/conf/conf_L3GD20H.h b/conf/conf_L3GD20H.h
new file mode 100644
index 0000000..e4ed819
--- /dev/null
+++ b/conf/conf_L3GD20H.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_SENSOR_L3GD20H_H
+#define CONFIGURATION_SENSOR_L3GD20H_H
+
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+#define SENSOR_GYRO_LABEL		"L3GD20H 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE	"l3gd20h_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			800					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+#define GYR_GBIAS_THRESHOLD		1491e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO			EV_MSC
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of gyro data to SI units (radian/sec)
+#define CONVERT_GYRO			((7.0f*((float)M_PI)) / 18000.0f)
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+
+#endif
diff --git a/conf/conf_LIS2DE12.h b/conf/conf_LIS2DE12.h
new file mode 100644
index 0000000..a0c9c34
--- /dev/null
+++ b/conf/conf_LIS2DE12.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LIS2DE12_H
+#define CONFIGURATION_LIS2DE12_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LIS2DE 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lis2de_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			100				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_LIS2DE12_H	*/
diff --git a/conf/conf_LIS2DH12.h b/conf/conf_LIS2DH12.h
new file mode 100644
index 0000000..469e143
--- /dev/null
+++ b/conf/conf_LIS2DH12.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LIS2DH12_H
+#define CONFIGURATION_LIS2DH12_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LIS2DH 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lis2dh_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			200				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_LIS2DH12_H	*/
diff --git a/conf/conf_LIS2DS12.h b/conf/conf_LIS2DS12.h
new file mode 100644
index 0000000..191990e
--- /dev/null
+++ b/conf/conf_LIS2DS12.h
@@ -0,0 +1,145 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This configuration file is valid for LIS2DS and LIS2DS12 sensors because
+ * share the same driver
+ */
+
+#ifndef CONFIGURATION_LIS2DS12_H
+#define CONFIGURATION_LIS2DS12_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+
+#define SENSORS_TILT_ENABLE			(1)
+#define SENSORS_SIGN_MOTION_ENABLE		(1)
+#define SENSORS_TAP_ENABLE			(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LIS2DS(12) 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST LIS2DS Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/range"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				1					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"LIS2DS(12) Tilt Detector sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TILT			"ST LIS2DS Tilt Sensor"		// Name of input device: struct input_dev->name
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"		// name of sysfs file for enable/disable the sensor state
+#define TILT_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* SIGNIFICANT MOTION SENSOR */
+#define SENSOR_SIGN_M_LABEL			"LIS2DS(12) Significant Motion Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_SIGN_M			"ST LIS2DS Significant Motion Sensor"		// Name of input device: struct input_dev->name
+#define SIGN_M_ENABLE_FILE_NAME			"sign_m/enable"		// name of sysfs file for enable/disable the sensor state
+#define SIGN_M_POWER_CONSUMPTION		ACCEL_POWER_CONSUMPTION
+
+/* STEP TAP SENSOR */
+#define SENSOR_TAP_LABEL			"LIS2DS(12) Tap Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TAP			"ST LIS2DS Step Detector Sensor"		// Name of input device: struct input_dev->name
+#define TAP_ENABLE_FILE_NAME			"tap/enable"		// name of sysfs file for enable/disable the sensor state
+#define TAP_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE			8					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+#define EVENT_TYPE_TAP				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+#define EVENT_TYPE_TAP_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, -1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_ACC_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_LIS2DS12_H	*/
diff --git a/conf/conf_LIS2DW12.h b/conf/conf_LIS2DW12.h
new file mode 100644
index 0000000..2917601
--- /dev/null
+++ b/conf/conf_LIS2DW12.h
@@ -0,0 +1,130 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This configuration file is valid for LIS2DW12 sensors because
+ * share the same driver
+ */
+
+#ifndef CONFIGURATION_LIS2DW12_H
+#define CONFIGURATION_LIS2DW12_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_TAP_ENABLE			(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LIS2DW12 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST LIS2DW12 Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				16 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				100					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				1					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* STEP TAP SENSOR */
+#define SENSOR_TAP_LABEL			"LIS2DW12 Tap Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TAP			"ST LIS2DW12 Tap Sensor"		// Name of input device: struct input_dev->name
+#define TAP_ENABLE_FILE_NAME			"tap/enable"		// name of sysfs file for enable/disable the sensor state
+#define TAP_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE			8					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+#define EVENT_TYPE_TAP				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+#define EVENT_TYPE_TAP_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, -1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_ACC_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_LIS2DW12_H	*/
diff --git a/conf/conf_LIS2HH12.h b/conf/conf_LIS2HH12.h
new file mode 100644
index 0000000..5374980
--- /dev/null
+++ b/conf/conf_LIS2HH12.h
@@ -0,0 +1,123 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ * This configuration file is valid for LIS2HH and LIS2HH sensors because
+ * share the same driver
+ */
+
+#ifndef CONFIGURATION_LIS2HH_H
+#define CONFIGURATION_LIS2HH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LIS2HH12 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"lis2hh12_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"device/pollrate_ms"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"device/enable_device"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"device/range"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				1					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE			8					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+#define EVENT_TYPE_TAP				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+#define EVENT_TYPE_TAP_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, -1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_ACC_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_LIS2HH_H	*/
diff --git a/conf/conf_LIS2MDL.h b/conf/conf_LIS2MDL.h
new file mode 100644
index 0000000..0e46511
--- /dev/null
+++ b/conf/conf_LIS2MDL.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LIS2MDL_H
+#define CONFIGURATION_LIS2MDL_H
+
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LIS2MDL 3-axis Magnetometer Sensor"
+#define SENSOR_UNCALIB_MAGN_LABEL	"LIS2MDL 3-axis Uncalibrated Magnetometer sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"ST LIS2MDL Magnetometer Sensor"
+#define MAGN_DELAY_FILE_NAME		"magn/polling_rate"
+#define MAGN_ENABLE_FILE_NAME		"magn/enable"
+#define MAGN_RANGE_FILE_NAME		"magn/range"
+#define CALIBRATION_ENABLE		1
+#define MAGN_MAX_RANGE			1000.0f
+#define MAGN_MAX_ODR			100
+#define MAGN_MIN_ODR			25
+#define MAGN_POWER_CONSUMPTION		0.077f
+#define MAGN_DEFAULT_FULLSCALE		50
+
+/* INEMO_ENGINE SENSOR */
+#define MAG_DEFAULT_RANGE		8				// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define MAG_DEFAULT_DELAY		12				// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define MAGNETOMETER_ACTIVE		1				// Enable Magnetometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define MAG_GBIAS_THRESHOLD		1200e-6				// Set magnetometer gbias threshold [uT]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_MAG			EV_MSC
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+#define CONVERT_M			(1.0f/10000.0f)
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+#define INPUT_EVENT_HAS_TIMESTAMP	1
+#define NOT_SET_MAG_INITIAL_STATE	1
+#define MAG_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_LIS2MDL_H	*/
diff --git a/conf/conf_LIS3DH.h b/conf/conf_LIS3DH.h
new file mode 100644
index 0000000..91e27fe
--- /dev/null
+++ b/conf/conf_LIS3DH.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LIS3DH_H
+#define CONFIGURATION_LIS3DH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LIS3DH 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lis3dh_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			200				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_LIS3DH_H	*/
diff --git a/conf/conf_LIS3DHH.h b/conf/conf_LIS3DHH.h
new file mode 100644
index 0000000..a1389f7
--- /dev/null
+++ b/conf/conf_LIS3DHH.h
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2017 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LIS3DHH_H
+#define CONFIGURATION_LIS3DHH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE	(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LIS3DHH 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lis3dhh"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			2.5*GRAVITY_EARTH		// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			1100				// Set Max value of ODR [Hz] - driver uses delayed works (min tick 1 jiffies)
+#define ACCEL_POWER_CONSUMPTION		0.033f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		2.5				// Set default full-scale (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		0.9				// 1/frequency (default: 10 -> 100 Hz) [ms]
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ * 
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ */
+
+static short matrix_acc[3][3] = {
+	{ 1, 0, 0 },
+	{ 0, 1, 0 },
+	{ 0, 0, 1 }
+};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000.0f)	// 1000000ug = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define ACC_EVENT_HAS_TIMESTAMP		1
+
+#endif	/*	CONFIGURATION_LIS3DHH_H	*/
diff --git a/conf/conf_LIS3MDL.h b/conf/conf_LIS3MDL.h
new file mode 100644
index 0000000..5d20925
--- /dev/null
+++ b/conf/conf_LIS3MDL.h
@@ -0,0 +1,116 @@
+/*
+ * Copyright (C) 2012 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LIS3MDL_H
+#define CONFIGURATION_LIS3MDL_H
+
+#define SENSORS_MAGNETIC_FIELD_ENABLE			(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE		(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LIS3MDL 3-axis Magnetometer Sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_MAGN_LABEL	"LIS3MDL 3-axis Uncalibrated Magnetometer sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lis3mdl_mag"				// Name of input device: struct input_dev->name
+#define MAGN_DELAY_FILE_NAME		"device/pollrate_ms"			// name of sysfs file for setting the pollrate
+#define MAGN_ENABLE_FILE_NAME		"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define MAGN_RANGE_FILE_NAME		"device/full_scale"			// name of sysfs file for setting the full scale
+#define CALIBRATION_ENABLE		1					// Enable Calibration -> [0]:off, [1]:on
+#define MAGN_MAX_RANGE			1000.0f					// Set Max Full-scale [uT]
+#define MAGN_MAX_ODR			80					// Set Max value of ODR [Hz]
+#define MAGN_POWER_CONSUMPTION		0.077f					// Set sensor's power consumption [mA]
+#define MAGN_DEFAULT_FULLSCALE		8					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define MAG_DEFAULT_RANGE		8					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define MAG_DEFAULT_DELAY		12					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define MAGNETOMETER_ACTIVE		1					// Enable Magnetometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define MAG_GBIAS_THRESHOLD		1471e-6					// Set magnetometer gbias threshold [uT] - Default value for LSM303DLHC: 1200e-6
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG			EV_MSC
+
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+#define MAG_EVENT_HAS_TIMESTAMP		1
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+*/
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of magnetic data to uT units
+#define CONVERT_M			(1.0f/10000.0f)
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+
+
+#endif	/*	CONFIGURATION_LIS3MDL_H	*/
diff --git a/conf/conf_LPS22HB.h b/conf/conf_LPS22HB.h
new file mode 100644
index 0000000..f78d342
--- /dev/null
+++ b/conf/conf_LPS22HB.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 STMicroelectronics
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com> - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LPS22HB_H
+#define CONFIGURATION_LPS22HB_H
+
+#define SENSORS_PRESSURE_ENABLE		(1)
+#define SENSORS_TEMP_PRESS_ENABLE	(1)
+
+/* PRESSURE SENSOR */
+#define SENSOR_PRESS_LABEL		"LPS22HB Pressure sensor"		// Label views in Android Applications
+#define SENSOR_TEMP_LABEL		"LPS22HB Temperature sensor"		// Label views in Android Applications
+#define SENSOR_DATANAME_BAROMETER	"lps22hb"				// Name of input device: struct input_dev->name
+#define PRESS_DELAY_FILE_NAME		"device/poll_period_ms"			// name of sysfs file for setting the pollrate
+#define PRESS_ENABLE_FILE_NAME		"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define PRESS_RANGE_FILE_NAME		"device/range"				// name of sysfs file for setting the full scale
+#define PRESS_MAX_RANGE			1260					// Set Max Full-scale [hPa]
+#define TEMP_MAX_RANGE			80					// Set Max Full-scale [Celsius]
+#define TEMPERATURE_OFFSET		0
+#define PRESS_MAX_ODR			75					// Set Max value of ODR [Hz]
+#define PRESS_MIN_ODR			1					// Set Min value of ODR [Hz]
+#define PRESS_POWER_CONSUMPTION		0.015f					// Set sensor's power consumption [mA]
+#define TEMP_MAX_ODR			PRESS_MAX_ODR				// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR			PRESS_MIN_ODR				// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION		PRESS_POWER_CONSUMPTION			// Set sensor's power consumption [mA]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+
+/* Event Type in pressure sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_PRESSURE		MSC_SERIAL
+#define EVENT_TYPE_TEMPERATURE		MSC_PULSELED
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of pressure data to SI units (hPa, 1hPa=1mbar)
+#define CONVERT_PRESS			(1.0f/4096.0f)
+
+// conversion of temperature data to SI units
+#define CONVERT_TEMP			(1.0f/100.0f)
+
+#endif	/* CONFIGURATION_LPS22HB_H */
diff --git a/conf/conf_LPS22HD.h b/conf/conf_LPS22HD.h
new file mode 100644
index 0000000..d5ad6a4
--- /dev/null
+++ b/conf/conf_LPS22HD.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017 STMicroelectronics
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com> - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LPS22HD_H
+#define CONFIGURATION_LPS22HD_H
+
+#define SENSORS_PRESSURE_ENABLE		(1)
+#define SENSORS_TEMP_PRESS_ENABLE	(1)
+
+/* PRESSURE SENSOR */
+#define SENSOR_PRESS_LABEL		"LPS22HD Pressure sensor"		// Label views in Android Applications
+#define SENSOR_TEMP_LABEL		"LPS22HD Temperature sensor"		// Label views in Android Applications
+#define SENSOR_DATANAME_BAROMETER	"lps22hd"				// Name of input device: struct input_dev->name
+#define PRESS_DELAY_FILE_NAME		"device/poll_period_ms"			// name of sysfs file for setting the pollrate
+#define PRESS_ENABLE_FILE_NAME		"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define PRESS_RANGE_FILE_NAME		"device/range"				// name of sysfs file for setting the full scale
+#define PRESS_MAX_RANGE			1260					// Set Max Full-scale [hPa]
+#define TEMP_MAX_RANGE			80					// Set Max Full-scale [Celsius]
+#define TEMPERATURE_OFFSET		0
+#define PRESS_MAX_ODR			75					// Set Max value of ODR [Hz]
+#define PRESS_MIN_ODR			1					// Set Min value of ODR [Hz]
+#define PRESS_POWER_CONSUMPTION		0.015f					// Set sensor's power consumption [mA]
+#define TEMP_MAX_ODR			PRESS_MAX_ODR				// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR			PRESS_MIN_ODR				// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION		PRESS_POWER_CONSUMPTION			// Set sensor's power consumption [mA]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+
+/* Event Type in pressure sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_PRESSURE		MSC_SERIAL
+#define EVENT_TYPE_TEMPERATURE		MSC_PULSELED
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of pressure data to SI units (hPa, 1hPa=1mbar)
+#define CONVERT_PRESS			(1.0f/4096.0f)
+
+// conversion of temperature data to SI units
+#define CONVERT_TEMP			(1.0f/100.0f)
+
+#endif	/* CONFIGURATION_LPS22HD_H */
diff --git a/conf/conf_LPS25H.h b/conf/conf_LPS25H.h
new file mode 100644
index 0000000..650fe1c
--- /dev/null
+++ b/conf/conf_LPS25H.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2016 STMicroelectronics
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com> - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LPS25H_H
+#define CONFIGURATION_LPS25H_H
+
+#define SENSORS_PRESSURE_ENABLE		(1)
+#define SENSORS_TEMP_PRESS_ENABLE	(1)
+
+/* PRESSURE SENSOR */
+#define SENSOR_PRESS_LABEL		"LPS25H Pressure sensor"		// Label views in Android Applications
+#define SENSOR_TEMP_LABEL		"LPS25H Temperature sensor"		// Label views in Android Applications
+#define SENSOR_DATANAME_BAROMETER	"lps25h"				// Name of input device: struct input_dev->name
+#define PRESS_DELAY_FILE_NAME		"device/poll_period_ms"			// name of sysfs file for setting the pollrate
+#define PRESS_ENABLE_FILE_NAME		"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define PRESS_RANGE_FILE_NAME		"device/range"				// name of sysfs file for setting the full scale
+#define PRESS_MAX_RANGE			1260					// Set Max Full-scale [hPa]
+#define TEMP_MAX_RANGE			105					// Set Max Full-scale [Celsius]
+#define TEMPERATURE_OFFSET		42.5f
+#define PRESS_MAX_ODR			25					// Set Max value of ODR [Hz]
+#define PRESS_MIN_ODR			1					// Set Min value of ODR [Hz]
+#define PRESS_POWER_CONSUMPTION		0.015f					// Set sensor's power consumption [mA]
+#define TEMP_MAX_ODR			PRESS_MAX_ODR				// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR			PRESS_MIN_ODR				// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION		PRESS_POWER_CONSUMPTION			// Set sensor's power consumption [mA]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+
+/* Event Type in pressure sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_PRESSURE		MSC_SERIAL
+#define EVENT_TYPE_TEMPERATURE		MSC_PULSELED
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of pressure data to SI units (hPa, 1hPa=1mbar)
+#define CONVERT_PRESS			(1.0f/4096.0f)
+
+// conversion of temperature data to SI units
+#define CONVERT_TEMP			(1.0f/480.0f)
+
+#endif	/* CONFIGURATION_LPS25H_H */
diff --git a/conf/conf_LPS33HW.h b/conf/conf_LPS33HW.h
new file mode 100644
index 0000000..85b74fd
--- /dev/null
+++ b/conf/conf_LPS33HW.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2017 STMicroelectronics
+ * Lorenzo Bianconi <lorenzo.bianconi@st.com> - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LPS33HW_H
+#define CONFIGURATION_LPS33HW_H
+
+#define SENSORS_PRESSURE_ENABLE		(1)
+#define SENSORS_TEMP_PRESS_ENABLE	(1)
+
+/* PRESSURE SENSOR */
+#define SENSOR_PRESS_LABEL		"LPS33HW Pressure sensor"		// Label views in Android Applications
+#define SENSOR_TEMP_LABEL		"LPS33HW Temperature sensor"		// Label views in Android Applications
+#define SENSOR_DATANAME_BAROMETER	"lps33hw"				// Name of input device: struct input_dev->name
+#define PRESS_DELAY_FILE_NAME		"device/poll_period_ms"			// name of sysfs file for setting the pollrate
+#define PRESS_ENABLE_FILE_NAME		"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define PRESS_RANGE_FILE_NAME		"device/range"				// name of sysfs file for setting the full scale
+#define PRESS_MAX_RANGE			1260					// Set Max Full-scale [hPa]
+#define TEMP_MAX_RANGE			80					// Set Max Full-scale [Celsius]
+#define TEMPERATURE_OFFSET		0
+#define PRESS_MAX_ODR			75					// Set Max value of ODR [Hz]
+#define PRESS_MIN_ODR			1					// Set Min value of ODR [Hz]
+#define PRESS_POWER_CONSUMPTION		0.015f					// Set sensor's power consumption [mA]
+#define TEMP_MAX_ODR			PRESS_MAX_ODR				// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR			PRESS_MIN_ODR				// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION		PRESS_POWER_CONSUMPTION			// Set sensor's power consumption [mA]
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+
+/* Event Type in pressure sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_PRESSURE		MSC_SERIAL
+#define EVENT_TYPE_TEMPERATURE		MSC_PULSELED
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of pressure data to SI units (hPa, 1hPa=1mbar)
+#define CONVERT_PRESS			(1.0f/4096.0f)
+
+// conversion of temperature data to SI units
+#define CONVERT_TEMP			(1.0f/100.0f)
+
+#endif	/* CONFIGURATION_LPS33HW_H */
diff --git a/conf/conf_LSM303AGR.h b/conf/conf_LSM303AGR.h
new file mode 100644
index 0000000..a831e38
--- /dev/null
+++ b/conf/conf_LSM303AGR.h
@@ -0,0 +1,175 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Armando Visconti - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_SENSOR_LSM303AGR_H
+#define CONFIGURATION_SENSOR_LSM303AGR_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_TEMP_ENABLE			(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE \
+							& OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM303AGR 3-axis Accelerometer"
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm303agr_acc"
+#define ACCEL_DELAY_FILE_NAME		"accel/pollrate_ms"
+#define ACCEL_ENABLE_FILE_NAME		"accel/enable"
+#define ACCEL_RANGE_FILE_NAME		"accel/range"
+#define ACCEL_MAX_RANGE			8*GRAVITY_EARTH
+#define ACCEL_MAX_ODR			100
+#define ACCEL_POWER_CONSUMPTION		0.033f
+#define ACCEL_DEFAULT_FULLSCALE		4
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LSM303AGR 3-axis Magnetometer Sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lsm303agr_mag"
+#define MAGN_DELAY_FILE_NAME		"device/pollrate_ms"
+#define MAGN_ENABLE_FILE_NAME		"device/enable_device"
+#define MAGN_RANGE_FILE_NAME		"device/full_scale"
+#define CALIBRATION_ENABLE		1
+#define MAGN_MAX_RANGE			1600.0f
+#define MAGN_MAX_ODR			100
+#define MAGN_POWER_CONSUMPTION		0.077f
+#define MAGN_DEFAULT_FULLSCALE		50
+#define MAGN_MIN_ODR			25
+
+#define SENSOR_TEMP_LABEL		"LSM303AGR Temperature sensor"
+#define SENSOR_DATANAME_TERMOMETER	"lsm303agr_temp"			// Name of input device: struct input_dev->name
+#define TEMP_DELAY_FILE_NAME		"temp/pollrate_ms"			// name of sysfs file for setting the pollrate
+#define TEMP_ENABLE_FILE_NAME		"temp/enable"				// name of sysfs file for enable/disable the sensor state
+#define TEMP_MAX_RANGE			85					// Set Max Full-scale [Celsius]
+#define TEMPERATURE_OFFSET		25
+#define TEMP_MAX_ODR			100					// Set Max value of ODR [Hz]
+#define TEMP_MIN_ODR			1					// Set Min value of ODR [Hz]
+#define TEMP_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE		4
+#define MAG_DEFAULT_RANGE		50
+#define ACC_DEFAULT_DELAY		100
+#define MAG_DEFAULT_DELAY		100
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f
+#define ACC_GBIAS_THRESHOLD		550e-6
+#define MAG_GBIAS_THRESHOLD		1200e-6
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_MAG			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/* Event Type in temperature sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_TEMPERATURE			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+*/
+
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+#define CONVERT_M			(1.0f/10000.0f)// 1uTESLA = 10 mGauss
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+// conversion of temperature data to SI units
+#define CONVERT_TEMP				(1.0f)
+
+#define MAG_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_ACC_INITIAL_STATE	1
+#define NOT_SET_MAG_INITIAL_STATE	1
+
+#endif /* CONFIGURATION_SENSOR_LSM303AGR_H */
diff --git a/conf/conf_LSM303AH.h b/conf/conf_LSM303AH.h
new file mode 100644
index 0000000..08ebaa7
--- /dev/null
+++ b/conf/conf_LSM303AH.h
@@ -0,0 +1,193 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM303AH_H
+#define CONFIGURATION_LSM303AH_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+#define SENSORS_TILT_ENABLE			(1)
+#define SENSORS_STEP_COUNTER_ENABLE		(1)
+#define SENSORS_STEP_DETECTOR_ENABLE		(1)
+#define SENSORS_SIGN_MOTION_ENABLE		(1)
+#define SENSORS_TAP_ENABLE			(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LSM303AH 3-axis Accelerometer Sensor"
+#define SENSOR_DATANAME_ACCELEROMETER		"lsm303ah_acc_accel"
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH
+#define ACCEL_MAX_ODR				200
+#define ACCEL_POWER_CONSUMPTION			0.6f
+#define ACCEL_DEFAULT_FULLSCALE			4
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL			"LSM303AH 3-axis Magnetometer Sensor"
+#define SENSOR_UNCALIB_MAGN_LABEL		"LSM303AH 3-axis Uncalibrated Magnetometer sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD		"ST LSM303AH Magnetometer Sensor"
+#define MAGN_DELAY_FILE_NAME			"magn/polling_rate"
+#define MAGN_ENABLE_FILE_NAME			"magn/enable"
+#define MAGN_RANGE_FILE_NAME			"magn/range"
+#define CALIBRATION_ENABLE			1
+#define MAGN_MAX_RANGE				1000.0f
+#define MAGN_MAX_ODR				100
+#define MAGN_MIN_ODR			25
+#define MAGN_POWER_CONSUMPTION			0.077f
+#define MAGN_DEFAULT_FULLSCALE			50
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"LSM303AH Tilt Detector sensor"
+#define SENSOR_DATANAME_TILT			"lsm303ah_acc_tilt"
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"
+#define TILT_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* STEP COUNTER SENSOR */
+#define SENSOR_STEP_C_LABEL			"LSM303AH Step Counter sensor"
+#define SENSOR_DATANAME_STEP_C			"lsm303ah_acc_step_c"
+#define STEP_C_ENABLE_FILE_NAME			"step_c/enable"
+#define STEP_C_DELAY_FILE_NAME			"step_c/max_delivery_rate"
+#define STEP_C_POWER_CONSUMPTION		ACCEL_POWER_CONSUMPTION
+
+/* STEP DETECTOR SENSOR */
+#define SENSOR_STEP_D_LABEL			"LSM303AH Step Detector Sensor"
+#define SENSOR_DATANAME_STEP_D			"lsm303ah_acc_step_d"
+#define STEP_D_ENABLE_FILE_NAME			"step_d/enable"
+#define STEP_D_POWER_CONSUMPTION		ACCEL_POWER_CONSUMPTION
+
+/* SIGNIFICANT MOTION SENSOR */
+#define SENSOR_SIGN_M_LABEL			"LSM303AH Significant Motion Sensor"
+#define SENSOR_DATANAME_SIGN_M			"lsm303ah_acc_sign_m"
+#define SIGN_M_ENABLE_FILE_NAME			"sign_m/enable"
+#define SIGN_M_POWER_CONSUMPTION		ACCEL_POWER_CONSUMPTION
+
+/* STEP TAP SENSOR */
+#define SENSOR_TAP_LABEL			"LSM303AH Tap Sensor"
+#define SENSOR_DATANAME_TAP			"lsm303ah_acc_tap"
+#define TAP_ENABLE_FILE_NAME			"tap/enable"
+#define TAP_POWER_CONSUMPTION			ACCEL_POWER_CONSUMPTION
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE			8
+#define ACC_DEFAULT_DELAY			10
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_MAG				EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_STEP_C			EV_MSC
+#define EVENT_TYPE_STEP_D			EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+#define EVENT_TYPE_TAP				EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+#define EVENT_TYPE_MAG_X			MSC_SERIAL
+#define EVENT_TYPE_MAG_Y			MSC_PULSELED
+#define EVENT_TYPE_MAG_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_C_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_D_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+#define EVENT_TYPE_TAP_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+#define CONVERT_M				(1.0f/10000.0f)
+#define CONVERT_M_X				(CONVERT_M)
+#define CONVERT_M_Y				(CONVERT_M)
+#define CONVERT_M_Z				(CONVERT_M)
+
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+#define NOT_SET_MAG_INITIAL_STATE		1
+#define MAG_EVENT_HAS_TIMESTAMP			1
+
+#endif	/*	CONFIGURATION_LSM303AH_H	*/
diff --git a/conf/conf_LSM303C.h b/conf/conf_LSM303C.h
new file mode 100644
index 0000000..3db3848
--- /dev/null
+++ b/conf/conf_LSM303C.h
@@ -0,0 +1,151 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_SENSOR_LSM303C_H
+#define CONFIGURATION_SENSOR_LSM303C_H
+
+#define SENSORS_ACCELEROMETER_ENABLE			(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE			(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM303C 3-axis Accelerometer"		// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm303c_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			8*GRAVITY_EARTH				// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			100					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LSM303C 3-axis Magnetometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lsm303c_mag"				// Name of input device: struct input_dev->name
+#define MAGN_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define MAGN_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define MAGN_RANGE_FILE_NAME		"device/full_scale"				// name of sysfs file for setting the full scale
+#define CALIBRATION_ENABLE		1					// Enable Calibration -> [0]:off, [1]:on
+#define MAGN_MAX_RANGE			1600.0f					// Set Max Full-scale [uT]
+#define MAGN_MAX_ODR			80					// Set Max value of ODR [Hz]
+#define MAGN_POWER_CONSUMPTION		0.077f					// Set sensor's power consumption [mA]
+#define MAGN_DEFAULT_FULLSCALE		8					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define MAG_DEFAULT_RANGE		8					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define MAG_DEFAULT_DELAY		13					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold [uT] - Default value for LSM303D: 550e-6
+#define MAG_GBIAS_THRESHOLD		1200e-6					// Set magnetometer gbias threshold [uT] - Default value for LSM303D: 1200e-6
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_MAG			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+*/
+
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000)	// (ug / 1000000) * 9.86 m/s^2
+#define CONVERT_A_X 		(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of magnetic data to uT units
+// 1uTESLA = 10 mgGauss
+// Sensitivity @8G: 0.029231219 uT/LSB
+#define CONVERT_M			(0.029231219f)
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+#endif /* CONFIGURATION_SENSOR_LSM303C_H */
diff --git a/conf/conf_LSM303D.h b/conf/conf_LSM303D.h
new file mode 100644
index 0000000..d645a9b
--- /dev/null
+++ b/conf/conf_LSM303D.h
@@ -0,0 +1,149 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_SENSOR_LSM303D_H
+#define CONFIGURATION_SENSOR_LSM303D_H
+
+#define SENSORS_ACCELEROMETER_ENABLE			(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE			(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE		(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM303D 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm303d_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/accelerometer/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/accelerometer/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/accelerometer/full_scale"		// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			1000					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		8					// Set default full-scale (value depends on the driver sysfs file)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LSM303D 3-axis Magnetometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lsm303d_mag"				// Name of input device: struct input_dev->name
+#define MAGN_DELAY_FILE_NAME		"device/magnetometer/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define MAGN_ENABLE_FILE_NAME		"device/magnetometer/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define MAGN_RANGE_FILE_NAME		"device/magnetometer/full_scale"		// name of sysfs file for setting the full scale
+#define CALIBRATION_ENABLE		1					// Enable Calibration -> [0]:off, [1]:on
+#define MAGN_MAX_RANGE			1200.0f					// Set Max Full-scale [uT]
+#define MAGN_MAX_ODR			200					// Set Max value of ODR [Hz]
+#define MAGN_POWER_CONSUMPTION		0.077f					// Set sensor's power consumption [mA]
+#define MAGN_DEFAULT_FULLSCALE		8					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define MAG_DEFAULT_RANGE		8					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define MAG_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold [uT] - Default value for LSM303D: 550e-6
+#define MAG_GBIAS_THRESHOLD		1200e-6					// Set magnetometer gbias threshold [uT] - Default value for LSM303D: 1200e-6
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_ABS
+#define EVENT_TYPE_MAG			EV_ABS
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		ABS_X
+#define EVENT_TYPE_ACCEL_Y		ABS_Y
+#define EVENT_TYPE_ACCEL_Z		ABS_Z
+
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG_X		ABS_X
+#define EVENT_TYPE_MAG_Y		ABS_Y
+#define EVENT_TYPE_MAG_Z		ABS_Z
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+*/
+
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000.0f)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of magnetic data to uT units
+#define CONVERT_M			(1.0f/10000.0f)		// 1uTESLA = 10000 uGauss
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+#endif /* CONFIGURATION_SENSOR_LSM303D_H */
diff --git a/conf/conf_LSM303DLHC.h b/conf/conf_LSM303DLHC.h
new file mode 100644
index 0000000..269c4ea
--- /dev/null
+++ b/conf/conf_LSM303DLHC.h
@@ -0,0 +1,153 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM303DLHC_H
+#define CONFIGURATION_LSM303DLHC_H
+
+#define SENSORS_ACCELEROMETER_ENABLE			(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE			(1)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE		(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM303DLHC 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm303dlhc_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			400					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LSM303DLHC 3-axis Magnetometer Sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_MAGN_LABEL      "LSM303DLHC 3-axis Uncalibrated Magnetometer sensor"
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lsm303dlhc_mag"			// Name of input device: struct input_dev->name
+#define MAGN_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define MAGN_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define MAGN_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define CALIBRATION_ENABLE		1					// Enable Calibration -> [0]:off, [1]:on
+#define MAGN_MAX_RANGE			810.0f					// Set Max Full-scale [uT]
+#define MAGN_MAX_ODR			220					// Set Max value of ODR [Hz]
+#define MAGN_POWER_CONSUMPTION		0.077f					// Set sensor's power consumption [mA]
+#define MAGN_DEFAULT_FULLSCALE		2500					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define MAG_DEFAULT_RANGE		2500					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define MAG_DEFAULT_DELAY		14					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define ACCELEROMETER_ACTIVE		1					// Enable Accelerometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define MAGNETOMETER_ACTIVE		1					// Enable Magnetometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold [uT] - Default value for LSM303DLHC: 550e-6
+#define MAG_GBIAS_THRESHOLD		1200e-6					// Set magnetometer gbias threshold [uT] - Default value for LSM303DLHC: 1200e-6
+
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_MAG			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+*/
+
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of magnetic data to uT units
+#define CONVERT_M			(1.0f/10.0f)		// 1uTESLA = 10 mgGauss
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+#endif	/*	CONFIGURATION_LSM303DLHC_H	*/
diff --git a/conf/conf_LSM330.h b/conf/conf_LSM330.h
new file mode 100644
index 0000000..c5a9690
--- /dev/null
+++ b/conf/conf_LSM330.h
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_LSM330_H
+#define CONFIGURATION_LSM330_H
+
+#define SENSORS_ACCELEROMETER_ENABLE			(1)
+#define SENSORS_GYROSCOPE_ENABLE			(1)
+#define SENSORS_SIGNIFICANT_MOTION_ENABLE		(1 & OS_VERSION_ENABLE)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE		(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM330 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm330_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			400					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"LSM330 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_GYRO_LABEL	"LSM330 3-axis Uncalibrated Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE	"lsm330_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			800					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SIGNIFICANT MOTION SENSOR */
+#define SENSOR_SIGNIFICANT_MOTION_LABEL	"LSM330 Significant Motion sensor"	// Label views in Android Applications
+#define SIGN_MOTION_ENABLE_FILE_NAME	"device/enable_state_prog"		// Name of sysfs file for enabling the feature
+#define SIGN_MOTION_POLL_EN_FILE_NAME	"device/enable_polling"
+#define SIGN_MOTION_ENABLE_VALUE	0x02					// Value to be passed to enable HW Sign Motion Feature
+#define SIGN_MOTION_DISABLE_VALUE	0x00					// Value to be passed to disable HW Sign Motion Feature
+
+/* SENSOR FUSION */
+#define ACCELEROMETER_ACTIVE		1					// Enable Accelerometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define GYROSCOPE_ACTIVE		1					// Enable Gyroscope sensor in Sensor Fusion -> [0]:off, [1]:on
+#define ACC_GBIAS_THRESHOLD		765e-6					// Set acceleration gbias threshold [uT] - Default value for LSM303DLHC: 550e-6
+#define GYR_GBIAS_THRESHOLD		1491e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_GYRO			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+#define EVENT_TYPE_SIGNIFICANT_MOTION	MSC_SCAN
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of gyro data to SI units (radian/sec)
+#define CONVERT_GYRO			((7.0f*((float)M_PI)) / 18000.0f)
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#endif	/*	CONFIGURATION_LSM330_H	*/
diff --git a/conf/conf_LSM330D.h b/conf/conf_LSM330D.h
new file mode 100644
index 0000000..1176f76
--- /dev/null
+++ b/conf/conf_LSM330D.h
@@ -0,0 +1,156 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_LSM330D_H
+#define CONFIGURATION_LSM330D_H
+
+#define SENSORS_ACCELEROMETER_ENABLE			(1)
+#define SENSORS_GYROSCOPE_ENABLE			(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE		(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM330D 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm330d_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			400					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"LSM330D 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_GYRO_LABEL      "LSM330D 3-axis Uncalibrated Gyroscope sensor"
+#define SENSOR_DATANAME_GYROSCOPE	"lsm330d_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			800					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACCELEROMETER_ACTIVE		1					// Enable Accelerometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define GYROSCOPE_ACTIVE		1					// Enable Gyroscope sensor in Sensor Fusion -> [0]:off, [1]:on
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold [uT] - Default value for LSM303DLHC: 550e-6
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_ABS
+#define EVENT_TYPE_GYRO		EV_ABS
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		ABS_X
+#define EVENT_TYPE_ACCEL_Y		ABS_Y
+#define EVENT_TYPE_ACCEL_Z		ABS_Z
+
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X		ABS_X
+#define EVENT_TYPE_GYRO_Y		ABS_Y
+#define EVENT_TYPE_GYRO_Z		ABS_Z
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of gyro data to SI units (radian/sec)
+#define CONVERT_GYRO			((7.0f*((float)M_PI)) / 18000.0f)
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+
+#endif	/*	CONFIGURATION_LSM330D_H	*/
diff --git a/conf/conf_LSM330DLC.h b/conf/conf_LSM330DLC.h
new file mode 100644
index 0000000..b393213
--- /dev/null
+++ b/conf/conf_LSM330DLC.h
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_LSM330DLC_H
+#define CONFIGURATION_LSM330DLC_H
+
+#define SENSORS_ACCELEROMETER_ENABLE			(1)
+#define SENSORS_GYROSCOPE_ENABLE			(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE		(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM330DLC 3-axis Accelerometer"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm330dlc_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			400					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.011f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"LSM330DLC 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_UNCALIB_GYRO_LABEL      	"LSM330DLC 3-axis Uncalibrated Gyroscope sensor"
+#define SENSOR_DATANAME_GYROSCOPE	"lsm330dlc_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			200					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold [uT] - Default value for LSM303DLHC: 550e-6
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_GYRO			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of gyro data to SI units (radian/sec)
+#define DPS2RAD				((float)M_PI/180.0f)
+#define G_SENSITIVITY			(70.0f)		//[mdps] Sensitivity at 2000dps
+#define CONVERT_GYRO			(DPS2RAD * (G_SENSITIVITY / (1000.0f)))
+
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+
+#endif	/*	CONFIGURATION_LSM330DLC_H	*/
diff --git a/conf/conf_LSM6DS0.h b/conf/conf_LSM6DS0.h
new file mode 100644
index 0000000..0a74c95
--- /dev/null
+++ b/conf/conf_LSM6DS0.h
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2012 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM6DS0_H
+#define CONFIGURATION_LSM6DS0_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM6DS0 3-axis Accelerometer"		// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm6ds0_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/accelerometer/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/accelerometer/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/accelerometer/range"			// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			8 * GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			952					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR			10
+#define ACCEL_POWER_CONSUMPTION		0.6f						// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4						// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"LSM6DS0 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE	"lsm6ds0_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/gyroscope/pollrate_ms"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/gyroscope/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/gyroscope/range"			// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			952					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR			15
+#define GYRO_POWER_CONSUMPTION		4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)			(x / 1000000.0f)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define ACCELEROMETER_ACTIVE		1					// Enable Accelerometer sensor in Sensor Fusion -> [0]:off, [1]:on
+#define GYROSCOPE_ACTIVE		1					// Enable Gyroscope sensor in Sensor Fusion -> [0]:off, [1]:on
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_GYRO			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000.0f)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD				((float)M_PI/180.0f)
+#define G_SENSITIVITY			(1.0f) //Already applied into the driver
+#define CONVERT_GYRO			(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#endif	/*	CONFIGURATION_LSM6DS0_H	*/
diff --git a/conf/conf_LSM6DS3.h b/conf/conf_LSM6DS3.h
new file mode 100644
index 0000000..9ff687d
--- /dev/null
+++ b/conf/conf_LSM6DS3.h
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM6DS3_H
+#define CONFIGURATION_LSM6DS3_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+#define SENSORS_TILT_ENABLE			(1)
+#define SENSORS_STEP_COUNTER_ENABLE		(1)
+#define SENSORS_STEP_DETECTOR_ENABLE		(1)
+#define SENSORS_SIGN_MOTION_ENABLE		(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LSM6DS3(H) 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST LSM6DS3 Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				12					// Set Min value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL			"LSM6DS3(H) 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE		"ST LSM6DS3 Gyroscope Sensor"		// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME			"gyro/polling_rate"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME			"gyro/enable"		// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME			"gyro/scale"			// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE				(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR				12					// Set Min value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION			4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE			2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)				(x / 1000000.0f)
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"LSM6DS3(H) Tilt Detector sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TILT			"ST LSM6DS3 Tilt Sensor"		// Name of input device: struct input_dev->name
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"		// name of sysfs file for enable/disable the sensor state
+#define TILT_POWER_CONSUMPTION			0.6f
+
+/* STEP COUNTER SENSOR */
+#define SENSOR_STEP_C_LABEL			"LSM6DS3(H) Step Counter sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_STEP_C			"ST LSM6DS3 Step Counter Sensor"		// Name of input device: struct input_dev->name
+#define STEP_C_ENABLE_FILE_NAME			"step_c/enable"		// name of sysfs file for enable/disable the sensor state
+#define STEP_C_DELAY_FILE_NAME			"step_c/max_delivery_rate"
+#define STEP_C_POWER_CONSUMPTION		0.6f
+
+/* STEP DETECTOR SENSOR */
+#define SENSOR_STEP_D_LABEL			"LSM6DS3(H) Step Detector Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_STEP_D			"ST LSM6DS3 Step Detector Sensor"		// Name of input device: struct input_dev->name
+#define STEP_D_ENABLE_FILE_NAME			"step_d/enable"		// name of sysfs file for enable/disable the sensor state
+#define STEP_D_POWER_CONSUMPTION		0.6f
+
+/* SIGNIFICANT MOTION SENSOR */
+#define SENSOR_SIGN_M_LABEL			"LSM6DS3(H) Significant Motion Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_SIGN_M			"ST LSM6DS3 Significant Motion Sensor"		// Name of input device: struct input_dev->name
+#define SIGN_M_ENABLE_FILE_NAME			"sign_m/enable"		// name of sysfs file for enable/disable the sensor state
+#define SIGN_M_POWER_CONSUMPTION		0.6f
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE			2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE			4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY			10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD			475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD		(0)
+#define GYRO_STARTUP_TIME_MS			(0)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_GYRO				EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_STEP_C			EV_MSC
+#define EVENT_TYPE_STEP_D			EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X			MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y			MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_C_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_D_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD					((float)M_PI/180.0f)
+#define G_SENSITIVITY				(1.0f) //Already applied into the driver
+#define CONVERT_GYRO				(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X				(CONVERT_GYRO)
+#define CONVERT_GYRO_Y				(CONVERT_GYRO)
+#define CONVERT_GYRO_Z				(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+//#define NOT_SET_ACC_INITIAL_STATE		1
+//#define NOT_SET_GYRO_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_LSM6DS3_H	*/
diff --git a/conf/conf_LSM6DSL.h b/conf/conf_LSM6DSL.h
new file mode 100644
index 0000000..0c12c1f
--- /dev/null
+++ b/conf/conf_LSM6DSL.h
@@ -0,0 +1,206 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM6DSL_H
+#define CONFIGURATION_LSM6DSL_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+
+#define SENSORS_TILT_ENABLE			(1)
+#define SENSORS_STEP_COUNTER_ENABLE		(1)
+#define SENSORS_STEP_DETECTOR_ENABLE		(1)
+#define SENSORS_SIGN_MOTION_ENABLE		(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LSM6DSL 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST LSM6DSL Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL			"LSM6DSL 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE		"ST LSM6DSL Gyroscope Sensor"		// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME			"gyro/polling_rate"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME			"gyro/enable"		// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME			"gyro/scale"			// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE				(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION			4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE			2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)				(x / 1000000.0f)
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"LSM6DSL Tilt Detector sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TILT			"ST LSM6DSL Tilt Sensor"		// Name of input device: struct input_dev->name
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"		// name of sysfs file for enable/disable the sensor state
+#define TILT_POWER_CONSUMPTION			0.6f
+
+/* STEP COUNTER SENSOR */
+#define SENSOR_STEP_C_LABEL			"LSM6DSL Step Counter sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_STEP_C			"ST LSM6DSL Step Counter Sensor"		// Name of input device: struct input_dev->name
+#define STEP_C_ENABLE_FILE_NAME			"step_c/enable"		// name of sysfs file for enable/disable the sensor state
+#define STEP_C_DELAY_FILE_NAME			"step_c/max_delivery_rate"
+#define STEP_C_POWER_CONSUMPTION		0.6f
+
+/* STEP DETECTOR SENSOR */
+#define SENSOR_STEP_D_LABEL			"LSM6DSL Step Detector Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_STEP_D			"ST LSM6DSL Step Detector Sensor"		// Name of input device: struct input_dev->name
+#define STEP_D_ENABLE_FILE_NAME			"step_d/enable"		// name of sysfs file for enable/disable the sensor state
+#define STEP_D_POWER_CONSUMPTION		0.6f
+
+/* SIGNIFICANT MOTION SENSOR */
+#define SENSOR_SIGN_M_LABEL			"LSM6DSL Significant Motion Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_SIGN_M			"ST LSM6DSL Significant Motion Sensor"		// Name of input device: struct input_dev->name
+#define SIGN_M_ENABLE_FILE_NAME			"sign_m/enable"		// name of sysfs file for enable/disable the sensor state
+#define SIGN_M_POWER_CONSUMPTION		0.6f
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE			2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE			4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY			10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD			475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD		(0)
+#define GYRO_STARTUP_TIME_MS			(0)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_GYRO				EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_STEP_C			EV_MSC
+#define EVENT_TYPE_STEP_D			EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X			MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y			MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_C_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_D_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD					((float)M_PI/180.0f)
+#define G_SENSITIVITY				(1.0f) //Already applied into the driver
+#define CONVERT_GYRO				(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X				(CONVERT_GYRO)
+#define CONVERT_GYRO_Y				(CONVERT_GYRO)
+#define CONVERT_GYRO_Z				(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+//#define NOT_SET_ACC_INITIAL_STATE		1
+//#define NOT_SET_GYRO_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_LSM6DSL_H	*/
diff --git a/conf/conf_LSM6DSM.h b/conf/conf_LSM6DSM.h
new file mode 100644
index 0000000..827fe08
--- /dev/null
+++ b/conf/conf_LSM6DSM.h
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM6DSM_H
+#define CONFIGURATION_LSM6DSM_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+#define SENSORS_UNCALIB_ACCELEROMETER_ENABLE	(1 & SENSORS_ACCELEROMETER_ENABLE & ANDROID_VERSION >= ANDROID_O)
+
+#define SENSORS_TILT_ENABLE			(1)
+#define SENSORS_STEP_COUNTER_ENABLE		(1)
+#define SENSORS_STEP_DETECTOR_ENABLE		(1)
+#define SENSORS_SIGN_MOTION_ENABLE		(1)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL			"LSM6DSM 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER		"ST LSM6DSM Accelerometer Sensor"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME			"accel/polling_rate"						// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME			"accel/enable"							// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME			"accel/scale"							// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE				8 * GRAVITY_EARTH									// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION			0.6f				// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE			4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL			"LSM6DSM 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE		"ST LSM6DSM Gyroscope Sensor"		// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME			"gyro/polling_rate"			// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME			"gyro/enable"		// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME			"gyro/scale"			// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE				(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR				200					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR				13					// Set Min value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION			4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE			2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)				(x / 1000000.0f)
+
+/* TILT SENSOR */
+#define SENSOR_TILT_LABEL			"LSM6DSM Tilt Detector sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_TILT			"ST LSM6DSM Tilt Sensor"		// Name of input device: struct input_dev->name
+#define TILT_ENABLE_FILE_NAME			"tilt/enable"		// name of sysfs file for enable/disable the sensor state
+#define TILT_POWER_CONSUMPTION			0.6f
+
+/* STEP COUNTER SENSOR */
+#define SENSOR_STEP_C_LABEL			"LSM6DSM Step Counter sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_STEP_C			"ST LSM6DSM Step Counter Sensor"		// Name of input device: struct input_dev->name
+#define STEP_C_ENABLE_FILE_NAME			"step_c/enable"		// name of sysfs file for enable/disable the sensor state
+#define STEP_C_DELAY_FILE_NAME			"step_c/max_delivery_rate"
+#define STEP_C_POWER_CONSUMPTION		0.6f
+
+/* STEP DETECTOR SENSOR */
+#define SENSOR_STEP_D_LABEL			"LSM6DSM Step Detector Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_STEP_D			"ST LSM6DSM Step Detector Sensor"		// Name of input device: struct input_dev->name
+#define STEP_D_ENABLE_FILE_NAME			"step_d/enable"		// name of sysfs file for enable/disable the sensor state
+#define STEP_D_POWER_CONSUMPTION		0.6f
+
+/* SIGNIFICANT MOTION SENSOR */
+#define SENSOR_SIGN_M_LABEL			"LSM6DSM Significant Motion Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_SIGN_M			"ST LSM6DSM Significant Motion Sensor"		// Name of input device: struct input_dev->name
+#define SIGN_M_ENABLE_FILE_NAME			"sign_m/enable"		// name of sysfs file for enable/disable the sensor state
+#define SIGN_M_POWER_CONSUMPTION		0.6f
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE			2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE			4					// full scale set to 8g (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY			10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY			10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define ACC_GBIAS_THRESHOLD			550e-6					// Set acceleration gbias threshold
+#define GYR_GBIAS_THRESHOLD			475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD		(0)
+#define GYRO_STARTUP_TIME_MS			(0)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL			EV_MSC
+#define EVENT_TYPE_GYRO				EV_MSC
+#define EVENT_TYPE_TILT				EV_MSC
+#define EVENT_TYPE_STEP_C			EV_MSC
+#define EVENT_TYPE_STEP_D			EV_MSC
+#define EVENT_TYPE_SIGN_M			EV_MSC
+
+#define EVENT_TYPE_TIME_MSB			MSC_SCAN
+#define EVENT_TYPE_TIME_LSB			MSC_MAX
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X			MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y			MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z			MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X			MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y			MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z			MSC_GESTURE
+
+#define EVENT_TYPE_TILT_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_C_DATA			MSC_SERIAL
+#define EVENT_TYPE_STEP_D_DATA			MSC_SERIAL
+#define EVENT_TYPE_SIGN_M_DATA			MSC_SERIAL
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 0, 1, 0 },
+				{ -1, 0, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A				(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 				(CONVERT_A)
+#define CONVERT_A_Y				(CONVERT_A)
+#define CONVERT_A_Z				(CONVERT_A)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD					((float)M_PI/180.0f)
+#define G_SENSITIVITY				(1.0f) //Already applied into the driver
+#define CONVERT_GYRO				(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X				(CONVERT_GYRO)
+#define CONVERT_GYRO_Y				(CONVERT_GYRO)
+#define CONVERT_GYRO_Z				(CONVERT_GYRO)
+
+#define GYRO_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP			1
+#define INPUT_EVENT_HAS_TIMESTAMP		1
+//#define NOT_SET_ACC_INITIAL_STATE		1
+//#define NOT_SET_GYRO_INITIAL_STATE		1
+#endif	/*	CONFIGURATION_LSM6DSM_H	*/
diff --git a/conf/conf_LSM9DS0.h b/conf/conf_LSM9DS0.h
new file mode 100644
index 0000000..6cefa64
--- /dev/null
+++ b/conf/conf_LSM9DS0.h
@@ -0,0 +1,197 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM9DS0_H
+#define CONFIGURATION_LSM9DS0_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM9DS0 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm9ds0_acc"			// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/accelerometer/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/accelerometer/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/accelerometer/full_scale"		// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			16*GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			100					// Set Max value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.033f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LSM9DS0 3-axis Magnetometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lsm9ds0_mag"			// Name of input device: struct input_dev->name
+#define MAGN_DELAY_FILE_NAME		"device/magnetometer/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define MAGN_ENABLE_FILE_NAME		"device/magnetometer/enable_device"		// name of sysfs file for enable/disable the sensor state
+#define MAGN_RANGE_FILE_NAME		"device/magnetometer/full_scale"		// name of sysfs file for setting the full scale
+#define MAGN_MAX_RANGE			1200.0f					// Set Max Full-scale [uT]
+#define MAGN_MAX_ODR			100					// Set Max value of ODR [Hz]
+#define MAGN_POWER_CONSUMPTION		0.077f					// Set sensor's power consumption [mA]
+#define MAGN_DEFAULT_FULLSCALE		8					// Set default full-scale (value depends on the driver sysfs file)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"LSM9DS0 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE	"lsm9ds0_gyr"			// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/pollrate_ms"				// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/enable_device"				// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/range"					// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f*(float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			200					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		6.1f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define MAG_DEFAULT_RANGE		8					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define MAG_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define MAG_GBIAS_THRESHOLD		1471e-6					// Set magnetometer gbias threshold [uT] - Default value for LSM303DLHC: 1200e-6
+#define GYR_GBIAS_THRESHOLD		1491e-6					// Set gyroscope gbias threshold [uT] - Default value for L3G4200D: 400e-6
+#define ACC_GBIAS_THRESHOLD		765e-6					// Set acceleration bias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(20)
+#define GYRO_STARTUP_TIME_MS		(200)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_MAG			EV_MSC
+#define EVENT_TYPE_GYRO			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ -1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ -1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, -1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ -1, 0, 0 },
+				{ 0, -1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH/1000000.0f)	// 1000mg = 9.86 m/s^2
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of magnetic data to uT units
+#define CONVERT_M			(0.0001f)		// 1uTESLA = 10 mGauss
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD				((float)M_PI/180.0f)
+#define G_SENSITIVITY			(1.0f) //Already applied into the driver
+#define CONVERT_GYRO			(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#endif	/*	CONFIGURATION_LSM9DS0_H	*/
diff --git a/conf/conf_LSM9DS1.h b/conf/conf_LSM9DS1.h
new file mode 100644
index 0000000..3e00885
--- /dev/null
+++ b/conf/conf_LSM9DS1.h
@@ -0,0 +1,209 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_LSM9DS1_H
+#define CONFIGURATION_LSM9DS1_H
+
+#define SENSORS_ACCELEROMETER_ENABLE		(1)
+#define SENSORS_GYROSCOPE_ENABLE		(1)
+#define SENSORS_MAGNETIC_FIELD_ENABLE		(1)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(1 & SENSORS_GYROSCOPE_ENABLE & OS_VERSION_ENABLE)
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE	(1 & SENSORS_MAGNETIC_FIELD_ENABLE & OS_VERSION_ENABLE)
+
+/* ACCELEROMETER SENSOR */
+#define SENSOR_ACC_LABEL		"LSM9DS1 3-axis Accelerometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_ACCELEROMETER	"lsm9ds1_acc"				// Name of input device: struct input_dev->name
+#define ACCEL_DELAY_FILE_NAME		"device/accelerometer/pollrate_ms"	// name of sysfs file for setting the pollrate
+#define ACCEL_ENABLE_FILE_NAME		"device/accelerometer/enable_device"	// name of sysfs file for enable/disable the sensor state
+#define ACCEL_RANGE_FILE_NAME		"device/accelerometer/range"		// name of sysfs file for setting the full scale
+#define ACCEL_MAX_RANGE			8 * GRAVITY_EARTH			// Set Max Full-scale [m/s^2]
+#define ACCEL_MAX_ODR			952					// Set Max value of ODR [Hz]
+#define ACCEL_MIN_ODR			1					// Set Min value of ODR [Hz]
+#define ACCEL_POWER_CONSUMPTION		0.6f					// Set sensor's power consumption [mA]
+#define ACCEL_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+
+/* MAGNETOMETER SENSOR */
+#define SENSOR_MAGN_LABEL		"LSM9DS1 3-axis Magnetometer Sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_MAGNETIC_FIELD	"lsm9ds1_mag"				// Name of input device: struct input_dev->name
+#define MAGN_DELAY_FILE_NAME		"device/pollrate_ms"			// name of sysfs file for setting the pollrate
+#define MAGN_ENABLE_FILE_NAME		"device/enable_device"			// name of sysfs file for enable/disable the sensor state
+#define MAGN_RANGE_FILE_NAME		"device/range"				// name of sysfs file for setting the full scale
+#define MAGN_MAX_RANGE			810.0f					// Set Max Full-scale [uT]
+#define MAGN_MAX_ODR			80					// Set Max value of ODR [Hz]
+#define MAGN_MIN_ODR			1					// Set Max value of ODR [Hz]
+#define MAGN_POWER_CONSUMPTION		0.6f					// Set sensor's power consumption [mA]
+#define MAGN_DEFAULT_FULLSCALE		4					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MGAUS(x)			(x / 1000.0f)
+
+/* GYROSCOPE SENSOR */
+#define SENSOR_GYRO_LABEL		"LSM9DS1 3-axis Gyroscope sensor"	// Label views in Android Applications
+#define SENSOR_DATANAME_GYROSCOPE	"lsm9ds1_gyr"				// Name of input device: struct input_dev->name
+#define GYRO_DELAY_FILE_NAME		"device/gyroscope/pollrate_ms"		// name of sysfs file for setting the pollrate
+#define GYRO_ENABLE_FILE_NAME		"device/gyroscope/enable_device"	// name of sysfs file for enable/disable the sensor state
+#define GYRO_RANGE_FILE_NAME		"device/gyroscope/range"		// name of sysfs file for setting the full scale
+#define GYRO_MAX_RANGE			(2000.0f * (float)M_PI/180.0f)		// Set Max Full-scale [rad/sec]
+#define GYRO_MAX_ODR			952					// Set Max value of ODR [Hz]
+#define GYRO_MIN_ODR			1					// Set Max value of ODR [Hz]
+#define GYRO_POWER_CONSUMPTION		4.0f					// Set sensor's power consumption [mA]
+#define GYRO_DEFAULT_FULLSCALE		2000					// Set default full-scale (value depends on the driver sysfs file)
+#define TO_MDPS(x)			(x / 1000000.0f)
+
+/* INEMO_ENGINE SENSOR */
+#define GYRO_DEFAULT_RANGE		2000					// full scale set to 2000 DPS (value depends on the driver sysfs file)
+#define ACC_DEFAULT_RANGE		4					// full scale set to 8g (value depends on the driver sysfs file)
+#define MAG_DEFAULT_RANGE		4					// full scale set to +-2.5Gauss (value depends on the driver sysfs file)
+#define ACC_DEFAULT_DELAY		10					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define MAG_DEFAULT_DELAY		14					// 1/frequency (default: 10 -> 100 Hz) [ms]
+#define GYR_DEFAULT_DELAY		10					// 1/frequency (default: 9.523809f -> 105 Hz) [ms]
+
+/* SENSOR FUSION */
+#define LOCAL_EARTH_MAGNETIC_FIELD	50.0f					// Value of local earth magnetic field [uT]
+#define ACC_GBIAS_THRESHOLD		550e-6					// Set acceleration gbias threshold
+#define MAG_GBIAS_THRESHOLD		1200e-6					// Set magnetometer gbias threshold
+#define GYR_GBIAS_THRESHOLD		475e-6					// Set gyroscope gbias threshold
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD	(0)
+#define GYRO_STARTUP_TIME_MS		(0)
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_ACCEL		EV_MSC
+#define EVENT_TYPE_MAG			EV_MSC
+#define EVENT_TYPE_GYRO			EV_MSC
+
+/* Event Type in accelerometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_ACCEL_X		MSC_SERIAL
+#define EVENT_TYPE_ACCEL_Y		MSC_PULSELED
+#define EVENT_TYPE_ACCEL_Z		MSC_GESTURE
+
+/* Event Type in magnetometer sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_MAG_X		MSC_SERIAL
+#define EVENT_TYPE_MAG_Y		MSC_PULSELED
+#define EVENT_TYPE_MAG_Z		MSC_GESTURE
+
+/* Event Type in gyroscope sensor: see input_set_abs_params() function in your input driver */
+#define EVENT_TYPE_GYRO_X		MSC_SERIAL
+#define EVENT_TYPE_GYRO_Y		MSC_PULSELED
+#define EVENT_TYPE_GYRO_Z		MSC_GESTURE
+
+#define EVENT_TYPE_TIME_MSB		MSC_SCAN
+#define EVENT_TYPE_TIME_LSB		MSC_MAX
+
+/*****************************************************************************/
+/* AXIS MAPPING */
+/*****************************************************************************/
+
+/* In this section you must define the axis mapping for individuate one only coordinate system ENU
+ *
+ * Example:
+ *                                                 y'     /| z'
+ *                                                  ^   /
+ *                                                  |  /       You must define this coordinate system (reference system of board)
+ *                                                  | /        in accordance to definition of the axis
+ *                                                  |/         definition in sensors.h file
+ *   +----------------------------------------------+---------> x'
+ *   |          ^ x                                 |
+ *   |          |                       ^ z         |
+ *   |          |                       |           |
+ *   |    +-----+---> y                 |           |
+ *   |    | ACC |             <---+-----+           |
+ *   |    |     |             x   | GYR |           |
+ *   |    +-----+                 |     |           |
+ *   |   /                        +-----+           |
+ *   | |/       y ^  /| z              /            |
+ *   |  z         | /                |/             |
+ *   |            |/                   y            |
+ *   |      +-----+---> x                           |
+ *   |      | MAG |                                 |
+ *   |      |     |                                 |
+ *   |      +-----+                                 |
+ *   |                                        BOARD |
+ *   +----------------------------------------------+
+ *
+ *
+ *   ACCELEROMETER:
+ *
+ *     board        acc     |  0  1  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  0 -1 |
+ *
+ *   MAGNETOMETER:
+ *
+ *     board        mag     |  1  0  0 |
+ *   [x' y' z'] = [x y z] * |  0  0  1 |
+ *                          |  0  0  1 |
+ *
+ *   GYROSCOPE:
+ *
+ *     board        gyr     | -1  0  0 |
+ *   [x' y' z'] = [x y z] * |  1  0  0 |
+ *                          |  0  -1 0 |
+ *
+*/
+static short matrix_acc[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_mag[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+static short matrix_gyr[3][3] = {
+				{ 1, 0, 0 },
+				{ 0, 1, 0 },
+				{ 0, 0, 1 }
+				};
+
+/*****************************************************************************/
+/* DATA CONVERSION */
+/*****************************************************************************/
+// conversion of acceleration data to SI units (m/s^2)
+#define CONVERT_A			(GRAVITY_EARTH / 1000000.0f)
+#define CONVERT_A_X 			(CONVERT_A)
+#define CONVERT_A_Y			(CONVERT_A)
+#define CONVERT_A_Z			(CONVERT_A)
+
+// conversion of magnetic data to uT units
+#define CONVERT_M			(1.0f/10000.0f)
+#define CONVERT_M_X			(CONVERT_M)
+#define CONVERT_M_Y			(CONVERT_M)
+#define CONVERT_M_Z			(CONVERT_M)
+
+/**
+ * Conversion of gyro data to SI units (radian/sec)
+ * FS = 2000dps, sensitivity conversion applied into the driver.
+ * Driver output as udps
+ */
+#define DPS2RAD				((float)M_PI/180.0f)
+#define G_SENSITIVITY			(1.0f) //Already applied into the driver
+#define CONVERT_GYRO			(DPS2RAD * (G_SENSITIVITY / (1000.0f * 1000.0f)))
+#define CONVERT_GYRO_X			(CONVERT_GYRO)
+#define CONVERT_GYRO_Y			(CONVERT_GYRO)
+#define CONVERT_GYRO_Z			(CONVERT_GYRO)
+
+#define MAG_EVENT_HAS_TIMESTAMP		1
+#define ACC_EVENT_HAS_TIMESTAMP		1
+#define GYRO_EVENT_HAS_TIMESTAMP	1
+
+#endif	/*	CONFIGURATION_LSM9DS1_H	*/
diff --git a/conf/conf_MAGCALIB.h b/conf/conf_MAGCALIB.h
new file mode 100644
index 0000000..6971f04
--- /dev/null
+++ b/conf/conf_MAGCALIB.h
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Giuseppe Barba, Alberto Marinoni - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_MAGCAL_H
+#define CONFIGURATION_MAGCAL_H
+
+#define MAG_CALIBRATION_ENABLE	(1 & ST_MAG_CALIB_MODULE_PRESENT & SENSORS_MAGNETIC_FIELD_ENABLE)
+#define CALIBRATION_FREQUENCY	(25)
+#define CALIBRATION_PERIOD_MS	(1000.0f / CALIBRATION_FREQUENCY)
+
+#endif /* CONFIGURATION_MAGCAL_H */
+ 
diff --git a/conf/conf_MLX90614.h b/conf/conf_MLX90614.h
new file mode 100644
index 0000000..a4a15a0
--- /dev/null
+++ b/conf/conf_MLX90614.h
@@ -0,0 +1,42 @@
+/*
+ *  MELEXIS IR thermal sensor HAL layer
+ *
+ *  Copyright (c) 2020 ID TECH.
+ *  Author: Jay Deng <jay.deng@idtechproducts.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef CONFIGURATION_SENSOR_MLX90614_H
+#define CONFIGURATION_SENSOR_MLX90614_H
+
+#define SENSORS_BODY_TEMP_ENABLE	(1)
+
+#define SENSOR_THERMAL_VENDOR		"Melexis"
+#define SENSOR_THERMAL_LABEL		"IR thermal sensor"
+#define SENSOR_FILE_PATH		"/sys/bus/iio/devices/iio:device0/"
+#define SENSOR_BODY_TEMP_LABEL		"MLX90614 IR Temperature sensor"
+#define SENSOR_AMBIENT_TEMP		"in_temp_ambient_raw"
+#define SENSOR_OBJECT_TEMP_0		"in_temp_object_raw"
+#define SENSOR_OBJECT_TEMP_1		"in_temp1_object_raw"
+#define SENSOR_OBJECT_TEMP		"mlx90614"
+
+#define SENSOR_OBJ_TEMP1_CALIBEMISSIVITY_FILE	"in_temp1_object_calibemissivity"
+#define SENSOR_OBJ_TEMP1_LOW_PASS_FREQ_FILE	"in_temp1_object_filter_low_pass_3db_frequency"
+#define SENSOR_OBJ_TEMP0_CALIBEMISSIVITY_FILE	"in_temp_object_calibemissivity"
+#define SENSOR_OBJ_TEMP0_LOW_PASS_FREQ_FILE	"in_temp_object_filter_low_pass_3db_frequency"
+#define SENSOR_TEMP_OFFSET_FILE			"in_temp_offset"
+#define SENSOR_TEMP_SCALE_FILE			"in_temp_scale"
+#define SENSOR_LOW_PASS_AVAILABLE_RANGE_FILE	"in_temp_object_filter_low_pass_3db_frequency_available"
+
+#define SENSOR_AMBIENT_MAX_RANGE	165	//Celsius -40 ~ 125
+#define SENSOR_OBJECT_MAX_RANGE		450	//Celsius -70 ~ 380
+#define SENSOR_TEMP_OFFSET		(-13657)
+#define SENSOR_POWER_CONSUMPTION	2.5f	// mA
+#define SENSOR_DEGREE_PER_UNIT		0.02f
+#define SENSOR_CMD_MIN_FREQ		100000	// microseconds
+#define SENSOR_CMD_MAX_FREQ		200000	// miscroseconds
+
+#endif /* CONFIGURATION_SENSOR_MLX90614_H */
diff --git a/conf/conf_VCNL4200.h b/conf/conf_VCNL4200.h
new file mode 100644
index 0000000..f829541
--- /dev/null
+++ b/conf/conf_VCNL4200.h
@@ -0,0 +1,36 @@
+/*
+ *  VCNL 4200 sensor HAL layer
+ *
+ *  Copyright (c) 2021 ID TECH.
+ *  Author: Jay Deng <jay.deng@idtechproducts.com>
+ *
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
+ */
+
+#ifndef CONFIGURATION_SENSOR_VCNL4200_H
+#define CONFIGURATION_SENSOR_VCNL4200_H
+
+#define SENSORS_PROXIMITY_ENABLE	(1)
+#define SENSORS_PROX_INC_LIGHT		(1)
+
+#define SENSOR_VENDOR_NAME		"Vishay"
+#define SENSOR_PRX_LABEL		"VCNL4200 Proximity"
+#define SENSOR_DATANAME_PROXIMITY	"vcnl4000-proximity"
+#define PROXIMITY_DELAY_FILE_NAME	"device/pollrate_ms"
+#define PROXIMITY_ENABLE_FILE_NAME	"device/enable_device"
+#define PROXIMITY_RANGE_FILE_NAME	"device/range"
+#define PROXIMITY_MAX_RANGE	150		// Set Max Full-scale [centimeters]
+#define PROXIMITY_MAX_ODR	1		// Set Max value of ODR [Hz]
+#define PROXIMITY_MIN_ODR	2		// Set Min value of ODR [Hz]
+#define PROXIMITY_POWER_CONSUMPTION 0.016f	// Set sensor's power consumption [mA]
+
+#define SENSOR_PRX_LIGHT_LABEL		"VCNL4200 Light"
+#define SENSOR_DATANAME_PROXIMITY_LIGHT	"vcnl4000-light"
+#define PROXIMITY_LIGHT_MAX_RANGE	150		// Set Max Full-scale [centimeters]
+#define PROXIMITY_LIGHT_MAX_ODR		1		// Set Max value of ODR [Hz]
+#define PROXIMITY_LIGHT_MIN_ODR		2		// Set Min value of ODR [Hz]
+#define PROXIMITY_LIGHT_POWER_CONSUMPTION 	0.016f	// Set sensor's power consumption [mA]
+
+#endif /* CONFIGURATION_SENSOR_VCNL4200_H */
diff --git a/conf/conf_VGYRO.h b/conf/conf_VGYRO.h
new file mode 100644
index 0000000..b0176bc
--- /dev/null
+++ b/conf/conf_VGYRO.h
@@ -0,0 +1,37 @@
+/*
+ * Copyright (C) 2014 STMicroelectronics
+ * Matteo Dameno, Ciocca Denis, Giuseppe Barba - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+#ifndef CONFIGURATION_VGYRO_H
+#define CONFIGURATION_VGYRO_H
+
+#define SENSORS_VIRTUAL_GYROSCOPE_ENABLE	(1 && SENSORS_ACCELEROMETER_ENABLE && SENSORS_MAGNETIC_FIELD_ENABLE && !SENSORS_GYROSCOPE_ENABLE && GEOMAG_FUSION_MODULE_PRESENT)
+#define SENSORS_UNCALIB_GYROSCOPE_ENABLE	(0)
+
+#define SENSOR_VIRTUAL_GYRO_LABEL		"STMicroelectronics VGyroscope sensor"
+#define VIRTUAL_GYRO_MAX_RANGE			(2000)
+#define VIRTUAL_GYRO_POWER_CONSUMPTION		(ACCEL_POWER_CONSUMPTION + MAGN_POWER_CONSUMPTION)
+#define VIRTUAL_GYRO_MAX_ODR			100
+#define VIRTUAL_GYRO_DEFAULT_FULLSCALE		2000
+#define VGYRO_DEFAULT_DELAY			10
+
+/* GYROSCOPE STARTUP */
+#define DEFAULT_SAMPLES_TO_DISCARD		(0)
+#define GYRO_STARTUP_TIME_MS			(0)
+
+#endif /* CONFIGURATION_VGYRO_H */
diff --git a/conf/conf_VL53L1X.h b/conf/conf_VL53L1X.h
new file mode 100644
index 0000000..87d5f53
--- /dev/null
+++ b/conf/conf_VL53L1X.h
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2015 STMicroelectronics
+ * Armando Visconti - Motion MEMS Product Div.
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef CONFIGURATION_SENSOR_VL53L1X_H
+#define CONFIGURATION_SENSOR_VL53L1X_H
+
+#define SENSORS_PROXIMITY_ENABLE		(1)
+
+#define SENSOR_PRX_LABEL		"VL53L1X Proximity"
+#define SENSOR_DATANAME_PROXIMITY	"vl53l1x_prx"
+#define PROXIMITY_DELAY_FILE_NAME		"device/pollrate_ms"
+#define PROXIMITY_ENABLE_FILE_NAME		"device/enable_device"
+#define PROXIMITY_RANGE_FILE_NAME		"device/range"
+#define PROXIMITY_MAX_RANGE		400					// Set Max Full-scale [centimeters]
+#define PROXIMITY_MAX_ODR		66					// Set Max value of ODR [Hz]
+#define PROXIMITY_MIN_ODR		2					// Set Min value of ODR [Hz]
+#define PROXIMITY_POWER_CONSUMPTION	0.016f					// Set sensor's power consumption [mA]
+
+
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+#define EVENT_TYPE_PRX				EV_MSC
+#define EVENT_TYPE_PRX_DISTANCE		MSC_SERIAL
+
+
+#endif /* CONFIGURATION_SENSOR_VL53L1X_H */
diff --git a/configuration.h b/configuration.h
new file mode 100644
index 0000000..8a81a61
--- /dev/null
+++ b/configuration.h
@@ -0,0 +1,294 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+
+/*
+ * Library Version: 2.0.0
+ */
+
+#ifndef CONFIGURATION_HAL_H
+#define CONFIGURATION_HAL_H
+
+/* ANDROID API VERSION */
+#define ANDROID_ICS				(14)
+#define ANDROID_JB				(16)
+#define ANDROID_JBMR2				(18)
+#define ANDROID_KK				(19)
+#define ANDROID_L				(21)
+#define ANDROID_M				(23)
+#define ANDROID_N				(24)
+#define ANDROID_O				(26)
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+  #define OS_VERSION_ENABLE			(1)
+#else
+  #define OS_VERSION_ENABLE			(0)
+#endif
+
+#if defined(LSM330D)
+  #include "conf_LSM330D.h"
+#endif
+#if defined(LSM330DLC)
+  #include "conf_LSM330DLC.h"
+#endif
+#if defined(LSM330)
+  #include "conf_LSM330.h"
+#endif
+#if defined(LIS2MDL)
+  #include "conf_LIS2MDL.h"
+#endif
+#if defined(LIS3MDL)
+  #include "conf_LIS3MDL.h"
+#endif
+#if defined(LIS3DH)
+  #include "conf_LIS3DH.h"
+#endif
+#if defined(LIS3DHH)
+  #include "conf_LIS3DHH.h"
+#endif
+#if defined(LSM6DS0)
+  #include "conf_LSM6DS0.h"
+#endif
+#if defined(LSM6DS3)
+  #include "conf_LSM6DS3.h"
+#endif
+#if defined(LSM6DSM)
+  #include "conf_LSM6DSM.h"
+#endif
+#if defined(LSM6DSL)
+  #include "conf_LSM6DSL.h"
+#endif
+#if defined(LSM9DS0)
+  #include "conf_LSM9DS0.h"
+#endif
+#if defined(LSM9DS1)
+  #include "conf_LSM9DS1.h"
+#endif
+#if defined(LSM303AGR)
+#include "conf_LSM303AGR.h"
+#endif
+#if defined(LSM303AH)
+#include "conf_LSM303AH.h"
+#endif
+#if defined(LSM303C)
+  #include "conf_LSM303C.h"
+#endif
+#if defined(LSM303D)
+  #include "conf_LSM303D.h"
+#endif
+#if defined(LSM303DLHC)
+  #include "conf_LSM303DLHC.h"
+#endif
+#if defined(L3GD20H)
+  #include "conf_L3GD20H.h"
+#endif
+#if defined(LIS2DH12)
+  #include "conf_LIS2DH12.h"
+#endif
+#if defined(LIS2DS12)
+  #include "conf_LIS2DS12.h"
+#endif
+#if defined(LIS2DE12)
+  #include "conf_LIS2DE12.h"
+#endif
+#if defined(LIS2HH12)
+  #include "conf_LIS2HH12.h"
+#endif
+#if defined(L3GD20)
+  #include "conf_L3GD20.h"
+#endif
+#if defined(LIS2DW12)
+  #include "conf_LIS2DW12.h"
+#endif
+#if defined(LPS22HB)
+  #include "conf_LPS22HB.h"
+#endif
+#if defined(LPS22HD)
+  #include "conf_LPS22HD.h"
+#endif
+#if defined(LPS33HW)
+  #include "conf_LPS33HW.h"
+#endif
+#if defined(LPS25H)
+  #include "conf_LPS25H.h"
+#endif
+#if defined(HTS221)
+  #include "conf_HTS221.h"
+#endif
+
+/* Automotive */
+#if defined(ASM330LXH)
+  #include "conf_ASM330LXH.h"
+#endif
+#if defined(ASM330LHH)
+  #include "conf_ASM330LHH.h"
+#endif
+#if defined(AIS328DQ)
+  #include "conf_AIS328DQ.h"
+#endif
+#if defined(A3G4250D)
+  #include "conf_A3G4250D.h"
+#endif
+
+/* Industrial */
+#if defined(ISM330DLC)
+  #include "conf_ISM330DLC.h"
+#endif
+#if defined(IIS2MDC)
+  #include "conf_IIS2MDC.h"
+#endif
+#if defined(IIS2DH)
+  #include "conf_IIS2DH.h"
+#endif
+#if defined(ISM303DAC)
+  #include "conf_ISM303DAC.h"
+#endif
+#if defined(IIS3DHHC)
+  #include "conf_IIS3DHHC.h"
+#endif
+
+#if defined(SENSOR_FUSION)
+  #include "conf_FUSION.h"
+#endif
+#if defined(SENSOR_ST_COMPASS)
+  #include "conf_COMPASS.h"
+#endif
+#if defined(V_GYRO)
+  #include "conf_VGYRO.h"
+#endif
+#if defined(GEOMAG_FUSION)
+  #include "conf_GEOMAG.h"
+#endif
+#if defined(GBIAS)
+  #include "conf_GBIAS.h"
+#endif
+#if defined(MAGCALIB)
+  #include "conf_MAGCALIB.h"
+#endif
+#if defined(ACT_RECO)
+  #include "conf_ACT_RECO.h"
+#endif
+#if defined(FILE_CALIB)
+  #include "conf_FILE_CALIB.h"
+#endif
+#if defined(VL53L1X)
+  #include "conf_VL53L1X.h"
+#endif
+#if defined(MLX90614)
+  #include "conf_MLX90614.h"
+#endif
+#if defined(VCNL4200)
+  #include "conf_VCNL4200.h"
+#endif
+
+#ifdef SENSORS_ORIENTATION_ENABLE
+ #if (SENSORS_ORIENTATION_ENABLE == 1)
+  #undef GEOMAG_COMPASS_ORIENTATION_ENABLE
+  #define GEOMAG_COMPASS_ORIENTATION_ENABLE (0)
+ #endif
+#endif
+
+#if (SENSORS_GRAVITY_ENABLE == 1)
+#undef GEOMAG_GRAVITY_ENABLE
+#define GEOMAG_GRAVITY_ENABLE (0)
+#endif
+
+#if (SENSORS_LINEAR_ACCELERATION_ENABLE == 1)
+#undef GEOMAG_LINEAR_ACCELERATION_ENABLE
+#define GEOMAG_LINEAR_ACCELERATION_ENABLE (0)
+#endif
+
+#ifndef SENSORS_GYROSCOPE_ENABLE
+  #define SENSORS_GYROSCOPE_ENABLE 		(0)
+#endif
+
+#ifndef SENSORS_ACCELEROMETER_ENABLE
+  #define SENSORS_ACCELEROMETER_ENABLE 		(0)
+#endif
+
+#ifndef SENSORS_MAGNETIC_FIELD_ENABLE
+  #define SENSORS_MAGNETIC_FIELD_ENABLE 	(0)
+#endif
+
+#ifndef SENSORS_PRESSURE_ENABLE
+  #define SENSORS_PRESSURE_ENABLE 		(0)
+#endif
+
+/* Sensors power consumption */
+#if (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)
+  #define UNCALIB_GYRO_POWER_CONSUMPTION 	(GYRO_POWER_CONSUMPTION + ACCEL_POWER_CONSUMPTION)
+#else
+  #define UNCALIB_GYRO_POWER_CONSUMPTION 	(GYRO_POWER_CONSUMPTION + MAGN_POWER_CONSUMPTION + ACCEL_POWER_CONSUMPTION)
+#endif
+
+#define SENSORS_TEMPERATURE_ENABLE	(SENSORS_TEMP_RH_ENABLE || SENSORS_TEMP_PRESS_ENABLE)
+
+/* DEBUG INFORMATION */
+#define DEBUG_ACCELEROMETER			(0)
+#define DEBUG_MAGNETOMETER			(0)
+#define DEBUG_GYROSCOPE				(0)
+#define DEBUG_INEMO_SENSOR			(0)
+#define DEBUG_PRESSURE_SENSOR			(0)
+#define DEBUG_CALIBRATION			(0)
+#define DEBUG_MAG_SI_COMPENSATION		(0)
+#define DEBUG_VIRTUAL_GYROSCOPE			(0)
+#define DEBUG_TILT				(0)
+#define DEBUG_STEP_C				(0)
+#define DEBUG_STEP_D				(0)
+#define DEBUG_SIGN_M				(0)
+#define DEBUG_POLL_RATE				(0)
+#define DEBUG_ACTIVITY_RECO			(0)
+#define DEBUG_LIGHT_SENSOR                      (0)
+#define DEBUG_PROXIMITY_SENSOR                  (0)
+
+#if (ANDROID_VERSION >= ANDROID_JB)
+  #define STLOGI(...)				ALOGI(__VA_ARGS__)
+  #define STLOGE(...)				ALOGE(__VA_ARGS__)
+  #define STLOGD(...)				ALOGD(__VA_ARGS__)
+  #define STLOGD_IF(...)			ALOGD_IF(__VA_ARGS__)
+  #define STLOGE_IF(...)			ALOGE_IF(__VA_ARGS__)
+#else
+  #define STLOGI(...)				LOGI(__VA_ARGS__)
+  #define STLOGE(...)				LOGE(__VA_ARGS__)
+  #define STLOGD(...)				LOGD(__VA_ARGS__)
+  #define STLOGD_IF(...)			LOGD_IF(__VA_ARGS__)
+  #define STLOGE_IF(...)			LOGE_IF(__VA_ARGS__)
+#endif
+
+#if !defined(ACCEL_MIN_ODR)
+  #define ACCEL_MIN_ODR				1
+#endif
+#if !defined(MAGN_MIN_ODR)
+  #define MAGN_MIN_ODR				1
+#endif
+#if !defined(GYRO_MIN_ODR)
+  #define GYRO_MIN_ODR				1
+#endif
+#if !defined(ORIENTATION_MIN_ODR)
+  #define ORIENTATION_MIN_ODR			1
+#endif
+#if !defined(FUSION_MIN_ODR)
+  #define FUSION_MIN_ODR			1
+#endif
+#if !defined(PRESS_TEMP_MIN_ODR)
+  #define PRESS_TEMP_MIN_ODR			1
+#endif
+#if !defined(VIRTUAL_GYRO_MIN_ODR)
+  #define VIRTUAL_GYRO_MIN_ODR			1
+#endif
+#endif	/*	CONFIGURATION_HAL_H	*/
diff --git a/iNemoEngineSensor.cpp b/iNemoEngineSensor.cpp
new file mode 100644
index 0000000..ff2b0d1
--- /dev/null
+++ b/iNemoEngineSensor.cpp
@@ -0,0 +1,677 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSOR_FUSION_ENABLE == 1)
+
+#include <fcntl.h>
+#include <errno.h>
+#include <math.h>
+#include <poll.h>
+#include <unistd.h>
+#include <dirent.h>
+#include <sys/select.h>
+#include <cutils/log.h>
+#include <linux/time.h>
+#include <string.h>
+#include "iNemoEngineSensor.h"
+
+#define FETCH_FULL_EVENT_BEFORE_RETURN		0
+
+/*****************************************************************************/
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+MagnSensor* iNemoEngineSensor::mag = NULL;
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+AccelSensor* iNemoEngineSensor::acc = NULL;
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+GyroSensor* iNemoEngineSensor::gyr = NULL;
+#endif
+int iNemoEngineSensor::status = 0;
+int iNemoEngineSensor::mEnabled = 0;
+int iNemoEngineSensor::startup_samples = DEFAULT_SAMPLES_TO_DISCARD;
+int iNemoEngineSensor::samples_to_discard = DEFAULT_SAMPLES_TO_DISCARD;
+int iNemoEngineSensor::DecimationBuffer[numSensors] = {0};
+int iNemoEngineSensor::DecimationCount[numSensors] = {0};
+int64_t iNemoEngineSensor::DelayBuffer[numSensors] = {0};
+int64_t iNemoEngineSensor::gyroDelay_ms = GYR_DEFAULT_DELAY;
+
+struct timespec old_time, new_time;
+
+
+int64_t timespecDiff(struct timespec *timeA_p, struct timespec *timeB_p)
+{
+	int64_t timeAft;
+	int64_t timeBef;
+	int64_t timeDiff;
+
+	timeBef = (int64_t)((int64_t)(timeB_p->tv_sec * 1000000000L) + timeB_p->tv_nsec);
+	timeAft = (int64_t)((int64_t)(timeA_p->tv_sec * 1000000000L) + timeA_p->tv_nsec);
+
+	if (timeAft > timeBef)
+		timeDiff = timeAft - timeBef;
+	else
+		timeDiff = timeBef - timeAft;
+
+	return (int64_t)timeDiff;
+}
+
+iNemoEngineSensor::iNemoEngineSensor()
+#if (!SENSORS_GYROSCOPE_ENABLE && SENSORS_VIRTUAL_GYROSCOPE_ENABLE)
+        : SensorBase(NULL, SENSOR_DATANAME_ACCELEROMETER),
+#else
+        : SensorBase(NULL, SENSOR_DATANAME_GYROSCOPE),
+#endif
+	mPendingMask(0),
+	mInputReader(4),
+	mHasPendingEvent(false)
+{
+	memset(mPendingEvents, 0, sizeof(mPendingEvents));
+	memset(mSensorsBufferedVectors, 0, sizeof(sensors_vec_t) * 3);
+	memset(DecimationCount, 0, sizeof(DecimationCount));
+
+#if (SENSORS_ORIENTATION_ENABLE == 1)
+	mPendingEvents[Orientation].version = sizeof(sensors_event_t);
+	mPendingEvents[Orientation].sensor = ID_ORIENTATION;
+	mPendingEvents[Orientation].type = SENSOR_TYPE_ORIENTATION;
+	mPendingEvents[Orientation].orientation.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+#if (SENSORS_GRAVITY_ENABLE == 1)
+	mPendingEvents[Gravity].version = sizeof(sensors_event_t);
+	mPendingEvents[Gravity].sensor = ID_GRAVITY;
+	mPendingEvents[Gravity].type = SENSOR_TYPE_GRAVITY;
+	mPendingEvents[Gravity].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+#if (SENSORS_LINEAR_ACCELERATION_ENABLE == 1)
+	mPendingEvents[LinearAcceleration].version = sizeof(sensors_event_t);
+	mPendingEvents[LinearAcceleration].sensor = ID_LINEAR_ACCELERATION;
+	mPendingEvents[LinearAcceleration].type = SENSOR_TYPE_LINEAR_ACCELERATION;
+	mPendingEvents[LinearAcceleration].acceleration.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+#if (SENSORS_ROTATION_VECTOR_ENABLE == 1)
+	mPendingEvents[RotationMatrix].version = sizeof(sensors_event_t);
+	mPendingEvents[RotationMatrix].sensor = ID_ROTATION_VECTOR;
+	mPendingEvents[RotationMatrix].type = SENSOR_TYPE_ROTATION_VECTOR;
+#endif
+#if (SENSORS_GAME_ROTATION_ENABLE == 1)
+	mPendingEvents[GameRotation].version = sizeof(sensors_event_t);
+	mPendingEvents[GameRotation].sensor = ID_GAME_ROTATION;
+	mPendingEvents[GameRotation].type = SENSOR_TYPE_GAME_ROTATION_VECTOR;
+#endif
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+  #if (SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1)
+	mPendingEvents[UncalibGyro].version = sizeof(sensors_event_t);
+	mPendingEvents[UncalibGyro].sensor = ID_UNCALIB_GYROSCOPE;
+	mPendingEvents[UncalibGyro].type = SENSOR_TYPE_GYROSCOPE_UNCALIBRATED;
+	mPendingEvents[UncalibGyro].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+  #endif
+	mPendingEvents[CalibGyro].version = sizeof(sensors_event_t);
+	mPendingEvents[CalibGyro].sensor = ID_GYROSCOPE;
+	mPendingEvents[CalibGyro].type = SENSOR_TYPE_GYROSCOPE;
+	mPendingEvents[CalibGyro].gyro.status = SENSOR_STATUS_ACCURACY_HIGH;
+#endif
+
+	if (data_fd) {
+		STLOGI("iNemoSensor::iNemoSensor main driver device_sysfs_path:(%s)", sysfs_device_path);
+	} else {
+		STLOGE("iNemoSensor::iNemoSensor main driver device_sysfs_path:(%s) not found", sysfs_device_path);
+	}
+
+	init_data_api.GbiasLearningMode = 2;
+	init_data_api.ATime = -1;
+	init_data_api.MTime = -1;
+	init_data_api.PTime = -1;
+	init_data_api.FrTime = -1;
+	init_data_api.gbias_file = NULL;
+	init_data_api.LocalEarthMagField = 50.0f;
+	init_data_api.Gbias_threshold_magn = 1200e-6;
+	init_data_api.Gbias_threshold_accel = 1200e-6;
+	init_data_api.Gbias_threshold_gyro = 1200e-6;
+
+	debug_init_data_api.accel_flag = 0;
+	debug_init_data_api.magn_flag = 0;
+	debug_init_data_api.gyro_flag = 0;
+
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	init_data_api.Gbias_threshold_accel = ACC_GBIAS_THRESHOLD;
+	debug_init_data_api.accel_flag = 1;
+	iNemoEngineSensor::acc = new AccelSensor();
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	init_data_api.Gbias_threshold_magn = MAG_GBIAS_THRESHOLD;
+	debug_init_data_api.magn_flag = 1;
+	iNemoEngineSensor::mag = new MagnSensor();
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	debug_init_data_api.gyro_flag = 1;
+	init_data_api.Gbias_threshold_gyro = GYR_GBIAS_THRESHOLD;
+	iNemoEngineSensor::gyr = new GyroSensor();
+#endif
+	if (iNemoEngine_API_Initialization(&init_data_api, &debug_init_data_api) < 0)
+		STLOGE("iNemoSensor:: Failed to initialize iNemoEngineAPI library");
+}
+
+iNemoEngineSensor::~iNemoEngineSensor()
+{
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	iNemoEngineSensor::gyr->~GyroSensor();
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	iNemoEngineSensor::mag->~MagnSensor();
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	iNemoEngineSensor::acc->~AccelSensor();
+#endif
+}
+
+int iNemoEngineSensor::setInitialState()
+{
+	startup_samples = samples_to_discard;
+
+	return 0;
+}
+
+int iNemoEngineSensor::getWhatFromHandle(int32_t handle)
+{
+	int what = -1;
+
+	switch(handle) {
+#if (SENSORS_ORIENTATION_ENABLE == 1)
+		case SENSORS_ORIENTATION_HANDLE:
+			what = Orientation;
+			break;
+#endif
+#if (SENSORS_GRAVITY_ENABLE == 1)
+		case SENSORS_GRAVITY_HANDLE:
+			what = Gravity;
+			break;
+#endif
+#if (SENSORS_LINEAR_ACCELERATION_ENABLE == 1)
+		case SENSORS_LINEAR_ACCELERATION_HANDLE:
+			what = LinearAcceleration;
+			break;
+#endif
+#if (SENSORS_ROTATION_VECTOR_ENABLE == 1)
+		case SENSORS_ROTATION_VECTOR_HANDLE:
+			what = RotationMatrix;
+			break;
+#endif
+#if (SENSORS_GAME_ROTATION_ENABLE == 1)
+		case SENSORS_GAME_ROTATION_HANDLE:
+			what = GameRotation;
+			break;
+#endif
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+  #if (SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1)
+		case SENSORS_UNCALIB_GYROSCOPE_HANDLE:
+			what = UncalibGyro;
+			break;
+  #endif
+		case SENSORS_GYROSCOPE_HANDLE:
+			what = CalibGyro;
+			break;
+#endif
+		default:
+			what = -1;
+			break;
+	}
+
+	return what;
+}
+
+int iNemoEngineSensor::enable(int32_t handle, int en, int  __attribute__((unused))type)
+{
+	int err = 0;
+	int what = -1;
+	static int enabled = 0;
+
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	if (iNemoEngineSensor::gyr->getFd() <= 0)
+		return -1;
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	if (handle != SENSORS_GAME_ROTATION_HANDLE) {
+		if (iNemoEngineSensor::mag->getFd() <= 0)
+			return -1;
+	}
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	if (iNemoEngineSensor::acc->getFd() <= 0)
+		return -1;
+#endif
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if(en) {
+		if(mEnabled == 0) {
+			enabled = 1;
+
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+			if (handle != SENSORS_GAME_ROTATION_HANDLE) {
+				iNemoEngineSensor::mag->enable(SENSORS_SENSOR_FUSION_HANDLE, 1, 1);
+				iNemoEngineSensor::mag->setFullScale(SENSORS_SENSOR_FUSION_HANDLE, MAG_DEFAULT_RANGE);
+			}
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+			iNemoEngineSensor::gyr->enable(SENSORS_SENSOR_FUSION_HANDLE, 1, 1);
+			iNemoEngineSensor::gyr->setFullScale(SENSORS_SENSOR_FUSION_HANDLE, GYRO_DEFAULT_RANGE);
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			iNemoEngineSensor::acc->enable(SENSORS_SENSOR_FUSION_HANDLE, 1, 1);
+			iNemoEngineSensor::acc->setFullScale(SENSORS_SENSOR_FUSION_HANDLE, ACC_DEFAULT_RANGE);
+#endif
+
+		}
+		mEnabled |= (1<<what);
+	} else {
+		int tmp = mEnabled;
+		mEnabled &= ~(1<<what);
+		if((mEnabled == 0)&&(tmp != 0)) {
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+			iNemoEngineSensor::gyr->setFullScale(SENSORS_SENSOR_FUSION_HANDLE, GYRO_DEFAULT_RANGE);
+			iNemoEngineSensor::gyr->enable(SENSORS_SENSOR_FUSION_HANDLE, 0, 1);
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+			if (handle != SENSORS_GAME_ROTATION_HANDLE) {
+				iNemoEngineSensor::mag->setFullScale(SENSORS_SENSOR_FUSION_HANDLE, MAG_DEFAULT_RANGE);
+				iNemoEngineSensor::mag->enable(SENSORS_SENSOR_FUSION_HANDLE, 0, 1);
+			}
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			iNemoEngineSensor::acc->enable(SENSORS_SENSOR_FUSION_HANDLE, 0, 1);
+#endif
+		}
+		setDelay(handle, DELAY_OFF);
+	}
+
+	if ((handle == SENSORS_GAME_ROTATION_HANDLE) ||
+		(handle == SENSORS_GYROSCOPE_HANDLE) ||
+		(handle == SENSORS_UNCALIB_GYROSCOPE_HANDLE))
+	{
+		if ((mEnabled & (1<<GameRotation)) ||
+		    (mEnabled & (1<<UncalibGyro)) ||
+		    (mEnabled & (1<<CalibGyro)))
+		{
+				iNemoEngine_API_enable6X(true);
+#if (DEBUG_INEMO_SENSOR == 1)
+				STLOGD( "iNemoEngineSensor: Fusion 6axis enabled");
+#endif
+		} else {
+				iNemoEngine_API_enable6X(false);
+#if (DEBUG_INEMO_SENSOR == 1)
+				STLOGD( "iNemoEngineSensor: Fusion 6axis disabled");
+#endif
+		}
+	} else {
+		if ((mEnabled & (1<<Orientation)) ||
+			(mEnabled & (1<<Gravity)) ||
+			(mEnabled & (1<<LinearAcceleration)) ||
+			(mEnabled & (1<<RotationMatrix)))
+		{
+			iNemoEngine_API_enable9X(true);
+#if (DEBUG_INEMO_SENSOR == 1)
+			STLOGD( "iNemoEngineSensor: Fusion 9axis enabled");
+#endif
+		} else {
+			iNemoEngine_API_enable9X(false);
+#if (DEBUG_INEMO_SENSOR == 1)
+			STLOGD( "iNemoEngineSensor: Fusion 9axis disabled");
+#endif
+		}
+	}
+
+	if (enabled) {
+		enabled = 0;
+		setInitialState();
+		clock_gettime(CLOCK_MONOTONIC, &old_time);
+	}
+
+	return err;
+}
+
+bool iNemoEngineSensor::hasPendingEvents() const
+{
+	return mHasPendingEvent;
+}
+
+int iNemoEngineSensor::setDelay(int32_t handle, int64_t delay_ns)
+{
+	int err;
+	int what = -1;
+	int64_t delay_ms = NSEC_TO_MSEC(delay_ns);
+	int64_t gyr_delay_ms;
+	int64_t mag_delay_ms;
+	int64_t acc_delay_ms;
+
+	what = getWhatFromHandle(handle);
+	if (what < 0)
+		return what;
+
+	if (delay_ms == NSEC_TO_MSEC(DELAY_OFF)) {
+		delay_ms = 0;
+		gyr_delay_ms = 0;
+		mag_delay_ms = 0;
+		acc_delay_ms = 0;
+	}
+	else{
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		gyr_delay_ms = (int64_t)MSEC_TO_NSEC(GYR_DEFAULT_DELAY);
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+		mag_delay_ms = (int64_t)MSEC_TO_NSEC(MAG_DEFAULT_DELAY);
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		acc_delay_ms = (int64_t)MSEC_TO_NSEC(ACC_DEFAULT_DELAY);
+#endif
+	}
+
+
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		err = iNemoEngineSensor::gyr->setDelay(SENSORS_SENSOR_FUSION_HANDLE, gyr_delay_ms);
+		if(err < 0)
+			return -1;
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+		if (handle != SENSORS_GAME_ROTATION_HANDLE) {
+			err = iNemoEngineSensor::mag->setDelay(SENSORS_SENSOR_FUSION_HANDLE, mag_delay_ms);
+			if(err < 0)
+				return -1;
+		}
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		err = iNemoEngineSensor::acc->setDelay(SENSORS_SENSOR_FUSION_HANDLE, acc_delay_ms);
+		if(err < 0)
+			return -1;
+#endif
+	/**
+	 * The handled sensor is disabled. Set 0 in its setDelayBuffer position
+	 * and update decimation buffer.
+	 */
+
+	DelayBuffer[what] = delay_ms;
+	updateDecimations(gyroDelay_ms);
+
+	return 0;
+}
+
+void iNemoEngineSensor::updateDecimations(int64_t delayms)
+{
+	int kk;
+
+	if (delayms) {
+		samples_to_discard = (int)(GYRO_STARTUP_TIME_MS/delayms)+1;
+		startup_samples = samples_to_discard;
+	}
+
+	// Decimation Definition
+	for(kk = 0; kk < numSensors; kk++)
+	{
+		if (delayms)
+			DecimationBuffer[kk] = DelayBuffer[kk]/delayms;
+		else
+			DecimationBuffer[kk] = 0;
+	}
+
+	memset(DecimationCount, 0, sizeof(DecimationCount));
+
+#if (DEBUG_POLL_RATE == 1)
+	STLOGD("iNemo::Gyro Delay = %lld", delayms);
+	STLOGD("iNemo::DelayBuffer = %lld, %lld, %lld", DelayBuffer[3], DelayBuffer[4], DelayBuffer[5]);
+	STLOGD("iNemo::DelayBuffer = %lld, %lld, %lld", DelayBuffer[6], DelayBuffer[7], DelayBuffer[8]);
+	STLOGD("iNemo::DelayBuffer = %lld", DelayBuffer[9]);
+	STLOGD("iNemo::DecimationBuffer = %d, %d, %d", DecimationBuffer[3], DecimationBuffer[4], DecimationBuffer[5]);
+	STLOGD("iNemo::DecimationBuffer = %d, %d, %d", DecimationBuffer[6], DecimationBuffer[7], DecimationBuffer[8]);
+	STLOGD("iNemo::DecimationBuffer = %d", DecimationBuffer[9]);
+#endif
+}
+
+int iNemoEngineSensor::readEvents(sensors_event_t *data, int count)
+{
+	static int cont = 0;
+	iNemoSensorsData sdata;
+	int64_t timeElapsed;
+	int64_t newGyroDelay_ms = GYR_DEFAULT_DELAY;
+	int err;
+	int numEventReceived = 0;
+	input_event const* event;
+
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+	float gbias[3];
+#endif
+
+	if (count < 1)
+		return -EINVAL;
+
+	if (mHasPendingEvent) {
+		mHasPendingEvent = false;
+	}
+
+	ssize_t n = mInputReader.fill(data_fd);
+	if (n < 0)
+		return n;
+
+#if (FETCH_FULL_EVENT_BEFORE_RETURN)
+	again:
+#endif
+
+	while (count && mInputReader.readEvent(&event)) {
+#if (defined(GYRO_EVENT_HAS_TIMESTAMP) || defined(ACC_EVENT_HAS_TIMESTAMP))
+  #if (!SENSORS_GYROSCOPE_ENABLE && SENSORS_VIRTUAL_GYROSCOPE_ENABLE)
+		if (event->type == EVENT_TYPE_ACCEL) {
+  #else
+		if (event->type == EVENT_TYPE_GYRO) {
+  #endif
+			if (event->code == EVENT_TYPE_TIME_MSB) {
+				timestamp = ((int64_t)(event->value)) << 32;
+			}
+			else if (event->code == EVENT_TYPE_TIME_LSB) {
+				timestamp |= (uint32_t)(event->value);
+			}
+		}
+#endif
+		if(event->type == EV_SYN) {
+
+			if (startup_samples) {
+				startup_samples--;
+#if (DEBUG_INEMO_SENSOR == 1)
+				STLOGD("iNemo::Start-up samples = %d", startup_samples);
+#endif
+				goto no_data;
+			}
+#if !(defined(GYRO_EVENT_HAS_TIMESTAMP) || defined(ACC_EVENT_HAS_TIMESTAMP))
+	timestamp = timevalToNano(event->time);
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	iNemoEngineSensor::gyr->getGyroDelay(&newGyroDelay_ms);
+#else
+	iNemoEngineSensor::acc->getAccDelay(&newGyroDelay_ms);
+#endif
+
+	if((newGyroDelay_ms != gyroDelay_ms) && mEnabled) {
+		updateDecimations(newGyroDelay_ms);
+		gyroDelay_ms = newGyroDelay_ms;
+	}
+
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			AccelSensor::getBufferData(&mSensorsBufferedVectors[Acceleration]);
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+			GyroSensor::getBufferData(&mSensorsBufferedVectors[AngularSpeed]);
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+			MagnSensor::getBufferData(&mSensorsBufferedVectors[MagneticField]);
+#else
+			/* Constant Magnetometer module is passed to the Library when Mag is disabled */
+			mSensorsBufferedVectors[MagneticField].v[0] = 0.0f;
+			mSensorsBufferedVectors[MagneticField].v[1] = 0.7f;
+			mSensorsBufferedVectors[MagneticField].v[2] = 0.7f;
+#endif
+
+			if (mEnabled & ((1<<Orientation) | (1<<Gravity) |
+					(1<<LinearAcceleration) | (1<<GameRotation) |
+					(1<<UncalibGyro) | (1<<RotationMatrix) |
+					(1<<CalibGyro))) {
+				/** Copy accelerometer data [m/s^2] */
+				memcpy(sdata.accel, mSensorsBufferedVectors[Acceleration].v, sizeof(float) * 3);
+
+				/** Copy magnetometer data [uT] */
+				memcpy(sdata.magn, mSensorsBufferedVectors[MagneticField].v, sizeof(float) * 3);
+
+				/** Copy gyroscope data [rad/sec] */
+				memcpy(sdata.gyro, mSensorsBufferedVectors[AngularSpeed].v, sizeof(float) * 3);
+
+#if (DEBUG_INEMO_SENSOR == 1)
+				STLOGD("Acc_x=%f [m/s^2], Acc_y=%f [m/s^2], Acc_z=%f [m/s^2]", sdata.accel[0], sdata.accel[1], sdata.accel[2]);
+				STLOGD("Mag_x=%f [uT], Mag_y=%f [uT], Mag_z=%f [uT]", sdata.magn[0], sdata.magn[1], sdata.magn[2]);
+				STLOGD("Gyr_x=%f [rad/sec], Gyr_y=%f [rad/sec], Gyr_z=%f [rad/sec]", sdata.gyro[0], sdata.gyro[1], sdata.gyro[2]);
+#endif
+				clock_gettime(CLOCK_MONOTONIC, &new_time);
+				timeElapsed = timespecDiff(&new_time, &old_time);
+				if (timeElapsed > (3 * MSEC_TO_NSEC(GYR_DEFAULT_DELAY)))
+					timeElapsed = MSEC_TO_NSEC(GYR_DEFAULT_DELAY);
+
+				iNemoEngine_API_Run(timeElapsed, &sdata);
+				old_time = new_time;
+#if (SENSORS_ORIENTATION_ENABLE == 1)
+				DecimationCount[Orientation]++;
+				if(mEnabled & (1<<Orientation) && (DecimationCount[Orientation] >= DecimationBuffer[Orientation])) {
+					DecimationCount[Orientation] = 0;
+					err = iNemoEngine_API_Get_Euler_Angles(mPendingEvents[Orientation].data);
+					if (err != 0) {
+						goto no_data;
+					}
+
+					mPendingEvents[Orientation].orientation.status = mSensorsBufferedVectors[MagneticField].status;
+					mPendingMask |= 1<<Orientation;
+  #if (DEBUG_INEMO_SENSOR == 1)
+					STLOGD("time =  %lld, menabled = %d, orientation = %f", timeElapsed, mEnabled, mPendingEvents[Orientation].data);
+  #endif
+				}
+#endif
+#if (SENSORS_GRAVITY_ENABLE == 1)
+				DecimationCount[Gravity]++;
+				if(mEnabled & (1<<Gravity) && (DecimationCount[Gravity] >= DecimationBuffer[Gravity])) {
+					DecimationCount[Gravity] = 0;
+					err = iNemoEngine_API_Get_Gravity(mPendingEvents[Gravity].data);
+					if (err != 0)
+						goto no_data;
+
+					mPendingMask |= 1<<Gravity;
+				}
+#endif
+#if (SENSORS_LINEAR_ACCELERATION_ENABLE == 1)
+				DecimationCount[LinearAcceleration]++;
+				if(mEnabled & (1<<LinearAcceleration) && (DecimationCount[LinearAcceleration] >= DecimationBuffer[LinearAcceleration])) {
+					DecimationCount[LinearAcceleration] = 0;
+					err = iNemoEngine_API_Get_Linear_Acceleration(mPendingEvents[LinearAcceleration].data);
+					if (err != 0)
+						goto no_data;
+
+					mPendingMask |= 1<<LinearAcceleration;
+				}
+#endif
+#if (SENSORS_ROTATION_VECTOR_ENABLE == 1)
+				DecimationCount[RotationMatrix]++;
+				if(mEnabled & (1<<RotationMatrix) && (DecimationCount[RotationMatrix] >= DecimationBuffer[RotationMatrix])) {
+					DecimationCount[RotationMatrix] = 0;
+					err = iNemoEngine_API_Get_Quaternion(mPendingEvents[RotationMatrix].data);
+					if (err != 0)
+						goto no_data;
+
+					mPendingEvents[RotationMatrix].data[4] = -1;
+					mPendingMask |= 1<<RotationMatrix;
+				}
+#endif
+#if (SENSORS_GAME_ROTATION_ENABLE == 1)
+				DecimationCount[GameRotation]++;
+				if(mEnabled & (1<<GameRotation) && (DecimationCount[GameRotation] >= DecimationBuffer[GameRotation])) {
+					DecimationCount[GameRotation] = 0;
+					err = iNemoEngine_API_Get_6X_Quaternion(mPendingEvents[GameRotation].data);
+					if (err != 0)
+						goto no_data;
+
+					mPendingMask |= 1<<GameRotation;
+				}
+#endif
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+  #if (SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1)
+				DecimationCount[UncalibGyro]++;
+				if(mEnabled & (1<<UncalibGyro) && (DecimationCount[UncalibGyro] >= DecimationBuffer[UncalibGyro])) {
+					DecimationCount[UncalibGyro] = 0;
+
+					err = iNemoEngine_API_Get_Gbias(gbias);
+					if (err != 0)
+						goto no_data;
+
+					int i;
+					for (i = 0 ; i < 3; i++) {
+						mPendingEvents[UncalibGyro].uncalibrated_gyro.uncalib[i] = sdata.gyro[i];
+						mPendingEvents[UncalibGyro].uncalibrated_gyro.bias[i] = gbias[i];
+					}
+					mPendingMask |= 1<<UncalibGyro;
+				}
+  #endif
+				DecimationCount[CalibGyro]++;
+				if(mEnabled & (1<<CalibGyro) && (DecimationCount[CalibGyro] >= DecimationBuffer[CalibGyro])) {
+					DecimationCount[CalibGyro] = 0;
+					err = iNemoEngine_API_Get_Gbias(gbias);
+					if (err != 0)
+						goto no_data;
+
+					int i;
+					for (i = 0 ; i < 3; i++) {
+						mPendingEvents[CalibGyro].data[i] = sdata.gyro[i] - gbias[i];
+					}
+					mPendingMask |= 1<<CalibGyro;
+				}
+#endif
+			}
+
+no_data:
+			for (int j=0 ; count && mPendingMask && j<numSensors ; j++) {
+				if (mPendingMask & (1<<j)) {
+					mPendingMask &= ~(1<<j);
+					mPendingEvents[j].timestamp = timestamp;
+					if (mEnabled & (1<<j)) {
+						*data++ = mPendingEvents[j];
+						count--;
+						numEventReceived++;
+					}
+				}
+			}
+		}
+		mInputReader.next();
+	}
+#if FETCH_FULL_EVENT_BEFORE_RETURN
+	/* if we didn't read a complete event, see if we can fill and
+	try again instead of returning with nothing and redoing poll. */
+	if (numEventReceived == 0 && mEnabled == 1) {
+		n = mInputReader.fill(data_fd);
+		if (n)
+			goto again;
+	}
+#endif
+
+
+	return numEventReceived;
+}
+
+#endif /* SENSOR_FUSION_ENABLE */
diff --git a/iNemoEngineSensor.h b/iNemoEngineSensor.h
new file mode 100644
index 0000000..c4d1562
--- /dev/null
+++ b/iNemoEngineSensor.h
@@ -0,0 +1,120 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include "configuration.h"
+#if (SENSOR_FUSION_ENABLE == 1)
+
+#ifndef ANDROID_INEMOENGINE_SENSOR_H
+#define ANDROID_INEMOENGINE_SENSOR_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include "sensors.h"
+#include "SensorBase.h"
+#include "InputEventReader.h"
+
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+#include "AccelSensor.h"
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+#include "GyroSensor.h"
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+#include "MagnSensor.h"
+#endif
+
+extern "C"
+{
+	#include "iNemoEngineProAPI.h"
+};
+
+/*****************************************************************************/
+
+struct input_event;
+
+class iNemoEngineSensor : public SensorBase
+{
+	enum {
+		Acceleration = 0,
+		MagneticField,
+		AngularSpeed,
+		Orientation,
+		Gravity,
+		LinearAcceleration,
+		RotationMatrix,
+		GameRotation,
+		UncalibGyro,
+		CalibGyro,
+		numSensors
+	};
+
+	int initialized;
+	static int mEnabled;
+	uint32_t mPendingMask;
+	InputEventCircularReader mInputReader;
+	sensors_event_t mPendingEvents[numSensors];
+	bool mHasPendingEvent;
+	int setInitialState();
+
+private:
+	static int startup_samples;
+	static int samples_to_discard;
+	sensors_vec_t mSensorsBufferedVectors[3];
+	iNemoInitData init_data_api;
+	iNemoDebugInitData debug_init_data_api;
+
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	char devices_sysfs_path_gyr[PATH_MAX];
+	int devices_sysfs_path_gyr_len;
+	static GyroSensor *gyr;
+#endif
+#if(SENSORS_ACCELEROMETER_ENABLE == 1)
+	char devices_sysfs_path_acc[PATH_MAX];
+	int devices_sysfs_path_acc_len;
+	static AccelSensor *acc;
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	char devices_sysfs_path_mag[PATH_MAX];
+	int devices_sysfs_path_mag_len;
+	static MagnSensor *mag;
+#endif
+	static int status;
+	static int64_t gyroDelay_ms;
+	static int64_t DelayBuffer[numSensors];
+	static int DecimationBuffer[numSensors];
+	static int DecimationCount[numSensors];
+
+	int64_t timestamp;
+
+public:
+	iNemoEngineSensor();
+	virtual ~iNemoEngineSensor();
+	virtual int readEvents(sensors_event_t* data, int count);
+	virtual bool hasPendingEvents() const;
+	virtual int setDelay(int32_t handle, int64_t ns);
+	virtual int enable(int32_t handle, int enabled, int type);
+	virtual void updateDecimations(int64_t Delay_ms);
+	virtual int getWhatFromHandle(int32_t handle);
+};
+
+#endif  // ANDROID_INEMOENGINE_SENSOR_H
+
+#endif /* SENSOR_FUSION_ENABLE */
diff --git a/lib/Android.mk b/lib/Android.mk
new file mode 100644
index 0000000..83175be
--- /dev/null
+++ b/lib/Android.mk
@@ -0,0 +1,17 @@
+# Copyright (C) 2012 STMicroelectronics
+# Matteo Dameno, Denis Ciocca - Motion MEMS Product Div.
+# Copyright (C) 2008 The Android Open Source Project
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#      http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+include $(call all-subdir-makefiles)
diff --git a/sensors.cpp b/sensors.cpp
new file mode 100644
index 0000000..44c6589
--- /dev/null
+++ b/sensors.cpp
@@ -0,0 +1,1346 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <hardware/sensors.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <dirent.h>
+#include <math.h>
+#include <poll.h>
+#include <pthread.h>
+#include <stdlib.h>
+#include <unistd.h>
+
+#include <linux/input.h>
+#include <cutils/log.h>
+
+#include "sensors.h"
+#include "configuration.h"
+
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+#include "MagnSensor.h"
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+#include "GyroSensor.h"
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+#include "AccelSensor.h"
+#endif
+#if (SENSOR_FUSION_ENABLE == 1)
+#include "iNemoEngineSensor.h"
+#endif
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+#include "PressSensor.h"
+#endif
+#if (SENSORS_TEMP_ENABLE == 1)
+#include "TempSensor.h"
+#endif
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+#include "VirtualGyroSensor.h"
+#endif
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+#include "TiltSensor.h"
+#endif
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+#include "StepCounterSensor.h"
+#endif
+#if (SENSORS_STEP_DETECTOR_ENABLE == 1)
+#include "StepDetectorSensor.h"
+#endif
+#if (SENSORS_SIGN_MOTION_ENABLE == 1)
+#include "SignMotionSensor.h"
+#endif
+#if (SENSORS_TAP_ENABLE == 1)
+#include "TapSensor.h"
+#endif
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+#include "HumiditySensor.h"
+#endif
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+#include "ProximitySensor.h"
+#endif
+
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+#include "BodyTempSensor.h"
+#endif
+#if ((SENSORS_LIGHT_ENABLE == 1) || (SENSORS_PROX_INC_LIGHT == 1))
+#include "LightSensor.h"
+#endif
+
+/*****************************************************************************/
+
+#define DELAY_OUT_TIME			0x7FFFFFFF
+
+#define LIGHT_SENSOR_POLLTIME		2000000000
+#define FREQUENCY_TO_USECONDS(x)		(1000000 / x)
+
+/*****************************************************************************/
+
+/* The SENSORS Module */
+static const struct sensor_t sSensorList[] = {
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	{
+		SENSOR_ACC_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_ACCELEROMETER_HANDLE,
+		SENSOR_TYPE_ACCELEROMETER,
+		ACCEL_MAX_RANGE,
+		0.0f,
+		ACCEL_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(ACCEL_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_ACCELEROMETER,
+		"",
+		FREQUENCY_TO_USECONDS(ACCEL_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_UNCALIB_ACCELEROMETER_ENABLE == 1)
+	{
+		SENSOR_ACC_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_UNCALIB_ACCELEROMETER_HANDLE,
+		SENSOR_TYPE_ACCELEROMETER_UNCALIBRATED,
+		ACCEL_MAX_RANGE,
+		0.0f,
+		ACCEL_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(ACCEL_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_ACCELEROMETER_UNCALIBRATED,
+		"",
+		FREQUENCY_TO_USECONDS(ACCEL_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	{
+		SENSOR_MAGN_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_MAGNETIC_FIELD_HANDLE,
+		SENSOR_TYPE_MAGNETIC_FIELD,
+		MAGN_MAX_RANGE,
+		0.0f,
+		MAGN_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(MAGN_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_MAGNETIC_FIELD,
+		"",
+		FREQUENCY_TO_USECONDS(MAGN_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	{
+		SENSOR_GYRO_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_GYROSCOPE_HANDLE,
+		SENSOR_TYPE_GYROSCOPE,
+		GYRO_MAX_RANGE,
+		0.0f,
+		GYRO_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(GYRO_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_GYROSCOPE,
+		"",
+		FREQUENCY_TO_USECONDS(GYRO_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if ((SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1) && ((GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1) || (GYROSCOPE_GBIAS_ESTIMATION_STANDALONE == 1)))
+	{
+		SENSOR_GYRO_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_UNCALIB_GYROSCOPE_HANDLE,
+		SENSOR_TYPE_GYROSCOPE_UNCALIBRATED,
+		GYRO_MAX_RANGE,
+		0.0f,
+		UNCALIB_GYRO_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(GYRO_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_GYROSCOPE_UNCALIBRATED,
+		"",
+		FREQUENCY_TO_USECONDS(GYRO_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+		{
+		SENSOR_SIGNIFICANT_MOTION_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_SIGNIFICANT_MOTION_HANDLE,
+		SENSOR_TYPE_SIGNIFICANT_MOTION,
+		1.0f,
+		0.0f,
+		ACCEL_POWER_CONSUMPTION,
+		-1,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_SIGNIFICANT_MOTION,
+		"",
+		-1,
+		SENSOR_FLAG_ONE_SHOT_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if ((SENSORS_ORIENTATION_ENABLE == 1) || (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1))
+	{
+  #if (SENSORS_ORIENTATION_ENABLE == 1)
+		"iNemoEngine Orientation sensor",
+  #else
+    #if (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1)
+		"iNemoEngineGeoMag Orientation sensor",
+    #else
+		"STMicroelectronics Orientation sensor",
+    #endif
+  #endif
+		"STMicroelectronics",
+		1,
+		SENSORS_ORIENTATION_HANDLE,
+		SENSOR_TYPE_ORIENTATION,
+		360.0f,
+		0.0f,
+		ORIENTATION_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(ORIENTATION_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_ORIENTATION,
+		"",
+		FREQUENCY_TO_USECONDS(ORIENTATION_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_GRAVITY_ENABLE == 1)
+	{
+		"iNemoEngine Gravity sensor",
+		"STMicroelectronics",
+		1,
+		SENSORS_GRAVITY_HANDLE,
+		SENSOR_TYPE_GRAVITY,
+		GRAVITY_EARTH,
+		0.0f,
+		GRAVITY_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(FUSION_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_GRAVITY,
+		"",
+		FREQUENCY_TO_USECONDS(FUSION_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_LINEAR_ACCELERATION_ENABLE == 1)
+	{
+		"iNemoEngine Linear Acceleration sensor",
+		"STMicroelectronics",
+		1,
+		SENSORS_LINEAR_ACCELERATION_HANDLE,
+		SENSOR_TYPE_LINEAR_ACCELERATION,
+		ACCEL_MAX_RANGE-GRAVITY_EARTH,
+		0.0f,
+		LINEAR_ACCEL_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(FUSION_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_LINEAR_ACCELERATION,
+		"",
+		FREQUENCY_TO_USECONDS(FUSION_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_ROTATION_VECTOR_ENABLE == 1)
+	{
+		"iNemoEngine Rotation_Vector sensor",
+		"STMicroelectronics",
+		1,
+		SENSORS_ROTATION_VECTOR_HANDLE,
+		SENSOR_TYPE_ROTATION_VECTOR,
+#if (!SENSORS_GYROSCOPE_ENABLE && SENSORS_VIRTUAL_GYROSCOPE_ENABLE)
+		VIRTUAL_GYRO_MAX_RANGE,
+#else
+		GYRO_MAX_RANGE,
+#endif
+		0.0f,
+		ROT_VEC_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(FUSION_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_ROTATION_VECTOR,
+		"",
+		FREQUENCY_TO_USECONDS(FUSION_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_GAME_ROTATION_ENABLE == 1)
+	{
+		"iNemoEngine Game Rotation sensor",
+		"STMicroelectronics",
+		1,
+		SENSORS_GAME_ROTATION_HANDLE,
+		SENSOR_TYPE_GAME_ROTATION_VECTOR,
+#if (!SENSORS_GYROSCOPE_ENABLE && SENSORS_VIRTUAL_GYROSCOPE_ENABLE)
+		VIRTUAL_GYRO_MAX_RANGE,
+#else
+		GYRO_MAX_RANGE,
+#endif
+		0.0f,
+		GYRO_POWER_CONSUMPTION+ACCEL_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(FUSION_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_GAME_ROTATION_VECTOR,
+		"",
+		FREQUENCY_TO_USECONDS(FUSION_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_PRESSURE_ENABLE == 1)
+	{
+		SENSOR_PRESS_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_PRESSURE_HANDLE,
+		SENSOR_TYPE_PRESSURE,
+		PRESS_MAX_RANGE,
+		0.0f,
+		PRESS_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(PRESS_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_PRESSURE,
+		"",
+		FREQUENCY_TO_USECONDS(PRESS_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_TEMPERATURE_ENABLE == 1)
+	{
+		SENSOR_TEMP_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_TEMPERATURE_HANDLE,
+		SENSOR_TYPE_TEMPERATURE,
+		TEMP_MAX_RANGE,
+		0.0f,
+		TEMP_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(TEMP_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_TEMPERATURE,
+		"",
+		FREQUENCY_TO_USECONDS(TEMP_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_TEMP_ENABLE == 1)
+	{
+		SENSOR_TEMP_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_TEMPERATURE_HANDLE,
+		SENSOR_TYPE_AMBIENT_TEMPERATURE,
+		TEMP_MAX_RANGE,
+		0.0f,
+		TEMP_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(TEMP_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_TEMPERATURE,
+		"",
+		FREQUENCY_TO_USECONDS(TEMP_MIN_ODR),
+		SENSOR_FLAG_ON_CHANGE_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE == 1)
+	{
+		SENSOR_MAGN_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE,
+		SENSOR_TYPE_MAGNETIC_FIELD_UNCALIBRATED,
+		MAGN_MAX_RANGE,
+		0.0f,
+		MAGN_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(MAGN_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_MAGNETIC_FIELD_UNCALIBRATED,
+		"",
+		FREQUENCY_TO_USECONDS(MAGN_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE == 1)
+	{
+		"iNemoEngine Geomagnetic Rotation Vector sensor",
+		"STMicroelectronics",
+		1,
+		SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE,
+		SENSOR_TYPE_GEOMAGNETIC_ROTATION_VECTOR,
+		1.0f,
+		0.0f,
+		MAGN_POWER_CONSUMPTION+ACCEL_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(MAGN_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_GEOMAGNETIC_ROTATION_VECTOR,
+		"",
+		FREQUENCY_TO_USECONDS(MAGN_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+	{
+		SENSOR_VIRTUAL_GYRO_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_VIRTUAL_GYROSCOPE_HANDLE,
+		SENSOR_TYPE_GYROSCOPE,
+		VIRTUAL_GYRO_MAX_RANGE,
+		0.0f,
+		VIRTUAL_GYRO_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(VIRTUAL_GYRO_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_GYROSCOPE,
+		"",
+		FREQUENCY_TO_USECONDS(VIRTUAL_GYRO_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+	{
+		SENSOR_TILT_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_TILT_DETECTOR_HANDLE,
+		SENSOR_TYPE_TILT_DETECTOR,
+		1.0f,
+		1.0f,
+		TILT_POWER_CONSUMPTION,
+		0,
+		0,
+		0,
+		SENSOR_STRING_TYPE_TILT_DETECTOR,
+		"",
+		0,
+		SENSOR_FLAG_SPECIAL_REPORTING_MODE,
+		{ }
+	},
+#endif
+
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+	{
+		SENSOR_STEP_C_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_STEP_COUNTER_HANDLE,
+		SENSOR_TYPE_STEP_COUNTER,
+		65535.0f,
+		1.0f,
+		STEP_C_POWER_CONSUMPTION,
+		0,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_STEP_COUNTER,
+		"",
+		0,
+		SENSOR_FLAG_ON_CHANGE_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+
+#if (SENSORS_STEP_DETECTOR_ENABLE == 1)
+	{
+		SENSOR_STEP_D_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_STEP_DETECTOR_HANDLE,
+		SENSOR_TYPE_STEP_DETECTOR,
+		1.0f,
+		1.0f,
+		STEP_D_POWER_CONSUMPTION,
+		0,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_STEP_DETECTOR,
+		"",
+		0,
+		SENSOR_FLAG_SPECIAL_REPORTING_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+
+#if (SENSORS_SIGN_MOTION_ENABLE == 1)
+	{
+		SENSOR_SIGN_M_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_SIGN_MOTION_HANDLE,
+		SENSOR_TYPE_SIGNIFICANT_MOTION,
+		1.0f,
+		1.0f,
+		SIGN_M_POWER_CONSUMPTION,
+		0,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_SIGNIFICANT_MOTION,
+		"",
+		0,
+		SENSOR_FLAG_ONE_SHOT_MODE | SENSOR_FLAG_WAKE_UP,
+#endif
+#endif
+		{ }
+	},
+#endif
+
+#if (SENSORS_TAP_ENABLE == 1)
+	{
+		SENSOR_TAP_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_TAP_HANDLE,
+		SENSOR_TYPE_TAP,
+		10.0f,
+		1.0f,
+		TAP_POWER_CONSUMPTION,
+		0,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_TAP,
+		"",
+		0,
+		SENSOR_FLAG_ON_CHANGE_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+	{
+		SENSOR_ACTIVITY_RECOGNIZERO_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_ACTIVITY_RECOGNIZER_HANDLE,
+		SENSOR_TYPE_ACTIVITY,
+		10.0f,
+		1.0f,
+		SENSORS_ACTIVITY_RECOGNIZER_POWER,
+		0,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_ACTIVITY,
+		"",
+		0,
+		SENSOR_FLAG_ON_CHANGE_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_HUMIDITY_ENABLE == 1)
+	{
+		SENSOR_HUMIDITY_LABEL,
+		"STMicroelectronics",
+		1,
+		SENSORS_HUMIDITY_HANDLE,
+		SENSOR_TYPE_RELATIVE_HUMIDITY,
+		HUMIDITY_MAX_RANGE,
+		0.0f,
+		HUMIDITY_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(HUMIDITY_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_RELATIVE_HUMIDITY,
+		"",
+		FREQUENCY_TO_USECONDS(HUMIDITY_MIN_ODR),
+		SENSOR_FLAG_CONTINUOUS_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+	{
+		SENSOR_PRX_LABEL,					// name
+		SENSOR_VENDOR_NAME,					// vendor
+		1,							// version
+		SENSORS_PROXIMITY_HANDLE,				// handle
+		SENSOR_TYPE_PROXIMITY,					// type
+		PROXIMITY_MAX_RANGE,					// maxRange
+		1.0f,							// resolution
+		PROXIMITY_POWER_CONSUMPTION,				// power
+		FREQUENCY_TO_USECONDS(PROXIMITY_MAX_ODR),		// minDelay
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,							// fifoReservedEventCount
+		0,							// fifoMaxEventCount
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_PROXIMITY,				// stringType
+		"",							// requiredPermission
+		FREQUENCY_TO_USECONDS(PROXIMITY_MIN_ODR),		// maxDelay
+		SENSOR_FLAG_ON_CHANGE_MODE | SENSOR_FLAG_WAKE_UP,	// flags
+#endif
+#endif
+		{ }
+	},
+#if (SENSORS_PROX_INC_LIGHT == 1)
+	{
+		SENSOR_PRX_LIGHT_LABEL,
+		SENSOR_VENDOR_NAME,
+		1,
+		SENSORS_LIGHT_HANDLE,
+		SENSOR_TYPE_LIGHT,
+		PROXIMITY_LIGHT_MAX_RANGE,
+		1.0f,
+		PROXIMITY_LIGHT_POWER_CONSUMPTION,
+		FREQUENCY_TO_USECONDS(PROXIMITY_LIGHT_MAX_ODR),
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,							// fifoReservedEventCount
+		0,							// fifoMaxEventCount
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_LIGHT,				// stringType
+		"",							// requiredPermission
+		FREQUENCY_TO_USECONDS(PROXIMITY_LIGHT_MIN_ODR),		// maxDelay
+		SENSOR_FLAG_ON_CHANGE_MODE | SENSOR_FLAG_WAKE_UP,	// flags
+#endif
+#endif
+		{ }
+
+	},
+#endif
+#endif
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+	{
+		SENSOR_BODY_TEMP_LABEL,
+		"Melexis",
+		1,
+		SENSORS_BODY_TEMPERATURE_HANDLE,
+		SENSOR_TYPE_AMBIENT_TEMPERATURE,
+		SENSOR_OBJECT_MAX_RANGE,
+		0.02f,
+		SENSOR_POWER_CONSUMPTION,
+		SENSOR_CMD_MIN_FREQ,
+#if (ANDROID_VERSION >= ANDROID_KK)
+		0,
+		0,
+#if (ANDROID_VERSION >= ANDROID_L)
+		SENSOR_STRING_TYPE_AMBIENT_TEMPERATURE,
+		"",
+		SENSOR_CMD_MAX_FREQ,
+		SENSOR_FLAG_ON_CHANGE_MODE,
+#endif
+#endif
+		{ }
+	},
+#endif
+};
+
+
+static int open_sensors(const struct hw_module_t* module, const char* id, struct hw_device_t** device);
+
+void get_ref(sensors_module_t *sm);
+
+static struct hw_module_methods_t sensors_module_methods = {
+	.open = open_sensors
+};
+
+int sensors__get_sensors_list(struct sensors_module_t __attribute__((unused))*module,
+						struct sensor_t const** list)
+{
+	*list = sSensorList;
+	return ARRAY_SIZE(sSensorList);
+};
+
+struct sensors_module_t HAL_MODULE_INFO_SYM = {
+	.common = {
+		.tag = HARDWARE_MODULE_TAG,
+		.version_major = 1,
+		.version_minor = 0,
+		.id = SENSORS_HARDWARE_MODULE_ID,
+		.name = "IDTech Sensor module",
+		.author = "IDTech",
+		.methods = &sensors_module_methods,
+		.dso = NULL,
+		.reserved = { },
+	},
+	.get_sensors_list = sensors__get_sensors_list,
+#if (ANDROID_VERSION >= ANDROID_M)
+	.set_operation_mode = NULL,
+#endif
+}
+;
+
+void get_ref(sensors_module_t __attribute__((unused))*sm) {
+	sm = &HAL_MODULE_INFO_SYM;
+	return;
+}
+
+struct sensors_poll_context_t {
+	struct SENSOR_POLL_DEVICE device;
+
+	sensors_poll_context_t();
+	~sensors_poll_context_t();
+	int activate(int handle, int enabled);
+	int setDelay(int handle, int64_t ns);
+	int pollEvents(sensors_event_t* data, int count);
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+	int batch(int sensor_handle, int flags, int64_t sampling_period_ns,
+		  int64_t max_report_latency_ns);
+	int flush(int sensor_handle);
+#endif
+private:
+	enum {
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+		gyro = 0,
+#endif
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+		virtual_gyro,
+#endif
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+		accel,
+#endif
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+		magn,
+#endif
+#if (SENSOR_FUSION_ENABLE == 1)
+		inemo,
+#endif
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+		press,
+#endif
+#if (SENSORS_TEMP_ENABLE == 1)
+		temperature,
+#endif
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+		tilt,
+#endif
+#if(SENSORS_STEP_COUNTER_ENABLE == 1)
+		step_c,
+#endif
+#if(SENSORS_STEP_DETECTOR_ENABLE == 1)
+		step_d,
+#endif
+#if(SENSORS_SIGN_MOTION_ENABLE == 1)
+		sign_m,
+#endif
+#if(SENSORS_TAP_ENABLE == 1)
+		tap,
+#endif
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+		humidity,
+#endif
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+		proximity,
+#endif
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+		bodyTemperature,
+#endif
+#if ((SENSORS_LIGHT_ENABLE == 1) || (SENSORS_PROX_INC_LIGHT == 1))
+		light,
+#endif
+		numSensorDrivers,
+		numFds,
+	};
+
+	struct pollfd mPollFds[numFds];
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+	static const size_t flushFD = numFds - 1;
+	int mWriteFlushPipe;
+#endif
+	SensorBase* mSensors[numSensorDrivers];
+
+	int handleToDriver(int handle) const
+	{
+		switch (handle) {
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+			case SENSORS_ACCELEROMETER_HANDLE:
+				return accel;
+#endif
+#if (SENSORS_UNCALIB_ACCELEROMETER_ENABLE == 1)
+			case SENSORS_UNCALIB_ACCELEROMETER_HANDLE:
+				return accel;
+#endif
+
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+			case SENSORS_MAGNETIC_FIELD_HANDLE:
+				return magn;
+#endif
+
+#if ((SENSORS_ORIENTATION_ENABLE == 1) || (GEOMAG_COMPASS_ORIENTATION_ENABLE == 1))
+			case SENSORS_ORIENTATION_HANDLE:
+#if (SENSORS_ORIENTATION_ENABLE == 1)
+				return inemo;
+#else
+				return magn;
+#endif
+#endif
+
+#if (SENSORS_GRAVITY_ENABLE == 1)
+			case SENSORS_GRAVITY_HANDLE:
+#if (SENSOR_FUSION_ENABLE == 1)
+				return inemo;
+#else
+				return magn;
+#endif
+#endif
+
+#if (SENSORS_LINEAR_ACCELERATION_ENABLE == 1)
+			case SENSORS_LINEAR_ACCELERATION_HANDLE:
+#if (SENSOR_FUSION_ENABLE == 1)
+				return inemo;
+#else
+				return magn;
+#endif
+#endif
+
+#if (SENSORS_ROTATION_VECTOR_ENABLE == 1)
+			case SENSORS_ROTATION_VECTOR_HANDLE:
+				return inemo;
+#endif
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+			case SENSORS_PRESSURE_HANDLE:
+			case SENSORS_TEMPERATURE_HANDLE:
+				return press;
+#endif
+#if (SENSORS_TEMP_ENABLE == 1)
+			case SENSORS_TEMPERATURE_HANDLE:
+				return temperature;
+#endif
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+			case SENSORS_GYROSCOPE_HANDLE:
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+				return inemo;
+#else
+				return gyro;
+#endif
+#endif
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+			case SENSORS_VIRTUAL_GYROSCOPE_HANDLE:
+				return virtual_gyro;
+#endif
+#if (SENSORS_GAME_ROTATION_ENABLE == 1) && (SENSOR_FUSION_ENABLE == 1)
+			case SENSORS_GAME_ROTATION_HANDLE:
+				return inemo;
+#endif
+#if (SENSORS_UNCALIB_GYROSCOPE_ENABLE == 1)
+			case SENSORS_UNCALIB_GYROSCOPE_HANDLE:
+#if (GYROSCOPE_GBIAS_ESTIMATION_FUSION == 1)
+				return inemo;
+#else
+				return gyro;
+#endif
+#endif
+#if (SENSORS_SIGNIFICANT_MOTION_ENABLE == 1)
+			case SENSORS_SIGNIFICANT_MOTION_HANDLE:
+				return accel;
+#endif
+#if SENSORS_UNCALIB_MAGNETIC_FIELD_ENABLE
+			case SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE:
+				return magn;
+#endif
+#if SENSORS_GEOMAG_ROTATION_VECTOR_ENABLE
+			case SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE:
+				return magn;
+#endif
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+			case SENSORS_TILT_DETECTOR_HANDLE:
+				return tilt;
+#endif
+#if SENSORS_STEP_COUNTER_ENABLE
+			case SENSORS_STEP_COUNTER_HANDLE:
+				return step_c;
+#endif
+#if SENSORS_STEP_DETECTOR_ENABLE
+			case SENSORS_STEP_DETECTOR_HANDLE:
+				return step_d;
+#endif
+#if SENSORS_SIGN_MOTION_ENABLE
+			case SENSORS_SIGN_MOTION_HANDLE:
+				return sign_m;
+#endif
+#if (SENSORS_ACTIVITY_RECOGNIZER_ENABLE == 1)
+			case SENSORS_ACTIVITY_RECOGNIZER_HANDLE:
+				return accel;
+#endif
+#if (SENSORS_TAP_ENABLE == 1)
+			case SENSORS_TAP_HANDLE:
+				return tap;
+#endif
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+			case SENSORS_TEMPERATURE_HANDLE:
+			case SENSORS_HUMIDITY_HANDLE:
+				return humidity;
+#endif
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+			case SENSORS_PROXIMITY_HANDLE:
+				return proximity;
+#endif
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+			case SENSORS_BODY_TEMPERATURE_HANDLE:
+				return bodyTemperature;
+#endif
+#if ((SENSORS_LIGHT_ENABLE == 1) || (SENSORS_PROX_INC_LIGHT == 1))
+			case SENSORS_LIGHT_HANDLE:
+				return light;
+#endif
+		}
+		return -EINVAL;
+	}
+};
+
+/*****************************************************************************/
+
+sensors_poll_context_t::sensors_poll_context_t()
+{
+#if (SENSORS_MAGNETIC_FIELD_ENABLE == 1)
+	mSensors[magn] = new MagnSensor();
+	mPollFds[magn].fd = mSensors[magn]->getFd();
+	mPollFds[magn].events = POLLIN;
+	mPollFds[magn].revents = 0;
+#endif
+
+#if (SENSORS_GYROSCOPE_ENABLE == 1)
+	mSensors[gyro] = new GyroSensor();
+	mPollFds[gyro].fd = mSensors[gyro]->getFd();
+	mPollFds[gyro].events = POLLIN;
+	mPollFds[gyro].revents = 0;
+#endif
+
+#if (SENSORS_VIRTUAL_GYROSCOPE_ENABLE == 1)
+	mSensors[virtual_gyro] = new VirtualGyroSensor();
+	mPollFds[virtual_gyro].fd = mSensors[virtual_gyro]->getFd();
+	mPollFds[virtual_gyro].events = POLLIN;
+	mPollFds[virtual_gyro].revents = 0;
+#endif
+
+#if (SENSORS_ACCELEROMETER_ENABLE == 1)
+	mSensors[accel] = new AccelSensor();
+	mPollFds[accel].fd = mSensors[accel]->getFd();
+	mPollFds[accel].events = POLLIN;
+	mPollFds[accel].revents = 0;
+#endif
+
+#if (SENSOR_FUSION_ENABLE == 1)
+	mSensors[inemo] = new iNemoEngineSensor();
+	mPollFds[inemo].fd = mSensors[inemo]->getFd();
+	mPollFds[inemo].events = POLLIN;
+	mPollFds[inemo].revents = 0;
+#endif
+
+#if ((SENSORS_PRESSURE_ENABLE == 1) || (SENSORS_TEMP_PRESS_ENABLE == 1))
+	mSensors[press] = new PressSensor();
+	mPollFds[press].fd = mSensors[press]->getFd();
+	mPollFds[press].events = POLLIN;
+	mPollFds[press].revents = 0;
+#endif
+
+#if (SENSORS_TEMP_ENABLE == 1)
+	mSensors[temperature] = new TempSensor();
+	mPollFds[temperature].fd = mSensors[temperature]->getFd();
+	mPollFds[temperature].events = POLLIN;
+	mPollFds[temperature].revents = 0;
+#endif
+
+#if ((SENSORS_TILT_ENABLE == 1) && (ANDROID_VERSION >= ANDROID_L))
+	mSensors[tilt] = new TiltSensor();
+	mPollFds[tilt].fd = mSensors[tilt]->getFd();
+	mPollFds[tilt].events = POLLIN;
+	mPollFds[tilt].revents = 0;
+#endif
+
+#if (SENSORS_STEP_COUNTER_ENABLE == 1)
+	mSensors[step_c] = new StepCounterSensor();
+	mPollFds[step_c].fd = mSensors[step_c]->getFd();
+	mPollFds[step_c].events = POLLIN;
+	mPollFds[step_c].revents = 0;
+#endif
+
+#if (SENSORS_STEP_DETECTOR_ENABLE == 1)
+	mSensors[step_d] = new StepDetectorSensor();
+	mPollFds[step_d].fd = mSensors[step_d]->getFd();
+	mPollFds[step_d].events = POLLIN;
+	mPollFds[step_d].revents = 0;
+#endif
+
+#if (SENSORS_SIGN_MOTION_ENABLE == 1)
+	mSensors[sign_m] = new SignMotionSensor();
+	mPollFds[sign_m].fd = mSensors[sign_m]->getFd();
+	mPollFds[sign_m].events = POLLIN;
+	mPollFds[sign_m].revents = 0;
+#endif
+
+#if (SENSORS_TAP_ENABLE == 1)
+	mSensors[tap] = new TapSensor();
+	mPollFds[tap].fd = mSensors[tap]->getFd();
+	mPollFds[tap].events = POLLIN;
+	mPollFds[tap].revents = 0;
+#endif
+
+#if ((SENSORS_HUMIDITY_ENABLE == 1) || (SENSORS_TEMP_RH_ENABLE == 1))
+	mSensors[humidity] = new HumiditySensor();
+	mPollFds[humidity].fd = mSensors[humidity]->getFd();
+	mPollFds[humidity].events = POLLIN;
+	mPollFds[humidity].revents = 0;
+#endif
+
+#if (SENSORS_PROXIMITY_ENABLE == 1)
+	mSensors[proximity] = new ProximitySensor();
+	mPollFds[proximity].fd = mSensors[proximity]->getFd();
+	mPollFds[proximity].events = POLLIN;
+	mPollFds[proximity].revents = 0;
+#endif
+
+#if (SENSORS_BODY_TEMP_ENABLE == 1)
+	mSensors[bodyTemperature] = new BodyTempSensor();
+	mPollFds[bodyTemperature].fd = mSensors[bodyTemperature]->getFd();
+	mPollFds[bodyTemperature].events = POLLIN;
+	mPollFds[bodyTemperature].revents = 0;
+#endif
+
+#if ((SENSORS_LIGHT_ENABLE == 1) || (SENSORS_PROX_INC_LIGHT == 1))
+#if (SENSORS_LIGHT_ENABLE == 1)
+	mSensors[light] = new LightSensor(SENSOR_OBJECT_LIGHT);
+#else
+	mSensors[light] = new LightSensor(SENSOR_DATANAME_PROXIMITY_LIGHT);
+#endif
+	mPollFds[light].fd = mSensors[light]->getFd();
+	mPollFds[light].events = POLLIN;
+	mPollFds[light].revents = 0;
+#endif
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+	int FlushFds[2];
+	int err = pipe(FlushFds);
+	if (err < 0) {
+		ALOGE("Failed to create pipe for flush sensor.");
+	} else {
+		fcntl(FlushFds[0], F_SETFL, O_NONBLOCK);
+		fcntl(FlushFds[1], F_SETFL, O_NONBLOCK);
+		mWriteFlushPipe = FlushFds[1];
+		mPollFds[flushFD].fd = FlushFds[0];
+		mPollFds[flushFD].events = POLLIN;
+		mPollFds[flushFD].revents = 0;
+	}
+#endif
+}
+
+sensors_poll_context_t::~sensors_poll_context_t()
+{
+	for (int i=0 ; i<numSensorDrivers ; i++) {
+		delete mSensors[i];
+	}
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+	close(mPollFds[flushFD].fd);
+	close(mWriteFlushPipe);
+#endif
+}
+
+int sensors_poll_context_t::activate(int handle, int enabled)
+{
+	int index = handleToDriver(handle);
+	if(index < 0)
+		return index;
+
+	int err =  mSensors[index]->enable(handle, enabled, 0);
+	return err;
+}
+
+int sensors_poll_context_t::setDelay(int handle, int64_t ns)
+{
+	int index = handleToDriver(handle);
+	if(index < 0)
+		return index;
+
+	return mSensors[index]->setDelay(handle, ns);
+}
+
+int sensors_poll_context_t::pollEvents(sensors_event_t* data, int count)
+{
+	int nbEvents = 0;
+	int n = 0;
+
+	do {
+		if (count) {
+			n = poll(mPollFds, numFds, nbEvents ? 0 : -1);
+			if (n < 0) {
+				STLOGE("poll() failed (%s)", strerror(errno));
+				return -errno;
+			}
+		}
+		for (int i=0 ; count && i<numSensorDrivers ; i++) {
+			SensorBase* const sensor(mSensors[i]);
+			if((mPollFds[i].revents & POLLIN) || (sensor->hasPendingEvents()))
+			{
+				int nb = sensor->readEvents(data, count);
+				if (nb < count) {
+					mPollFds[i].revents = 0;
+				}
+				count -= nb;
+				nbEvents += nb;
+				data += nb;
+			}
+		}
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+		if(mPollFds[flushFD].revents & POLLIN && count) {
+			if (read(mPollFds[flushFD].fd, data, sizeof(struct sensors_event_t)) > 0) {
+				count--;
+				nbEvents++;
+				data++;
+			}
+			mPollFds[flushFD].revents = 0;
+		}
+#endif
+	} while (n && count);
+
+	return nbEvents;
+}
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+int sensors_poll_context_t::batch(int sensor_handle, int __attribute__((unused))flags,
+						int64_t sampling_period_ns,
+				  int64_t __attribute__((unused))max_report_latency_ns)
+{
+	this->setDelay(sensor_handle, sampling_period_ns);
+
+	return 0;
+}
+
+int sensors_poll_context_t::flush(int sensor_handle)
+{
+	sensors_event_t flush_event;
+	int err;
+
+	flush_event.timestamp = 0;
+	flush_event.meta_data.sensor = sensor_handle;
+	flush_event.meta_data.what = META_DATA_FLUSH_COMPLETE;
+	flush_event.type = SENSOR_TYPE_META_DATA;
+	flush_event.version = META_DATA_VERSION;
+	flush_event.sensor = 0;
+
+	err = write(mWriteFlushPipe, &flush_event, sizeof(flush_event));
+	if (err < 0) {
+		ALOGE("Failed to write flush data. %d", err);
+		return -EINVAL;
+	}
+
+	return 0;
+}
+#endif
+/*****************************************************************************/
+
+static int poll__close(struct hw_device_t *dev)
+{
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	if(ctx) {
+		delete ctx;
+	}
+	return 0;
+}
+
+static int poll__activate(struct sensors_poll_device_t *dev, int handle, int enabled)
+{
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->activate(handle, enabled);
+}
+
+static int poll__setDelay(struct sensors_poll_device_t *dev, int handle, int64_t ns)
+{
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->setDelay(handle, ns);
+}
+
+static int poll__poll(struct sensors_poll_device_t *dev, sensors_event_t* data, int count)
+{
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->pollEvents(data, count);
+}
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+static int poll__batch(struct sensors_poll_device_1* dev, int sensor_handle, int flags,
+						int64_t sampling_period_ns, int64_t max_report_latency_ns)
+{
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->batch(sensor_handle, flags, sampling_period_ns, max_report_latency_ns);
+}
+
+static int poll__flush(struct sensors_poll_device_1* dev, int sensor_handle)
+{
+	sensors_poll_context_t *ctx = (sensors_poll_context_t *)dev;
+	return ctx->flush(sensor_handle);
+}
+#endif
+/*****************************************************************************/
+
+/** Open a new instance of a sensor device using name */
+static int open_sensors(const struct hw_module_t* module,
+			const char __attribute__((unused))*id,
+			struct hw_device_t** device)
+{
+	int status = -EINVAL;
+	sensors_poll_context_t *dev = new sensors_poll_context_t();
+
+	memset(&dev->device, 0, sizeof(SENSOR_POLL_DEVICE));
+
+	dev->device.common.tag		= HARDWARE_DEVICE_TAG;
+
+#if (ANDROID_VERSION > ANDROID_KK)
+	dev->device.common.version	= SENSORS_DEVICE_API_VERSION_1_3;
+#else
+#if (ANDROID_VERSION > ANDROID_JBMR2)
+	dev->device.common.version	= SENSORS_DEVICE_API_VERSION_1_1;
+#else
+#if (ANDROID_VERSION == ANDROID_JBMR2)
+	dev->device.common.version	= SENSORS_DEVICE_API_VERSION_1_0;
+#else
+	dev->device.common.version	= 0;
+#endif
+#endif
+#endif
+	dev->device.common.module	= const_cast<hw_module_t*>(module);
+	dev->device.common.close	= poll__close;
+	dev->device.activate		= poll__activate;
+	dev->device.setDelay		= poll__setDelay;
+	dev->device.poll			= poll__poll;
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+	dev->device.batch			= poll__batch;
+	dev->device.flush			= poll__flush;
+#endif
+
+	*device = &dev->device.common;
+	status = 0;
+
+	return status;
+}
+
diff --git a/sensors.h b/sensors.h
new file mode 100644
index 0000000..2688a15
--- /dev/null
+++ b/sensors.h
@@ -0,0 +1,115 @@
+/*
+ * Copyright (c) 2021 ID TECH.
+ * Author: Jay Deng <jay.deng@idtechproducts.com>
+ * Copyright (C) 2008 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#ifndef ANDROID_SENSORS_H
+#define ANDROID_SENSORS_H
+
+#include <stdint.h>
+#include <errno.h>
+#include <sys/cdefs.h>
+#include <sys/types.h>
+
+#include <linux/input.h>
+
+#include <hardware/hardware.h>
+#include <hardware/sensors.h>
+#include "configuration.h"
+
+__BEGIN_DECLS
+
+/*****************************************************************************/
+
+#define ARRAY_SIZE(a) (sizeof(a) / sizeof(a[0]))
+
+#define ID_BASE					(SENSORS_HANDLE_BASE+1)
+#define ID_ACCELEROMETER			(ID_BASE+0)
+#define ID_MAGNETIC_FIELD			(ID_BASE+1)
+#define ID_ORIENTATION				(ID_BASE+2)
+#define ID_GYROSCOPE				(ID_BASE+3)
+#define ID_LIGHT				(ID_BASE+4)
+#define ID_PRESSURE				(ID_BASE+5)
+#define ID_TEMPERATURE				(ID_BASE+6)
+#define ID_PROXIMITY				(ID_BASE+7)
+#define ID_GRAVITY				(ID_BASE+8)
+#define ID_LINEAR_ACCELERATION			(ID_BASE+9)
+#define ID_ROTATION_VECTOR			(ID_BASE+10)
+#define ID_GAME_ROTATION			(ID_BASE+11)
+#define ID_UNCALIB_GYROSCOPE			(ID_BASE+12)
+#define ID_SIGNIFICANT_MOTION			(ID_BASE+13)
+#define ID_UNCALIB_MAGNETIC_FIELD		(ID_BASE+14)
+#define ID_GEOMAG_ROTATION_VECTOR		(ID_BASE+15)
+#define ID_SENSOR_FUSION			(ID_BASE+16)
+#define ID_VIRTUAL_GYROSCOPE			(ID_BASE+17)
+#define ID_TILT_DETECTOR			(ID_BASE+18)
+#define ID_STEP_COUNTER				(ID_BASE+19)
+#define ID_STEP_DETECTOR			(ID_BASE+20)
+#define ID_SIGN_MOTION				(ID_BASE+21)
+#define ID_ACTIVITY_RECOGNIZER			(ID_BASE+22)
+#define ID_TAP					(ID_BASE+23)
+#define ID_HUMIDITY				(ID_BASE+24)
+#define ID_UNCALIB_ACCELEROMETER		(ID_BASE+25)
+#define ID_BODY_TEMPERATURE			(ID_BASE+26)
+
+#define SENSORS_ACCELEROMETER_HANDLE		ID_ACCELEROMETER
+#define SENSORS_MAGNETIC_FIELD_HANDLE		ID_MAGNETIC_FIELD
+#define SENSORS_ORIENTATION_HANDLE		ID_ORIENTATION
+#define SENSORS_LIGHT_HANDLE			ID_LIGHT
+#define SENSORS_PROXIMITY_HANDLE		ID_PROXIMITY
+#define SENSORS_GYROSCOPE_HANDLE		ID_GYROSCOPE
+#define SENSORS_GRAVITY_HANDLE			ID_GRAVITY
+#define SENSORS_LINEAR_ACCELERATION_HANDLE	ID_LINEAR_ACCELERATION
+#define SENSORS_ROTATION_VECTOR_HANDLE		ID_ROTATION_VECTOR
+#define SENSORS_PRESSURE_HANDLE			ID_PRESSURE
+#define SENSORS_TEMPERATURE_HANDLE		ID_TEMPERATURE
+#define SENSORS_GAME_ROTATION_HANDLE		ID_GAME_ROTATION
+#define SENSORS_UNCALIB_GYROSCOPE_HANDLE	ID_UNCALIB_GYROSCOPE
+#define SENSORS_SIGNIFICANT_MOTION_HANDLE	ID_SIGNIFICANT_MOTION
+#define SENSORS_UNCALIB_MAGNETIC_FIELD_HANDLE	ID_UNCALIB_MAGNETIC_FIELD
+#define SENSORS_GEOMAG_ROTATION_VECTOR_HANDLE	ID_GEOMAG_ROTATION_VECTOR
+#define SENSORS_SENSOR_FUSION_HANDLE		ID_SENSOR_FUSION
+#define SENSORS_VIRTUAL_GYROSCOPE_HANDLE	ID_VIRTUAL_GYROSCOPE
+#define SENSORS_TILT_DETECTOR_HANDLE		ID_TILT_DETECTOR
+#define SENSORS_STEP_COUNTER_HANDLE		ID_STEP_COUNTER
+#define SENSORS_STEP_DETECTOR_HANDLE		ID_STEP_DETECTOR
+#define SENSORS_SIGN_MOTION_HANDLE		ID_SIGN_MOTION
+#define SENSORS_ACTIVITY_RECOGNIZER_HANDLE	ID_ACTIVITY_RECOGNIZER
+#define SENSORS_TAP_HANDLE			ID_TAP
+#define SENSORS_HUMIDITY_HANDLE			ID_HUMIDITY
+#define SENSORS_UNCALIB_ACCELEROMETER_HANDLE	ID_UNCALIB_ACCELEROMETER
+#define SENSORS_BODY_TEMPERATURE_HANDLE		ID_BODY_TEMPERATURE
+
+#define SENSOR_TYPE_TAP				(SENSOR_TYPE_DEVICE_PRIVATE_BASE + 2)
+#define SENSOR_TYPE_ACTIVITY			(SENSOR_TYPE_DEVICE_PRIVATE_BASE + 3)
+
+#define SENSOR_STRING_TYPE_TAP			"com.st.tap"
+
+#define TRACE_FUNCTION_START			ALOGD("%s:start at %lld", __func__, SensorBase::getTimestamp());
+#define TRACE_FUNCTION_END			ALOGD("%s:end at %lld", __func__, SensorBase::getTimestamp());
+/*****************************************************************************/
+/* EVENT TYPE */
+/*****************************************************************************/
+
+#if (ANDROID_VERSION >= ANDROID_JBMR2)
+#define SENSOR_POLL_DEVICE sensors_poll_device_1
+#else
+#define SENSOR_POLL_DEVICE sensors_poll_device_t
+#endif
+
+__END_DECLS
+
+#endif  // ANDROID_SENSORS_H
