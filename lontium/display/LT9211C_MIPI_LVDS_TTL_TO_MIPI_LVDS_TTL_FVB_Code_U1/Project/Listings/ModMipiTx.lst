C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 1   


C51 COMPILER V9.53.0.0, COMPILATION OF MODULE MODMIPITX
OBJECT MODULE PLACED IN ..\..\..\..\..\out\ModMipiTx.obj
COMPILER INVOKED BY: C:\Keil_v5\c51\C51\BIN\C51.EXE ..\User\Module\ModMipiTx.c LARGE OPTIMIZE(8,SIZE) OPTIMIZE(8,SIZE) R
                    -EGFILE(..\..\..\..\..\out\LT9211C_MIPI DSI to LVDS test.ORC) BROWSE INCDIR(..\User\Driver;..\User\App;..\User\Ocm;..\Use
                    -r\Module) DEBUG OBJECTEXTEND PRINT(.\Listings\ModMipiTx.lst) OBJECT(..\..\..\..\..\out\ModMipiTx.obj)

line level    source

   1          /******************************************************************************
   2          *  Copyright (C), 2006-2022, Lontium Tech.
   3          *  Project       : LT2103
   4          *  File Name     : ModMipiTx.c
   5          *  Version       : V1.0
   6          *  Author        : sxue
   7          *  Created       : 2022/7/15
   8          *  Description   : 
   9          *  
  10          *  History:
  11          *  2022/7/15     sxue      Created File
  12          ******************************************************************************/
  13          #include    "include.h"
  14          
  15          #if ((LT9211C_MODE_SEL == LVDS_IN_MIPI_OUT)||(LT9211C_MODE_SEL == MIPI_IN_MIPI_OUT)||(LT9211C_MODE_SEL == 
             -TTL_IN_MIPI_OUT))
              
              StructMipiTx g_stMipiTx;
              StructMipiTxDPhy g_stMipiTxDPhy;
              
              RDATA char* g_szStrTxFormat[MIPITX_FORMAT_CNT] = 
              {
                  "RGB 6bit",
                  "RGB 8bit",
                  "RGB 10bit",
                  "RGB 12bit",
                  "YUV444 8Bit",
                  "YUV444 10bit",
                  "YUV422 8bit",
                  "YUV422 10bit",
                  "YUV422 12bit",
                  "YUV420 8bit",
                  "YUV420 10bit",
              };
              
              //========================================================================
              // Func Name   : Mod_SystemTx_PowerOnInit
              // Description : mipi tx struct init
              // Input       : void  
              // Output      : None
              // Return      : void
              //========================================================================
              
              
              
              void Mod_MipiTx_PortLane_Adj(void)
              {
              #if (MIPITX_OUT_SEL == MIPI_CSI)
                  if (g_stMipiTx.ulMipiInClk > 600000 )//over 4K60
                  {
                      g_stMipiTx.b1DphyCsi8Lane = ENABLED;
                      g_stMipiTx.ucTxPortNum = SPort;
                      g_stMipiTx.ucTxLaneNum = MIPITX_8LANE;
C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 2   

                  }
              //    else
              //    {
              //        g_stMipiTx.b1DphyCsi8Lane = DISABLED;
              //        g_stMipiTx.ucTxPortNum = SPort;
              //        g_stMipiTx.ucTxLaneNum = MIPITX_4LANE;
              //    }
              #endif
              }
              
              //========================================================================
              // Func Name   : Mod_MipiTx_DataRateAdj
              // Description : calc DPHY data rate, limit up && low
              // Input       : void  
              // Output      : None
              // Return      : void
              //========================================================================
              void Mod_MipiTx_DataRateAdj(void)
              {
                  //MIPI D-PHY
                  //DPHY is 8bit to 8bit
                  g_stMipiTx.ulMipiDataRate = g_stMipiTx.ulMipiInClk * g_stMipiTx.ucBpp * 2 / (g_stMipiTx.ucTxPortNum * 
             -g_stMipiTx.ucTxLaneNum);
              
                  //clk连续时，加快80M，clk非连续时，加快120M，如果双port再加快40M，以满足DPHY timing LP和HS的切换的需求
                  if(g_stMipiTx.b1MipiClockburst)
                  {
                      g_stMipiTx.ulMipiDataRate += 120000;
                  }
                  else
                  {
                      g_stMipiTx.ulMipiDataRate += 80000;
                  }
              
              
                  if(g_stMipiTx.ulMipiDataRate < MIPITX_PLL_LOW) //set byteclk minium value to 50M , phyclk minium value
             - is 80M 
                  {
                      g_stMipiTx.ulMipiDataRate = MIPITX_PLL_LOW ;
                  }
                  if(g_stMipiTx.ulMipiDataRate > MIPITX_PLL_HIGH)//set byteclk maxmum value to 312.5M , phyclk maxmum va
             -lue is 2.5G 
                  {
                      g_stMipiTx.ulMipiDataRate = MIPITX_PLL_HIGH ;
                  }
              }
              
              void Mod_MipiTxVidFmt_Get()
              {
                  g_stMipiTx.ucTxFormat = g_stChipRx.ucRxFormat;
              }
              
              //========================================================================
              // Func Name   : Mod_MipiTx_ParaSet
              // Description : 设置 port, lane, clockburst, 3dmode
              //               get MipiInClk
              // Input       : void  
              // Output      : None
              // Return      : void
              //========================================================================
              void Mod_MipiTx_ParaSet(void)
              {
C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 3   

                  u32 ulTmpClk ;
              
                  Mod_MipiTxVidFmt_Get();
                  g_stMipiTx.ucTxPortNum = SPort;
                  g_stMipiTx.ucTxLaneNum = MIPITX_LANE_NUM;
                  g_stMipiTx.b1MipiClockburst = MIPI_CLOCK_BURST;
                  LTLog(LOG_DEBUG, "burst:0x%02bx", g_stMipiTx.b1MipiClockburst);
              
                  switch (g_stMipiTx.ucTxFormat)
                  {
                      case RGB_6Bit:
                          g_stMipiTx.ucBpp = 18;
                          break;
                      case RGB_8Bit:
                      case YUV444_8Bit:
                      case YUV420_8bit:
                          g_stMipiTx.ucBpp = 24;
                          break;
                      case RGB_10Bit:
                      case YUV444_10Bit:
                      case YUV420_10bit:
                          g_stMipiTx.ucBpp = 30;
                          break;
                      case RGB_12Bit:
                          g_stMipiTx.ucBpp = 36;
                          break;
                      case YUV422_8bit:
                          g_stMipiTx.ucBpp = 16;
                          break;
                      case YUV422_10bit:
                          g_stMipiTx.ucBpp = 20;
                          break;
                      case YUV422_12bit:
                          g_stMipiTx.ucBpp = 24;
                          break;
                      default:
                          g_stMipiTx.ucBpp = 24;
                          break;
                  }
              
                  Drv_MipiTx_GetMipiInClk(&g_stMipiTx);
              
                  //MIPI D-PHY check either use 2port or not
                  ulTmpClk = g_stMipiTx.ulMipiInClk * g_stMipiTx.ucBpp * 2 / (g_stMipiTx.ucTxLaneNum);
                  if (ulTmpClk > MIPITX_PLL_HIGH)
                  {
                      LTLog(LOG_ERROR,"Over Maximum MIPITX Datarate");
                  }
              
                  //csi port adjust
              //    Mod_MipiTx_PortLane_Adj();
              }
              
              //========================================================================
              // Func Name   : Mod_MipiTx_Resolution_Config
              // Description : get vid chk timing, set mipi resolution config
              // Input       : void  
              // Output      : None
              // Return      : void
              //========================================================================
              void Mod_MipiTx_Resolution_Config(void)
              {
C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 4   

                  Drv_VidChkAll_Get(&g_stVidChk);
                  Drv_MipiTx_TimingSet(&g_stVidChk);
                  Drv_MipiTx_InHSyncPol_Sel(g_stVidChk.ucHspol);
                  Drv_MipiTx_InVSyncPol_Sel(g_stVidChk.ucVspol);
              }
              
              void Mod_MipiTx_HssSet(void)
              {
                  u16 Hss;
                  #if (MIPITX_OUT_SEL == MIPI_DSI)
                  Hss = 0x0A; //Hss
                  #else 
                  if(g_stMipiTx.b1MipiClockburst == ENABLED)
                  {
                      Hss = (3 * g_stMipiTxDPhy.ucHsRqStPre + g_stMipiTxDPhy.ucHsTrail + 9) / 2 + 22; //Hss
                  }
                  else
                  {
                      Hss = (g_stMipiTxDPhy.ucHsRqStPre + (g_stMipiTxDPhy.ucHsTrail + 13) / 2) + 20;
                  }    
                  #endif
                  Drv_MipiTx_Hss_Set(Hss);
              }
              
              void Mod_MipiTx_FifoRddly_Config(void)
              {
                  u16 ushss, usrgodhact;
                  u16 ulRdHalfpixclk, usrdbyteclk;
                  u32 ulTemp, ulrddly_max, ulrddly_min1, ulrddly_min2;
                  u32 ulrddly = 0;
              
                  //MIPI_DPHY Dphy is double-byte design , Cphy not
                  ulRdHalfpixclk =  (u16)(g_stMipiTx.ulMipiInClk / 1000); //half pix
              //    usrdbyteclk = (Drv_System_FmClkGet(AD_MLTX_WRITE_CLK) / 2); //使用实际的byteclk运算会偏小
              
                  usrdbyteclk = (u16)(g_stMipiTx.ulMipiDataRate / 2000);
                  usrdbyteclk = usrdbyteclk / 8;
                
                  usrdbyteclk *= g_stMipiTx.ucTxPortNum;
                  
                  if((g_stMipiTx.ucTxLaneNum == 8)&&(g_stMipiTx.ucTxPortNum == 1))
                  {
                      usrdbyteclk <<= 1;
                  }
                  
                  ushss = Drv_MipiTx_Hss_Get();
                  usrgodhact = Drv_MipiTx_FSMHact_Get();
                  ulTemp = (usrdbyteclk * ((g_stVidChk.usHs >> 1) + (g_stVidChk.usHbp >> 1)) / ulRdHalfpixclk); 
                  
                  if(ulTemp > ushss)
                  {
                      ulrddly_min1 = (usrdbyteclk * ((g_stVidChk.usHs >> 1) + (g_stVidChk.usHbp >> 1)) / ulRdHalfpixclk)
             - - ushss;
                  }
                  else
                  {
                      ulrddly_min1 = 0;
                  }
                  
                  if(g_stMipiTx.ucTxPortNum == 1)
                  {
                      ulrddly_min2 = (u32)usrdbyteclk * ((g_stVidChk.usHs >> 1) + (g_stVidChk.usHbp >> 1) + (g_stVidChk.
C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 5   

             -usHact >> 1));
                      ulTemp = ((u32)ulrddly_min2 / (u32)ulRdHalfpixclk);
                      if(ulTemp > (ushss + usrgodhact))
                      {
                          ulrddly_min2 =(u32)(((u32)ulrddly_min2 / (u32)ulRdHalfpixclk) - ushss - usrgodhact);
                      }
                      else
                      {
                          ulrddly_min2 = 0;
                      }
                  }
                  else
                  {
                      ulrddly_min2 = ulrddly_min1;
                  }
                  
                  if (ulrddly_min1 > ulrddly_min2)
                  {
                      ulrddly_min2 = ulrddly_min1;
                  }
              
                  ulrddly_max = 0x8000 / (g_stMipiTx.ucBpp << 1);  //0x8000: 512fifo * 8 byte * 8 bit
                  ulrddly_max = usrdbyteclk * (ulrddly_max + (g_stVidChk.usHs >> 1) + (g_stVidChk.usHbp >> 1));
                  ulrddly_max = ulrddly_max / (u32)ulRdHalfpixclk - ushss;
              //    ulrddly = (ulrddly_max - ulrddly_min2) / 20 + ulrddly_min2;
                  ulrddly = (ulrddly_max / 7) + ulrddly_min2;
              
                  Drv_MipiTx_FifoDelay_Set(ulrddly);
                  LTLog(LOG_DEBUG, "rddly is 0x%04lx;",ulrddly);          
              }
              
              //========================================================================
              // Func Name   : Mod_MipiTx_Digital_Config
              // Description : mipi tx digital config
              // Input       : void  
              // Output      : None
              // Return      : void
              //========================================================================
              void Mod_MipiTx_Digital_Config(void)
              {
                  Drv_MipiTx_LaneSet(g_stMipiTx.ucTxLaneNum);
                  Drv_MipiTx_PortCopy();
                  Drv_MipiTx_PortDataEnable();
                  Drv_MipiTx_DPHYClkData_Set();
                  Drv_MipiTx_DPHYClkMode_Sel(g_stMipiTx.b1MipiClockburst);
                  if (g_stMipiTx.b1DphyCsi8Lane == ENABLED)
                  {
                      Drv_MipiTx_HalfWrClkSrc_Sel(WRITE_CLK);
                      Drv_MipiTx_DPHYCSI8Lane_En(ENABLED);
                  }
                  Drv_MipiTx_PortSet(g_stMipiTx.ucTxPortNum);
                  #if (MIPITX_OUT_SEL == MIPI_DSI)
                  Drv_MipiTx_DsiDataTypeSet(g_stMipiTx.ucTxFormat);
                  Drv_MipiTx_DcsAutoMode();
                  #else
                  Drv_MipiTx_CsiDataTypeSet(g_stMipiTx.ucTxFormat);
                  Drv_MipiTx_CsiFrameCntSet();
                  #endif
                  LTLog(LOG_INFO, "MipiTx Output Format: %s",g_szStrTxFormat[g_stMipiTx.ucTxFormat]);
              }
              
              
C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 6   

              void Mod_MipiTx_StateHandler(void)
              {
                  switch (g_stChipTx.ucTxState)
                  {
                      case STATE_CHIPTX_POWER_ON:
                          memset(&g_stMipiTx, 0, sizeof(StructMipiTx));
                          Mod_SystemTx_SetState(STATE_CHIPTX_UPSTREAM_VIDEO_READY);
                          break;
              
                      case STATE_CHIPTX_UPSTREAM_VIDEO_READY:
                          if(g_stChipTx.b1TxStateChanged == TRUE)
                          {
                              Drv_MipiTx_VideoSet(OFF);
                              g_stChipTx.b1TxStateChanged = FALSE;
                          }
                          
                          if(g_stChipTx.b1UpstreamVideoReady == TRUE) 
                          {
                              Mod_SystemTx_SetState(STATE_CHIPTX_CONFIG_VIDEO);
                          }
                          break;
                      case STATE_CHIPTX_CONFIG_VIDEO:
                          Drv_SystemTxSram_Sel(MIPITX);
                          Mod_MipiTx_ParaSet();
                          Mod_MipiTx_DataRateAdj();
                          Drv_MipiTx_DPhySet();
                          Drv_MipiTx_PllSet(&g_stMipiTx);
                          if (Drv_MipiTx_PllCali() == SUCCESS)
                          {
                              Drv_MipiTx_HalfWrClkSrc_Sel(HALF_WRITE_CLK);
                              Mod_MipiTx_Resolution_Config();
                              Drv_MipiTx_PhyTimingParaSet(&g_stMipiTx, &g_stMipiTxDPhy);
                              Mod_MipiTx_Digital_Config();
                              Mod_MipiTx_HssSet();
                              Mod_MipiTx_FifoRddly_Config();
              
                              Drv_MipiTx_DPhyClkHsTrig();
                              Drv_MipiTx_DPhySkewCali();
                              Mod_SystemTx_SetState(STATE_CHIPTX_VIDEO_OUT);
                          }
                          break;
                      case STATE_CHIPTX_VIDEO_OUT:
                                      Drv_MipiTx_PanelInit();
                          Drv_MipiTx_VideoSet(ON);
                          Mod_SystemTx_SetState(STATE_CHIPTX_PLAY_BACK);
                          break;
                      case STATE_CHIPTX_PLAY_BACK:
                          ;
                      break;    
                  }
              }
              
              void Mod_MipiTx_StateJudge(void)
              {
                  //monitor upstream video stable.
                  if(g_stChipTx.ucTxState > STATE_CHIPTX_UPSTREAM_VIDEO_READY)
                  {
                      if(g_stChipTx.b1UpstreamVideoReady == FALSE)
                      {
                          Drv_MipiTx_VideoSet(OFF);
                          Mod_SystemTx_SetState(STATE_CHIPTX_UPSTREAM_VIDEO_READY);
                      }
C51 COMPILER V9.53.0.0   MODMIPITX                                                         06/30/2023 14:32:05 PAGE 7   

                  }
              }
              
              void Mod_MipiTx_Handler(void)
              {   
                  Mod_MipiTx_StateJudge();
                  Mod_MipiTx_StateHandler();
              }
              
              
              #endif


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   ----    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
